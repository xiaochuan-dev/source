(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcoMobile = {}, global.React, global.ReactDOM));
})(this, (function (exports, React, ReactDOM) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
    var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends$1(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$2 = function() {
        __assign$2 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };

    function __rest$1(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    /** @deprecated */
    function __spreadArrays$1() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var opt = Object.prototype.toString;
    /**
     * 判断一个对象是否为数组类型
     * @desc {en} Whether it is an array
     * @param {any} obj 入参
     * @param {any} obj {en} Entering
     * @returns {boolean} 返回是否为数组类型
     * @returns {boolean} {en} Returns whether it is an array type
     * @example
     * ```
     * import { isArray } from '@arco-design/mobile-utils';
     *
     * const test = isArray([]);
     * ```
     */

    function isArray(obj) {
      return opt.call(obj) === '[object Array]';
    }
    /**
     * 判断一个对象是否为对象类型
     * @desc {en} Whether it is an object
     * @param {any} obj 入参
     * @param {any} obj {en} Entering
     * @returns {boolean} 返回是否为对象类型
     * @returns {boolean} {en} Returns whether it is an object type
     * @example
     * ```
     * import { isObject } from '@arco-design/mobile-utils';
     *
     * const test = isObject({});
     * ```
     */

    function isObject$2(obj) {
      return opt.call(obj) === '[object Object]';
    }
    /**
     * 判断一个对象是否为字符串类型
     * @desc {en} Whether it is an string
     * @param {any} obj 入参
     * @param {any} obj {en} Entering
     * @returns {boolean} 返回是否为字符串类型
     * @returns {boolean} {en} Returns whether it is an string type
     * @example
     * ```
     * import { isString } from '@arco-design/mobile-utils';
     *
     * const test = isString('');
     * ```
     */

    function isString(obj) {
      return opt.call(obj) === '[object String]';
    }
    /**
     * 检查一个值是否在给定的有效值列表中
     * @desc {en} Checks whether a value is in the given list of valid values
     * @param {T} value 检查的值
     * @param {T} value {en} value to check
     * @param {T[]} validList 有效值列表
     * @param {T[]} validList {en} List of valid values
     * @returns {boolean} 返回要检查的值是否在有效值列表中
     * @returns {boolean} {en} Returns whether the value to be checked is in the list of valid values
     * @example
     * ```
     * import { isOneOf } from '@arco-design/mobile-utils';
     *
     * const test = isOneOf(1, [1, 2, 3]);
     * ```
     */

    function isOneOf(value, validList) {
      return validList.indexOf(value) !== -1;
    }
    /**
     * 检查一个值是否为空值
     * @desc {en} Check if a value is null
     * @param {any} obj 入参
     * @param {any} obj {en} Entering
     * @returns {boolean} 返回该值是否为空值
     * @returns {boolean} {en} Returns whether the value is null
     * @example
     * ```
     * import { isEmptyValue } from '@arco-design/mobile-utils';
     *
     * const test = isEmptyValue(null);
     * ```
     */

    function isEmptyValue(obj) {
      return obj === undefined || obj === null || obj === '';
    }
    /**
     * 检查一个值是否为函数类型
     * @desc {en} Check if a value is function
     * @param {unknown} obj 入参
     * @param {unknown} obj {en} Entering
     * @returns {boolean} 返回该值是否为函数
     * @returns {boolean} {en} Returns whether the value is function
     * @example
     * ```
     * import { isFunction } from '@arco-design/mobile-utils';
     *
     * const test = isFunction(() => {});
     * ```
     */

    function isFunction(obj) {
      return Object.prototype.toString.call(obj).toLowerCase() === '[object function]';
    }
    /**
     * 检查一个值是否为空数组
     * @desc {en} Check if a value is an empty array
     * @param {Array<unknown>} obj 入参
     * @param {Array<unknown>} obj {en} Entering
     * @returns {boolean} 返回该值是否为空数组
     * @returns {boolean} {en} Returns whether the value is an empty array
     * @example
     * ```
     * import { isEmptyArray } from '@arco-design/mobile-utils';
     *
     * const test = isEmptyArray([]);
     * ```
     */

    function isEmptyArray(obj) {
      return isArray(obj) && !(obj === null || obj === void 0 ? void 0 : obj.length);
    }
    /**
     * 深比较两个对象是否相等
     * @desc {en} Check if a value is an empty array
     * @param {any} obj 要比较的第一个对象
     * @param {any} obj {en} the first object to compare
     * @param {any} obj 要比较的第二个对象
     * @param {any} obj {en} the second object to be compared
     * @returns {boolean} 返回两个对象是否相等
     * @returns {boolean} {en} Returns whether two objects are equal
     * @example
     * ```
     * import { isDeepEqual } from '@arco-design/mobile-utils';
     *
     * const test = isDeepEqual({a: 1}, {a: 1});
     * ```
     */

    function isDeepEqual(obj, sub) {
      if (typeof obj !== 'object' || typeof sub !== 'object' || obj === null || sub === null) {
        return obj === sub;
      }

      if (isFunction(obj) && isFunction(sub)) {
        return obj === sub || obj.toString() === sub.toString();
      }

      if (Object.keys(obj).length !== Object.keys(sub).length) {
        return false;
      }

      for (var key in obj) {
        if (!isDeepEqual(obj[key], sub[key])) return false;
      }

      return true;
    }

    /**
     * @type utils
     * @name classnames
     */
    /**
     * 将传入的值转为class字符串
     * @param args 字符串，字符串数组，对象，undefined，null，boolean
     * @param args {en} string, string[], object, undefined, null, boolean
     * @returns class字符串
     * @returns {en} class string
     * @example
     * import { cls } from '@arco-design/mobile-utils';
     *
     * <div className={cls('a', 'b', { ok: true })} />
     * // result: <div class="a b ok"></div>
     */

    function cls () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var length = args.length;
      var classNames = [];

      var _loop_1 = function _loop_1(i) {
        var v = args[i];

        if (!v) {
          return "continue";
        }

        if (isString(v)) {
          classNames.push(v);
        } else if (isArray(v)) {
          classNames = classNames.concat(v);
        } else if (isObject$2(v)) {
          Object.keys(v).forEach(function (k) {
            if (v[k]) {
              classNames.push(k);
            }
          });
        } else {
          throw new Error("[classnames] Arguments must be one of string/array/object. Current value: " + (JSON.stringify(v) || String(v)));
        }
      };

      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }

      return classNames.join(' ');
    }

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     */
    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    var float32ArraySupported = typeof Float32Array === 'function';

    function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }

    function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }

    function C(aA1) {
      return 3.0 * aA1;
    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


    function getSlope(aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX, currentT;
      var i = 0;

      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;

        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

      return currentT;
    }

    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);

        if (currentSlope === 0.0) {
          return aGuessT;
        }

        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }

      return aGuessT;
    }

    function LinearEasing(x) {
      return x;
    }
    /**
     * 获取一个用于计算贝塞尔曲线的函数
     * @desc {en} Gets a function used to calculate Bezier curves
     * @param mX1 第一个点的x坐标
     * @param mX1 {en} The X coordinate of first point
     * @param mY1 第一个点的y坐标
     * @param mY1 {en} The Y coordinate of first point
     * @param mX2 第二个点的x坐标
     * @param mX2 {en} The X coordinate of second point
     * @param mY2 第二个点的y坐标
     * @param mY2 {en} The Y coordinate of second point
     * @returns 计算贝塞尔曲线的函数
     * @returns {function} {en} The function of calculating bezier curve
     * @example
     * ```
     * import { bezierEasing } from '@arco-design/mobile-utils';
     *
     * const p = (Date.now() - start) / duration;
     * if (p > 1) {
     *     scrollTo(targetTop);
     * } else {
     *     const newTop = initTop + (targetTop - initTop) * bezierEasing(0.34, 0.69, 0.1, 1)(p);
     *     scrollTo(newTop);
     * }
     * ```
     */


    function bezier(mX1, mY1, mX2, mY2) {
      if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }

      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      } // Precompute samples table


      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }

      function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }

        --currentSample; // Interpolate to provide an initial guess for t

        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);

        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }

        if (initialSlope === 0.0) {
          return guessForT;
        }

        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

      return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0 || x === 1) {
          return x;
        }

        return calcBezier(getTForX(x), mY1, mY2);
      };
    }

    /**
     * 阻止 TouchEvent 事件的默认行为
     * @desc {en} Stops the default behavior of a TouchEvent
     * @param {TouchEvent} e 要阻止的 TouchEvent 事件
     * @param {TouchEvent} e {en} The TouchEvent to stop
     * @returns {void}
     * @example
     * ```
     * import { stopTouch } from '@arco-design/mobile-utils';
     *
     * // Before calling stopTouch
     * const touchEvent = new TouchEvent("touchstart", { cancelable: true });
     * console.log(touchEvent.defaultPrevented); // false
     *
     * // Call stopTouch to prevent the default behavior
     * stopTouch(touchEvent);
     *
     * // After calling stopTouch
     * console.log(touchEvent.defaultPrevented); // true
     * ```
     */

    function stopTouch(e) {
      // If the TouchEvent is cancelable, prevent it's default behavior using preventDefault
      e.cancelable && e.preventDefault();
    }
    /**
     * 阻止元素滚动
     * @desc {en} Prevents an element from scrolling
     * @param scrollContainer 滚动容器的函数，默认为 document.body
     * @param scrollContainer {en} A function that returns the scroll container, defaults to document.body
     * @param preventWindow 是否阻止窗口滚动
     * @param preventWindow {en} Whether to prevent window scrolling
     * @param customStopTouch 自定义停止触摸事件的函数
     * @param customStopTouch {en} A custom function to stop touch events
     * @example
     * ```
     * import { preventEleScroll } from '@arco-design/mobile-utils';
     *
     * // Example 1: Prevent scrolling in the entire document body
     * preventEleScroll();
     *
     * // Example 2: Prevent scrolling in a specific element
     * preventEleScroll(() => document.getElementById('myScrollableElement'));
     *
     * // Example 3: Prevent scrolling in a specific element with custom touch event handling
     * preventEleScroll(
     *   () => document.getElementById('myScrollableElement'),
     *   false,
     *   (e) => {
     *     // Custom touch event handling logic here
     *     e.preventDefault();
     *   }
     * );
     * ```
     */

    function preventEleScroll(scrollContainer, preventWindow, customStopTouch) {
      if (scrollContainer === void 0) {
        scrollContainer = function scrollContainer() {
          return document.body;
        };
      }

      var element = scrollContainer();

      if (!element) {
        return;
      }

      element.style.overflow = 'hidden';
      element.style.touchAction = 'none';
      var preEle = preventWindow ? window : element;
      preEle.addEventListener('touchmove', customStopTouch || stopTouch, {
        passive: false,
        capture: true
      });
    }
    /**
     * 允许元素滚动
     * @desc {en} Allows an element to scroll
     * @param scrollContainer 滚动容器的函数，默认为 document.body
     * @param scrollContainer {en} A function that returns the scroll container, defaults to document.body
     * @param preventWindow 是否阻止窗口滚动
     * @param preventWindow {en} Whether to prevent window scrolling
     * @param customStopTouch 自定义停止触摸事件的函数
     * @param customStopTouch {en} A custom function to stop touch events
     * @example
     * ```
     * import { freeEleScroll } from '@arco-design/mobile-utils';
     *
     * // Example 1: Allow scrolling in the entire document body
     * freeEleScroll();
     *
     * // Example 2: Allow scrolling in a specific element
     * freeEleScroll(() => document.getElementById('myScrollableElement'));
     *
     * // Example 3: Allow scrolling in a specific element with custom touch event handling
     * freeEleScroll(
     *   () => document.getElementById('myScrollableElement'),
     *   false,
     *   (e) => {
     *     // Custom touch event handling logic here
     *     // You can choose to call e.preventDefault() or not based on your needs
     *   }
     * );
     * ```
     */

    function freeEleScroll(scrollContainer, preventWindow, customStopTouch) {
      if (scrollContainer === void 0) {
        scrollContainer = function scrollContainer() {
          return document.body;
        };
      }

      var element = scrollContainer();

      if (!element) {
        return;
      }

      element.style.overflow = '';
      element.style.touchAction = '';
      var preEle = preventWindow ? window : element;
      preEle.removeEventListener('touchmove', customStopTouch || stopTouch, {
        capture: true
      });
    }
    /**
     * 判断父节点是否包含子节点
     * @desc {en} confirm parentNode contains children nodes
     * @param {HTMLElement | null} parentEl 父节点
     * @param {HTMLElement | null} parentEl {en} The parent element
     * @param {HTMLElement | null} childrenEl 子节点
     * @param {HTMLElement | null} childrenEl {en} The child element
     * @returns {boolean} 是否包含子节点
     * @returns {boolean} {en} Whether the parent contains the child
     * @example
     * ```
     * import { isContains } from '@arco-design/mobile-utils';
     *
     * // Example 1: When the parent contains the direct child
     * const parentElement = document.getElementById('parent');
     * const childElement = document.getElementById('directChild');
     * const result1 = isContains(parentElement, childElement);
     * console.log(result1); // Output: true
     * // Explanation: In this example, the parent element (#parent) contains a direct child element (#directChild).
     *
     * // Example 2: When the parent contains an indirect child
     * const grandparentElement = document.getElementById('grandparent');
     * const indirectChildElement = document.getElementById('indirectChild');
     * const result2 = isContains(grandparentElement, indirectChildElement);
     * console.log(result2); // Output: true
     * // Explanation: Here, the grandparent element (#grandparent) contains an indirect child element (#indirectChild) nested within other elements.
     *
     * // Example 3: When the parent does not contain the child
     * const unrelatedParent = document.getElementById('unrelatedParent');
     * const unrelatedChild = document.getElementById('unrelatedChild');
     * const result3 = isContains(unrelatedParent, unrelatedChild);
     * console.log(result3); // Output: false
     * // Explanation: In this case, the unrelated parent element (#unrelatedParent) and unrelated child element (#unrelatedChild) are not related in the DOM structure.
     * ```
     */

    function isContains(parentEl, childrenEl) {
      if (!parentEl || !childrenEl) return false;

      if (parentEl.contains) {
        return parentEl.contains(childrenEl);
      }

      var parent = childrenEl;

      while (parent) {
        if (parentEl === parent) {
          return true;
        }

        parent = parent.parentNode;
      }

      return false;
    }
    /**
     * 使用 requestAnimationFrame 执行函数，如果不支持则使用 setTimeout 作为兜底
     * @desc {en} Executes a function using requestAnimationFrame, if not supported, falls back to setTimeout
     * @param {Function} fn 需要执行的函数
     * @param {Function} fn {en} the function to be executed
     * @returns {number} 返回 requestAnimationFrame 或 setTimeout 的 ID
     * @returns {number} {en} returns the ID of requestAnimationFrame or setTimeout
     * @example
     * ```
     * import { execRAF } from '@arco-design/mobile-utils';
     *
     * // Example 1: Using requestAnimationFrame
     * const rafId = execRAF(() => {
     *   console.log("Using requestAnimationFrame");
     * });
     * console.log(rafId); // Output: A numerical ID representing the requestAnimationFrame callback
     * // Explanation:
     * // This example demonstrates using `execRAF` with `requestAnimationFrame` to execute a function.
     * // `requestAnimationFrame` is typically used for animations and smooth updates.
     * // The ID returned by `requestAnimationFrame` is logged, which can be useful for canceling the animation frame if needed.
     *
     * // Example 2: Using setTimeout as a fallback
     * const setTimeoutId = execRAF(() => {
     *   console.log("Using setTimeout as a fallback");
     * });
     * console.log(setTimeoutId); // Output: A numerical ID representing the setTimeout callback
     * // Explanation:
     * // In situations where the browser does not support `requestAnimationFrame`,
     * // `execRAF` falls back to using `setTimeout` with a delay of approximately 17 milliseconds (equivalent to a frame rate of 60 frames per second).
     * // The ID returned by `setTimeout` is logged, allowing you to manage the execution of the function, even in browsers without `requestAnimationFrame` support.
     * ```
     */

    function execRAF(fn) {
      try {
        return requestAnimationFrame(fn);
      } catch (e) {
        // Note that the delay time for setTimeout is 17 milliseconds, which is approximately equivalent to a frame rate of 60 frames per second.
        // This is a good fallback option because requestAnimationFrame also typically runs at a rate of about 60 frames per second.
        return setTimeout(fn, 17);
      }
    }
    /**
     * 使用动画滚动页面
     * @desc {en} Scroll the page with animation
     * @param {number} initTop 初始滚动位置（像素）
     * @param {number} initTop {en} Initial scroll position (in pixels)
     * @param {number} target 目标滚动位置（像素）
     * @param {number} target {en} Target scroll position (in pixels)
     * @param {function} scrollTo 滚动函数
     * @param {function} scrollTo {en} Scroll function
     * @param {number} duration 动画持续时间（毫秒）
     * @param {number} duration {en} Animation duration (in milliseconds)
     * @param {Array<number>} bezier 贝塞尔曲线参数
     * @param {Array<number>} bezier {en} Bezier curve parameters
     * @param {'by'|'to'} type 滚动类型：'by'表示相对滚动，'to'表示绝对滚动
     * @param {'by'|'to'} type {en} Scroll type: 'by' for relative scrolling, 'to' for absolute scrolling
     * @example
     * ```
     * import { scrollWithAnimation } from '@arco-design/mobile-utils';
     *
     * // Scroll to 500px from the current position over 1 second
     * scrollWithAnimation(
     *   window.pageYOffset,
     *   500,
     *   (top) => window.scrollTo({ top }),
     *   1000,
     *   [0.34, 0.69, 0.1, 1],
     *   'to'
     * );
     * ```
     */

    function scrollWithAnimation(initTop, target, scrollTo, duration, bezier$1, type) {
      if (duration === void 0) {
        duration = 300;
      }

      if (bezier$1 === void 0) {
        bezier$1 = [0.34, 0.69, 0.1, 1];
      }

      if (type === void 0) {
        type = 'to';
      }

      var targetTop = type === 'by' ? initTop + target : target;
      var start = Date.now();

      var fn = function fn() {
        var p = (Date.now() - start) / duration;

        if (p > 1) {
          scrollTo(targetTop);
        } else {
          var newTop = initTop + (targetTop - initTop) * bezier.apply(void 0, bezier$1)(p);
          scrollTo(newTop);
          execRAF(fn);
        }
      };

      execRAF(fn);
    }
    /**
     * 返回节点的 document 对象属性
     * @desc {en} Returns the node's document properties
     * @param {HTMLElement} node dom 节点
     * @param {HTMLElement} node {en} dom Node
     * @returns {HTMLElement | Document | null} 返回节点的最近可滚动父节点或 document 对象
     * @returns {HTMLElement | Document | null} {en} Returns the nearest scrollable parent node of the node or the document object
     * @example
     * ```
     * import { scrollParent } from '@arco-design/mobile-utils';
     *
     * // Example 1: Finding the scroll parent of a DOM node
     * const targetNode = document.getElementById('targetElement');
     * const scrollParentNode = scrollParent(targetNode);
     * console.log(scrollParentNode); // Output: The nearest scrollable parent element or the document
     * // Explanation:
     * // This example demonstrates how to use the `scrollParent` function to find the nearest scrollable parent element of a given DOM node.
     * // It returns the nearest scrollable parent element, or if none is found, it returns the document.
     *
     * // Example 2: Finding the scroll parent of the document body
     * const bodyNode = document.body;
     * const scrollParentBody = scrollParent(bodyNode);
     * console.log(scrollParentBody); // Output: The document's HTML element (document.documentElement)
     * // Explanation: In this scenario, we use the `scrollParent` function to find the scrollable parent of the document body.
     * ```
     */

    function scrollParent(node) {
      var excludeStaticParent = node.style.position === 'absolute';
      var overflowList = ['scroll', 'auto'];
      var parent = node;

      while (parent) {
        if (!parent.parentNode) {
          return node.ownerDocument || document.documentElement;
        }

        var style = window.getComputedStyle(parent);
        var position = style.position;
        var overflowX = style.overflowX || '';
        var overflowY = style.overflowY || '';

        if (position === 'static' && excludeStaticParent) {
          parent = parent.parentNode;
          continue;
        }

        if (overflowList.indexOf(overflowY) > -1 || overflowList.indexOf(overflowX) > -1) {
          return parent;
        }

        parent = parent.parentNode;
      }

      return node.ownerDocument || document.documentElement;
    }
    /**
     * 获得元素 offset
     * @desc {en} Get element offset
     * @param {HTMLElement} node dom 节点
     * @param {HTMLElement} node {en} Dom node
     * @example
     * ```
     * import { getOffset } from '@arco-design/mobile-utils';
     *
     * const element = document.getElementById('exampleElement');
     * const offset = getOffset(element);
     * console.log('Element Width:', offset.width);
     * console.log('Element Height:', offset.height);
     * console.log('Element Top Offset:', offset.top);
     * console.log('Element Left Offset:', offset.left);
     * ```
     */

    function getOffset(node) {
      var _a;

      var width, height, left, top;

      if (node instanceof HTMLElement) {
        _a = node.getBoundingClientRect() || {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        }, width = _a.width, height = _a.height, left = _a.left, top = _a.top;
      } else {
        width = 0;
        height = 0;
        top = 0;
        left = 0;
      }

      return {
        width: width,
        height: height,
        top: top,
        left: left
      };
    }
    /**
     * 格式化偏移量
     * Format the offset
     * @param {Array|number} offset 输入的偏移量，可以是一个数字或者一个长度为2或4的数组
     * @param {Array|number} offset {en} The input offset, which can be a number or an array of length 2 or 4
     * @returns {Array} 返回一个长度为4的数组，表示上、右、下、左四个方向的偏移量
     * @returns {Array} {en} Returns an array of length 4, representing the offsets in the top, right, bottom, and left directions
     * @example
     * ```
     * import { formatOffset } from '@arco-design/mobile-utils';
     *
     * console.log(formatOffset(10)) // output: [10, 10, 10, 10]
     * console.log(formatOffset([10, 20])) // output: [10, 0, 20, 0]
     * console.log(formatOffset([10, 20, 30, 40])) // output: [10, 20, 30, 40]
     * ```
     */

    function formatOffset(offset) {
      var offsets;

      if (Array.isArray(offset)) {
        if (offset.length === 2) {
          offsets = [offset[0], 0, offset[1], 0];
        } else if (offset.length === 4) {
          offsets = offset;
        }
      } else {
        offsets = [offset, offset, offset, offset];
      }

      return offsets;
    }
    /**
     * 检查 overflow 为 scroll 或 auto 时，元素是否在视口区域内
     * @desc {en} Check if the element is within the viewport area when overflow is scroll or auto
     * @param component 当前元素节点
     * @param component {en} Current element node
     * @param parent 当前元素所在容器 dom 节点
     * @param parent {en} The dom node of the container where the current element is located
     * @example
     * ```
     * import { checkOverflowVisible } from '@arco-design/mobile-utils';
     *
     * const component = {
     *   node: document.getElementById('myComponent'),
     *   offset: 20, // Set the offset value
     *   threshold: 0.5, // Set the threshold value
     * }
     * const myParent = document.getElementById('myParent');
     * const isVisible = checkOverflowVisible(component, myParent);
     * ```
     */


    function checkOverflowVisible(component, parent) {
      var node = component.node,
          offset = component.offset,
          threshold = component.threshold;

      var _a = getOffset(parent),
          parentTop = _a.top,
          parentHeight = _a.height,
          parentLeft = _a.left,
          parentWidth = _a.width;

      var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
      var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;
      var intersectionTop = Math.max(parentTop, 0);
      var intersectionHeight = Math.min(windowInnerHeight, parentTop + parentHeight) - intersectionTop;
      var intersectionLeft = Math.max(parentLeft, 0);
      var intersectionWidth = Math.min(windowInnerWidth, parentLeft + parentWidth) - intersectionLeft;

      var _b = getOffset(node),
          top = _b.top,
          elementHeight = _b.height,
          left = _b.left,
          elementWidth = _b.width;

      var offsets = formatOffset(offset);
      var offsetTop = top - intersectionTop;
      var thresholdHeight = elementHeight * threshold;
      var offsetLeft = left - intersectionLeft;
      var thresholdWidth = elementWidth * threshold;
      return offsetTop - offsets[2] + thresholdHeight <= intersectionHeight && offsetTop + elementHeight + offsets[0] >= 0 + thresholdHeight && offsetLeft - offsets[1] + thresholdWidth <= intersectionWidth && offsetLeft + elementWidth + offsets[3] >= 0 + thresholdWidth;
    }
    /**
     * 检查非局部滚动容器元素是否在视口区域内
     * @desc {en} Check if a non-local scroll container element is inside the viewport area
     * @param component 当前元素节点
     * @param component {en} Current element node
     * @returns {boolean} 如果元素可见，则返回 true，否则返回 false。
     * @returns {boolean} {en} Returns true if the element is visible, otherwise returns false.
     * @example
     * ```
     * import { checkNormalVisible } from '@arco-design/mobile-utils';
     *
     * // Example usage:
     * const element = document.getElementById('myElement');
     *
     * // Make sure to set the offset and threshold values to actual values that suit your use case.
     * const isVisible = checkNormalVisible({
     *   node: element,
     *   offset: 20, // Set the offset value
     *   threshold: 0.5, // Set the threshold value
     * });
     *
     * if (isVisible) {
     *   console.log('The element is in the viewport area');
     * } else {
     *   console.log('The element is not in the viewport area');
     * }
     * ```
     */

    function checkNormalVisible(component) {
      var node = component.node,
          offset = component.offset,
          threshold = component.threshold;

      if (!(node instanceof HTMLElement)) {
        return false;
      }

      if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) {
        return false;
      }

      var _a = getOffset(node),
          top = _a.top,
          elementHeight = _a.height,
          left = _a.left,
          elementWidth = _a.width;

      var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
      var thresholdHeight = elementHeight * threshold;
      var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;
      var thresholdWidth = elementWidth * threshold;
      var offsets = formatOffset(offset);
      return top - offsets[2] + thresholdHeight <= windowInnerHeight && top + elementHeight + offsets[0] >= 0 + thresholdHeight && left - offsets[1] + thresholdWidth <= windowInnerWidth && left + elementWidth + offsets[3] >= 0 + thresholdWidth;
    }
    /**
     * 根据id动态添加dom元素
     * @desc {en} Dynamically add dom element based on id
     * @param id 添加的dom id
     * @param id {en} added dom id
     * @param getContainer 被添加元素的父级
     * @param getContainer {en} The parent of the added element
     * @example
     * ```
     * import { appendElementById } from '@arco-design/mobile-utils';
     *
     * // Example 1: Add a div element with the id "myDiv" to the body.
     * const { child, container } = appendElementById("myDiv");
     *
     * // Example 2: Add a div element with the id "customDiv" to a specific container.
     * const customContainer = document.getElementById("customContainer");
     * const { child, container } = appendElementById("customDiv", () => customContainer);
     * ```
     */

    function appendElementById(id, getContainer) {
      var div = document.querySelector("#" + id) || document.createElement('div');
      div.id = id;
      var container = getContainer && getContainer() ? getContainer() : document.body;
      container.appendChild(div);
      return {
        child: div,
        container: container
      };
    }
    /**
     * 从父级节点移除该元素
     * @desc {en} Remove element from parent node
     * @param ele 待移除元素
     * @param ele {en} Element to be removed
     * @example
     * ```
     * import { removeElement } from '@arco-design/mobile-utils';
     *
     * // HTML: <div id="myElement">This is a div</div>
     * const elementToRemove = document.getElementById('myElement');
     * // The element with ID 'myElement' will be removed from the DOM
     * removeElement(elementToRemove);
     * ```
     */

    function removeElement(ele) {
      if (ele && ele.parentNode) {
        ele.parentNode.removeChild(ele);
      }
    }
    /**
     * 获取滚动容器，如果传入 string 则使用 querySelector 选取容器
     * @desc {en} Get the scrolling container. If a string is passed in, use querySelector to select the container
     * @param getContainer 指定滚动容器
     * @param getContainer {en} Specifies the scrolling container.
     * @example
     * ```
     * import { getActualContainer } from '@arco-design/mobile-utils';
     *
     * const customContainer = document.getElementById("customContainer");
     * const actualContainer = getActualContainer(() => customContainer);
     * ```
     */

    function getActualContainer(getContainer) {
      var container = getContainer ? getContainer() : void 0;
      return typeof container === 'string' ? document.querySelector(container) : container;
    }
    /**
     * 获取有效滚动监听容器，默认情况或者监听 body 的滚动时均指定为 window
     * @desc {en} Get the effective scrolling container, which is specified as window by default or for listening to the scrolling of the body
     * @param getContainer 指定滚动容器
     * @param getContainer {en} Specifies the scrolling container.
     * @example
     * ```
     * import { getValidScrollContainer } from '@arco-design/mobile-utils';
     *
     * const customContainer = document.getElementById("customContainer");
     * const validScrollContainer = getValidScrollContainer(() => customContainer);
     */

    function getValidScrollContainer(getContainer) {
      // 默认为window
      // @en Default is window
      var originContainer = getContainer ? getContainer() : window; // body的滚动在window上监听，document.body.addEventListener('scroll') 是不生效的
      // @en The scrolling of the body is monitored on the window, document.body.addEventListener('scroll') is ineffective

      return originContainer === document.body ? window : originContainer;
    }
    /**
     * 获取滚动容器的属性。针对 window 和 document 额外进行一些属性兼容处理。
     * @desc {en} Get properties of the scrolling container. Perform additional attribute compatibility processing for window and document.
     * @param property 所需属性
     * @param property {en} Required attributes
     * @param {() => HTMLElement | Window | Document | null} getContainer 待计算滚动容器
     * @param getContainer {en} Scrolling container to be calculated.
     * @example
     * ```
     * import { getScrollContainerAttribute } from '@arco-design/mobile-utils';
     *
     * const contentRef = useRef<HTMLDivElement>(null);
     * const scrollTop = getScrollContainerAttribute('scrollTop', () => contentRef.current);
     * ```
     */

    function getScrollContainerAttribute(property, getContainer) {
      var container = getContainer ? getContainer() : window;
      if (!container) return 0;

      if (container === window || container === document) {
        // 一些值可能不准的属性兼容
        // @en Some properties whose values may be inaccurate are compatible
        var globalPropMap = {
          clientHeight: 'innerHeight',
          clientWidth: 'innerWidth'
        };
        var windowProp = globalPropMap[property];
        var documentValue = document.documentElement[property];

        if (windowProp && window[windowProp] && documentValue) {
          return Math.min(window[windowProp], documentValue);
        }

        return documentValue || document.body[property];
      }

      if (container === document.body) {
        return document.body[property] || document.documentElement[property];
      }

      return container[property];
    }
    /**
     * 提供了元素的大小及其相对于视口的位置。
     * @desc {en} Provide information about the size of an element and its position relative to the viewport.
     * @param {HTMLElement | Window | null} container 滚动容器
     * @param container {en} Scroll Container
     * @example
     * ```
     * import { getScrollContainerAttribute } from '@arco-design/mobile-utils';
     *
     * const contentRef = useRef<HTMLDivElement>(null);
     * const scrollTop = getScrollContainerAttribute('scrollTop', () => contentRef.current);
     * ```
     */

    function getScrollContainerRect(container) {
      var containerRect = {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        height: 0,
        width: 0
      };

      if (!container) {
        return {
          isGlobal: false,
          scrollEle: container,
          containerRect: containerRect
        };
      }

      var scrollEle = container === window ? document.documentElement : container;
      var isGlobal = scrollEle === document.documentElement || scrollEle === document.body; // html和body内部滚动时，DOMRect.top会变，此时需求是取相对于视口的top值，因此top直接设置为0
      // @en When html and body are scrolled, DOMRect.top will change. At this time, the requirement is to take the top value relative to the viewport, so top is directly set to 0

      containerRect = isGlobal ? {
        top: 0,
        left: 0,
        bottom: window.innerHeight,
        right: window.innerWidth,
        width: window.innerWidth,
        height: window.innerHeight
      } : scrollEle.getBoundingClientRect();
      return {
        isGlobal: isGlobal,
        scrollEle: scrollEle,
        containerRect: containerRect
      };
    }
    var styleDoms = {};
    /**
     * 删除自定义 style 标签，配合 addCssStyleDom 函数一起使用
     * @desc {en} Remove custom style tags and use it in conjunction with the addCssStyleDom function
     * @param key 标签对应的key
     * @param key {en} Key corresponding to the tag
     * @example
     * ```
     * import { removeCssStyleDom } from '@arco-design/mobile-utils';
     *
     * removeCssStyleDom('arcoTheme');
     * ```
     */

    function removeCssStyleDom(key) {
      var styleDom = styleDoms[key];

      if (styleDom) {
        document.documentElement.removeChild(styleDom);
        delete styleDoms[key];
      }
    }
    /**
     * 添加自定义 style 标签，addCssKeyframes 和 addCssRules 的底层方法
     * @desc {en} Add custom style tags, underlying methods for addCssKeyframes and addCssRules
     * @param key 标签对应的key
     * @param key {en} Key corresponding to the tag
     * @param html 样式内容
     * @param html {en} style information (CSS)
     * @example
     * ```
     * import { addCssStyleDom } from '@arco-design/mobile-utils';
     *
     * addCssStyleDom('arcoTheme', ':root {--base-font-size: 50;}');
     * ```
     */

    function addCssStyleDom(key, html) {
      removeCssStyleDom(key);
      var style = document.createElement('style');
      style.innerHTML = html;
      document.documentElement.appendChild(style);
      styleDoms[key] = style;
    }
    /**
     * 增加自定义关键帧动画变量，实现动画函数复用。
     * @desc {en} Add custom keyframe animation variables to achieve reuse of animation functions
     * @param key 规则名称
     * @param key {en} Rule Name
     * @param rules 动画关键帧
     * @param rules {en} Animation keyframes
     * @example
     * ```
     * import { addCssKeyframes } from '@arco-design/mobile-utils';
     *
     * const maxScaleWithDefault = 2;
        addCssKeyframes(
            'animationKey',
            `{
                0% {
                    width: 100%;
                }
                50% {
                    width: ${100 * maxScaleWithDefault}%;
                }
                100% {
                    width: 100%;
                }
            }`,
        );
     * ```
     */

    function addCssKeyframes(key, rules) {
      addCssStyleDom(key, "@keyframes " + key + " " + rules + "\n@-webkit-keyframes " + key + " " + rules);
    }
    /**
     * 增加自定义 CSS 变量规则，使用后将在线替换css变量。需设置less变量 @use-css-vars: 1
     * @desc {en} Add custom CSS variable rules, which will replace CSS variables online after use.The less variable needs to be set @use-css-vars: 1.
     * @param key 规则名称
     * @param key {en} Rule Name
     * @param rules 规则对象
     * @param rules {en} Rule Object
     * @example
     * ```
     * import { addCssRules } from '@arco-design/mobile-utils';
     *
     * addCssRules('arcoTheme', { 'base-font-size': '50' });
     * ```
     */

    function addCssRules(key, rules) {
      if (!rules || !Object.keys(rules).length) {
        return;
      }

      addCssStyleDom(key, ":root {" + Object.keys(rules).map(function (rule) {
        return "--" + rule + ": " + rules[rule] + ";";
      }).join('\n') + "}");
    }
    /**
     * 获取元素的时间属性值，结果统一成毫秒级别
     * @desc {en} Get the time attribute value of the element, and the results are unified into milliseconds
     * @param ele 要获取样式的元素
     * @param ele {en} Element to get the computed style
     * @param property 与时间相关属性
     * @param property {en} Property related to time
     * @example
     * ```
     * import { convertCssDuration } from '@arco-design/mobile-utils';
     *
     * const contentRef = useRef<HTMLDivElement>(null);
     * const transTimeout = convertCssDuration(contentRef.current, 'transitionDuration');
     * ```
     */

    function convertCssDuration(ele, property) {
      var timeout = window.getComputedStyle(ele)[property];

      if (/ms$/.test(timeout)) {
        return Number(timeout.replace('ms', '')) || 0;
      }

      if (/s$/.test(timeout)) {
        return (Number(timeout.replace('s', '')) || 0) * 1000;
      }

      return 0;
    }
    /**
     * 获取指定元素的 CSS 样式，当抛出异常时返回空对象
     * @desc {en} Get the CSS style of the specified element and return an empty object when an exception is thrown
     * @param element 要获取样式的元素
     * @param element {en} Element to get the computed style
     * @example
     * ```
     * import { safeGetComputedStyle } from '@arco-design/mobile-utils';
     *
     * const element = document.querySelector("p");
     * const compStyle =safeGetComputedStyle(element);
     * ```
     */

    function safeGetComputedStyle(element) {
      try {
        return window.getComputedStyle(element);
      } catch (e) {
        return {};
      }
    }

    /* eslint-disable no-redeclare */

    /**
     * @type utils
     * @name types
     */
    function componentWrapper(Component, params, extra) {
      var Comp = Component;

      if (typeof params === 'string') {
        Comp.displayName = params;
        extra && Object.keys(extra).length && Object.keys(extra).forEach(function (key) {
          Comp[key] = extra[key];
        });
      } else {
        Object.keys(params).forEach(function (key) {
          Comp[key] = params[key];
        });
      }

      return Comp;
    }

    /**
     * @type utils
     * @name color
     */
    var w3cx11 = {
      aliceblue: '#f0f8ff',
      antiquewhite: '#faebd7',
      aqua: '#00ffff',
      aquamarine: '#7fffd4',
      azure: '#f0ffff',
      beige: '#f5f5dc',
      bisque: '#ffe4c4',
      black: '#000000',
      blanchedalmond: '#ffebcd',
      blue: '#0000ff',
      blueviolet: '#8a2be2',
      brown: '#a52a2a',
      burlywood: '#deb887',
      cadetblue: '#5f9ea0',
      chartreuse: '#7fff00',
      chocolate: '#d2691e',
      coral: '#ff7f50',
      cornflower: '#6495ed',
      cornflowerblue: '#6495ed',
      cornsilk: '#fff8dc',
      crimson: '#dc143c',
      cyan: '#00ffff',
      darkblue: '#00008b',
      darkcyan: '#008b8b',
      darkgoldenrod: '#b8860b',
      darkgray: '#a9a9a9',
      darkgreen: '#006400',
      darkgrey: '#a9a9a9',
      darkkhaki: '#bdb76b',
      darkmagenta: '#8b008b',
      darkolivegreen: '#556b2f',
      darkorange: '#ff8c00',
      darkorchid: '#9932cc',
      darkred: '#8b0000',
      darksalmon: '#e9967a',
      darkseagreen: '#8fbc8f',
      darkslateblue: '#483d8b',
      darkslategray: '#2f4f4f',
      darkslategrey: '#2f4f4f',
      darkturquoise: '#00ced1',
      darkviolet: '#9400d3',
      deeppink: '#ff1493',
      deepskyblue: '#00bfff',
      dimgray: '#696969',
      dimgrey: '#696969',
      dodgerblue: '#1e90ff',
      firebrick: '#b22222',
      floralwhite: '#fffaf0',
      forestgreen: '#228b22',
      fuchsia: '#ff00ff',
      gainsboro: '#dcdcdc',
      ghostwhite: '#f8f8ff',
      gold: '#ffd700',
      goldenrod: '#daa520',
      gray: '#808080',
      green: '#008000',
      greenyellow: '#adff2f',
      grey: '#808080',
      honeydew: '#f0fff0',
      hotpink: '#ff69b4',
      indianred: '#cd5c5c',
      indigo: '#4b0082',
      ivory: '#fffff0',
      khaki: '#f0e68c',
      laserlemon: '#ffff54',
      lavender: '#e6e6fa',
      lavenderblush: '#fff0f5',
      lawngreen: '#7cfc00',
      lemonchiffon: '#fffacd',
      lightblue: '#add8e6',
      lightcoral: '#f08080',
      lightcyan: '#e0ffff',
      lightgoldenrod: '#fafad2',
      lightgoldenrodyellow: '#fafad2',
      lightgray: '#d3d3d3',
      lightgreen: '#90ee90',
      lightgrey: '#d3d3d3',
      lightpink: '#ffb6c1',
      lightsalmon: '#ffa07a',
      lightseagreen: '#20b2aa',
      lightskyblue: '#87cefa',
      lightslategray: '#778899',
      lightslategrey: '#778899',
      lightsteelblue: '#b0c4de',
      lightyellow: '#ffffe0',
      lime: '#00ff00',
      limegreen: '#32cd32',
      linen: '#faf0e6',
      magenta: '#ff00ff',
      maroon: '#800000',
      maroon2: '#7f0000',
      maroon3: '#b03060',
      mediumaquamarine: '#66cdaa',
      mediumblue: '#0000cd',
      mediumorchid: '#ba55d3',
      mediumpurple: '#9370db',
      mediumseagreen: '#3cb371',
      mediumslateblue: '#7b68ee',
      mediumspringgreen: '#00fa9a',
      mediumturquoise: '#48d1cc',
      mediumvioletred: '#c71585',
      midnightblue: '#191970',
      mintcream: '#f5fffa',
      mistyrose: '#ffe4e1',
      moccasin: '#ffe4b5',
      navajowhite: '#ffdead',
      navy: '#000080',
      oldlace: '#fdf5e6',
      olive: '#808000',
      olivedrab: '#6b8e23',
      orange: '#ffa500',
      orangered: '#ff4500',
      orchid: '#da70d6',
      palegoldenrod: '#eee8aa',
      palegreen: '#98fb98',
      paleturquoise: '#afeeee',
      palevioletred: '#db7093',
      papayawhip: '#ffefd5',
      peachpuff: '#ffdab9',
      peru: '#cd853f',
      pink: '#ffc0cb',
      plum: '#dda0dd',
      powderblue: '#b0e0e6',
      purple: '#800080',
      purple2: '#7f007f',
      purple3: '#a020f0',
      rebeccapurple: '#663399',
      red: '#ff0000',
      rosybrown: '#bc8f8f',
      royalblue: '#4169e1',
      saddlebrown: '#8b4513',
      salmon: '#fa8072',
      sandybrown: '#f4a460',
      seagreen: '#2e8b57',
      seashell: '#fff5ee',
      sienna: '#a0522d',
      silver: '#c0c0c0',
      skyblue: '#87ceeb',
      slateblue: '#6a5acd',
      slategray: '#708090',
      slategrey: '#708090',
      snow: '#fffafa',
      springgreen: '#00ff7f',
      steelblue: '#4682b4',
      tan: '#d2b48c',
      teal: '#008080',
      thistle: '#d8bfd8',
      tomato: '#ff6347',
      turquoise: '#40e0d0',
      violet: '#ee82ee',
      wheat: '#f5deb3',
      white: '#ffffff',
      whitesmoke: '#f5f5f5',
      yellow: '#ffff00',
      yellowgreen: '#9acd32'
    };
    /**
     * 获取任意颜色的透明色
     * @desc {en} Get any transparent color
     * @param color 颜色
     * @param color {en} color
     * @returns transparent color
     * @example
     * ```
     * import { fadeColor } from '@arco-design/mobile-utils';
     *
     * const transparentColor = fadeColor('#ffffff');
     * // transparentColor is '#ffffff00'
     * ```
     */

    function fadeColor(color) {
      if (!color) {
        return '';
      }

      if (w3cx11[color]) {
        return w3cx11[color] + "00";
      }

      if (/^#[A-Fa-f0-9]{6}$/.test(color)) {
        return color + "00";
      }

      if (/^rgb\(.*?\)$/.test(color)) {
        return color.replace(/rgb\((.*?)\)/, 'rgba($1, 0)');
      }

      return '';
    }

    /**
     * 获取当前设备的操作系统
     * @desc {en} Get the operating system of the current device
     * @returns {string} 返回当前设备的操作系统，可能的值包括 'android'、'ios' 或 'pc'，如果无法获取，则返回空字符串
     * @returns {string} {en} Returns the operating system of the current device, possible values are 'android', 'ios', or 'pc'. Returns an empty string if it cannot be obtained
     * @example
     * ```
     * import { getSystem } from '@arco-design/mobile-utils';
     *
     * const systemInfo = getSystem();
     * if (systemInfo === 'android') {
     *     console.log('You are using the Android operating system');
     * } else if (systemInfo === 'ios') {
     *     console.log('You are using the iOS operating system');
     * } else if (systemInfo === 'pc') {
     *     console.log('You are using a desktop PC operating system');
     * } else {
     *     console.log('Unable to detect your operating system');
     * }
     * ```
     */
    function getSystem() {
      try {
        var u = navigator.userAgent;
        var android = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;
        var ios = u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
        var pc = !android && !ios;
        var system = android ? 'android' : 'ios';
        return pc ? 'pc' : system;
      } catch (e) {
        return '';
      }
    }
    /**
     * 检查是否在 SSR 环境
     * @desc {en} Check if in ssr environment
     * @example
     * ```
     * import { isSSR } from '@arco-design/mobile-utils';
     *
     * if (isSSR()) {
     *     console.log("It is currently in the ssr stage");
     * } else {
     *     console.log("It is currently in the csr stage");
     * }
     * ```
     */

    function isSSR() {
      return typeof window === 'undefined';
    }

    var defaultMessageTemplate$1 = '%s 不是 %s 类型';
    var localeConfig = {
      locale: 'zh-CN',
      LoadMore: {
        loadMoreText: '加载更多',
        loadingText: '正在努力加载中...',
        prepareText: '上拉/点击加载更多',
        noDataText: '没有更多数据了',
        failLoadText: '加载失败，点击重试',
        prepareScrollText: '上拉',
        prepareClickText: '点击'
      },
      Picker: {
        okText: '确认',
        cancelText: '取消'
      },
      Tag: {
        addTag: '添加标签'
      },
      Dialog: {
        okText: '确认',
        cancelText: '取消'
      },
      SwipeLoad: {
        normalText: '更多',
        activeText: '释放查看'
      },
      PullRefresh: {
        loadingText: '加载中...',
        pullingText: '下拉即可刷新',
        finishText: '刷新成功',
        loosingText: '释放即可刷新'
      },
      DropdownMenu: {
        select: '请选择'
      },
      Pagination: {
        previousPage: '上一页',
        nextPage: '下一页'
      },
      Image: {
        loadError: '重试'
      },
      ImagePicker: {
        loadError: '加载失败'
      },
      SearchBar: {
        placeholder: '请输入要查询的内容',
        cancelBtn: '取消'
      },
      Stepper: {
        minusButtonName: '减少',
        addButtonName: '增加'
      },
      Keyboard: {
        confirm: '完成'
      },
      Form: {
        required: '%s 为必填项',
        type: {
          email: defaultMessageTemplate$1,
          url: defaultMessageTemplate$1,
          string: defaultMessageTemplate$1,
          number: defaultMessageTemplate$1,
          array: defaultMessageTemplate$1,
          object: defaultMessageTemplate$1,
          boolean: defaultMessageTemplate$1
        },
        number: {
          min: '`%s` 小于 `%s`',
          max: '`%s` 大于 `%s`',
          equal: '`%s` 不等于 `%s`',
          range: '`%s` 不在 `%s ~ %s` 范围中 ',
          positive: '`%s` 不是正数',
          negative: '`%s`不是负数'
        },
        string: {
          max: '%s 超过 %s 个字符',
          min: '%s 少于 %s 个字符',
          len: '%s 字符个数应为 %s',
          match: '`%s` 不匹配 %s 模式',
          uppercase: '%s 需全为大写字符',
          lowercase: '%s 需全为小写字符',
          whitespace: '%s 不能为连续空格'
        },
        array: {
          max: '%s 数组长度大于 %s',
          min: '%s 数组长度小于 %s',
          len: '%s 数组长度需为 %s',
          includes: '%s 不包含 %s',
          deepEqual: '%s 不完全等于 %s'
        },
        object: {
          deepEqual: '%s 不完全等于 %s',
          hasKeys: '%s 不包含必要字段 %s'
        },
        boolean: {
          equal: '%s 不等于 `%s`'
        }
      },
      NavBar: {
        backBtnAriaLabel: '返回'
      }
    };

    var defaultLocale = localeConfig;

    var DateWithUTC =
    /** @class */
    function () {
      function DateWithUTC(ts, utc) {
        this.date = new Date(ts);
        this.utc = utc;
      }

      DateWithUTC.prototype.getFullYear = function () {
        return this.utc ? this.date.getUTCFullYear() : this.date.getFullYear();
      };

      DateWithUTC.prototype.getMonth = function () {
        return this.utc ? this.date.getUTCMonth() : this.date.getMonth();
      };

      DateWithUTC.prototype.getDate = function () {
        return this.utc ? this.date.getUTCDate() : this.date.getDate();
      };

      DateWithUTC.prototype.getHours = function () {
        return this.utc ? this.date.getUTCHours() : this.date.getHours();
      };

      DateWithUTC.prototype.getMinutes = function () {
        return this.utc ? this.date.getUTCMinutes() : this.date.getMinutes();
      };

      DateWithUTC.prototype.getSeconds = function () {
        return this.utc ? this.date.getUTCSeconds() : this.date.getSeconds();
      };

      DateWithUTC.prototype.setFullYear = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCFullYear.apply(_a, args) : (_b = this.date).setFullYear.apply(_b, args);
      };

      DateWithUTC.prototype.setMonth = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCMonth.apply(_a, args) : (_b = this.date).setMonth.apply(_b, args);
      };

      DateWithUTC.prototype.setDate = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCDate.apply(_a, args) : (_b = this.date).setDate.apply(_b, args);
      };

      DateWithUTC.prototype.setHours = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCHours.apply(_a, args) : (_b = this.date).setHours.apply(_b, args);
      };

      DateWithUTC.prototype.setMinutes = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCMinutes.apply(_a, args) : (_b = this.date).setMinutes.apply(_b, args);
      };

      DateWithUTC.prototype.setSeconds = function () {
        var _a, _b;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return this.utc ? (_a = this.date).setUTCSeconds.apply(_a, args) : (_b = this.date).setSeconds.apply(_b, args);
      };

      DateWithUTC.prototype.getTime = function () {
        return this.date.getTime();
      };

      return DateWithUTC;
    }();

    var ValidatorType;

    (function (ValidatorType) {
      ValidatorType["Number"] = "number";
      ValidatorType["String"] = "string";
      ValidatorType["Array"] = "array";
      ValidatorType["Boolean"] = "boolean";
      ValidatorType["Object"] = "object";
      ValidatorType["Custom"] = "custom";
    })(ValidatorType || (ValidatorType = {}));

    var __assign$1 = undefined && undefined.__assign || function () {
      __assign$1 = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign$1.apply(this, arguments);
    };
    var defaultMessageTemplate = '%s is not a %s type';
    var messageTemplate = {
      required: '%s is required',
      type: {
        email: defaultMessageTemplate,
        url: defaultMessageTemplate,
        string: defaultMessageTemplate,
        number: defaultMessageTemplate,
        array: defaultMessageTemplate,
        object: defaultMessageTemplate,
        boolean: defaultMessageTemplate
      },
      number: {
        min: '`%s` is not greater than `%s`',
        max: '`%s` is not less than `%s`',
        equal: '`%s` is not equal to `%s`',
        range: '`%s` is not in range `%s ~ %s`',
        positive: '`%s` is not a positive number',
        negative: '`%s` is not a negative number'
      },
      string: {
        max: '%s cannot be longer than %s characters',
        min: '%s must be at least %s characters',
        len: '%s must be exactly %s characters',
        match: '`%s` does not match the pattern %s',
        uppercase: '%s must be all uppercased',
        lowercase: '%s must be all lowercased',
        whitespace: '%s cannot be string of whitespace'
      },
      array: {
        max: '%s cannot be greater than %s in length',
        min: '%s cannot be less than %s in length',
        len: '%s must be exactly %s in length',
        includes: '%s is not includes %s',
        deepEqual: '%s is not deep equal with%s'
      },
      object: {
        deepEqual: '%s is not deep equal with %s',
        hasKeys: '%s does not contain required fields %s'
      },
      boolean: {
        equal: '%s is not equal to `%s`'
      }
    };
    var getMsgTemplate = function getMsgTemplate(templates, temName, values) {
      var temNameArr = temName.split('.');
      var theTemplate = defaultMessageTemplate;

      if (temNameArr[0] in templates) {
        var firstTemplate = templates[temNameArr[0]];

        if (Object.prototype.toString.call(firstTemplate).toLowerCase() === '[object object]' && temNameArr.length > 1 && temNameArr[1] in templates[temNameArr[0]]) {
          theTemplate = firstTemplate[temNameArr[1]];
        } else {
          theTemplate = firstTemplate;
        }
      }

      var cur = 0;
      return theTemplate.replace(/%s/g, function (curVal) {
        return cur < values.length ? values[cur++] : curVal;
      });
    };
    var mergeMsgTemplate = function mergeMsgTemplate(originMT, newMT) {
      var targetMT = originMT;

      if (newMT) {
        Object.keys(originMT).forEach(function (key) {
          var originValue = originMT[key];
          var curValue = newMT === null || newMT === void 0 ? void 0 : newMT[key];
          targetMT[key] = isObject$2(originValue) ? __assign$1(__assign$1({}, originValue), curValue) : curValue || originValue;
        });
      }

      return targetMT;
    };

    var __extends = undefined && undefined.__extends || function () {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
          }
        };

        return _extendStatics(d, b);
      };

      return function (d, b) {
        _extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var __rest = undefined && undefined.__rest || function (s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }; // eslint-disable-next-line max-classes-per-file

    var BaseValidator =
    /** @class */
    function () {
      function BaseValidator(value, rule, options) {
        this.value = value;

        var _a = rule.message,
            message = _a === void 0 ? '' : _a,
            rest = __rest(rule, ["message"]);

        this.message = message || '';
        this.type = rule.type || ValidatorType.String;
        this.error = {
          value: value,
          message: [],
          errorTypes: []
        };
        this.field = options.field || '';
        this.rule = rest;
        this.validateRules = [];
        this.curValidMsgTemplate = mergeMsgTemplate(messageTemplate, options.validateMessage);
      }

      BaseValidator.prototype.isRequired = function () {
        // 优先级最高
        if (isEmptyValue(this.value) || isEmptyArray(this.value)) {
          this.error.message = [this.message || getMsgTemplate(this.curValidMsgTemplate, 'required', [this.field])];
          this.error.errorTypes = ['required'];
          return false;
        }

        return true;
      };

      BaseValidator.prototype.addError = function (errorType, message) {
        var _a;

        if (message) {
          this.error.errorTypes.push(errorType);
          (_a = this.error.message) === null || _a === void 0 ? void 0 : _a.push(message);
        }
      };

      BaseValidator.prototype.dealError = function (isError, _a) {
        var _b;

        var errTemplate = _a.errTemplate,
            values = _a.values;

        if (isError) {
          var theMessage = this.message || getMsgTemplate(this.curValidMsgTemplate, errTemplate, values);
          this.error.errorTypes.push(errTemplate);
          (_b = this.error.message) === null || _b === void 0 ? void 0 : _b.push(theMessage);
          return theMessage;
        }

        return '';
      };

      BaseValidator.prototype.getErrors = function () {
        return this.error;
      };

      return BaseValidator;
    }();

    var NumberValidator =
    /** @class */
    function (_super) {
      __extends(NumberValidator, _super);

      function NumberValidator(value, rules, options) {
        var _this = _super.call(this, value, rules, options) || this;

        _this.validateRules = ['min', 'max', 'equal', 'positive', 'negative'];
        return _this;
      }

      NumberValidator.prototype.min = function (num) {
        this.dealError(!isEmptyValue(this.value) && this.value < num, {
          errTemplate: 'number.min',
          values: [this.field, "" + num]
        });
      };

      NumberValidator.prototype.max = function (num) {
        this.dealError(!isEmptyValue(this.value) && this.value > num, {
          errTemplate: 'number.max',
          values: [this.field, "" + num]
        });
      };

      NumberValidator.prototype.equal = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value !== num, {
          errTemplate: 'number.equal',
          values: [this.field, "" + num]
        });
      };

      NumberValidator.prototype.positive = function () {
        return this.dealError(!isEmptyValue(this.value) && this.value < 0, {
          errTemplate: 'number.positive',
          values: [this.field]
        });
      };

      NumberValidator.prototype.negative = function () {
        return this.dealError(!isEmptyValue(this.value) && this.value > 0, {
          errTemplate: 'number.negative',
          values: [this.field]
        });
      };

      return NumberValidator;
    }(BaseValidator);

    var StringValidator =
    /** @class */
    function (_super) {
      __extends(StringValidator, _super);

      function StringValidator(value, rules, options) {
        var _this = _super.call(this, value, rules, options) || this;

        _this.validateRules = ['min', 'max', 'len', 'match', 'uppercase', 'lowercase', 'whitespace'];
        return _this;
      }

      StringValidator.prototype.min = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value.length < num, {
          errTemplate: 'string.min',
          values: [this.field, "" + num]
        });
      };

      StringValidator.prototype.max = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value.length > num, {
          errTemplate: 'string.max',
          values: [this.field, "" + num]
        });
      };

      StringValidator.prototype.len = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value !== num, {
          errTemplate: 'string.equal',
          values: [this.field, "" + num]
        });
      };

      StringValidator.prototype.match = function (regStr) {
        var reg = new RegExp(regStr);
        return this.dealError(!isEmptyValue(this.value) && !reg.test(this.value), {
          errTemplate: 'string.match',
          values: [this.field, regStr]
        });
      };

      StringValidator.prototype.uppercase = function (isValue) {
        var isUppercase = (this.value || '').toLocaleUpperCase() === this.value;
        return this.dealError(!isEmptyValue(this.value) && isUppercase !== isValue, {
          errTemplate: 'string.uppercase',
          values: [this.field]
        });
      };

      StringValidator.prototype.lowercase = function (isValue) {
        var isLowercase = (this.value || '').toLocaleLowerCase() === this.value;
        return this.dealError(!isEmptyValue(this.value) && isLowercase !== isValue, {
          errTemplate: 'string.lowercase',
          values: [this.field]
        });
      };

      StringValidator.prototype.whitespace = function () {
        return this.dealError(!isEmptyValue(this.value) && isEmptyValue(this.value.trim()), {
          errTemplate: 'string.whitespace',
          values: [this.field]
        });
      };

      return StringValidator;
    }(BaseValidator);

    var ArrayValidator =
    /** @class */
    function (_super) {
      __extends(ArrayValidator, _super);

      function ArrayValidator(value, rules, options) {
        var _this = _super.call(this, value, rules, options) || this;

        _this.validateRules = ['min', 'max', 'deepEqual', 'includes'];
        return _this;
      }

      ArrayValidator.prototype.min = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value.length < num, {
          errTemplate: 'array.min',
          values: [this.field, "" + num]
        });
      };

      ArrayValidator.prototype.max = function (num) {
        return this.dealError(!isEmptyValue(this.value) && this.value.length > num, {
          errTemplate: 'array.max',
          values: [this.field, "" + num]
        });
      };

      ArrayValidator.prototype.deepEqual = function (sub) {
        return this.dealError(!isDeepEqual(this.value, sub), {
          errTemplate: 'array.equal',
          values: [this.field, "" + JSON.stringify(sub)]
        });
      };

      ArrayValidator.prototype.includes = function (sub) {
        var _this = this;

        return this.dealError(sub.some(function (el) {
          return !_this.value.includes(el);
        }), {
          errTemplate: 'array.includes',
          values: [this.field, "" + JSON.stringify(sub)]
        });
      };

      return ArrayValidator;
    }(BaseValidator);

    var ObjectValidator =
    /** @class */
    function (_super) {
      __extends(ObjectValidator, _super);

      function ObjectValidator(value, rules, options) {
        var _this = _super.call(this, value, rules, options) || this;

        _this.validateRules = ['deepEqual', 'hasKeys'];
        return _this;
      }

      ObjectValidator.prototype.deepEqual = function (sub) {
        return this.dealError(!isDeepEqual(this.value, sub), {
          errTemplate: 'object.deepEqual',
          values: [this.field, "" + JSON.stringify(sub)]
        });
      };

      ObjectValidator.prototype.hasKeys = function (keys) {
        var allKeys = isEmptyValue(this.value) ? [] : Object.keys(this.value);
        return this.dealError(!isEmptyValue(this.value) && keys.some(function (theKey) {
          return !allKeys.includes(theKey);
        }), {
          errTemplate: 'object.hasKeys',
          values: [this.field, "" + JSON.stringify(keys)]
        });
      };

      return ObjectValidator;
    }(BaseValidator);

    var CustomValidator =
    /** @class */
    function (_super) {
      __extends(CustomValidator, _super);

      function CustomValidator(value, rules, options) {
        return _super.call(this, value, rules, options) || this;
      }

      CustomValidator.prototype.validator = function (validatorTool) {
        var _this = this;

        if (validatorTool) {
          return new Promise(function (resolve) {
            var ret = validatorTool(_this.value, function (message) {
              if (message === void 0) {
                message = '';
              }

              return _this.addError('custom', message || '');
            });

            if (ret && (ret === null || ret === void 0 ? void 0 : ret.then)) {
              ret.then(function () {
                return resolve(_this.getErrors());
              });
            } else {
              resolve(_this.getErrors());
            }
          });
        }

        return null;
      };

      return CustomValidator;
    }(BaseValidator);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var es6Promise$1 = createCommonjsModule(function (module, exports) {
    /*!
     * @overview es6-promise - a tiny implementation of Promises/A+.
     * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
     * @license   Licensed under MIT license
     *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
     * @version   v4.2.8+1e68dce6
     */

    (function (global, factory) {
    	module.exports = factory() ;
    }(commonjsGlobal, (function () {
    function objectOrFunction(x) {
      var type = typeof x;
      return x !== null && (type === 'object' || type === 'function');
    }

    function isFunction(x) {
      return typeof x === 'function';
    }



    var _isArray = void 0;
    if (Array.isArray) {
      _isArray = Array.isArray;
    } else {
      _isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    }

    var isArray = _isArray;

    var len = 0;
    var vertxNext = void 0;
    var customSchedulerFn = void 0;

    var asap = function asap(callback, arg) {
      queue[len] = callback;
      queue[len + 1] = arg;
      len += 2;
      if (len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (customSchedulerFn) {
          customSchedulerFn(flush);
        } else {
          scheduleFlush();
        }
      }
    };

    function setScheduler(scheduleFn) {
      customSchedulerFn = scheduleFn;
    }

    function setAsap(asapFn) {
      asap = asapFn;
    }

    var browserWindow = typeof window !== 'undefined' ? window : undefined;
    var browserGlobal = browserWindow || {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

    // node
    function useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function () {
        return process.nextTick(flush);
      };
    }

    // vertx
    function useVertxTimer() {
      if (typeof vertxNext !== 'undefined') {
        return function () {
          vertxNext(flush);
        };
      }

      return useSetTimeout();
    }

    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function () {
        node.data = iterations = ++iterations % 2;
      };
    }

    // web worker
    function useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = flush;
      return function () {
        return channel.port2.postMessage(0);
      };
    }

    function useSetTimeout() {
      // Store setTimeout reference so es6-promise will be unaffected by
      // other code modifying setTimeout (like sinon.useFakeTimers())
      var globalSetTimeout = setTimeout;
      return function () {
        return globalSetTimeout(flush, 1);
      };
    }

    var queue = new Array(1000);
    function flush() {
      for (var i = 0; i < len; i += 2) {
        var callback = queue[i];
        var arg = queue[i + 1];

        callback(arg);

        queue[i] = undefined;
        queue[i + 1] = undefined;
      }

      len = 0;
    }

    function attemptVertx() {
      try {
        var vertx = Function('return this')().require('vertx');
        vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return useVertxTimer();
      } catch (e) {
        return useSetTimeout();
      }
    }

    var scheduleFlush = void 0;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (isNode) {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else if (isWorker) {
      scheduleFlush = useMessageChannel();
    } else if (browserWindow === undefined && typeof commonjsRequire === 'function') {
      scheduleFlush = attemptVertx();
    } else {
      scheduleFlush = useSetTimeout();
    }

    function then(onFulfillment, onRejection) {
      var parent = this;

      var child = new this.constructor(noop);

      if (child[PROMISE_ID] === undefined) {
        makePromise(child);
      }

      var _state = parent._state;


      if (_state) {
        var callback = arguments[_state - 1];
        asap(function () {
          return invokeCallback(_state, child, callback, parent._result);
        });
      } else {
        subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }

    /**
      `Promise.resolve` returns a promise that will become resolved with the
      passed `value`. It is shorthand for the following:

      ```javascript
      let promise = new Promise(function(resolve, reject){
        resolve(1);
      });

      promise.then(function(value){
        // value === 1
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      let promise = Promise.resolve(1);

      promise.then(function(value){
        // value === 1
      });
      ```

      @method resolve
      @static
      @param {Any} value value that the returned promise will be resolved with
      Useful for tooling.
      @return {Promise} a promise that will become fulfilled with the given
      `value`
    */
    function resolve$1(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(noop);
      resolve(promise, object);
      return promise;
    }

    var PROMISE_ID = Math.random().toString(36).substring(2);

    function noop() {}

    var PENDING = void 0;
    var FULFILLED = 1;
    var REJECTED = 2;

    function selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
      try {
        then$$1.call(value, fulfillmentHandler, rejectionHandler);
      } catch (e) {
        return e;
      }
    }

    function handleForeignThenable(promise, thenable, then$$1) {
      asap(function (promise) {
        var sealed = false;
        var error = tryThen(then$$1, thenable, function (value) {
          if (sealed) {
            return;
          }
          sealed = true;
          if (thenable !== value) {
            resolve(promise, value);
          } else {
            fulfill(promise, value);
          }
        }, function (reason) {
          if (sealed) {
            return;
          }
          sealed = true;

          reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          reject(promise, error);
        }
      }, promise);
    }

    function handleOwnThenable(promise, thenable) {
      if (thenable._state === FULFILLED) {
        fulfill(promise, thenable._result);
      } else if (thenable._state === REJECTED) {
        reject(promise, thenable._result);
      } else {
        subscribe(thenable, undefined, function (value) {
          return resolve(promise, value);
        }, function (reason) {
          return reject(promise, reason);
        });
      }
    }

    function handleMaybeThenable(promise, maybeThenable, then$$1) {
      if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
        handleOwnThenable(promise, maybeThenable);
      } else {
        if (then$$1 === undefined) {
          fulfill(promise, maybeThenable);
        } else if (isFunction(then$$1)) {
          handleForeignThenable(promise, maybeThenable, then$$1);
        } else {
          fulfill(promise, maybeThenable);
        }
      }
    }

    function resolve(promise, value) {
      if (promise === value) {
        reject(promise, selfFulfillment());
      } else if (objectOrFunction(value)) {
        var then$$1 = void 0;
        try {
          then$$1 = value.then;
        } catch (error) {
          reject(promise, error);
          return;
        }
        handleMaybeThenable(promise, value, then$$1);
      } else {
        fulfill(promise, value);
      }
    }

    function publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      publish(promise);
    }

    function fulfill(promise, value) {
      if (promise._state !== PENDING) {
        return;
      }

      promise._result = value;
      promise._state = FULFILLED;

      if (promise._subscribers.length !== 0) {
        asap(publish, promise);
      }
    }

    function reject(promise, reason) {
      if (promise._state !== PENDING) {
        return;
      }
      promise._state = REJECTED;
      promise._result = reason;

      asap(publishRejection, promise);
    }

    function subscribe(parent, child, onFulfillment, onRejection) {
      var _subscribers = parent._subscribers;
      var length = _subscribers.length;


      parent._onerror = null;

      _subscribers[length] = child;
      _subscribers[length + FULFILLED] = onFulfillment;
      _subscribers[length + REJECTED] = onRejection;

      if (length === 0 && parent._state) {
        asap(publish, parent);
      }
    }

    function publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) {
        return;
      }

      var child = void 0,
          callback = void 0,
          detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback),
          value = void 0,
          error = void 0,
          succeeded = true;

      if (hasCallback) {
        try {
          value = callback(detail);
        } catch (e) {
          succeeded = false;
          error = e;
        }

        if (promise === value) {
          reject(promise, cannotReturnOwn());
          return;
        }
      } else {
        value = detail;
      }

      if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (succeeded === false) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        fulfill(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }

    function initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value) {
          resolve(promise, value);
        }, function rejectPromise(reason) {
          reject(promise, reason);
        });
      } catch (e) {
        reject(promise, e);
      }
    }

    var id = 0;
    function nextId() {
      return id++;
    }

    function makePromise(promise) {
      promise[PROMISE_ID] = id++;
      promise._state = undefined;
      promise._result = undefined;
      promise._subscribers = [];
    }

    function validationError() {
      return new Error('Array Methods must be provided an Array');
    }

    var Enumerator = function () {
      function Enumerator(Constructor, input) {
        this._instanceConstructor = Constructor;
        this.promise = new Constructor(noop);

        if (!this.promise[PROMISE_ID]) {
          makePromise(this.promise);
        }

        if (isArray(input)) {
          this.length = input.length;
          this._remaining = input.length;

          this._result = new Array(this.length);

          if (this.length === 0) {
            fulfill(this.promise, this._result);
          } else {
            this.length = this.length || 0;
            this._enumerate(input);
            if (this._remaining === 0) {
              fulfill(this.promise, this._result);
            }
          }
        } else {
          reject(this.promise, validationError());
        }
      }

      Enumerator.prototype._enumerate = function _enumerate(input) {
        for (var i = 0; this._state === PENDING && i < input.length; i++) {
          this._eachEntry(input[i], i);
        }
      };

      Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
        var c = this._instanceConstructor;
        var resolve$$1 = c.resolve;


        if (resolve$$1 === resolve$1) {
          var _then = void 0;
          var error = void 0;
          var didError = false;
          try {
            _then = entry.then;
          } catch (e) {
            didError = true;
            error = e;
          }

          if (_then === then && entry._state !== PENDING) {
            this._settledAt(entry._state, i, entry._result);
          } else if (typeof _then !== 'function') {
            this._remaining--;
            this._result[i] = entry;
          } else if (c === Promise$1) {
            var promise = new c(noop);
            if (didError) {
              reject(promise, error);
            } else {
              handleMaybeThenable(promise, entry, _then);
            }
            this._willSettleAt(promise, i);
          } else {
            this._willSettleAt(new c(function (resolve$$1) {
              return resolve$$1(entry);
            }), i);
          }
        } else {
          this._willSettleAt(resolve$$1(entry), i);
        }
      };

      Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
        var promise = this.promise;


        if (promise._state === PENDING) {
          this._remaining--;

          if (state === REJECTED) {
            reject(promise, value);
          } else {
            this._result[i] = value;
          }
        }

        if (this._remaining === 0) {
          fulfill(promise, this._result);
        }
      };

      Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
        var enumerator = this;

        subscribe(promise, undefined, function (value) {
          return enumerator._settledAt(FULFILLED, i, value);
        }, function (reason) {
          return enumerator._settledAt(REJECTED, i, reason);
        });
      };

      return Enumerator;
    }();

    /**
      `Promise.all` accepts an array of promises, and returns a new promise which
      is fulfilled with an array of fulfillment values for the passed promises, or
      rejected with the reason of the first passed promise to be rejected. It casts all
      elements of the passed iterable to promises as it runs this algorithm.

      Example:

      ```javascript
      let promise1 = resolve(1);
      let promise2 = resolve(2);
      let promise3 = resolve(3);
      let promises = [ promise1, promise2, promise3 ];

      Promise.all(promises).then(function(array){
        // The array here would be [ 1, 2, 3 ];
      });
      ```

      If any of the `promises` given to `all` are rejected, the first promise
      that is rejected will be given as an argument to the returned promises's
      rejection handler. For example:

      Example:

      ```javascript
      let promise1 = resolve(1);
      let promise2 = reject(new Error("2"));
      let promise3 = reject(new Error("3"));
      let promises = [ promise1, promise2, promise3 ];

      Promise.all(promises).then(function(array){
        // Code here never runs because there are rejected promises!
      }, function(error) {
        // error.message === "2"
      });
      ```

      @method all
      @static
      @param {Array} entries array of promises
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise} promise that is fulfilled when all `promises` have been
      fulfilled, or rejected if any of them become rejected.
      @static
    */
    function all(entries) {
      return new Enumerator(this, entries).promise;
    }

    /**
      `Promise.race` returns a new promise which is settled in the same way as the
      first passed promise to settle.

      Example:

      ```javascript
      let promise1 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 1');
        }, 200);
      });

      let promise2 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 2');
        }, 100);
      });

      Promise.race([promise1, promise2]).then(function(result){
        // result === 'promise 2' because it was resolved before promise1
        // was resolved.
      });
      ```

      `Promise.race` is deterministic in that only the state of the first
      settled promise matters. For example, even if other promises given to the
      `promises` array argument are resolved, but the first settled promise has
      become rejected before the other promises became fulfilled, the returned
      promise will become rejected:

      ```javascript
      let promise1 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 1');
        }, 200);
      });

      let promise2 = new Promise(function(resolve, reject){
        setTimeout(function(){
          reject(new Error('promise 2'));
        }, 100);
      });

      Promise.race([promise1, promise2]).then(function(result){
        // Code here never runs
      }, function(reason){
        // reason.message === 'promise 2' because promise 2 became rejected before
        // promise 1 became fulfilled
      });
      ```

      An example real-world use case is implementing timeouts:

      ```javascript
      Promise.race([ajax('foo.json'), timeout(5000)])
      ```

      @method race
      @static
      @param {Array} promises array of promises to observe
      Useful for tooling.
      @return {Promise} a promise which settles in the same way as the first passed
      promise to settle.
    */
    function race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      if (!isArray(entries)) {
        return new Constructor(function (_, reject) {
          return reject(new TypeError('You must pass an array to race.'));
        });
      } else {
        return new Constructor(function (resolve, reject) {
          var length = entries.length;
          for (var i = 0; i < length; i++) {
            Constructor.resolve(entries[i]).then(resolve, reject);
          }
        });
      }
    }

    /**
      `Promise.reject` returns a promise rejected with the passed `reason`.
      It is shorthand for the following:

      ```javascript
      let promise = new Promise(function(resolve, reject){
        reject(new Error('WHOOPS'));
      });

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      let promise = Promise.reject(new Error('WHOOPS'));

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      @method reject
      @static
      @param {Any} reason value that the returned promise will be rejected with.
      Useful for tooling.
      @return {Promise} a promise rejected with the given `reason`.
    */
    function reject$1(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(noop);
      reject(promise, reason);
      return promise;
    }

    function needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      let promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          let xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {Function} resolver
      Useful for tooling.
      @constructor
    */

    var Promise$1 = function () {
      function Promise(resolver) {
        this[PROMISE_ID] = nextId();
        this._result = this._state = undefined;
        this._subscribers = [];

        if (noop !== resolver) {
          typeof resolver !== 'function' && needsResolver();
          this instanceof Promise ? initializePromise(this, resolver) : needsNew();
        }
      }

      /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.
       ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```
       Chaining
      --------
       The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.
       ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });
       findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
       ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```
       Assimilation
      ------------
       Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.
       ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```
       If the assimliated promise rejects, then the downstream promise will also reject.
       ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```
       Simple Example
      --------------
       Synchronous Example
       ```javascript
      let result;
       try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```
       Errback Example
       ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```
       Promise Example;
       ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```
       Advanced Example
      --------------
       Synchronous Example
       ```javascript
      let author, books;
       try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```
       Errback Example
       ```js
       function foundBooks(books) {
       }
       function failure(reason) {
       }
       findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```
       Promise Example;
       ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```
       @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
      */

      /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.
      ```js
      function findAuthor(){
      throw new Error('couldn't find that author');
      }
      // synchronous
      try {
      findAuthor();
      } catch(reason) {
      // something went wrong
      }
      // async with promises
      findAuthor().catch(function(reason){
      // something went wrong
      });
      ```
      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
      */


      Promise.prototype.catch = function _catch(onRejection) {
        return this.then(null, onRejection);
      };

      /**
        `finally` will be invoked regardless of the promise's fate just as native
        try/catch/finally behaves
      
        Synchronous example:
      
        ```js
        findAuthor() {
          if (Math.random() > 0.5) {
            throw new Error();
          }
          return new Author();
        }
      
        try {
          return findAuthor(); // succeed or fail
        } catch(error) {
          return findOtherAuther();
        } finally {
          // always runs
          // doesn't affect the return value
        }
        ```
      
        Asynchronous example:
      
        ```js
        findAuthor().catch(function(reason){
          return findOtherAuther();
        }).finally(function(){
          // author was either found, or not
        });
        ```
      
        @method finally
        @param {Function} callback
        @return {Promise}
      */


      Promise.prototype.finally = function _finally(callback) {
        var promise = this;
        var constructor = promise.constructor;

        if (isFunction(callback)) {
          return promise.then(function (value) {
            return constructor.resolve(callback()).then(function () {
              return value;
            });
          }, function (reason) {
            return constructor.resolve(callback()).then(function () {
              throw reason;
            });
          });
        }

        return promise.then(callback, callback);
      };

      return Promise;
    }();

    Promise$1.prototype.then = then;
    Promise$1.all = all;
    Promise$1.race = race;
    Promise$1.resolve = resolve$1;
    Promise$1.reject = reject$1;
    Promise$1._setScheduler = setScheduler;
    Promise$1._setAsap = setAsap;
    Promise$1._asap = asap;

    /*global self*/
    function polyfill() {
      var local = void 0;

      if (typeof commonjsGlobal !== 'undefined') {
        local = commonjsGlobal;
      } else if (typeof self !== 'undefined') {
        local = self;
      } else {
        try {
          local = Function('return this')();
        } catch (e) {
          throw new Error('polyfill failed because global object is unavailable in this environment');
        }
      }

      var P = local.Promise;

      if (P) {
        var promiseToString = null;
        try {
          promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
          // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
          return;
        }
      }

      local.Promise = Promise$1;
    }

    // Strange compat..
    Promise$1.polyfill = polyfill;
    Promise$1.Promise = Promise$1;

    return Promise$1;

    })));




    });

    var __assign = undefined && undefined.__assign || function () {
      __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };

    var __spreadArrays = undefined && undefined.__spreadArrays || function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
      }

      for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
          r[k] = a[j];
        }
      }

      return r;
    };

    var Validator =
    /** @class */
    function () {
      function Validator(rules, options) {
        this.rules = rules;
        this.options = __assign({
          first: true
        }, options || {});
      }

      Validator.prototype.createValidatorGroup = function (value, rule, field) {
        var _a;

        var curOption = {
          field: field,
          validateMessage: (_a = this.options) === null || _a === void 0 ? void 0 : _a.validateMessages
        };
        return {
          number: new NumberValidator(value, rule, curOption),
          array: new ArrayValidator(value, rule, curOption),
          string: new StringValidator(value, rule, curOption),
          object: new ObjectValidator(value, rule, curOption),
          custom: new CustomValidator(value, rule, curOption)
        };
      }; // 一条rule执行


      Validator.prototype.getSingleValidateGroup = function (value, rule, field) {
        var vType = (rule === null || rule === void 0 ? void 0 : rule.type) || 'string';
        var validPromises = [];
        var validatorGroup = this.createValidatorGroup(value, rule, field);
        var typeValidator = vType in validatorGroup ? validatorGroup[vType] : null;

        if (rule.required) {
          validPromises.push(new es6Promise$1.Promise(function (resolve) {
            validatorGroup.string.isRequired();
            var curError = validatorGroup.string.getErrors();
            resolve(__assign(__assign({}, curError), {
              validateLevel: (rule === null || rule === void 0 ? void 0 : rule.validateLevel) || 'error'
            }));
          }));
        }

        if (typeValidator) {
          Object.keys(rule).map(function (key) {
            if (key === 'validator') {
              var resPromise = rule.validator ? validatorGroup.custom.validator(rule.validator || null) : null;
              resPromise && validPromises.push(resPromise);
              return;
            }

            if (typeValidator.validateRules.includes(key)) {
              validPromises.push(new es6Promise$1.Promise(function (resolve) {
                typeValidator.validateRules.includes(key) && typeValidator[key](rule[key]);
                var curError = typeValidator.getErrors();
                resolve(__assign(__assign({}, curError), {
                  validateLevel: (rule === null || rule === void 0 ? void 0 : rule.validateLevel) || 'error'
                }));
              }));
            }
          });
        }

        return validPromises;
      };

      Validator.prototype.singleValidate = function (promises) {
        var _this = this;

        var cur = 0;
        return new es6Promise$1.Promise(function (resolve) {
          var validate = function validate(promise) {
            var next = function next() {
              if (cur < promises.length - 1) {
                return validate(promises[++cur]);
              }

              return resolve({});
            };

            promise.then(function (errors) {
              var _a;

              if (_this.options.first && ((_a = errors.message || []) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return resolve(errors);
              }

              next();
            });
          };

          validate(promises[cur]);
        });
      };

      Validator.prototype.validate = function (value, callback) {
        var _this = this;

        var promiseGroup = [];
        var keys = [];

        if (this.rules) {
          Object.keys(this.rules).forEach(function (key) {
            var spPromiseGroup = [];

            if (isArray(_this.rules[key])) {
              for (var i = 0; i < _this.rules[key].length; i++) {
                var rule = _this.rules[key][i];

                var curPromises = _this.getSingleValidateGroup(value[key], rule, key);

                spPromiseGroup = __spreadArrays(spPromiseGroup, curPromises);
              }
            }

            if (spPromiseGroup.length) {
              promiseGroup.push(_this.singleValidate(spPromiseGroup));
              keys.push(key);
            }
          });
        }

        if (promiseGroup.length > 0) {
          es6Promise$1.Promise.all(promiseGroup).then(function (data) {
            var lastErrors = data.reduce(function (pre, cur, index) {
              if (!(keys[index] in pre)) {
                pre[keys[index]] = [];
              }

              pre[keys[index]].push(cur);
              return pre;
            }, {});
            callback && callback(lastErrors);
          });
        } else {
          callback && callback({});
        }
      };

      return Validator;
    }();

    /**
     * @type utils
     * @name utils
     */
    /**
     * 基于给定的过滤函数返回一个过滤后的数组
     * @desc {en} Returns a filtered array based on the given filter function
     * @param {T[]} data 数据数组
     * @param {T[]} data {en} data array
     * @param {Function} filterFn 过滤函数
     * @param {Function} filterFn {en} filter function
     * @param {Object} options 可选对象
     * @param {Object} options {en} Optional object
     * @return {string} 过滤后的数组
     * @return {string} filtered array
     * @example
     * ```
     * import { arrayTreeFilter } from '@arco-design/mobile-utils';
     *
     * const test = arrayTreeFilter(data, (item: any, level: number) => level <= index && item.value === value[level]);
     * ```
     */

    function arrayTreeFilter(data, filterFn, options) {
      options = options || {};
      options.childrenKeyName = options.childrenKeyName || 'children';
      var children = data || [];
      var result = [];
      var level = 0;

      do {
        var foundItem = children.find(function (item) {
          return filterFn(item, level);
        });

        if (!foundItem && options.fallbackChildIndex !== undefined) {
          foundItem = children[options.fallbackChildIndex];
        }

        if (!foundItem) {
          break;
        }

        result.push(foundItem);
        children = foundItem[options.childrenKeyName] || [];
        level += 1;
      } while (children.length > 0);

      return result;
    }
    /**
     * 在下一个事件循环周期执行给定的函数
     * @desc {en} Execute the given function on the next event loop cycle
     * @param {Function} func 执行的函数
     * @param {Function} func {en} function executed
     * @example
     * ```
     * import { nextTick } from '@arco-design/mobile-utils';
     *
     * nextTick(() => { updateLayoutData(); });
     * ```
     */

    function nextTick(func) {
      setTimeout(func, 20);
    }
    /**
     * 模拟滑动阻尼效果，使用函数x = X/(aX+b)，x为元素位移，X为滑动距离，a,b为自定义参数通过设置两个目标对应关系求得
     * @desc {en} To simulate the sliding damping effect, use the function x = X/(aX+b), where x is the element displacement, X is the sliding distance, and a and b are custom parameters obtained by setting the corresponding relationship between the two targets
     * 例如目标X=500时x=100, X=200时x=60，可得a,b
     * @desc {en} For example, when the target X=500, x=100, when X=200, x=60, you can get a,b
     * @param {number} x 元素位移
     * @param {number} x {en} element displacement
     * @param {[number, number] | number} damping 阻尼参数
     * @param {[number, number] | number} damping {en} Damping parameters
     * @return {number} 返回需要滑动的距离
     * @return {number} {en} Return the distance required to slide
     * @example
     * ```
     * import { fingerDisToLabelDis } from '@arco-design/mobile-utils';
     *
     * const test = fingerDisToLabelDis(1000, 0.01);
     * ```
     */

    function fingerDisToLabelDis(x, damping) {
      var dampArr = typeof damping === 'number' ? [damping] : damping;

      var _a = dampArr || [],
          _b = _a[0],
          a = _b === void 0 ? 0.013312 : _b,
          _c = _a[1],
          b = _c === void 0 ? 1.636345 : _c;

      return x / (a * x + b);
    }

    var DEFAULT_DARK_MODE_SELECTOR = 'arco-theme-dark';
    var defaultContext = {
      prefixCls: 'arco',
      system: '',
      useDarkMode: false,
      darkModeSelector: DEFAULT_DARK_MODE_SELECTOR,
      locale: defaultLocale,
      useRtl: false
    };
    var GlobalContext = /*#__PURE__*/React.createContext(defaultContext);
    /**
     * 全局数据控制组件，用于替换全局数据。
     * @en Global data control component, used to replace global data.
     * @type 其他
     * @type_en Others
     * @name 全局配置
     * @name_en ContextProvider
     */

    function ContextProvider(props) {
      var children = props.children,
          useDarkMode = props.useDarkMode,
          userSetIsDarkMode = props.isDarkMode,
          _a = props.darkModeSelector,
          darkModeSelector = _a === void 0 ? DEFAULT_DARK_MODE_SELECTOR : _a,
          theme = props.theme,
          _b = props.locale,
          locale = _b === void 0 ? defaultLocale : _b,
          onDarkModeChange = props.onDarkModeChange,
          restProps = __rest$1(props, ["children", "useDarkMode", "isDarkMode", "darkModeSelector", "theme", "locale", "onDarkModeChange"]);

      var _c = React.useState(function () {
        if (typeof window !== 'undefined' && useDarkMode) {
          return window.matchMedia('(prefers-color-scheme: dark)').matches;
        }

        return false;
      }),
          isDarkModeState = _c[0],
          setIsDarkModeState = _c[1];

      var mountedRef = React.useRef(false);

      var setDarkModeState = function setDarkModeState(isDark, needChange) {
        if (needChange === void 0) {
          needChange = true;
        }

        setIsDarkModeState(isDark);
        needChange && onDarkModeChange && onDarkModeChange(isDark);
      };

      var isDarkMode = React.useMemo(function () {
        // 如果未开启暗黑模式则不对body做操作
        // @en If dark mode is not turned on, no operation will be performed on the body
        if (userSetIsDarkMode === void 0 && !useDarkMode) {
          return false;
        }

        var value = Boolean(userSetIsDarkMode !== void 0 ? userSetIsDarkMode : isDarkModeState);
        var needUpdateBody = darkModeSelector && typeof document !== 'undefined';

        if (value) {
          needUpdateBody && document.body.classList.add(darkModeSelector);
        } else {
          needUpdateBody && document.body.classList.remove(darkModeSelector);
        }

        return value;
      }, [userSetIsDarkMode, isDarkModeState, darkModeSelector, useDarkMode]);
      var changeDarkMode = React.useCallback(function (res) {
        return setDarkModeState(res.matches);
      }, []);
      React.useEffect(function () {
        var matchMedia = window.matchMedia('(prefers-color-scheme: dark)');

        if (useDarkMode) {
          var dark = matchMedia.matches;
          setDarkModeState(dark, mountedRef.current);

          if (typeof matchMedia.addEventListener === 'function') {
            matchMedia.addEventListener('change', changeDarkMode);
          } else if (typeof matchMedia.addListener === 'function') {
            matchMedia.addListener(changeDarkMode);
          }
        }

        mountedRef.current = true;
        return function () {
          if (useDarkMode) {
            if (typeof matchMedia.removeEventListener === 'function') {
              matchMedia.removeEventListener('change', changeDarkMode);
            } else if (typeof matchMedia.removeListener === 'function') {
              matchMedia.removeListener(changeDarkMode);
            }
          }
        };
      }, [useDarkMode]);
      React.useEffect(function () {
        if (!theme) {
          return;
        }

        addCssRules('arcoCustomTheme', theme);
        return function () {
          removeCssStyleDom('arcoCustomTheme');
        };
      }, [theme]);
      return /*#__PURE__*/React__default["default"].createElement(GlobalContext.Provider, {
        value: __assign$2(__assign$2(__assign$2({}, defaultContext), restProps), {
          isDarkMode: isDarkMode,
          useDarkMode: useDarkMode,
          locale: locale || defaultLocale
        })
      }, children);
    }
    var ContextLayout = GlobalContext.Consumer;
    function CompWithGlobalContext(Component) {
      return function (props) {
        var propsContext = props.context,
            others = __rest$1(props, ["context"]);

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (context) {
          return /*#__PURE__*/React__default["default"].createElement(ContextProvider, __assign$2({}, __assign$2(__assign$2({}, context), propsContext)), /*#__PURE__*/React__default["default"].createElement(Component, __assign$2({}, others)));
        });
      };
    }

    /**
     * 监听页面resize事件的统一封装
     * @desc {en} Unified encapsulation for monitoring page resize events
     * @param resizeHandler resize事件回调
     * @param resizeHandler {en} Resize event callback
     * @param deps 触发事件绑定更新的依赖
     * @param deps {en} Dependencies that trigger event binding updates
     * @param needListen 是否开启事件监听，默认开启
     * @param needListen {en} Whether to enable event monitoring
     * @example
     * ```
     * import { useListenResize } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * useListenResize(setSize, [], listenResize);
     * ```
     */

    function useListenResize(resizeHandler, deps, needListen) {
      if (deps === void 0) {
        deps = [];
      }

      if (needListen === void 0) {
        needListen = true;
      }

      React.useEffect(function () {
        if (needListen) {
          window.addEventListener('resize', resizeHandler);
          window.addEventListener('orientationchange', resizeHandler);
        }

        return function () {
          if (needListen) {
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', resizeHandler);
          }
        };
      }, __spreadArrays$1(deps, [needListen]));
    }
    /**
     * useState自定义封装，统一处理在组件卸载后还使用setState的行为
     * tips：在unmount后有异步处理未完成的场景使用，不推荐无脑替换useState
     * @desc {en} Custom encapsulation of useState, uniformly handle the behavior of using setState after the component is unloaded
     * @desc {en} Tips: Use in scenarios where asynchronous processing is not completed after unmount. It is not recommended to replace useState without brains
     * @param initialState 初始状态
     * @param initialState {en} Initial State
     * @returns [state, setState]，同useState返回值
     * @example
     * ```
     * import { useMountedState } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const [scrollValue, setScrollValue] = useMountedState(value);
     * ```
     */

    function useMountedState(initialState) {
      var _a = React.useState(initialState),
          state = _a[0],
          setState = _a[1];

      var leavingRef = React.useRef(false);
      var setValidState = React.useCallback(function (value) {
        if (leavingRef.current) {
          return;
        }

        setState(value);
      }, []);
      React.useEffect(function () {
        return function () {
          leavingRef.current = true;
        };
      }, []);
      var result = [state, setValidState];
      return result;
    }
    /**
     * 用useState管理状态，且在状态更新之前同步至ref，并返回ref
     * @desc {en} Use useState to manage the state, and synchronize to ref before the state is updated, and return ref
     * @param initialValue 初始状态
     * @param initialValue {en} Initial State
     * @returns [state, stateRef, setState]
     * @example
     * ```
     * import { useSameRefState } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const [opened, openedRef, setOpened] = useSameRefState(false);
     * ```
     */

    function useSameRefState(initialValue) {
      var _a = React.useState(initialValue),
          state = _a[0],
          setState = _a[1];

      var stateRef = React.useRef(state);

      var setStateProxy = function setStateProxy(data) {
        stateRef.current = data;
        setState(data);
      };

      return [state, stateRef, setStateProxy];
    }
    /**
     * 用useState管理状态，且在状态更新后同步至ref，并返回ref
     * @desc {en} Use useState to manage the state, and synchronize to ref after the state is updated, and return ref
     * @param initialValue 初始状态
     * @param initialValue {en} Initial State
     * @returns [state, stateRef, setState]
     * @example
     * ```
     * import { useRefState } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const [index, indexRef, setIndex] = useRefState(currentIndex);
     * ```
     */

    function useRefState(initialValue) {
      var _a = React.useState(initialValue),
          state = _a[0],
          setState = _a[1];

      var stateRef = React.useRef(state);
      React.useEffect(function () {
        stateRef.current = state;
      }, [state]);
      return [state, stateRef, setState];
    }
    /**
     * useEffect特殊封装，仅在非首次依赖更新时触发回调
     * @desc {en} Special encapsulation of useEffect, which only triggers the callback when the dependency is not updated for the first time
     * @param effect useEffect回调
     * @param effect {en} useEffect callback
     * @param dependencies useEffect依赖
     * @param dependencies {en} useEffect dependencies
     * @example
     * ```
     * import { useUpdateEffect } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * useUpdateEffect(() => {
     *     handleIndexChange(index);
     * }, [index]);
     * ```
     */

    function useUpdateEffect(effect, dependencies) {
      if (dependencies === void 0) {
        dependencies = [];
      }

      var isInitialMount = React.useRef(true);
      React.useEffect(function () {
        if (isInitialMount.current) {
          isInitialMount.current = false;
        } else {
          return effect();
        }
      }, dependencies);
    }
    /**
     * 获取任意变量的最新ref值（用于监听属性、方法等非state变量）
     * @desc {en} Get the latest ref value of any variable (used to monitor non-state variables such as properties and methods)
     * @param variable 待获取最新值的变量
     * @param variable {en} Variable to get latest value
     * @returns variableRef，变量的最新ref值
     * @example
     * ```
     * import { useLatestRef } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const { wrapSize } = props;
     * const wrapSizeRef = useLatestRef(wrapSize);
     * ```
     */

    function useLatestRef(variable) {
      var variableRef = React.useRef(variable);
      React.useEffect(function () {
        variableRef.current = variable;
      }, [variable]);
      return variableRef;
    }
    /**
     * 从navigator.userAgent中获取当前操作系统，如果无法获取ua，则从ContextProvider传入的system中获取值
     * @desc {en} Get the current operating system from navigator.userAgent, if ua cannot be obtained, get the value from the system passed in by ContextProvider
     * @returns system 操作系统，"" | "pc" | "android" | "ios"
     * @example
     * ```
     * import { useSystem } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const system = useSystem();
     * ```
     */

    function useSystem() {
      var currentSystem = React.useContext(GlobalContext).system;

      var _a = React.useState(function () {
        return currentSystem || getSystem();
      }),
          system = _a[0],
          setSystem = _a[1];

      React.useEffect(function () {
        setSystem(currentSystem || getSystem());
      }, [currentSystem]);
      return system;
    }
    /**
     * 获取页面视口宽高大小，并在页面有resize时更新大小
     * @desc {en} Get the width and height of the page viewport, and update the size when the page is resized
     * @param needListen 是否开启resize事件监听
     * @param needListen {en} Whether to enable resize event monitoring
     * @returns 页面宽高，{ windowWidth, windowHeight }
     * @example
     * ```
     * import { useWindowSize } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const { windowHeight, windowWidth } = useWindowSize();
     * ```
     */

    function useWindowSize(listenResize) {
      var _a = React.useState(typeof window !== 'undefined' ? window.innerWidth : 0),
          windowWidth = _a[0],
          setWindowWidth = _a[1];

      var _b = React.useState(typeof window !== 'undefined' ? window.innerHeight : 0),
          windowHeight = _b[0],
          setWindowHeight = _b[1];

      function setSize() {
        setWindowWidth(window.innerWidth);
        setWindowHeight(window.innerHeight);
      }

      useListenResize(setSize, [], listenResize);
      React.useEffect(function () {
        setSize();
      }, []);
      return {
        windowWidth: windowWidth,
        windowHeight: windowHeight
      };
    }
    /**
     * 弹窗中滚动统一处理，防止滚动穿透
     * @desc {en} Unified processing of scrolling in pop-up windows to prevent scrolling penetration
     * @param visible 弹窗是否被打开
     * @param visible {en} Whether the popup is opened
     * @param popupDom 弹窗的dom元素
     * @param popupDom {en} DOM element of the popup
     * @param getScrollContainer 弹窗中的滚动容器，可传入多个
     * @param getScrollContainer {en} The scrolling container in the popup, which can pass in multiple
     * @param orientationDirection 弹窗内容朝向，默认为top（从上到下），用于实现模拟横屏
     * @param orientationDirection {en} The content orientation of the popup, the default is top (from top to bottom), which is used to simulate a horizontal screen
     * @param preventCallback 在滚动穿透被阻止（preventDefault被触发）时的回调
     * @param preventCallback {en} Callback when scrolling is blocked (preventDefault is triggered)
     * @param onTouchMove touchmove 自定义事件
     * @param onTouchMove {en} Touchmove custom event
     * @param gestureOutOfControl 是否禁用滚动穿透处理
     * @param gestureOutOfControl {en} Whether to disable scroll through processing
     * @example
     * ```
     * import { usePopupScroll } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * usePopupScroll(visible, domRef.current, getScrollContainer, orientationDirection, onPreventTouchMove, onTouchMove, gestureOutOfControl);
     * ```
     */

    function usePopupScroll(visible, popupDom, getScrollContainer, orientationDirection, preventCallback, onTouchMove, gestureOutOfControl) {
      if (orientationDirection === void 0) {
        orientationDirection = 'top';
      }

      var scrollRef = React.useRef([]);
      var touchingRef = React.useRef({
        dom: null,
        inScrollIndexes: []
      });
      var touchStartYRef = React.useRef(0);
      var touchStartXRef = React.useRef(0);
      var preventCallbackRef = useLatestRef(preventCallback);
      var onTouchMoveRef = useLatestRef(onTouchMove);
      var handleTouchStart = React.useCallback(function (e) {
        if (gestureOutOfControl) {
          return;
        }

        touchStartXRef.current = e.touches && e.touches[0] ? e.touches[0].clientX : 0;
        touchStartYRef.current = e.touches && e.touches[0] ? e.touches[0].clientY : 0;
        var ele = getScrollContainer ? getScrollContainer() : null;

        if (ele) {
          var actualEle = Array.isArray(ele) ? ele : [ele];
          scrollRef.current = actualEle.reduce(function (acc, nowEle) {
            return __spreadArrays$1(acc, nowEle && safeGetComputedStyle(nowEle).overflow !== 'hidden' ? [{
              ele: nowEle,
              maxScrollX: orientationDirection === 'left' || orientationDirection === 'right' ? nowEle.scrollHeight - nowEle.clientHeight : nowEle.scrollWidth - nowEle.clientWidth,
              maxScrollY: orientationDirection === 'left' || orientationDirection === 'right' ? nowEle.scrollWidth - nowEle.clientWidth : nowEle.scrollHeight - nowEle.clientHeight
            }] : []);
          }, []);
        } else {
          scrollRef.current = [];
        }

        touchingRef.current = {
          dom: null,
          inScrollIndexes: []
        };
      }, [getScrollContainer, gestureOutOfControl, orientationDirection]);

      function judgeInScroll(originNode, scroll) {
        var inScrollIndexes = [];

        for (var i = 0; i < scroll.length; i += 1) {
          var node = originNode;

          while (node && scroll[i]) {
            if (node === scroll[i].ele) {
              inScrollIndexes.push(i);
              break;
            } else {
              node = node.parentElement;
            }
          }
        }

        touchingRef.current = {
          dom: originNode,
          inScrollIndexes: inScrollIndexes
        };
        return inScrollIndexes;
      }

      var handleTouchMove = React.useCallback(function (e) {
        var _a, _b, _c, _d;

        function getScrollTop(scroll) {
          var ele = scroll.ele,
              maxScrollX = scroll.maxScrollX,
              maxScrollY = scroll.maxScrollY;

          switch (orientationDirection) {
            case 'left':
              return maxScrollY - ele.scrollLeft;

            case 'right':
              return ele.scrollLeft;

            case 'bottom':
              return maxScrollX - ele.scrollTop;

            case 'top':
            default:
              return ele.scrollTop;
          }
        }

        function getScrollLeft(scroll) {
          var ele = scroll.ele,
              maxScrollX = scroll.maxScrollX,
              maxScrollY = scroll.maxScrollY;

          switch (orientationDirection) {
            case 'left':
              return ele.scrollTop;

            case 'right':
              return maxScrollX - ele.scrollTop;

            case 'bottom':
              return maxScrollY - ele.scrollLeft;

            case 'top':
            default:
              return ele.scrollLeft;
          }
        }

        var touchMoveX = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0;
        var touchMoveY = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0;
        var scroll = scrollRef.current;
        var node = e.target;
        var _e = touchingRef.current,
            touchingDom = _e.dom,
            touchingIndexes = _e.inScrollIndexes; // target一样就取缓存结果，不取dom判断了
        // @en If the target is the same, the cached result is taken, and the dom judgment is not taken.

        var inScrollIndexes = touchingDom === node ? touchingIndexes : judgeInScroll(node, scroll);
        var distanceX = touchMoveX - touchStartXRef.current;
        var distanceY = touchMoveY - touchStartYRef.current;
        var absX = Math.abs(distanceX);
        var absY = Math.abs(distanceY);
        var direc = absY > absX ? 'y' : 'x';
        var prevented = false;

        if (gestureOutOfControl) {
          (_a = onTouchMoveRef.current) === null || _a === void 0 ? void 0 : _a.call(onTouchMoveRef, e, prevented, direc);
          return;
        }

        if (scroll.length && inScrollIndexes.length) {
          var needPrevents = [];

          for (var i = 0; i < inScrollIndexes.length; i += 1) {
            var touchingScroll = scroll[inScrollIndexes[i]];
            var scrollTop = getScrollTop(touchingScroll);
            var scrollLeft = getScrollLeft(touchingScroll);

            if (distanceY > 0 && absY > absX && scrollTop === 0 || distanceX > 0 && absX > absY && scrollLeft === 0) {
              needPrevents.push(true);
              continue;
            }

            if (distanceY < 0 && absY > absX && scrollTop + 1 >= touchingScroll.maxScrollY || distanceX < 0 && absX > absY && scrollLeft + 1 >= touchingScroll.maxScrollX) {
              needPrevents.push(true);
              continue;
            }

            needPrevents.push(false);
          } // 满足一个不prevent的条件就停止prevent，否则prevent
          // @en Stop prevent if a non-prevent condition is met, otherwise prevent.


          if (needPrevents.indexOf(false) < 0) {
            (_b = preventCallbackRef.current) === null || _b === void 0 ? void 0 : _b.call(preventCallbackRef, e, direc);
            e.cancelable && e.preventDefault();
            prevented = true;
          }
        } else {
          (_c = preventCallbackRef.current) === null || _c === void 0 ? void 0 : _c.call(preventCallbackRef, e, direc);
          e.cancelable && e.preventDefault();
          prevented = true;
        }

        (_d = onTouchMoveRef.current) === null || _d === void 0 ? void 0 : _d.call(onTouchMoveRef, e, prevented, direc);
      }, [orientationDirection, gestureOutOfControl]);
      React.useEffect(function () {
        if (!visible || !popupDom) {
          return function () {};
        }

        popupDom.addEventListener('touchstart', handleTouchStart);
        popupDom.addEventListener('touchmove', handleTouchMove, {
          passive: false
        });
        return function () {
          popupDom.removeEventListener('touchstart', handleTouchStart);
          popupDom.removeEventListener('touchmove', handleTouchMove);
        };
      }, [visible, popupDom, handleTouchStart, handleTouchMove]);
    }
    /**
     * 在滑动类组件中，如果有内部可滚动区域，则在内部滚动区域滚动时禁用滑动事件
     * @desc {en} In the sliding class component, if there is an inner scrollable area, the sliding event is disabled when the inner scrolling area is scrolled
     * @param getInnerScrollContainer 内部可滚动区域，可传入多个
     * @param getInnerScrollContainer {en} Inner scrollable area, can pass in multiple
     * @example
     * ```
     * import { useSwiperInnerScroll } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * useSwiperInnerScroll(getInnerScrollContainer);
     * ```
     */

    function useSwiperInnerScroll(getInnerScrollContainer) {
      var stopFunc = React.useCallback(function (e) {
        return e.stopPropagation();
      }, []);
      React.useEffect(function () {
        if (!getInnerScrollContainer) {
          return;
        }

        var containers = getInnerScrollContainer();
        var validContainers = Array.isArray(containers) ? containers : [containers];
        validContainers.forEach(function (container) {
          if (container) {
            container.addEventListener('touchstart', stopFunc);
            container.addEventListener('touchmove', stopFunc);
          }
        });
        return function () {
          validContainers.forEach(function (container) {
            if (container) {
              container.removeEventListener('touchstart', stopFunc);
              container.removeEventListener('touchmove', stopFunc);
            }
          });
        };
      }, [getInnerScrollContainer]);
    }
    /**
     * 事件绑定统一封装
     * @desc {en} Unified encapsulation of event binding
     * @param dom 待绑定事件的dom元素
     * @param dom {en} The dom element to be bound to the event
     * @param event 待绑定事件名称
     * @param event {en} The name of the event to be bound
     * @param handler 待绑定事件回调
     * @param handler {en} The callback of the event to be bound
     * @param options 待绑定事件配置，默认为 { capture: true }
     * @param options {en} Event configuration to be bound, the default is { capture: true }
     * @example
     * ```
     * import { useAddListener } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * useAddListener(domRef.current, 'touchstart', onTouchStart);
     * useAddListener(domRef.current, 'touchend', onTouchEnd);
     * ```
     */

    function useAddListener(dom, event, handler, options) {
      if (options === void 0) {
        options = {
          capture: true
        };
      }

      React.useEffect(function () {
        if (!dom) return;

        if (handler) {
          dom.addEventListener(event, handler, options);
        }

        return function () {
          if (handler) {
            dom.removeEventListener(event, handler, options);
          }
        };
      }, [handler]);
    }
    /**
     * 统计同时出现的全屏组件
     * @en Count simultaneous full-screen components
     */

    var arcoFullScreenCount = 0;
    var arcoFullScreenOriginOverflow = '';
    /**
     * 在全屏组件出现时，将body的overflow设置为hidden，防止滚动穿透
     * @desc {en} When the full screen component appears, set the overflow of the body to hidden to prevent scrolling penetration
     * @param visible 全屏组件是否被打开
     * @param visible {en} Whether the full screen component is opened
     * @param preventBodyScroll 是否启用防滚动穿透，默认启用
     * @param preventBodyScroll {en} Whether to enable anti-scroll penetration, enabled by default
     * @param initialBodyOverflow body在初始状态下的overflow值，在全屏组件全部关闭后会还原
     * @param initialBodyOverflow {en} The overflow value of the body in the initial state, which will be restored after all full-screen components are closed
     * @example
     * ```
     * import { usePreventBodyScroll } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * usePreventBodyScroll(visible, preventBodyScroll, initialBodyOverflow);
     * ```
     */

    function usePreventBodyScroll(visible, preventBodyScroll, initialBodyOverflow) {
      if (preventBodyScroll === void 0) {
        preventBodyScroll = true;
      } // 新出现一个全屏组件则计数+1，并设置body hidden样式
      // @en When a new full-screen component appears, count + 1 and set the body hidden style


      var addFullScreen = React.useCallback(function () {
        var count = arcoFullScreenCount; // 在当前没有全屏组件出现时，记下body overflow的初始值
        // @en Note the initial value of body overflow when no full-screen components are currently present

        if (!count) {
          arcoFullScreenOriginOverflow = initialBodyOverflow !== void 0 ? initialBodyOverflow : document.body.style.overflow;
        }

        arcoFullScreenCount += 1;
        document.body.style.overflow = 'hidden';
      }, []);
      /**
       * 移除一个全屏组件时，根据剩余是否还有全屏组件判断是否需要还原overflow样式
       * @en When removing a full-screen component, determine whether the overflow style needs to be restored according to whether there are any remaining full-screen components.
       */

      var removeFullScreen = React.useCallback(function () {
        var newCount = arcoFullScreenCount - 1;
        arcoFullScreenCount = newCount;

        if (!newCount) {
          document.body.style.overflow = arcoFullScreenOriginOverflow;
        }
      }, []);
      React.useEffect(function () {
        if (!preventBodyScroll) {
          return function () {};
        } // 如果一开始就是visible=true则加上样式
        // @en If it is visible=true at the beginning, add the style.


        if (visible) {
          addFullScreen();
        }

        return function () {
          // 如果这里visible为true，则说明即将隐藏组件或在展示时卸载组件
          // @en If visible here is true, it means that the component is about to be hidden or unloaded when displayed.
          if (visible) {
            removeFullScreen();
          }
        };
      }, [visible]);
    }
    /**
     * 进度条计算公共逻辑，根据传入的参数计算出当前百分比和过渡效果开关，进度类组件内部使用
     * @desc {en} Progress bar calculation common logic, used internally by the progress class component
     * @returns [当前计算的百分比, 当前是否应有过渡效果]
     * @example
     * ```
     * import { usePreventBodyScroll } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const [currentPercentage, transitionControl] = useProgress(mountedTransition, percentage, duration, mountedBezier, step);
     * ```
     */

    function useProgress(mountedTransition, percentage, duration, mountedBezier, step) {
      var _a = React.useState(0),
          currentPercentage = _a[0],
          setCurrentPercentage = _a[1];

      var _b = React.useState(false),
          transitionControl = _b[0],
          setTransitionControl = _b[1];

      var _c = React.useState(0),
          count = _c[0],
          setCount = _c[1];

      var latestPercentage = React.useRef(percentage);
      React.useEffect(function () {
        mountedTransition ? scrollWithAnimation(0, percentage, function (progress) {
          var targetProgress = progress / percentage * latestPercentage.current;
          setCurrentPercentage(Math.floor(targetProgress));
        }, duration, mountedBezier) : setCurrentPercentage(percentage);
        var id = setTimeout(function () {
          setTransitionControl(true);
        }, 30);
        return function () {
          return clearTimeout(id);
        };
      }, []);
      React.useEffect(function () {
        latestPercentage.current = percentage;
        setCount(Math.floor(percentage / step));
      }, [percentage, step]);
      React.useEffect(function () {
        percentage === 100 ? setCurrentPercentage(100) : setCurrentPercentage(count * step);
      }, [count, percentage, step]);
      return [currentPercentage, transitionControl];
    }
    /**
     * 单击和双击事件统一处理
     * @desc {en} Unified processing of single and double click events
     * @param onClick 单击事件回调
     * @param onClick {en} Callback of single click event
     * @param onDoubleClick 双击事件回调
     * @param onDoubleClick {en} Callback of double click event
     * @param delay 两次点击被判定为双击事件的最大间隔时间
     * @param delay {en} The maximum interval between two clicks is judged as a double-click event
     * @returns clickHandler，统一后的事件处理方法
     * @example
     * ```
     * import { useSingleAndDoubleClick } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const handleClick = useSingleAndDoubleClick(handleImageClick, handleImageDoubleClick);
     * ```
     */

    function useSingleAndDoubleClick(onClick, onDoubleClick, delay) {
      if (delay === void 0) {
        delay = 200;
      }

      var _a = React.useState(0),
          clickTimes = _a[0],
          setClickTimes = _a[1];

      var eventRef = React.useRef();
      React.useEffect(function () {
        var timer = setTimeout(function () {
          if (clickTimes === 1) onClick(eventRef.current);
          setClickTimes(0);
        }, delay);
        if (clickTimes === 2) onDoubleClick(eventRef.current);
        return function () {
          return clearTimeout(timer);
        };
      }, [clickTimes]);
      return function (e) {
        eventRef.current = e;
        setClickTimes(function (prev) {
          return prev + 1;
        });
      };
    }
    var arcoSvgKeyCount = 0;
    /**
     * 自动生成svg <def>标签的唯一标识，用于区分不同svg的<def>内容
     * @desc {en} Automatically generate the unique identifier of the svg <def> tag, which is used to distinguish the <def> content of different svg
     * @param userSetSvgKey 自定义唯一标识，传入则覆盖自动生成的值
     * @param userSetSvgKey {en} Customize the unique identifier, if passed in, it will override the automatically generated value
     * @returns 包含svgKey的对象 生成后的唯一标识
     * @globalVariable
     * ```
     * let arcoSvgKeyCount = 0;
     * ```
     * @example
     * ```
     * import { useGenSvgKey } from '@arco-design/mobile-react/esm/_helpers/hooks';
     *
     * const { svgKey } = useGenSvgKey(userSetSvgKey);
     * ```
     */

    function useGenSvgKey(userSetSvgKey) {
      var _a = React.useState(''),
          innerSvgKey = _a[0],
          setInnerSvgKey = _a[1];

      var svgKey = userSetSvgKey || innerSvgKey;
      React.useEffect(function () {
        setInnerSvgKey("inner-" + arcoSvgKeyCount);
        arcoSvgKeyCount += 1;
      }, []);
      return {
        svgKey: svgKey
      };
    }

    var _a;

    function isObject$1(obj) {
      return Object.prototype.toString.call(obj) === '[object Object]';
    }

    var __SECRET_INTERNALS__ = '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED';
    var CopyReactDOM = ReactDOM__default["default"];
    var copyRender;
    var isReact18 = Number((_a = CopyReactDOM.version) === null || _a === void 0 ? void 0 : _a.split('.')[0]) > 17;

    var updateUsingClientEntryPoint = function updateUsingClientEntryPoint(skipWarning) {
      // https://github.com/facebook/react/blob/17806594cc28284fe195f918e8d77de3516848ec/packages/react-dom/npm/client.js#L10
      // Avoid console warning
      if (isObject$1(CopyReactDOM[__SECRET_INTERNALS__])) {
        CopyReactDOM[__SECRET_INTERNALS__].usingClientEntryPoint = skipWarning;
      }
    };

    var createRoot;

    try {
      createRoot = CopyReactDOM.createRoot;
    } catch (_) {}

    if (isReact18 && createRoot) {
      copyRender = function copyRender(app, container) {
        updateUsingClientEntryPoint(true);
        var root = createRoot(container);
        updateUsingClientEntryPoint(false);
        root.render(app);

        root._unmount = function () {
          setTimeout(function () {
            var _a;

            (_a = root === null || root === void 0 ? void 0 : root.unmount) === null || _a === void 0 ? void 0 : _a.call(root);
          });
        };

        return root;
      };
    } else {
      copyRender = function copyRender(app, container) {
        CopyReactDOM.render(app, container);
        return {
          render: function render(comment) {
            CopyReactDOM.render(comment, container);
          },
          _unmount: function _unmount() {
            CopyReactDOM.unmountComponentAtNode(container);
          }
        };
      };
    }

    var render = copyRender;

    /**
     * 获取带浏览器前缀的样式
     * @desc {en} Get style with browser vendor prefix
     * @param {CSSProperties} style 原始样式
     * @param {CSSProperties} style {en} Original style
     * @returns {CSSProperties} newStyle 添加了浏览器前缀的新样式
     * @returns {CSSProperties} newStyle {en} New style with browser vendor prefix
     * @example
     * ```
     * import { getStyleWithVendor } from '@arco-design/mobile-react/esm/_helpers';
     *
     * // Example usage:
     * const originalStyle = {
     *     transform: 'translateX(50px)',
     *     transition: 'all 0.3s ease',
     *     opacity: 0.8,
     * };
     *
     * const styleWithPrefix = getStyleWithVendor(originalStyle);
     *
     * // Result:
     * // styleWithPrefix will be:
     * // {
     * //     transform: 'translateX(50px)',
     * //     WebkitTransform: 'translateX(50px)', // Browser-specific prefix added
     * //     transition: 'all 0.3s ease',
     * //     WebkitTransition: 'all 0.3s ease', // Browser-specific prefix added
     * //     opacity: 0.8,
     * // }
     * ```
     */

    function getStyleWithVendor(style) {
      var allowReg = /(transform|transition|animation)/i;
      var newStyle = Object.keys(style).reduce(function (acc, key) {
        var _a, _b;

        var webkitStyle = allowReg.test(key) ? (_a = {}, _a["Webkit" + key.replace(/^(.)/, function (_, p1) {
          return p1.toUpperCase();
        })] = style[key], _a) : {};
        return __assign$2(__assign$2(__assign$2({}, acc), (_b = {}, _b[key] = style[key], _b)), webkitStyle);
      }, {});
      return newStyle;
    }
    /**
     * 给元素设置带浏览器前缀的样式
     * @desc {en} Set element style with browser vendor prefix
     * @param {HTMLElement} dom 需要设置样式的元素
     * @param {HTMLElement} dom {en} Element to set style
     * @param {CSSProperties} style Original style
     * @param {CSSProperties} style {en} Original style
     * @returns {void}
     * @example
     * ```
     * import { setStyleWithVendor } from '@arco-design/mobile-utils';
     *
     * // Example: Setting and displaying styles with the Webkit browser vendor prefix
     * const element = document.getElementById('myElement');
     * const originalStyle = {
     *   transform: 'translateX(100px)',
     *   transition: 'transform 0.5s ease',
     *   borderRadius: '5px',
     * };
     *
     * // Set the styles with the Webkit browser vendor prefix
     * setStyleWithVendor(element, originalStyle);
     *
     * // Display the styles with the Webkit browser vendor prefixes applied
     * const computedStyle = getComputedStyle(element);
     * console.log(computedStyle.getPropertyValue('-webkit-transform')); // Output: The transformed style with the Webkit browser vendor prefix
     * console.log(computedStyle.getPropertyValue('-webkit-transition')); // Output: The transition style with the Webkit browser vendor prefix
     * console.log(computedStyle.getPropertyValue('border-radius')); // Output: The borderRadius style without a vendor prefix
     * ```
     */

    function setStyleWithVendor(dom, style) {
      var vendorStyle = getStyleWithVendor(style);

      for (var key in vendorStyle) {
        dom.style[key] = vendorStyle[key];
      }
    }
    /**
     * 计算默认值，仅未定义时使用默认值
     * @desc {en} Calculate the default value, use default value only if undefined
     * @param {T | undefined} value 输入的值
     * @param {T | undefined} value {en} The input value
     * @param {T} defaultValue 默认值
     * @param {T} defaultValue {en} The default value
     * @returns {T} 如果输入的值是未定义的，那么返回默认值，否则返回输入的值
     * @returns {T} {en} Returns the default value if the input is undefined, otherwise returns the input value
     * @example
     * ```
     * import { getDefaultValue } from '@arco-design/mobile-react/esm/_helpers';
     *
     * const result = getDefaultValue(42, 0);
     * console.log(result); // Output: 42
     *
     * const result2 = getDefaultValue(undefined, 100);
     * console.log(result2); // Output: 100
     * ```
     */

    var getDefaultValue = function getDefaultValue(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };

    var TabCellUnderline = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var prefix = props.prefix,
          useCaterpillar = props.useCaterpillar,
          distance = props.distance,
          tabDirection = props.tabDirection,
          underlineInnerStyle = props.underlineInnerStyle,
          duration = props.duration,
          cellTrans = props.cellTrans,
          showLine = props.showLine,
          activeIndex = props.activeIndex,
          wrapWidth = props.wrapWidth,
          wrapHeight = props.wrapHeight,
          jumpingDis = props.jumpingDis,
          translateZ = props.translateZ,
          caterpillarMaxScale = props.caterpillarMaxScale,
          caterpillarProperty = props.caterpillarProperty,
          underlineSize = props.underlineSize,
          underlineThick = props.underlineThick,
          underlineAdaptive = props.underlineAdaptive,
          renderUnderline = props.renderUnderline,
          getTabRect = props.getTabRect,
          getTabCenterLeft = props.getTabCenterLeft;
      var useRtl = React.useContext(GlobalContext).useRtl;

      var _a = React.useState({}),
          underlineStyle = _a[0],
          setUnderlineStyle = _a[1];

      var _b = useRefState(false),
          caterpillar = _b[0],
          caterpillarRef = _b[1],
          setCaterpillar = _b[2];

      var _c = React.useState(0),
          caterpillarDelay = _c[0],
          setCaterpillarDelay = _c[1];

      var lineRef = React.useRef(null);
      var timeRef = React.useRef(0);
      var system = useSystem();
      var isVertical = tabDirection === 'vertical';
      var maxScaleWithDefault = caterpillarMaxScale || 2;
      var translateZStr = translateZ ? ' translateZ(0)' : '';
      var rtlRatio = isVertical && useRtl ? -1 : 1;
      React.useImperativeHandle(ref, function () {
        return {
          setCaterpillarAnimate: setCaterpillarAnimate,
          resetUnderlineStyle: resetUnderlineStyle
        };
      }, [setCaterpillarAnimate, resetUnderlineStyle]);
      var animationKey = React.useMemo(function () {
        if (!useCaterpillar) {
          return '';
        }

        if (caterpillarProperty === 'size') {
          return "tabsCaterpillar" + (isVertical ? 'W' : 'H') + maxScaleWithDefault;
        }

        if (caterpillarMaxScale) {
          return "tabsCaterpillar" + (isVertical ? 'X' : 'Y') + caterpillarMaxScale;
        }

        return '';
      }, [useCaterpillar, isVertical, caterpillarMaxScale, caterpillarProperty]);
      React.useEffect(function () {
        if (!animationKey) {
          return;
        }

        var dir = isVertical ? 'X' : 'Y';

        if (caterpillarProperty === 'size') {
          var attr = isVertical ? 'width' : 'height';
          addCssKeyframes(animationKey, "{\n                        0% {\n                            " + attr + ": 100%;\n                        }\n                        50% {\n                            " + attr + ": " + 100 * maxScaleWithDefault + "%;\n                        }\n                        100% {\n                            " + attr + ": 100%;\n                        }\n                    }");
          return;
        }

        addCssKeyframes(animationKey, "{\n                    0% {\n                        transform: scale" + dir + "(1)" + translateZStr + ";\n                        -webkit-transform: scale" + dir + "(1)" + translateZStr + ";\n                    }\n                    50% {\n                        transform: scale" + dir + "(" + caterpillarMaxScale + ")" + translateZStr + ";\n                        -webkit-transform: scale" + dir + "(" + caterpillarMaxScale + ")" + translateZStr + ";\n                    }\n                    100% {\n                        transform: scale" + dir + "(1)" + translateZStr + ";\n                        -webkit-transform: scale" + dir + "(1)" + translateZStr + ";\n                    }\n                }");
        return function () {
          removeCssStyleDom(animationKey);
        };
      }, [animationKey]);
      React.useEffect(function () {
        if (jumpingDis && useCaterpillar && system !== 'ios') {
          var movedRatio = wrapWidth ? jumpingDis / wrapWidth : 0;
          setCaterpillarAnimate(movedRatio);
        }
      }, [jumpingDis]);
      React.useEffect(function () {
        resetUnderlineStyle();
      }, [useCaterpillar, caterpillar, cellTrans, duration, tabDirection, wrapWidth, wrapHeight, distance, animationKey, caterpillarDelay, underlineSize, underlineThick, underlineAdaptive]);

      function getLineWidth(index) {
        var _a, _b;

        if (underlineAdaptive) {
          return getTabRect(index).width;
        }

        var offsetSize = isVertical ? (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth : (_b = lineRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight;
        var lineWidth = offsetSize || 0;
        return lineWidth;
      }

      function getLineLeft(index) {
        if (underlineAdaptive) {
          return getTabRect(index).left;
        }

        var lineWidth = getLineWidth(index);
        return getTabCenterLeft(index) - lineWidth / 2;
      }

      function getDescIndex() {
        var comparedDis = distance * rtlRatio;

        if (comparedDis > 0) {
          return activeIndex - 1;
        }

        if (comparedDis < 0) {
          return activeIndex + 1;
        }

        return activeIndex;
      }

      function getLineScale(ratio) {
        var absRatio = Math.abs(ratio);
        return absRatio > 0.5 ? (1 - absRatio) * 2 * (maxScaleWithDefault - 1) + 1 : absRatio * 2 * (maxScaleWithDefault - 1) + 1;
      }

      function getLineStyle() {
        var _a, _b;

        if (!lineRef.current) {
          return {};
        }

        var currentLeft = getLineLeft(activeIndex);
        var descIndex = getDescIndex();
        var descLeft = getLineLeft(descIndex);
        var comparedDis = distance * rtlRatio;
        var moveRatio = wrapWidth ? comparedDis / wrapWidth : 0;
        var leftOffset = moveRatio * (currentLeft - descLeft);
        var direc = isVertical ? 'X' : 'Y';
        var transStyle = useCaterpillar && !jumpingDis && !underlineAdaptive ? caterpillarProperty === 'size' ? (_a = {}, _a[isVertical ? 'width' : 'height'] = 100 * getLineScale(moveRatio) + "%", _a.willChange = 'width', _a) : {
          transform: "scale" + direc + "(" + getLineScale(moveRatio) + ")"
        } : {};
        var adaptiveStyle = {};
        var adaptiveOuterStyle = {};

        if (underlineAdaptive) {
          var currentWidth = getLineWidth(activeIndex);
          var descWidth = getLineWidth(descIndex);
          var widthOffset = moveRatio * (currentWidth - descWidth);
          adaptiveStyle = (_b = {}, _b[isVertical ? 'width' : 'height'] = comparedDis > 0 ? currentWidth - widthOffset : currentWidth + widthOffset, _b.willChange = 'width', _b);
          adaptiveOuterStyle = isVertical ? {
            width: 'auto'
          } : {
            height: 'auto'
          };
        }

        var outerSize = isVertical ? {
          width: underlineSize,
          height: underlineThick
        } : {
          height: underlineSize,
          width: underlineThick
        };
        return {
          outer: __assign$2(__assign$2({
            transform: "translate" + direc + "(" + (comparedDis > 0 ? currentLeft - leftOffset : currentLeft + leftOffset) + "px)" + translateZStr
          }, outerSize), adaptiveOuterStyle),
          inner: __assign$2(__assign$2({}, transStyle), adaptiveStyle)
        };
      }

      function getUnderlineStyle() {
        var transStyle = {};

        if (!underlineAdaptive) {
          if (useCaterpillar) {
            transStyle.animationDuration = duration + "ms";
          }

          if (caterpillarRef.current && animationKey) {
            transStyle.animationName = animationKey;
          }

          if (caterpillarDelay) {
            transStyle.animationDelay = "-" + caterpillarDelay + "ms";
          }
        }

        var lineStyle = getLineStyle();
        return {
          outer: getStyleWithVendor(__assign$2({
            transitionDuration: cellTrans ? duration + "ms" : '0ms'
          }, lineStyle.outer || {})),
          inner: getStyleWithVendor(__assign$2(__assign$2({}, transStyle), lineStyle.inner || {}))
        };
      }

      function resetUnderlineStyle() {
        setUnderlineStyle(getUnderlineStyle());
      }

      function setCaterpillarAnimate(movedRatio) {
        if (movedRatio === void 0) {
          movedRatio = 0;
        }

        if (!duration) {
          return;
        }

        var movedTime = (duration || 0) * Math.abs(movedRatio);
        setCaterpillarDelay(movedTime);
        nextTick(function () {
          setCaterpillar(true);
        });

        if (timeRef.current) {
          clearTimeout(timeRef.current);
        }

        timeRef.current = window.setTimeout(function () {
          setCaterpillar(false);
          setCaterpillarDelay(0);
        }, (duration || 0) - movedTime + 20);
      }

      return renderUnderline ? /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, renderUnderline(underlineStyle, showLine, lineRef)) : /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-underline", {
          show: showLine
        }),
        ref: lineRef,
        style: underlineStyle.outer
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-underline-inner", {
          caterpillar: caterpillar,
          'custom-animate': animationKey,
          'caterpillar-moving': caterpillar || useCaterpillar && distance
        }, tabDirection),
        style: __assign$2(__assign$2({}, underlineStyle.inner || {}), underlineInnerStyle || {})
      }));
    });

    var TabCell = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var tabs = props.tabs,
          prefixCls = props.prefixCls,
          activeIndex = props.activeIndex,
          activeIndexRef = props.activeIndexRef,
          tabDirection = props.tabDirection,
          type = props.type,
          onTabClick = props.onTabClick,
          changeIndex = props.changeIndex,
          tabBarPosition = props.tabBarPosition,
          tabBarArrange = props.tabBarArrange,
          tabBarScroll = props.tabBarScroll,
          tabBarFixed = props.tabBarFixed,
          renderUnderline = props.renderUnderline,
          duration = props.duration,
          transitionDuration = props.transitionDuration,
          useCaterpillar = props.useCaterpillar,
          wrapWidth = props.wrapWidth,
          wrapHeight = props.wrapHeight,
          cellTrans = props.cellTrans,
          distance = props.distance,
          jumpingDis = props.jumpingDis,
          tabBarExtra = props.tabBarExtra,
          onTabBarOverflowChange = props.onTabBarOverflowChange,
          tabBarGutter = props.tabBarGutter,
          tabBarPadding = props.tabBarPadding,
          underlineSize = props.underlineSize,
          underlineThick = props.underlineThick,
          underlineInnerStyle = props.underlineInnerStyle,
          caterpillarMaxScale = props.caterpillarMaxScale,
          caterpillarProperty = props.caterpillarProperty,
          onTabBarScroll = props.onTabBarScroll,
          hideTabBarBeforeMounted = props.hideTabBarBeforeMounted,
          _a = props.overflowThreshold,
          overflowThreshold = _a === void 0 ? 5 : _a,
          tabBarScrollBezier = props.tabBarScrollBezier,
          tabBarScrollDuration = props.tabBarScrollDuration,
          tabBarScrollChance = props.tabBarScrollChance,
          tabBarHasDivider = props.tabBarHasDivider,
          showUnderline = props.showUnderline,
          underlineAdaptive = props.underlineAdaptive,
          disabled = props.disabled,
          renderTabBarItem = props.renderTabBarItem,
          renderTabBarInner = props.renderTabBarInner,
          tabBarStyle = props.tabBarStyle,
          tabBarClass = props.tabBarClass,
          translateZ = props.translateZ,
          tabBarStopPropagation = props.tabBarStopPropagation;
      var prefix = prefixCls + "-tab-cell";
      var useRtl = React.useContext(GlobalContext).useRtl;
      var domRef = React.useRef(null);
      var underlineRef = React.useRef(null);
      var allCellRectRef = React.useRef([]);

      var _b = React.useState(false),
          showLine = _b[0],
          setShowLine = _b[1];

      var _c = React.useState(false),
          hasOverflow = _c[0],
          setHasOverflow = _c[1];

      var _d = React.useState(function () {
        return tabs.length < overflowThreshold ? tabBarArrange : 'start';
      }),
          originArrange = _d[0],
          setOriginArrange = _d[1]; // 默认tab小于overflowThreshold个时不开启加载前隐藏，大于overflowThreshold个时开启


      var _e = React.useState(function () {
        return hideTabBarBeforeMounted === void 0 ? tabs.length < overflowThreshold || activeIndex === 0 : !hideTabBarBeforeMounted;
      }),
          showTab = _e[0],
          setShowTab = _e[1];

      var isVertical = tabDirection === 'vertical';
      var isLine = (type || '').indexOf('line') !== -1;
      var isCard = type === 'card';
      /**
       * 非card类型才有间隙和两侧留白
       * @en Non-card types have gaps and blank on both sides
       */

      var cellPadding = isCard ? void 0 : tabBarPadding;
      var cellGutter = isCard ? void 0 : tabBarGutter;
      var hasDivider = tabBarHasDivider === void 0 ? isLine : tabBarHasDivider;
      var wrapSize = isVertical ? wrapWidth : wrapHeight;
      var system = useSystem();
      React.useEffect(function () {
        nextTick(function () {
          setCellOverflow(); // dom出来之后originArrange置空，交由tabBarArrange控制
          // @en After the dom comes out, originArrange is left empty and controlled by tabBarArrange

          setOriginArrange(void 0); // dom出来了才知道布局，计算完成后展示出来防止跳动的情况
          // @en The layout is determined only when the dom comes out. It is displayed to prevent the jumping after the calculation is completed

          setShowTab(true);
          setShowLine(true);
        });
      }, [domRef.current, wrapSize, tabs]);
      React.useEffect(function () {
        nextTick(function () {
          var _a;

          (_a = underlineRef.current) === null || _a === void 0 ? void 0 : _a.resetUnderlineStyle();
        });
      }, [activeIndex, tabs, getCellPadding('left'), getCellPadding('right'), tabBarGutter, tabDirection]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          scrollTo: scrollTo,
          scrollToCenter: scrollToCenter,
          hasOverflow: hasOverflow,
          setCaterpillarAnimate: function setCaterpillarAnimate(ratio) {
            var _a;

            return (_a = underlineRef.current) === null || _a === void 0 ? void 0 : _a.setCaterpillarAnimate(ratio);
          },
          resetUnderlineStyle: function resetUnderlineStyle() {
            var _a;

            return (_a = underlineRef.current) === null || _a === void 0 ? void 0 : _a.resetUnderlineStyle();
          }
        };
      }, [scrollToCenter, scrollTo, hasOverflow]);
      React.useEffect(function () {
        if (wrapSize && tabBarScrollChance !== 'none') {
          setTimeout(function () {
            scrollToCenter();
          }, tabBarScrollChance === 'after-jump' ? Math.max(transitionDuration || 0, duration || 0) : 0);
        }
      }, [activeIndex, wrapSize]);
      React.useEffect(function () {
        tabBarScrollChance !== 'none' && scrollToCenter(true); // TabCell左右可滚动时，防止触发父级touchmove事件导致滚不动
        // @en When the TabCell can be scrolled left and right, prevent the parent touchmove event from being triggered which result in inability to scroll

        var stopFunc = function stopFunc(e) {
          return e.stopPropagation();
        };

        if (isVertical && hasOverflow && domRef.current && tabBarStopPropagation) {
          domRef.current.addEventListener('touchstart', stopFunc);
          domRef.current.addEventListener('touchmove', stopFunc);
        }

        return function () {
          if (isVertical && hasOverflow && domRef.current && tabBarStopPropagation) {
            domRef.current.removeEventListener('touchstart', stopFunc);
            domRef.current.removeEventListener('touchmove', stopFunc);
          }
        };
      }, [hasOverflow]);

      function setCellOverflow() {
        var overflow = false;

        if (domRef.current) {
          overflow = isVertical ? domRef.current.scrollWidth > domRef.current.offsetWidth : domRef.current.scrollHeight > domRef.current.offsetHeight;
        }

        if (overflow !== hasOverflow) {
          onTabBarOverflowChange && onTabBarOverflowChange(overflow);
        }

        setHasOverflow(overflow);
      }

      function scrollToCenter(rightNow) {
        if (!wrapSize || !hasOverflow) {
          return;
        }

        var currentTabLeft = getTabCenterLeft(activeIndexRef.current);
        var newLeft = currentTabLeft - wrapSize / 2;
        scrollTo(newLeft, rightNow);
      }

      function scrollTo(position, rightNow) {
        if (!domRef.current) {
          return;
        }

        var needRafScroll = false; // 部分安卓机在动画和raf同时执行时会卡顿
        // @en Some Android machines will freeze when animation and raf are executed at the same time
        // 如果是安卓机，且对滚动的时长和变化曲线无要求时，优先用原生顺滑滚动
        // @en If it is an Android device, and there is no requirement for the scrolling duration and change curve, the native smooth scrolling is preferred
        // 当浏览器不支持原生顺滑滚动，或对上述滚动参数有要求时，用raf滚动兜底
        // @en When the browser does not support native smooth scrolling, or there are requirements for the above scrolling parameters, use raf to scroll the bottom line

        if (system === 'android' && tabBarScrollBezier === void 0 && tabBarScrollDuration === void 0) {
          try {
            var disObj = isVertical ? {
              left: position
            } : {
              top: position
            };
            domRef.current.scrollTo(__assign$2(__assign$2({}, disObj), rightNow ? {} : {
              behavior: 'smooth'
            }));
          } catch (e) {
            needRafScroll = true;
          }
        } else {
          needRafScroll = true;
        }

        if (needRafScroll) {
          scrollWithAnimation(isVertical ? domRef.current.scrollLeft : domRef.current.scrollTop, position, function (top) {
            if (domRef.current) {
              if (isVertical) {
                domRef.current.scrollLeft = top;
              } else {
                domRef.current.scrollTop = top;
              }
            }
          }, rightNow ? 0 : tabBarScrollDuration, tabBarScrollBezier);
        }
      }

      function getTabRect(index) {
        var currentTab = allCellRectRef.current[index] || {};
        return {
          left: (isVertical ? currentTab.left : currentTab.top) || 0,
          width: (isVertical ? currentTab.width : currentTab.height) || 0
        };
      }

      function getTabCenterLeft(index) {
        var _a = getTabRect(index),
            currentTabLeft = _a.left,
            currentTabWidth = _a.width;

        return currentTabLeft + currentTabWidth / 2;
      }

      function getCellPadding(pType) {
        if (typeof cellPadding === 'object') {
          return cellPadding[pType];
        }

        return cellPadding;
      }

      function getCellStyle(index) {
        var _a, _b;

        if (!isVertical) {
          return {};
        }

        var marginStart = useRtl ? 'marginRight' : 'marginLeft';
        var marginEnd = useRtl ? 'marginLeft' : 'marginRight';

        if (index === 0) {
          return _a = {}, _a[marginEnd] = cellGutter, _a[marginStart] = getCellPadding('left'), _a;
        }

        return _b = {}, _b[marginEnd] = index === tabs.length - 1 ? void 0 : cellGutter, _b;
      }

      function renderBarItem(tab, index) {
        if (renderTabBarItem) {
          return renderTabBarItem(tab, index, {
            active: index === activeIndex
          });
        }

        return typeof tab === 'string' ? tab : tab.title;
      }

      function renderTabUnderline() {
        if (!showUnderline || !isLine) {
          return null;
        }

        var lineProps = {
          prefix: prefix,
          showLine: showLine,
          useCaterpillar: useCaterpillar,
          distance: distance,
          tabDirection: tabDirection,
          underlineInnerStyle: underlineInnerStyle,
          cellTrans: cellTrans,
          duration: duration,
          activeIndex: activeIndex,
          wrapWidth: wrapWidth,
          wrapHeight: wrapHeight,
          jumpingDis: jumpingDis,
          caterpillarMaxScale: caterpillarMaxScale,
          caterpillarProperty: caterpillarProperty,
          translateZ: translateZ,
          underlineSize: underlineSize,
          underlineThick: underlineThick,
          underlineAdaptive: underlineAdaptive,
          renderUnderline: renderUnderline
        };
        return /*#__PURE__*/React__default["default"].createElement(TabCellUnderline, __assign$2({
          ref: underlineRef,
          getTabCenterLeft: getTabCenterLeft,
          getTabRect: getTabRect
        }, lineProps));
      }

      var cellInner = /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, tabs.map(function (tab, index) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: index,
          className: cls(prefix, tabDirection, type, system, {
            active: index === activeIndex
          }, {
            'no-shrink': tabBarScroll
          }, {
            last: index === tabs.length - 1
          }, {
            custom: Boolean(renderTabBarItem)
          }),
          style: getCellStyle(index),
          onClick: function onClick(e) {
            if (disabled) {
              return;
            }

            changeIndex(index, 'click');
            onTabClick && onTabClick(tab, index, e);
          },
          ref: function ref(innerRef) {
            // distance=0 说明不在滑动切换，减少计算次数
            if (innerRef && !distance) {
              allCellRectRef.current[index] = {
                top: innerRef.offsetTop,
                left: innerRef.offsetLeft,
                width: innerRef.offsetWidth,
                height: innerRef.offsetHeight
              };
            }
          }
        }, renderBarItem(tab, index));
      }), cellPadding && !isCard && isVertical ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: "fake-padding",
        style: {
          width: getCellPadding('right'),
          height: '100%'
        }
      }) : null);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-container-wrap", tabDirection, "type-" + type, tabBarClass, system),
        style: tabBarStyle
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-container-inner", tabDirection, "pos-" + tabBarPosition, "type-" + type, {
          fixed: tabBarFixed
        }, {
          'has-divider': hasDivider
        }, system),
        style: typeof tabBarFixed === 'object' ? tabBarFixed : {}
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-container", tabDirection, "pos-" + tabBarPosition, "arrange-" + (originArrange || tabBarArrange), "type-" + type, {
          overflow: hasOverflow
        }, {
          shown: showTab
        }),
        ref: domRef,
        onScroll: onTabBarScroll
      }, renderTabBarInner ? renderTabBarInner(cellInner) : cellInner, renderTabUnderline()), tabBarExtra));
    });

    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$1 = freeGlobal || freeSelf || Function('return this')();

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root$1.Date.now();
    };

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            result = wait - timeSinceLastCall;

        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle$1(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var lodash_throttle = throttle$1;

    var TabPane = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var prefixCls = props.prefixCls,
          panes = props.panes,
          tabDirection = props.tabDirection,
          activeIndex = props.activeIndex,
          activeIndexRef = props.activeIndexRef,
          distance = props.distance,
          wrapWidth = props.wrapWidth,
          wrapHeight = props.wrapHeight,
          handlePaneTouchEnd = props.handlePaneTouchEnd,
          transitionDuration = props.transitionDuration,
          paneTrans = props.paneTrans,
          swipeable = props.swipeable,
          lazyloadCount = props.lazyloadCount,
          hideContentStyle = props.hideContentStyle,
          renderHideContent = props.renderHideContent,
          mode = props.mode,
          tabPaneStyle = props.tabPaneStyle,
          tabPaneClass = props.tabPaneClass,
          tabPaneExtra = props.tabPaneExtra,
          getScrollContainer = props.getScrollContainer,
          scrollThrottle = props.scrollThrottle,
          _b = props.scrollOffset,
          scrollOffset = _b === void 0 ? 0 : _b,
          goLastWhenScrollBottom = props.goLastWhenScrollBottom,
          scrollVertical = props.scrollVertical,
          translateZ = props.translateZ,
          fullScreen = props.fullScreen,
          autoHeight = props.autoHeight,
          swipeEnergySaving = props.swipeEnergySaving,
          changeIndex = props.changeIndex,
          onScroll = props.onScroll,
          rtlRatio = props.rtlRatio;
      var domRef = React.useRef(null);
      var panesRef = React.useRef([]);
      var autoScrollingRef = React.useRef(false);
      var timerRef = React.useRef(0);

      var _c = React.useState([activeIndex, activeIndex]),
          shownIndexes = _c[0],
          setShownIndexes = _c[1];

      var _d = React.useState(activeIndex),
          shownActiveIndex = _d[0],
          setShownActiveIndex = _d[1];

      var prefix = prefixCls + "-tab-pane";
      var handleTouchEnd = swipeable ? handlePaneTouchEnd : void 0;

      var _e = React.useState('auto'),
          currentPaneHeight = _e[0],
          setCurrentPaneHeight = _e[1];

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          getTransition: getTransition,
          scrollToIndex: scrollToIndex,
          setCurrentHeight: setCurrentHeight
        };
      });
      React.useEffect(function () {
        if (mode === 'swipe') {
          setTimeout(function () {
            calcShownIndexes();
          }, getTransition());
        }
      }, [lazyloadCount, activeIndex, mode]);
      var scrollHandler = React.useMemo(function () {
        if (mode !== 'scroll') {
          return function () {};
        }

        var handler = function handler() {
          onScroll === null || onScroll === void 0 ? void 0 : onScroll();

          if (autoScrollingRef.current) {
            return;
          }

          var container = getScrollContainer ? getScrollContainer() : window;
          if (!container) return;

          var _a = getContainerTop(container),
              containerTop = _a.containerTop,
              containerBottom = _a.containerBottom;

          for (var i = 0; i < panes.length; i += 1) {
            // 判断范围：-∞ ... top0 ... top1 ... top n ... ∞
            // @en Judge the range: (-∞, top0, top1, ...top n, ∞)
            var curPaneTop = i === 0 ? -Infinity : getRectTop(panesRef.current[i]);
            var nextPaneTop = i === panes.length - 1 ? Infinity : getRectTop(panesRef.current[i + 1]);

            if (containerTop >= curPaneTop - scrollOffset && containerTop < nextPaneTop - scrollOffset) {
              changeIndex(i, 'scroll');
              break;
            }
          }

          if (goLastWhenScrollBottom) {
            var lastIndex = panes.length - 1;
            var curPaneBottom = getRectTop(panesRef.current[lastIndex], 'bottom');

            if (containerBottom === curPaneBottom) {
              changeIndex(lastIndex, 'scroll');
            }
          }
        };

        return scrollThrottle ? lodash_throttle(handler, scrollThrottle) : handler;
      }, [mode, scrollThrottle, getScrollContainer, panes.length, scrollOffset, goLastWhenScrollBottom, scrollVertical, onScroll]);
      React.useEffect(function () {
        var container = (getScrollContainer === null || getScrollContainer === void 0 ? void 0 : getScrollContainer()) || window;

        if (container && mode === 'scroll') {
          container.addEventListener('scroll', scrollHandler);
        }

        return function () {
          if (container && mode === 'scroll') {
            container.removeEventListener('scroll', scrollHandler);
          }
        };
      }, [scrollHandler]);

      function setCurrentHeight() {
        if (!domRef.current || !autoHeight || mode !== 'swipe' || tabDirection !== 'vertical') {
          return;
        }

        var allPanesDom = panesRef.current;
        var nowIndex = activeIndexRef.current;
        var currentHeight = (allPanesDom[nowIndex] || {}).offsetHeight || 'auto';
        setCurrentPaneHeight(currentHeight);
      }

      function calcShownIndexes() {
        setShownActiveIndex(activeIndex);

        if (typeof lazyloadCount === 'number') {
          setShownIndexes([activeIndex - lazyloadCount, activeIndex + lazyloadCount]);
          return;
        }

        setShownIndexes([0, Infinity]);
      }

      function getTransition() {
        return paneTrans ? transitionDuration || 0 : 0;
      }

      function scrollToIndex(index, rightNow) {
        var container = (getScrollContainer === null || getScrollContainer === void 0 ? void 0 : getScrollContainer()) || window;

        var _a = getContainerTop(container),
            isGlobal = _a.isGlobal,
            scrollEle = _a.scrollEle,
            containerTop = _a.containerTop;

        var curPaneTop = getRectTop(panesRef.current[index]);
        var topDis = curPaneTop - containerTop - scrollOffset;
        var scrollAttr = scrollVertical ? 'scrollTop' : 'scrollLeft';
        var scrollTop = isGlobal ? Math.max(document.documentElement[scrollAttr], document.body[scrollAttr]) : scrollEle[scrollAttr];
        var scrollSizeAttr = scrollVertical ? 'scrollHeight' : 'scrollWidth';
        var sizeAttr = scrollVertical ? 'offsetHeight' : 'offsetWidth';
        var maxTopDis = isGlobal ? Math.max(document.documentElement[scrollSizeAttr], document.body[scrollSizeAttr]) - scrollTop - (scrollVertical ? window.innerHeight : window.innerWidth) : scrollEle[scrollSizeAttr] - scrollTop - scrollEle[sizeAttr];
        var normalizedTopDis = Math.min(maxTopDis, topDis);
        clearTimeout(timerRef.current);
        autoScrollingRef.current = true;
        var duration = rightNow ? 0 : transitionDuration || 0;
        scrollWithAnimation(scrollTop, scrollTop + normalizedTopDis, function (top) {
          if (isGlobal) {
            document.documentElement[scrollAttr] = top;
            document.body[scrollAttr] = top;
          } else {
            scrollEle[scrollAttr] = top;
          }
        }, duration); // 在自动滚动完成后，过一小段时间再解锁，避免最后一次触发scroll还未完成时就解锁导致乱跳的情况
        // @en After the automatic scrolling is completed, unlock it after a short period of time, to avoid the situation of random jumping caused by unlocking when the scroll is not completed for the last time.

        var buffer = 100;
        timerRef.current = window.setTimeout(function () {
          autoScrollingRef.current = false;
        }, duration + (scrollThrottle || 0) + buffer);
      }

      function getContainerTop(container) {
        var _a = getScrollContainerRect(container),
            isGlobal = _a.isGlobal,
            scrollEle = _a.scrollEle,
            containerRect = _a.containerRect;

        var containerTop = Math.floor(scrollVertical ? containerRect.top : containerRect.left);
        var containerBottom = Math.floor(scrollVertical ? containerRect.bottom : containerRect.right);
        return {
          isGlobal: isGlobal,
          scrollEle: scrollEle,
          containerTop: containerTop,
          containerBottom: containerBottom
        };
      }

      function getRectTop(ele, attr) {
        if (attr === void 0) {
          attr = 'top';
        }

        var attrMap = scrollVertical ? {
          top: 'top',
          bottom: 'bottom'
        } : {
          top: 'left',
          bottom: 'right'
        };
        var attrKey = attrMap[attr];
        var rect = (ele === null || ele === void 0 ? void 0 : ele.getBoundingClientRect()) || {}; // 消除误差
        // @en Eliminate errors

        return rect[attrKey] ? Math.floor(rect[attrKey]) : 0;
      }

      function getPaneStyle() {
        var commonStyle = tabPaneStyle || {};

        if (mode === 'scroll') {
          return commonStyle;
        }

        var translateStr = translateZ ? ' translateZ(0)' : '';
        var translatePercentInSSR = (panes.length ? 100 / panes.length : 0) * activeIndex * rtlRatio * -1 + "%";
        var verticalTranslate = distance - wrapWidth * activeIndex * rtlRatio + "px";
        var horizontalTranslate = distance - wrapHeight * activeIndex + "px";
        var sizeStyle = tabDirection === 'vertical' ? {
          width: 100 * panes.length + "%",
          transform: "translateX(" + (isSSR() ? translatePercentInSSR : verticalTranslate) + ")" + translateStr
        } : {
          height: 100 * panes.length + "%",
          transform: "translateY(" + (isSSR() ? translatePercentInSSR : horizontalTranslate) + ")" + translateStr
        };
        var heightStyle = currentPaneHeight && currentPaneHeight !== 'auto' ? {
          height: currentPaneHeight
        } : {};
        return getStyleWithVendor(__assign$2(__assign$2(__assign$2(__assign$2({}, swipeEnergySaving ? {} : sizeStyle), {
          transitionDuration: getTransition() + "ms"
        }), heightStyle), commonStyle));
      }

      function getEnergySavingPaneStyle(index) {
        if (mode === 'scroll' || !swipeEnergySaving) {
          return undefined;
        }

        if (index !== shownActiveIndex) {
          return {
            position: 'absolute',
            left: '-100%',
            top: '-100%'
          };
        }

        var translateStr = translateZ ? ' translateZ(0)' : '';
        var sizeStyle = tabDirection === 'vertical' ? {
          transform: "translateX(" + (distance - wrapWidth * (activeIndex - index) * rtlRatio) + "px)" + translateStr
        } : {
          transform: "translateY(" + (distance - wrapHeight * (activeIndex - index)) + "px)" + translateStr
        };
        return getStyleWithVendor(__assign$2(__assign$2({}, sizeStyle), {
          transitionDuration: getTransition() + "ms"
        }));
      }

      function renderContent(pane, index) {
        var contentProps = {
          key: index,
          className: cls(prefix, "mode-" + mode, {
            'full-screen': fullScreen
          }),
          ref: function ref(r) {
            return panesRef.current[index] = r;
          }
        };
        var energySavingStyle = getEnergySavingPaneStyle(index); // 是滚动模式或在加载范围内，直接渲染
        // @en Render directly when in scroll mode or in loading scope

        if (mode === 'scroll' || index >= shownIndexes[0] && index <= shownIndexes[1]) {
          return /*#__PURE__*/React__default["default"].createElement("div", __assign$2({}, contentProps, {
            style: energySavingStyle
          }), pane);
        }

        var energySavingHideStyle = __assign$2(__assign$2({}, energySavingStyle), hideContentStyle || {}); // 不在加载范围内，视renderHideContent和hideContentStyle情况而定
        // @en Not in the loading range, depending on renderHideContent and hideContentStyle


        if (renderHideContent) {
          return /*#__PURE__*/React__default["default"].createElement("div", __assign$2({}, contentProps, {
            style: energySavingHideStyle
          }), renderHideContent(index, pane));
        }

        if (hideContentStyle === null) {
          return /*#__PURE__*/React__default["default"].createElement("div", __assign$2({}, contentProps, {
            style: energySavingStyle
          }));
        }

        return /*#__PURE__*/React__default["default"].createElement("div", __assign$2({}, contentProps, {
          style: energySavingHideStyle
        }), pane);
      }

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-container", tabDirection, swipeEnergySaving ? "mode-" + mode + "-energy-saving" : "mode-" + mode, tabPaneClass, {
          'full-screen': fullScreen
        }, (_a = {}, _a["mode-scroll-" + (scrollVertical ? 'vertical' : 'horizontal')] = mode === 'scroll', _a)),
        style: getPaneStyle(),
        ref: domRef,
        onTouchEnd: handleTouchEnd,
        onTouchCancel: handleTouchEnd
      }, panes.map(function (pane, index) {
        return renderContent(pane, index);
      }), tabPaneExtra ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefix + "-extra"
      }, tabPaneExtra) : null);
    });

    /**
     * 用于让用户在不同的视图中进行切换。为优化移动端渲染性能，如有替换DOM、发请求更新数据等操作，请在`onAfterChange`而非`onChange`回调中进行。
     * @en Used to let the user switch between different views. In order to optimize the rendering performance of the mobile terminal, if you need to replace the DOM, send a request to update data, etc., please do it in the `onAfterChange` instead of the `onChange` callback.
     * @type 导航
     * @type_en Navigation
     * @name 选项卡
     * @name_en Tabs
     */

    var Tabs = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          style = props.style,
          _a = props.tabs,
          tabs = _a === void 0 ? [] : _a,
          _b = props.tabBarPosition,
          tabBarPosition = _b === void 0 ? 'top' : _b,
          activeTab = props.activeTab,
          _c = props.defaultActiveTab,
          defaultActiveTab = _c === void 0 ? 0 : _c,
          children = props.children,
          onChange = props.onChange,
          onAfterChange = props.onAfterChange,
          onTabClick = props.onTabClick,
          onTabBarOverflowChange = props.onTabBarOverflowChange,
          onTouchStart = props.onTouchStart,
          onTouchMove = props.onTouchMove,
          onTouchEnd = props.onTouchEnd,
          onTabBarScroll = props.onTabBarScroll,
          onDistanceChange = props.onDistanceChange,
          onScroll = props.onScroll,
          _d = props.type,
          type = _d === void 0 ? 'line' : _d,
          _e = props.swipeable,
          swipeable = _e === void 0 ? true : _e,
          disabled = props.disabled,
          _f = props.tabBarArrange,
          tabBarArrange = _f === void 0 ? 'center' : _f,
          _g = props.tabBarScroll,
          tabBarScroll = _g === void 0 ? true : _g,
          tabBarFixed = props.tabBarFixed,
          tabBarExtra = props.tabBarExtra,
          tabBarScrollBezier = props.tabBarScrollBezier,
          tabBarScrollDuration = props.tabBarScrollDuration,
          _h = props.tabBarScrollChance,
          tabBarScrollChance = _h === void 0 ? 'jump' : _h,
          tabBarHasDivider = props.tabBarHasDivider,
          _j = props.tabBarResetWhenScroll,
          tabBarResetWhenScroll = _j === void 0 ? 'touchmove' : _j,
          _k = props.stopPropagation,
          stopPropagation = _k === void 0 ? true : _k,
          getInnerScrollContainer = props.getInnerScrollContainer,
          _l = props.mode,
          mode = _l === void 0 ? 'swipe' : _l,
          getScrollContainer = props.getScrollContainer,
          _m = props.scrollThrottle,
          scrollThrottle = _m === void 0 ? 300 : _m,
          _o = props.scrollOffset,
          scrollOffset = _o === void 0 ? 0 : _o,
          scrollWhenMounted = props.scrollWhenMounted,
          _p = props.goLastWhenScrollBottom,
          goLastWhenScrollBottom = _p === void 0 ? true : _p,
          _q = props.scrollVertical,
          scrollVertical = _q === void 0 ? true : _q,
          renderUnderline = props.renderUnderline,
          renderTabBar = props.renderTabBar,
          renderTabBarItem = props.renderTabBarItem,
          renderTabBarInner = props.renderTabBarInner,
          _r = props.duration,
          duration = _r === void 0 ? 240 : _r,
          _s = props.transitionDuration,
          transitionDuration = _s === void 0 ? 300 : _s,
          _t = props.useCaterpillar,
          useCaterpillar = _t === void 0 ? false : _t,
          _u = props.distanceToChangeTab,
          distanceToChangeTab = _u === void 0 ? 10 : _u,
          _v = props.percentToChangeTab,
          percentToChangeTab = _v === void 0 ? 0.3 : _v,
          _w = props.speedToChangeTab,
          speedToChangeTab = _w === void 0 ? 200 : _w,
          _x = props.disableClickTransition,
          disableClickTransition = _x === void 0 ? true : _x,
          lazyloadCount = props.lazyloadCount,
          _y = props.hideContentStyle,
          hideContentStyle = _y === void 0 ? null : _y,
          renderHideContent = props.renderHideContent,
          hideTabBarBeforeMounted = props.hideTabBarBeforeMounted,
          _z = props.overflowThreshold,
          overflowThreshold = _z === void 0 ? 5 : _z,
          tabBarGutter = props.tabBarGutter,
          tabBarPadding = props.tabBarPadding,
          underlineSize = props.underlineSize,
          underlineThick = props.underlineThick,
          underlineInnerStyle = props.underlineInnerStyle,
          caterpillarMaxScale = props.caterpillarMaxScale,
          _0 = props.caterpillarProperty,
          caterpillarProperty = _0 === void 0 ? 'scale' : _0,
          _1 = props.showUnderline,
          showUnderline = _1 === void 0 ? true : _1,
          _2 = props.underlineAdaptive,
          underlineAdaptive = _2 === void 0 ? false : _2,
          _3 = props.stopTouchThreshold,
          stopTouchThreshold = _3 === void 0 ? 0 : _3,
          _4 = props.touchSideDisableThreshold,
          touchSideDisableThreshold = _4 === void 0 ? 0 : _4,
          onTouchStopped = props.onTouchStopped,
          tabBarStyle = props.tabBarStyle,
          tabPaneStyle = props.tabPaneStyle,
          tabBarClass = props.tabBarClass,
          tabPaneClass = props.tabPaneClass,
          tabPaneExtra = props.tabPaneExtra,
          _5 = props.translateZ,
          translateZ = _5 === void 0 ? true : _5,
          fullScreen = props.fullScreen,
          autoHeight = props.autoHeight,
          _6 = props.tabBarStopPropagation,
          tabBarStopPropagation = _6 === void 0 ? true : _6,
          _7 = props.swipeEnergySaving,
          swipeEnergySaving = _7 === void 0 ? false : _7;
      var useRtl = React.useContext(GlobalContext).useRtl;
      var domRef = React.useRef(null);
      var cellRef = React.useRef(null);
      var paneRef = React.useRef(null);

      var _8 = React.useState(defaultActiveTab),
          innerIndex = _8[0],
          setInnerIndex = _8[1];

      var _9 = React.useState(0),
          jumpingDis = _9[0],
          setJumpingDis = _9[1];

      var _10 = React.useState(0),
          wrapWidth = _10[0],
          setWrapWidth = _10[1];

      var _11 = React.useState(0),
          wrapHeight = _11[0],
          setWrapHeight = _11[1];

      var _12 = React.useState(false),
          cellTrans = _12[0],
          setCellTrans = _12[1];

      var _13 = React.useState(false),
          paneTrans = _13[0],
          setPaneTrans = _13[1];

      var _14 = useRefState(activeTab === void 0 ? innerIndex : activeTab),
          activeIndex = _14[0],
          activeIndexRef = _14[1],
          setActiveIndex = _14[2];

      var _15 = useRefState(0),
          distance = _15[0],
          distanceRef = _15[1],
          setDistance = _15[2];

      var posAdjustingRef = React.useRef(false);
      var touchStartedRef = React.useRef(false);
      var touchStartXRef = React.useRef(0);
      var touchStartYRef = React.useRef(0);
      var touchStartTimeRef = React.useRef(0);
      var touchMovedRef = React.useRef(false);
      var scrollingRef = React.useRef(null);
      var touchStoppedRef = React.useRef(false);
      var changeFromRef = React.useRef('');
      var touchMoveBarScrollRef = React.useRef(false);
      var system = useSystem();
      var allPanes = getAllPanes();
      var tabDirection = ['top', 'bottom'].indexOf(tabBarPosition) !== -1 ? 'vertical' : 'horizontal';
      var canSwipe = mode === 'swipe' && !disabled && swipeable && tabDirection === 'vertical' && tabs.length > 1;
      var horizontalUseRtl = tabDirection === 'vertical' && useRtl;
      var rtlRatio = horizontalUseRtl ? -1 : 1;
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          bar: cellRef.current,
          pane: paneRef.current,
          barOverflow: cellRef.current ? cellRef.current.hasOverflow : false,
          updateLayout: updateLayout,
          changeIndex: function changeIndex(newIndex, rightNow) {
            return _changeIndex(newIndex, 'manual', rightNow);
          },
          scrollToIndex: paneRef.current ? paneRef.current.scrollToIndex : function () {}
        };
      });
      useListenResize(updateLayout);
      useSwiperInnerScroll(getInnerScrollContainer);
      React.useEffect(function () {
        if (distanceToChangeTab > 0 && distanceToChangeTab < 1) {
          console.warn("[Tabs Props Warning] The value of the prop `distanceToChangeTab` is too small(" + distanceToChangeTab + "). Do you meant to use the prop `percentToChangeTab`?");
        }
      }, [distanceToChangeTab]);
      React.useEffect(function () {
        var _a;

        updateLayout();

        if (mode === 'scroll') {
          // 判断初始是否滚动时，如果指定了scrollWhenMounted则看它的值，否则看是否默认选中第一个
          // @en When judging whether to scroll initially, if scrollWhenMounted is specified, see its value, otherwise, see if the first one is selected by default
          var needScroll = scrollWhenMounted === void 0 ? activeIndex !== 0 : scrollWhenMounted;

          if (needScroll) {
            (_a = paneRef.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex(activeIndex, true);
          }
        }
      }, []);
      React.useEffect(function () {
        paneRef.current && paneRef.current.setCurrentHeight();
      }, [children, activeIndex, autoHeight]);
      React.useEffect(function () {
        // 受控时用受控值，否则用内部值
        // @en When controlled, use the controlled value, otherwise use the internal value
        setActiveIndex(activeTab === void 0 ? innerIndex : activeTab);
      }, [activeTab, innerIndex]);
      useUpdateEffect(function () {
        // 利用受控手动更改index时，给cell line加上动画
        // @en Animate the cell line when changeing the index
        setCellTrans(true);

        if (!changeFromRef.current) {
          changeFromRef.current = 'manual';
        }
      }, [activeTab]);
      useUpdateEffect(function () {
        onDistanceChange && onDistanceChange(distance, wrapWidth, activeIndex);
      }, [distance, wrapWidth, activeIndex]);
      useUpdateEffect(function () {
        var _a, _b;

        if (changeFromRef.current !== 'scroll' && mode === 'scroll') {
          (_a = paneRef.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex(activeIndex);
        }

        if (changeFromRef.current === 'click' && useCaterpillar) {
          (_b = cellRef.current) === null || _b === void 0 ? void 0 : _b.setCaterpillarAnimate();
        }

        var changeFrom = changeFromRef.current;
        changeFromRef.current = '';
        nextTick(function () {
          setTimeout(function () {
            onAfterChange && onAfterChange(tabs[activeIndex], activeIndex, changeFrom);
          }, paneRef.current ? paneRef.current.getTransition() : 0);
        });
      }, [activeIndex]);
      var handlePaneTouchStart = React.useCallback(function (e) {
        if (onTouchStart && onTouchStart(e, activeIndexRef.current)) {
          return;
        }

        if (posAdjustingRef.current) {
          return;
        }

        touchStartedRef.current = true;
        touchMovedRef.current = false;
        setCellTrans(false);
        setPaneTrans(false);
        var evt = e.touches[0];
        touchStartXRef.current = evt.clientX || 0;
        touchStartYRef.current = evt.clientY || 0;
        scrollingRef.current = null;
        posAdjustingRef.current = false;
        touchStartTimeRef.current = new Date().getTime();
        touchStoppedRef.current = false;
      }, [onTouchStart]);
      var handlePaneTouchMove = React.useCallback(function (e) {
        if (onTouchMove && onTouchMove(e, activeIndexRef.current)) {
          return;
        } // 从屏幕边缘开始滑动时，屏蔽tabs滑动事件


        if (touchStartXRef.current < touchSideDisableThreshold) {
          return;
        }

        stopPropagation && e.stopPropagation();

        if (!touchStartedRef.current || posAdjustingRef.current) {
          e.cancelable && e.preventDefault();
          return;
        }

        touchMovedRef.current = true;
        var evt = e.changedTouches[0];
        var touchMoveX = evt.clientX || 0;
        var touchMoveY = evt.clientY || 0; // bugfix: 兼容safari在右滑返回上一页时clientX为负值的情况，安卓有折叠屏，触点会有超出屏幕(clientX < 0)的情况，因此这里限定ios系统
        // @en bugfix: bugfix: Compatible with the case in safari where clientX is negative when swiping right back to the previous page

        var posDisX = system === 'ios' && touchMoveX < 0 ? 0 : touchMoveX - touchStartXRef.current;
        var posDisY = touchMoveY - touchStartYRef.current;
        var absDisX = Math.abs(posDisX);
        var absDisY = Math.abs(posDisY);
        var comparedDis = posDisX * rtlRatio;

        if (scrollingRef.current === null) {
          scrollingRef.current = absDisX < absDisY;
        } // 如果是在上下滚动页面则禁用滑动手势
        // @en Disable swipe gestures if scrolling up and down


        if (scrollingRef.current) {
          if (tabBarResetWhenScroll === 'touchmove' && !touchMoveBarScrollRef.current) {
            cellRef.current && cellRef.current.scrollToCenter();
            touchMoveBarScrollRef.current = true;
          }

          setDistance(0);
          return;
        }

        if (activeIndexRef.current === 0 && comparedDis > 0 || activeIndexRef.current === tabs.length - 1 && comparedDis < 0) {
          if (!touchStoppedRef.current && absDisX > stopTouchThreshold) {
            touchStoppedRef.current = true;
            onTouchStopped && onTouchStopped(comparedDis >= 0 ? -1 : 1);
          }

          setDistance(0);
          return;
        }

        e.cancelable && e.preventDefault();
        setDistance(posDisX);
      }, [onTouchMove, onTouchStopped, stopTouchThreshold, tabs.length, touchSideDisableThreshold, tabBarResetWhenScroll, stopPropagation]);
      React.useEffect(function () {
        if (paneRef.current && paneRef.current.dom && canSwipe) {
          paneRef.current.dom.addEventListener('touchstart', handlePaneTouchStart);
          paneRef.current.dom.addEventListener('touchmove', handlePaneTouchMove);
        }

        return function () {
          if (paneRef.current && paneRef.current.dom && canSwipe) {
            paneRef.current.dom.removeEventListener('touchstart', handlePaneTouchStart);
            paneRef.current.dom.removeEventListener('touchmove', handlePaneTouchMove);
          }
        };
      }, [handlePaneTouchStart, handlePaneTouchMove, canSwipe]);

      function handlePaneTouchEnd(e) {
        if (onTouchEnd && onTouchEnd(e.nativeEvent, activeIndexRef.current)) {
          return;
        }

        stopPropagation && e.stopPropagation();
        touchMoveBarScrollRef.current = false;

        if (scrollingRef.current && tabBarResetWhenScroll === 'touchend') {
          cellRef.current && cellRef.current.scrollToCenter();
        }

        if (!touchStartedRef.current || posAdjustingRef.current || scrollingRef.current || !touchMovedRef.current) {
          return;
        }

        touchStartedRef.current = false;
        setCellTrans(true);
        setPaneTrans(true);
        var touchEndTime = new Date().getTime();
        var dis = distanceRef.current;
        var speed = dis / (touchEndTime - touchStartTimeRef.current) * 1000;
        var maxSlice = wrapWidth * percentToChangeTab;
        var index = activeIndexRef.current;
        var needJump = Math.abs(dis) > maxSlice && Math.abs(dis) > distanceToChangeTab || Math.abs(speed) > speedToChangeTab;
        var newIndex = index;
        var comparedDis = dis * rtlRatio;

        if (comparedDis > 0 && needJump) {
          newIndex = index - 1;
        } else if (comparedDis < 0 && needJump) {
          newIndex = index + 1;
        }

        nextTick(function () {
          jumpTo(newIndex);
        });
      }

      function jumpTo(newIndex) {
        posAdjustingRef.current = true;

        if (newIndex !== activeIndexRef.current) {
          setJumpingDis(distanceRef.current);
        }

        _changeIndex(newIndex, 'swipe');

        touchStartTimeRef.current = 0;
        setTimeout(function () {
          posAdjustingRef.current = false;
          setJumpingDis(0);
        }, transitionDuration);
      }

      function updateLayout() {
        var _a, _b;

        var _c = getOffset(domRef.current),
            width = _c.width,
            height = _c.height;

        cellRef.current && cellRef.current.resetUnderlineStyle();
        setWrapWidth(width || ((_a = domRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth) || 0);
        setWrapHeight(height || ((_b = domRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0);
        paneRef.current && paneRef.current.setCurrentHeight();
      }

      function getAllPanes() {
        var panes = children ? [children] : [];

        if (children && Object.prototype.toString.call(children) === '[object Array]') {
          panes = children;
        } // panes不可超过tabs.length


        return panes.slice(0, tabs.length);
      }

      function _changeIndex(newIndex, changeFrom, rightNow) {
        if (rightNow || changeFrom === 'click' && disableClickTransition) {
          setPaneTrans(false);
        } else {
          setPaneTrans(true);
        }

        changeFromRef.current = changeFrom || '';
        setCellTrans(true);
        setInnerIndex(newIndex);
        setDistance(0);

        if (newIndex !== activeIndexRef.current) {
          onChange && onChange(tabs[newIndex], newIndex, changeFrom);
        }
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-tabs";
        var commonProps = {
          prefixCls: prefixCls,
          activeIndex: activeIndex,
          activeIndexRef: activeIndexRef,
          tabDirection: tabDirection,
          changeIndex: _changeIndex,
          duration: duration,
          transitionDuration: transitionDuration,
          wrapWidth: wrapWidth,
          wrapHeight: wrapHeight,
          distance: distance,
          mode: mode,
          translateZ: translateZ,
          fullScreen: fullScreen
        };

        var cellProps = __assign$2({
          ref: cellRef,
          tabs: tabs,
          onTabClick: onTabClick,
          type: type,
          tabBarPosition: tabBarPosition,
          tabBarArrange: tabBarArrange,
          tabBarScroll: tabBarScroll,
          renderUnderline: renderUnderline,
          useCaterpillar: useCaterpillar,
          cellTrans: cellTrans,
          jumpingDis: jumpingDis,
          tabBarExtra: tabBarExtra,
          onTabBarOverflowChange: onTabBarOverflowChange,
          tabBarGutter: tabBarGutter,
          tabBarPadding: tabBarPadding,
          tabBarFixed: tabBarFixed,
          tabBarScrollBezier: tabBarScrollBezier,
          tabBarScrollDuration: tabBarScrollDuration,
          tabBarScrollChance: tabBarScrollChance,
          tabBarHasDivider: tabBarHasDivider,
          underlineSize: underlineSize,
          underlineThick: underlineThick,
          underlineInnerStyle: underlineInnerStyle,
          caterpillarMaxScale: caterpillarMaxScale,
          caterpillarProperty: caterpillarProperty,
          onTabBarScroll: onTabBarScroll,
          hideTabBarBeforeMounted: hideTabBarBeforeMounted,
          overflowThreshold: overflowThreshold,
          showUnderline: showUnderline,
          underlineAdaptive: underlineAdaptive,
          disabled: disabled,
          renderTabBarItem: renderTabBarItem,
          renderTabBarInner: renderTabBarInner,
          tabBarStyle: tabBarStyle,
          tabBarClass: tabBarClass,
          tabBarStopPropagation: tabBarStopPropagation
        }, commonProps);

        var CellComp = /*#__PURE__*/React__default["default"].createElement(TabCell, __assign$2({}, cellProps));
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + " " + prefix + "-" + tabBarPosition + " " + prefix + "-" + tabDirection + " all-border-box", {
            'full-screen': fullScreen
          }, className || ''),
          style: style,
          ref: domRef
        }, renderTabBar ? renderTabBar(CellComp, cellProps) : CellComp, /*#__PURE__*/React__default["default"].createElement(TabPane, __assign$2({
          ref: paneRef,
          panes: allPanes,
          handlePaneTouchEnd: handlePaneTouchEnd,
          paneTrans: paneTrans,
          swipeable: canSwipe,
          lazyloadCount: lazyloadCount,
          hideContentStyle: hideContentStyle,
          renderHideContent: renderHideContent,
          tabPaneStyle: tabPaneStyle,
          getScrollContainer: getScrollContainer,
          scrollThrottle: scrollThrottle,
          scrollOffset: scrollOffset,
          goLastWhenScrollBottom: goLastWhenScrollBottom,
          scrollVertical: scrollVertical,
          tabPaneClass: tabPaneClass,
          tabPaneExtra: tabPaneExtra,
          autoHeight: autoHeight,
          onScroll: onScroll,
          swipeEnergySaving: swipeEnergySaving,
          rtlRatio: rtlRatio
        }, commonProps)));
      });
    });

    /**
     * React.createPortal的简单封装。
     * @en Simple wrapper for React.createPortal
     * @type 其他
     * @type_en Others
     * @name 自定义挂载
     * @name_en Portal
     */

    function Portal(props) {
      var _a = React.useState(),
          container = _a[0],
          setContainer = _a[1];

      var children = props.children,
          getContainer = props.getContainer;
      React.useEffect(function () {
        setContainer(getContainer ? getContainer() : document.body);
      }, [getContainer]);
      return container ? /*#__PURE__*/ReactDOM__default["default"].createPortal(children, container) : null;
    }

    /**
     * 粘性布局组件，元素相对于窗口或指定容器的吸顶效果。
     * @en Sticky layout component, The sticky-to-top effect of the element relative to the window or specified container
     * @type 布局
     * @type_en Layout
     * @name 粘性布局
     * @name_en Sticky
     */

    var Sticky = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.position,
          position = _a === void 0 ? 'top' : _a,
          _b = props.topOffset,
          topOffset = _b === void 0 ? 0 : _b,
          _c = props.bottomOffset,
          bottomOffset = _c === void 0 ? 0 : _c,
          _d = props.followOffset,
          followOffset = _d === void 0 ? 0 : _d,
          children = props.children,
          className = props.className,
          style = props.style,
          _e = props.zIndex,
          zIndex = _e === void 0 ? 100 : _e,
          _f = props.portalWhenSticky,
          portalWhenSticky = _f === void 0 ? false : _f,
          _g = props.stickyStyle,
          stickyStyle = _g === void 0 ? 'fixed' : _g,
          userSetStickyCssStyle = props.stickyCssStyle,
          getPortalContainer = props.getPortalContainer,
          getContainer = props.getContainer,
          getScrollContainer = props.getScrollContainer,
          onStickyStateChange = props.onStickyStateChange,
          onTopChange = props.onTopChange;

      var _h = useRefState(false),
          isSticky = _h[0],
          isStickyRef = _h[1],
          setIsSticky = _h[2];

      var _j = useRefState(false),
          wasSticky = _j[0],
          wasStickyRef = _j[1],
          setWasSticky = _j[2];

      var _k = React.useState({}),
          stickyStateStyle = _k[0],
          setStickyStateStyle = _k[1];

      var contentRef = React.useRef(null);
      var placeholderRef = React.useRef(null);
      var contentCalculateHeightRef = React.useRef(0);
      var containerRef = React.useRef(null);
      var scrollContainerRef = React.useRef(null);
      var framePendingRef = React.useRef(false);
      var containerEventHandler = React.useCallback(function (_a) {
        var followTop = _a.followTop,
            followBottom = _a.followBottom;

        if (!contentRef.current) {
          return;
        }

        var needTop = position === 'top' || position === 'both';
        var needBottom = position === 'bottom' || position === 'both';
        var placeholderClientRect = placeholderRef.current.getBoundingClientRect();
        var contentClientRect = contentRef.current.getBoundingClientRect();
        var calculatedHeight = contentClientRect.height;
        contentCalculateHeightRef.current = contentClientRect.height;
        var containerRect = getScrollContainerRect(scrollContainerRef.current).containerRect;
        var containerTop = containerRect.top,
            containerBottom = containerRect.bottom,
            containerHeight = containerRect.height;
        var disFromTop = Math.round(placeholderClientRect.top - containerTop);
        var disFromBottom = Math.round(placeholderClientRect.top + calculatedHeight - containerBottom);
        var topFollowDifference = followBottom - followOffset - calculatedHeight - topOffset - containerTop;
        var bottomFollowDifference = containerHeight - followTop - followOffset - calculatedHeight - bottomOffset;
        setWasSticky(Boolean(isStickyRef.current));
        var isTopSticky = needTop ? disFromTop <= topOffset && followBottom > containerTop + followOffset : false;
        var isBottomSticky = needBottom ? disFromBottom >= -bottomOffset && followTop < containerBottom - followOffset : false;
        var newStickyState = isTopSticky || isBottomSticky;
        var cssTop = (stickyStyle === 'absolute' ? 0 : containerTop) + topOffset;
        var cssBottom = (stickyStyle === 'absolute' ? 0 : window.innerHeight - containerBottom) + bottomOffset;
        var stickyCssStyle = {};

        if (newStickyState) {
          stickyCssStyle = __assign$2(__assign$2(__assign$2(__assign$2({
            transform: 'translateZ(0)',
            WebkitTransform: 'translateZ(0)',
            position: stickyStyle === 'absolute' ? 'absolute' : 'fixed',
            zIndex: zIndex
          }, isTopSticky ? {
            top: topFollowDifference > 0 ? cssTop : cssTop + topFollowDifference
          } : {}), isBottomSticky ? {
            bottom: bottomFollowDifference > 0 ? cssBottom : cssBottom + bottomFollowDifference
          } : {}), {
            left: placeholderClientRect.left,
            width: placeholderClientRect.width
          }), userSetStickyCssStyle || {});
        }

        onTopChange === null || onTopChange === void 0 ? void 0 : onTopChange(Math.max(0, contentClientRect.top - containerTop - topOffset));
        setIsSticky(newStickyState);
        setStickyStateStyle(stickyCssStyle);

        if (newStickyState !== wasStickyRef.current) {
          onStickyStateChange && onStickyStateChange({
            isTopSticky: isTopSticky,
            isBottomSticky: isBottomSticky,
            isSticky: newStickyState,
            wasSticky: wasStickyRef.current
          });
        }
      }, [position, topOffset, bottomOffset, followOffset, zIndex, stickyStyle, onStickyStateChange, onTopChange, userSetStickyCssStyle]);
      var recalculatePosition = React.useCallback(function () {
        if (framePendingRef.current) {
          return;
        }

        execRAF(function () {
          framePendingRef.current = false;

          if (containerRef.current) {
            var _a = containerRef.current.getBoundingClientRect(),
                top_1 = _a.top,
                bottom = _a.bottom;

            containerEventHandler({
              followTop: top_1,
              followBottom: bottom
            });
          }
        });
        framePendingRef.current = true;
      }, [containerEventHandler]);
      var updatePlaceholderLayoutInner = React.useCallback(function () {
        if (placeholderRef.current) {
          var contentHeight = contentCalculateHeightRef.current; // 当元素吸顶时，默认有一个占位的元素占住该元素的位置，避免布局产生抖动
          // @en When an element is sticky to the top, a placeholder element occupies the element's position by default to avoid jitter in the layout

          placeholderRef.current.style.height = (isStickyRef.current ? contentHeight : 0) + "px";
        }
      }, []);
      var updatePlaceholderLayout = React.useCallback(function () {
        if (contentRef.current) {
          var contentClientRect = contentRef.current.getBoundingClientRect();
          contentCalculateHeightRef.current = contentClientRect.height;
        }

        updatePlaceholderLayoutInner();
      }, []);
      React.useEffect(function () {
        var containerEle = getActualContainer(getContainer);
        containerRef.current = containerEle || document.body;
        var eventTarget = getScrollContainer ? getActualContainer(getScrollContainer) : window;
        if (!eventTarget) return;
        scrollContainerRef.current = eventTarget;

        var attachEventListeners = function attachEventListeners(target) {
          target.addEventListener('scroll', recalculatePosition);
        };

        var removeEventListeners = function removeEventListeners(target) {
          target.removeEventListener('scroll', recalculatePosition);
        };

        attachEventListeners(eventTarget);
        recalculatePosition();
        return function () {
          removeEventListeners(eventTarget);
        };
      }, [getContainer, getScrollContainer, recalculatePosition]);
      React.useEffect(function () {
        updatePlaceholderLayoutInner();
      }, [isSticky, wasSticky]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: contentRef.current,
          recalculatePosition: recalculatePosition,
          updatePlaceholderLayout: updatePlaceholderLayout
        };
      }, [recalculatePosition, updatePlaceholderLayout]);
      var computedStyle = React.useMemo(function () {
        return __assign$2(__assign$2({}, style || {}), stickyStateStyle);
      }, [stickyStateStyle, style]);

      function renderSticky(prefixCls) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-sticky", className),
          ref: contentRef,
          style: computedStyle
        }, children);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", null, /*#__PURE__*/React__default["default"].createElement("div", {
          ref: placeholderRef
        }), portalWhenSticky && isSticky ? /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: getPortalContainer
        }, renderSticky(prefixCls)) : renderSticky(prefixCls));
      });
    });

    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };
      return _extends$1.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }

    /**
     * Checks if a given element has a CSS class.
     * 
     * @param element the element
     * @param className the CSS class name
     */
    function hasClass(element, className) {
      if (element.classList) return !!className && element.classList.contains(className);
      return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }

    /**
     * Adds a CSS class to a given element.
     * 
     * @param element the element
     * @param className the CSS class name
     */

    function addClass(element, className) {
      if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
    }

    function replaceClassName(origClass, classToRemove) {
      return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
    }
    /**
     * Removes a CSS class from a given element.
     * 
     * @param element the element
     * @param className the CSS class name
     */


    function removeClass$1(element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (typeof element.className === 'string') {
        element.className = replaceClassName(element.className, className);
      } else {
        element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
      }
    }

    var config = {
      disabled: false
    };

    var TransitionGroupContext = React__default["default"].createContext(null);

    var UNMOUNTED = 'unmounted';
    var EXITED = 'exited';
    var ENTERING = 'entering';
    var ENTERED = 'entered';
    var EXITING = 'exiting';
    /**
     * The Transition component lets you describe a transition from one component
     * state to another _over time_ with a simple declarative API. Most commonly
     * it's used to animate the mounting and unmounting of a component, but can also
     * be used to describe in-place transition states as well.
     *
     * ---
     *
     * **Note**: `Transition` is a platform-agnostic base component. If you're using
     * transitions in CSS, you'll probably want to use
     * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
     * instead. It inherits all the features of `Transition`, but contains
     * additional features necessary to play nice with CSS transitions (hence the
     * name of the component).
     *
     * ---
     *
     * By default the `Transition` component does not alter the behavior of the
     * component it renders, it only tracks "enter" and "exit" states for the
     * components. It's up to you to give meaning and effect to those states. For
     * example we can add styles to a component when it enters or exits:
     *
     * ```jsx
     * import { Transition } from 'react-transition-group';
     *
     * const duration = 300;
     *
     * const defaultStyle = {
     *   transition: `opacity ${duration}ms ease-in-out`,
     *   opacity: 0,
     * }
     *
     * const transitionStyles = {
     *   entering: { opacity: 1 },
     *   entered:  { opacity: 1 },
     *   exiting:  { opacity: 0 },
     *   exited:  { opacity: 0 },
     * };
     *
     * const Fade = ({ in: inProp }) => (
     *   <Transition in={inProp} timeout={duration}>
     *     {state => (
     *       <div style={{
     *         ...defaultStyle,
     *         ...transitionStyles[state]
     *       }}>
     *         I'm a fade Transition!
     *       </div>
     *     )}
     *   </Transition>
     * );
     * ```
     *
     * There are 4 main states a Transition can be in:
     *  - `'entering'`
     *  - `'entered'`
     *  - `'exiting'`
     *  - `'exited'`
     *
     * Transition state is toggled via the `in` prop. When `true` the component
     * begins the "Enter" stage. During this stage, the component will shift from
     * its current transition state, to `'entering'` for the duration of the
     * transition and then to the `'entered'` stage once it's complete. Let's take
     * the following example (we'll use the
     * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <Transition in={inProp} timeout={500}>
     *         {state => (
     *           // ...
     *         )}
     *       </Transition>
     *       <button onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the button is clicked the component will shift to the `'entering'` state
     * and stay there for 500ms (the value of `timeout`) before it finally switches
     * to `'entered'`.
     *
     * When `in` is `false` the same thing happens except the state moves from
     * `'exiting'` to `'exited'`.
     */

    var Transition$1 = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(Transition, _React$Component);

      function Transition(props, context) {
        var _this;

        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;

        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }

        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }

      Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;

        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }

        return null;
      } // getSnapshotBeforeUpdate(prevProps) {
      //   let nextStatus = null
      //   if (prevProps !== this.props) {
      //     const { status } = this.state
      //     if (this.props.in) {
      //       if (status !== ENTERING && status !== ENTERED) {
      //         nextStatus = ENTERING
      //       }
      //     } else {
      //       if (status === ENTERING || status === ENTERED) {
      //         nextStatus = EXITING
      //       }
      //     }
      //   }
      //   return { nextStatus }
      // }
      ;

      var _proto = Transition.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;

        if (prevProps !== this.props) {
          var status = this.state.status;

          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }

        this.updateStatus(false, nextStatus);
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };

      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;

        if (timeout != null && typeof timeout !== 'number') {
          exit = timeout.exit;
          enter = timeout.enter; // TODO: remove fallback for next major

          appear = timeout.appear !== undefined ? timeout.appear : enter;
        }

        return {
          exit: exit,
          enter: enter,
          appear: appear
        };
      };

      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }

        if (nextStatus !== null) {
          // nextStatus will always be ENTERING or EXITING.
          this.cancelNextCallback();

          if (nextStatus === ENTERING) {
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };

      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;

        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;

        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default["default"].findDOMNode(this), appearing],
            maybeNode = _ref2[0],
            maybeAppearing = _ref2[1];

        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
        // if we are mounting and running this it means appear _must_ be set

        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }

        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function () {
          _this2.props.onEntering(maybeNode, maybeAppearing);

          _this2.onTransitionEnd(enterTimeout, function () {
            _this2.safeSetState({
              status: ENTERED
            }, function () {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };

      _proto.performExit = function performExit() {
        var _this3 = this;

        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? undefined : ReactDOM__default["default"].findDOMNode(this); // no exit animation skip right to EXITED

        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(maybeNode);
          });
          return;
        }

        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function () {
          _this3.props.onExiting(maybeNode);

          _this3.onTransitionEnd(timeouts.exit, function () {
            _this3.safeSetState({
              status: EXITED
            }, function () {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };

      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };

      _proto.safeSetState = function safeSetState(nextState, callback) {
        // This shouldn't be necessary, but there are weird race conditions with
        // setState callbacks and unmounting in testing, so always make sure that
        // we can cancel any pending setState callbacks after we unmount.
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };

      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;

        var active = true;

        this.nextCallback = function (event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };

        this.nextCallback.cancel = function () {
          active = false;
        };

        return this.nextCallback;
      };

      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default["default"].findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

        if (!node || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }

        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
              maybeNode = _ref3[0],
              maybeNextCallback = _ref3[1];

          this.props.addEndListener(maybeNode, maybeNextCallback);
        }

        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };

      _proto.render = function render() {
        var status = this.state.status;

        if (status === UNMOUNTED) {
          return null;
        }

        var _this$props = this.props,
            children = _this$props.children;
            _this$props.in;
            _this$props.mountOnEnter;
            _this$props.unmountOnExit;
            _this$props.appear;
            _this$props.enter;
            _this$props.exit;
            _this$props.timeout;
            _this$props.addEndListener;
            _this$props.onEnter;
            _this$props.onEntering;
            _this$props.onEntered;
            _this$props.onExit;
            _this$props.onExiting;
            _this$props.onExited;
            _this$props.nodeRef;
            var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

        return (
          /*#__PURE__*/
          // allows for nested Transitions
          React__default["default"].createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === 'function' ? children(status, childProps) : React__default["default"].cloneElement(React__default["default"].Children.only(children), childProps))
        );
      };

      return Transition;
    }(React__default["default"].Component);

    Transition$1.contextType = TransitionGroupContext;
    Transition$1.propTypes = {}; // Name the function so it is clearer in the documentation

    function noop() {}

    Transition$1.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop,
      onEntering: noop,
      onEntered: noop,
      onExit: noop,
      onExiting: noop,
      onExited: noop
    };
    Transition$1.UNMOUNTED = UNMOUNTED;
    Transition$1.EXITED = EXITED;
    Transition$1.ENTERING = ENTERING;
    Transition$1.ENTERED = ENTERED;
    Transition$1.EXITING = EXITING;
    var Transition$2 = Transition$1;

    var _addClass = function addClass$1(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return addClass(node, c);
      });
    };

    var removeClass = function removeClass(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return removeClass$1(node, c);
      });
    };
    /**
     * A transition component inspired by the excellent
     * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
     * use it if you're using CSS transitions or animations. It's built upon the
     * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
     * component, so it inherits all of its props.
     *
     * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
     * and `exit` states of the transition. The first class is applied and then a
     * second `*-active` class in order to activate the CSS transition. After the
     * transition, matching `*-done` class names are applied to persist the
     * transition state.
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
     *         <div>
     *           {"I'll receive my-node-* classes"}
     *         </div>
     *       </CSSTransition>
     *       <button type="button" onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the `in` prop is set to `true`, the child component will first receive
     * the class `example-enter`, then the `example-enter-active` will be added in
     * the next tick. `CSSTransition` [forces a
     * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
     * between before adding the `example-enter-active`. This is an important trick
     * because it allows us to transition between `example-enter` and
     * `example-enter-active` even though they were added immediately one after
     * another. Most notably, this is what makes it possible for us to animate
     * _appearance_.
     *
     * ```css
     * .my-node-enter {
     *   opacity: 0;
     * }
     * .my-node-enter-active {
     *   opacity: 1;
     *   transition: opacity 200ms;
     * }
     * .my-node-exit {
     *   opacity: 1;
     * }
     * .my-node-exit-active {
     *   opacity: 0;
     *   transition: opacity 200ms;
     * }
     * ```
     *
     * `*-active` classes represent which styles you want to animate **to**, so it's
     * important to add `transition` declaration only to them, otherwise transitions
     * might not behave as intended! This might not be obvious when the transitions
     * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
     * the example above (minus `transition`), but it becomes apparent in more
     * complex transitions.
     *
     * **Note**: If you're using the
     * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
     * prop, make sure to define styles for `.appear-*` classes as well.
     */


    var CSSTransition = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(CSSTransition, _React$Component);

      function CSSTransition() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        };

        _this.onEnter = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument[0],
              appearing = _this$resolveArgument[1];

          _this.removeClasses(node, 'exit');

          _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

          if (_this.props.onEnter) {
            _this.props.onEnter(maybeNode, maybeAppearing);
          }
        };

        _this.onEntering = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument2[0],
              appearing = _this$resolveArgument2[1];

          var type = appearing ? 'appear' : 'enter';

          _this.addClass(node, type, 'active');

          if (_this.props.onEntering) {
            _this.props.onEntering(maybeNode, maybeAppearing);
          }
        };

        _this.onEntered = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument3[0],
              appearing = _this$resolveArgument3[1];

          var type = appearing ? 'appear' : 'enter';

          _this.removeClasses(node, type);

          _this.addClass(node, type, 'done');

          if (_this.props.onEntered) {
            _this.props.onEntered(maybeNode, maybeAppearing);
          }
        };

        _this.onExit = function (maybeNode) {
          var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument4[0];

          _this.removeClasses(node, 'appear');

          _this.removeClasses(node, 'enter');

          _this.addClass(node, 'exit', 'base');

          if (_this.props.onExit) {
            _this.props.onExit(maybeNode);
          }
        };

        _this.onExiting = function (maybeNode) {
          var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument5[0];

          _this.addClass(node, 'exit', 'active');

          if (_this.props.onExiting) {
            _this.props.onExiting(maybeNode);
          }
        };

        _this.onExited = function (maybeNode) {
          var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument6[0];

          _this.removeClasses(node, 'exit');

          _this.addClass(node, 'exit', 'done');

          if (_this.props.onExited) {
            _this.props.onExited(maybeNode);
          }
        };

        _this.resolveArguments = function (maybeNode, maybeAppearing) {
          return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
          : [maybeNode, maybeAppearing];
        };

        _this.getClassNames = function (type) {
          var classNames = _this.props.classNames;
          var isStringClassNames = typeof classNames === 'string';
          var prefix = isStringClassNames && classNames ? classNames + "-" : '';
          var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
          var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
          var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
          return {
            baseClassName: baseClassName,
            activeClassName: activeClassName,
            doneClassName: doneClassName
          };
        };

        return _this;
      }

      var _proto = CSSTransition.prototype;

      _proto.addClass = function addClass(node, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];

        var _this$getClassNames = this.getClassNames('enter'),
            doneClassName = _this$getClassNames.doneClassName;

        if (type === 'appear' && phase === 'done' && doneClassName) {
          className += " " + doneClassName;
        } // This is to force a repaint,
        // which is necessary in order to transition styles when adding a class name.


        if (phase === 'active') {
          /* eslint-disable no-unused-expressions */
          node && node.scrollTop;
        }

        if (className) {
          this.appliedClasses[type][phase] = className;

          _addClass(node, className);
        }
      };

      _proto.removeClasses = function removeClasses(node, type) {
        var _this$appliedClasses$ = this.appliedClasses[type],
            baseClassName = _this$appliedClasses$.base,
            activeClassName = _this$appliedClasses$.active,
            doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {};

        if (baseClassName) {
          removeClass(node, baseClassName);
        }

        if (activeClassName) {
          removeClass(node, activeClassName);
        }

        if (doneClassName) {
          removeClass(node, doneClassName);
        }
      };

      _proto.render = function render() {
        var _this$props = this.props;
            _this$props.classNames;
            var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

        return /*#__PURE__*/React__default["default"].createElement(Transition$2, _extends$1({}, props, {
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        }));
      };

      return CSSTransition;
    }(React__default["default"].Component);

    CSSTransition.defaultProps = {
      classNames: ''
    };
    CSSTransition.propTypes = {};

    /**
     * react-transition-group/CSSTransition 的简单封装。
     * @en Simple wrapper for react-transition-group/CSSTransition.
     * @type 其他
     * @type_en Others
     * @name 动画过渡
     * @name_en Transition
     */

    function Transition(props) {
      var _a = props.children,
          children = _a === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", null) : _a,
          type = props.type,
          transIn = props.in,
          _b = props.timeout,
          timeout = _b === void 0 ? 300 : _b,
          _c = props.mountOnEnter,
          mountOnEnter = _c === void 0 ? true : _c,
          _d = props.unmountOnExit,
          unmountOnExit = _d === void 0 ? true : _d,
          restProps = __rest$1(props, ["children", "type", "in", "timeout", "mountOnEnter", "unmountOnExit"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(CSSTransition, __assign$2({
          in: transIn,
          timeout: timeout,
          classNames: prefixCls + "-" + type,
          mountOnEnter: mountOnEnter,
          unmountOnExit: unmountOnExit
        }, restProps), children);
      });
    }

    function IconErrorCircle(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-error-circle " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M12 24C5.4 24 0 18.6 0 12S5.4 0 12 0s12 5.4 12 12-5.4 12-12 12zm0-22.5C6.2 1.5 1.5 6.2 1.5 12S6.2 22.5 12 22.5 22.5 17.8 22.5 12 17.8 1.5 12 1.5z"
        }), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M13.1 12l3.7-3.7c.3-.3.3-.7 0-1l-.1-.1c-.3-.3-.7-.3-1 0L12 10.9 8.3 7.2c-.3-.3-.7-.3-1 0l-.1.1c-.3.3-.3.7 0 1l3.7 3.7-3.7 3.7c-.3.3-.3.7 0 1l.1.1c.2.1.3.2.5.2s.4-.1.5-.2l3.7-3.7 3.7 3.7c.3.3.7.3 1 0l.1-.1c.3-.3.3-.7 0-1L13.1 12z"
        }));
      });
    }

    function IconWarnCircle(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-warn-circle " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M12 24C5.4 24 0 18.6 0 12S5.4 0 12 0s12 5.4 12 12-5.4 12-12 12zm0-22.5C6.2 1.5 1.5 6.2 1.5 12S6.2 22.5 12 22.5 22.5 17.8 22.5 12 17.8 1.5 12 1.5z"
        }), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M11.8 15.2h.3c.4 0 .7-.3.7-.7V7.2c0-.4-.3-.7-.7-.7h-.3c-.4 0-.7.3-.7.7v7.3c0 .4.3.7.7.7zM12.2 16.5h-.3c-.4 0-.7.3-.7.7v.3c0 .4.3.7.7.7h.3c.4 0 .7-.3.7-.7v-.3c0-.4-.3-.7-.7-.7z"
        }));
      });
    }

    function IconSuccessCircle(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-success-circle " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M12 24C5.4 24 0 18.6 0 12S5.4 0 12 0s12 5.4 12 12-5.4 12-12 12zm0-22.5C6.2 1.5 1.5 6.2 1.5 12S6.2 22.5 12 22.5 22.5 17.8 22.5 12 17.8 1.5 12 1.5z"
        }), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M17.5 8c-.3-.3-.7-.3-1 0l-6.3 6.3-3-3c-.3-.3-.7-.3-1 0-.3.3-.3.7 0 1l3.5 3.5c.1.1.3.2.4.2s.4-.1.5-.2L17.5 9c.2-.3.2-.7 0-1z"
        }));
      });
    }

    var ReactDOMRender =
    /** @class */
    function () {
      function ReactDOMRender(app, container, context) {
        var _this = this;

        this.render = function (props) {
          var CustomApp = _this.app;

          var propsWithContext = __assign$2(__assign$2({}, props), {
            context: _this.context
          });

          if (_this.root) {
            _this.root.render( /*#__PURE__*/React__default["default"].createElement(CustomApp, __assign$2({}, propsWithContext)));
          } else {
            _this.root = render( /*#__PURE__*/React__default["default"].createElement(CustomApp, __assign$2({}, propsWithContext)), _this.container);
          }
        };

        this.unmount = function () {
          var _a;

          (_a = _this.root) === null || _a === void 0 ? void 0 : _a._unmount();
          _this.root = undefined;
        };

        this.app = app;
        this.container = container;
        this.context = context;
      }

      return ReactDOMRender;
    }();

    function toast(Component, type) {
      return function (originConfig, context) {
        var config = typeof originConfig === 'string' ? {
          content: originConfig,
          type: 'info'
        } : originConfig;

        if (type !== void 0) {
          config.type = type;
          config.loading = type === 'loading';
        }

        var div = document.createElement('div');
        document.body.appendChild(div);

        var _a = new ReactDOMRender(Component, div, context),
            render = _a.render,
            unmount = _a.unmount;

        function destroy() {
          var onClose = config.onClose;
          onClose && onClose();
          unmount();

          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
        }

        var dynamicProps = __assign$2(__assign$2({}, config), {
          close: close,
          getContainer: function getContainer() {
            return div;
          },
          onClose: destroy,
          visible: false
        });

        var leaving = false;

        function update(newConfig) {
          dynamicProps = __assign$2(__assign$2({}, dynamicProps), newConfig);
          render(dynamicProps);
        }

        function close() {
          leaving = true;
          dynamicProps.visible = false;
          render(dynamicProps);
        }

        render(dynamicProps);
        nextTick(function () {
          // 在即将打开时发现已经调用了close则取消打开操作
          // @en When it is about to be opened, it is found that close has been called and the open operation is canceled
          if (leaving) return;
          dynamicProps.visible = true;
          render(dynamicProps);
        });
        return {
          update: update,
          close: close,
          hide: close
        };
      };
    }

    /**
     * 加载中组件，分为四种类型，`circle`为环形，`arc`为弧线，`spin`为旋转，`dot`为圆点。所有类型均可定制颜色，环形和弧线类型可定制线圈半径及粗细，旋转和圆点类型可定制内部元素透明度。
     * @en Loading component, divided into four types, `circle` is a ring, `arc` is an arc `spin` is a rotation, and `dot` is a dot. All types can be customized in color, ring and arc types can be customized with coil radius and thickness, and rotation and dot types can be customized with internal element transparency.
     * @type 反馈
     * @type_en Feedback
     * @name 加载
     * @name_en Loading
     */

    var Loading = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var style = props.style,
          _a = props.className,
          className = _a === void 0 ? '' : _a,
          color = props.color,
          _b = props.type,
          type = _b === void 0 ? 'dot' : _b,
          list = props.list,
          _c = props.duration,
          duration = _c === void 0 ? 1000 : _c,
          _d = props.svgKey,
          userSetSvgKey = _d === void 0 ? '' : _d,
          _e = props.radius,
          radius = _e === void 0 ? 9 : _e,
          _f = props.stroke,
          stroke = _f === void 0 ? 2 : _f,
          _g = props.filleted,
          filleted = _g === void 0 ? true : _g;

      var _h = React.useState([]),
          statusList = _h[0],
          setStatusList = _h[1];

      var timerId = React.useRef(-1);
      var halfCircle = Math.PI * radius;
      var circlePos = 0.5 * stroke + radius;
      var circleSize = radius * 2 + stroke;
      var domRef = React.useRef(null);
      var svgKey = useGenSvgKey(userSetSvgKey).svgKey;
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      React.useEffect(function () {
        if (type === 'dot' && statusList.length) {
          var interval = duration / statusList.length;
          timerId.current = setInterval(function () {
            var newList = __spreadArrays$1(statusList);

            var item = newList.pop();
            item && newList.unshift(item);
            setStatusList(newList);
          }, interval);
        }

        return function () {
          if (timerId.current >= 0) {
            clearInterval(timerId.current);
          }
        };
      }, [type, statusList, duration]);
      React.useEffect(function () {
        var newList;

        if (list && list.length) {
          newList = list;
        } else {
          switch (type) {
            case 'spin':
              newList = [1, 0.1, 0.2286, 0.3572, 0.4858, 0.6144, 0.743, 0.8716];
              break;

            case 'dot':
              newList = [0.2, 0.6, 1];
              break;

            default:
              newList = [];
              break;
          }
        }

        setStatusList(newList);
      }, [list, type]);

      function renderSpin() {
        var len = statusList.length;
        return statusList.map(function (opacity, index) {
          return /*#__PURE__*/React__default["default"].createElement("span", {
            key: index,
            className: "spin-cell",
            style: getStyleWithVendor({
              opacity: opacity,
              transform: "rotate(" + index / len + "turn)",
              width: stroke
            })
          }, /*#__PURE__*/React__default["default"].createElement("span", {
            className: "spin-cell-inner bg-color-with-config",
            style: __assign$2({
              backgroundColor: color
            }, filleted ? {
              borderRadius: stroke
            } : {})
          }));
        });
      }

      function renderDot() {
        return statusList.map(function (opacity, index) {
          return /*#__PURE__*/React__default["default"].createElement("span", {
            key: index,
            className: cls('dot-cell', 'bg-color-with-config', {
              filleted: filleted
            }),
            style: {
              opacity: opacity,
              backgroundColor: color
            }
          });
        });
      }

      function renderCircle() {
        return /*#__PURE__*/React__default["default"].createElement("svg", {
          viewBox: "0 0 " + circleSize + " " + circleSize
        }, /*#__PURE__*/React__default["default"].createElement("defs", null, /*#__PURE__*/React__default["default"].createElement("linearGradient", {
          id: "grad1-" + svgKey,
          x1: "0%",
          y1: "0%",
          x2: "100%",
          y2: "0%"
        }, /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "0%",
          className: "loading-circle-middle stop-color-with-config",
          style: {
            stopColor: color
          }
        }), /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "100%",
          className: "loading-circle-start stop-color-with-config",
          style: {
            stopColor: color
          }
        })), /*#__PURE__*/React__default["default"].createElement("linearGradient", {
          id: "grad2-" + svgKey,
          x1: "0%",
          y1: "0%",
          x2: "100%",
          y2: "0%"
        }, /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "0%",
          className: "loading-circle-middle stop-color-with-config",
          style: {
            stopColor: color
          }
        }), /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "100%",
          className: "loading-circle-end stop-color-with-config",
          style: {
            stopColor: color
          }
        }))), /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos,
          cy: circlePos,
          r: radius,
          stroke: "url(#grad1-" + svgKey + ")",
          strokeWidth: stroke,
          strokeDasharray: halfCircle,
          strokeDashoffset: halfCircle,
          fill: "none"
        }), /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos,
          cy: circlePos,
          r: radius,
          stroke: "url(#grad2-" + svgKey + ")",
          strokeWidth: stroke,
          strokeDasharray: halfCircle,
          fill: "none"
        }), filleted ? /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos * 2 - stroke / 2,
          cy: circlePos,
          r: stroke / 2,
          className: "loading-circle-filleted fill-color-with-config",
          style: {
            fill: color
          }
        }) : null);
      }

      function renderArc() {
        return /*#__PURE__*/React__default["default"].createElement("svg", {
          viewBox: "0 0 " + circleSize + " " + circleSize
        }, /*#__PURE__*/React__default["default"].createElement("circle", {
          className: "arc-bg",
          cx: circlePos,
          cy: circlePos,
          r: radius,
          strokeWidth: stroke,
          fill: "none"
        }), /*#__PURE__*/React__default["default"].createElement("circle", __assign$2({
          className: "arc-line stroke-color-with-config",
          cx: circlePos,
          cy: circlePos,
          r: radius,
          style: {
            stroke: color
          },
          strokeWidth: stroke,
          strokeDashoffset: halfCircle * 0.5,
          strokeDasharray: halfCircle * 0.5 + " " + halfCircle * 1.5,
          fill: "none"
        }, filleted ? {
          strokeLinecap: 'round'
        } : {})));
      }

      function renderLoadingByType() {
        switch (type) {
          case 'spin':
            return renderSpin();

          case 'dot':
            return renderDot();

          case 'circle':
            return renderCircle();

          case 'arc':
            return renderArc();

          default:
            return null;
        }
      }

      function getLoadingStyle() {
        var circleStyle = isOneOf(type, ['circle', 'arc']) ? {
          width: circleSize,
          height: circleSize
        } : {};
        return getStyleWithVendor(__assign$2(__assign$2({
          animationDuration: duration + "ms"
        }, circleStyle), style || {}));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-loading all-border-box", type, className),
          style: getLoadingStyle(),
          ref: domRef
        }, renderLoadingByType());
      });
    });

    var Toast = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          getContainer = props.getContainer,
          _a = props.visible,
          visible = _a === void 0 ? false : _a,
          onClose = props.onClose,
          close = props.close,
          _b = props.type,
          type = _b === void 0 ? 'info' : _b,
          icon = props.icon,
          _c = props.layout,
          layout = _c === void 0 ? 'vertical' : _c,
          _d = props.duration,
          duration = _d === void 0 ? 3000 : _d,
          _e = props.transitionDuration,
          transitionDuration = _e === void 0 ? 300 : _e,
          content = props.content,
          _f = props.loading,
          loading = _f === void 0 ? false : _f,
          loadingIcon = props.loadingIcon,
          _g = props.disableBodyTouch,
          disableBodyTouch = _g === void 0 ? false : _g,
          loadingInner = props.loadingInner,
          _h = props.direction,
          direction = _h === void 0 ? 'center' : _h,
          typeIconMap = props.typeIconMap,
          initialBodyOverflow = props.initialBodyOverflow;
      var closeTimerRef = React.useRef();
      var domRef = React.useRef(null);
      var wrapDomRef = React.useRef(null);
      var isInitialMount = React.useRef(false);
      var hasType = type && type !== 'info';
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      usePreventBodyScroll(visible, disableBodyTouch, initialBodyOverflow);

      function handleClose() {
        if (close) {
          close();
        }
      }

      function startCloseTimer() {
        if (duration) {
          clearTimeout(closeTimerRef.current);
          closeTimerRef.current = window.setTimeout(function () {
            handleClose();
          }, duration);
        }
      }

      function handleClickMask(e) {
        if (disableBodyTouch) {
          e.preventDefault();
        }
      }

      function getTypeIcons() {
        var map = typeIconMap || {};
        var defaultMap = {
          success: /*#__PURE__*/React__default["default"].createElement(IconSuccessCircle, null),
          error: /*#__PURE__*/React__default["default"].createElement(IconErrorCircle, null),
          warn: /*#__PURE__*/React__default["default"].createElement(IconWarnCircle, null)
        };
        return map[type] || defaultMap[type] || null;
      }

      React.useEffect(function () {
        var mounted = isInitialMount.current;

        if (visible) {
          startCloseTimer();
        } else {
          clearTimeout(closeTimerRef.current);

          if (mounted) {
            setTimeout(function () {
              onClose && onClose();
            }, transitionDuration);
          }
        }

        isInitialMount.current = true;
      }, [visible]);
      React.useEffect(function () {
        startCloseTimer();
      }, [duration]);

      function renderComponent(prefixClass) {
        var _a;

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixClass + "-wrapper", "from-" + direction, {
            'no-event': !disableBodyTouch
          }),
          onClick: handleClickMask,
          ref: wrapDomRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixClass + "-inner", layout, (_a = {}, _a[prefixClass + "-inner-mixin"] = (loading || hasType || icon) && layout === 'vertical', _a))
        }, loading && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixClass + "-loading-wrapper"
        }, loadingIcon !== void 0 ? loadingIcon : /*#__PURE__*/React__default["default"].createElement(Loading, {
          className: "loading-icon",
          type: "arc",
          stroke: 2,
          radius: loadingInner ? 19 : 11
        }), loadingInner ? /*#__PURE__*/React__default["default"].createElement("span", {
          className: prefixClass + "-loading-inner"
        }, loadingInner) : null), !loading && hasType ? getTypeIcons() : null, !loading && !hasType && icon ? icon : null, content ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixClass + "-content"
        }, content) : null));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: getContainer
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-toast", 'all-border-box', className),
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: visible,
          timeout: transitionDuration,
          type: "fade",
          nodeRef: wrapDomRef
        }, renderComponent(prefixCls + "-toast"))));
      });
    });
    function methodsGenerator$7(Comp) {
      return {
        /**
         * 展示常规提示框
         * @desc {en} Show regular toast
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        toast: toast(Comp),

        /**
         * 展示常规提示框，同 Toast.toast
         * @desc {en} Show regular toast, the same as Toast.toast
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        info: toast(Comp, 'info'),

        /**
         * 展示成功提示框(含成功icon)
         * @desc {en} Show success prompt toast (including success icon)
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        success: toast(Comp, 'success'),

        /**
         * 展示错误提示框(含错误icon)
         * @desc {en} Display error prompt toast (including error icon)
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        error: toast(Comp, 'error'),

        /**
         * 展示加载中提示框(含加载中icon)
         * @desc {en} Display loading prompt toast (including loading icon)
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        loading: toast(Comp, 'loading'),

        /**
         * 展示警告提示框(含警告icon)
         * @desc {en} Display warning prompt toast (including warning icon)
         * @param {string | ToastProps} config Configuration
         * @returns {{ update: (config: ToastProps) => void; close: () => void }}
         */
        warn: toast(Comp, 'warn')
      };
    }
    var ToastWithGlobalContext = CompWithGlobalContext(Toast);
    /**
     * 轻提示组件，支持各个场景下调用方法。
     * @en The toast component, supports calling methods in various scenarios.
     * @type 反馈
     * @type_en Feedback
     * @name 轻提示
     * @name_en Toast
     */

    var index$p = componentWrapper(Toast, methodsGenerator$7(ToastWithGlobalContext));

    function getOpenMethod(Component, containerId, normalize) {
      if (normalize === void 0) {
        normalize = function normalize(config) {
          return config;
        };
      }

      return function (config, context) {
        var baseProps = __assign$2(__assign$2({
          unmountOnExit: true
        }, normalize(config)), {
          visible: false,
          close: function close() {}
        }); // 不同的key用不同的容器挂载


        var id = "_" + (containerId || 'ARCO_MASKING') + "_DIV_" + (config.key || '') + "_";
        var div = appendElementById(id, baseProps.getContainer).child;
        var leaving = false;
        var render = new ReactDOMRender(Component, div, context).render;

        var dynamicProps = __assign$2(__assign$2({}, baseProps), {
          getContainer: function getContainer() {
            return div;
          }
        });

        function update(newConfig) {
          dynamicProps = __assign$2(__assign$2({}, dynamicProps), normalize(newConfig));
          render(dynamicProps);
        }

        function close() {
          leaving = true;
          dynamicProps.visible = false;
          render(dynamicProps);
        }

        dynamicProps.close = close;

        dynamicProps.onClose = function (scene) {
          baseProps.onClose && baseProps.onClose(scene);

          if (baseProps.unmountOnExit) {
            removeElement(div);
          }
        };

        render(dynamicProps);
        nextTick(function () {
          if (leaving) return;
          dynamicProps.visible = true;
          render(dynamicProps);
        });
        return {
          close: close,
          update: update
        };
      };
    }
    function open$5(Component, containerId) {
      return getOpenMethod(Component, containerId);
    }

    var Masking = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          _a = props.visible,
          visible = _a === void 0 ? false : _a,
          maskClass = props.maskClass,
          maskStyle = props.maskStyle,
          contentClass = props.contentClass,
          contentStyle = props.contentStyle,
          close = props.close,
          onClose = props.onClose,
          onOpen = props.onOpen,
          onMaskClick = props.onMaskClick,
          children = props.children,
          _b = props.maskTransitionType,
          maskTransitionType = _b === void 0 ? 'fade' : _b,
          _c = props.contentTransitionType,
          contentTransitionType = _c === void 0 ? 'fade' : _c,
          _d = props.maskTransitionTimeout,
          maskTransitionTimeout = _d === void 0 ? 300 : _d,
          _e = props.contentTransitionTimeout,
          contentTransitionTimeout = _e === void 0 ? 300 : _e,
          _f = props.maskClosable,
          maskClosable = _f === void 0 ? true : _f,
          animatingClosable = props.animatingClosable,
          _g = props.mountOnEnter,
          mountOnEnter = _g === void 0 ? true : _g,
          _h = props.unmountOnExit,
          unmountOnExit = _h === void 0 ? true : _h,
          _j = props.orientationDirection,
          orientationDirection = _j === void 0 ? 'top' : _j,
          _k = props.preventBodyScroll,
          preventBodyScroll = _k === void 0 ? true : _k,
          initialBodyOverflow = props.initialBodyOverflow,
          _l = props.contentAtCenter,
          contentAtCenter = _l === void 0 ? false : _l,
          _m = props.gestureOutOfControl,
          gestureOutOfControl = _m === void 0 ? false : _m,
          getContainer = props.getContainer,
          getScrollContainer = props.getScrollContainer,
          onPreventTouchMove = props.onPreventTouchMove,
          onTouchMove = props.onTouchMove;
      var domRef = React.useRef(null);
      var maskRef = React.useRef(null);
      var contentRef = React.useRef(null);
      var timerRef = React.useRef(-1);
      var isInitialMount = React.useRef(false);
      var isAnimating = React.useRef(false);
      var closeScene = React.useRef('');

      var _o = React.useState(visible),
          innerVisible = _o[0],
          setInnerVisible = _o[1];

      var _p = React.useState(visible),
          outerVisible = _p[0],
          setOuterVisible = _p[1];

      var _q = React.useState(''),
          extraClass = _q[0],
          setExtraClass = _q[1];

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          mask: maskRef.current,
          content: contentRef.current,
          setCloseScene: setCloseScene
        };
      });
      usePopupScroll(innerVisible, domRef.current, getScrollContainer, orientationDirection, onPreventTouchMove, onTouchMove, gestureOutOfControl);
      usePreventBodyScroll(visible, preventBodyScroll, initialBodyOverflow);
      React.useEffect(function () {
        if (timerRef.current >= 0) {
          clearTimeout(timerRef.current);
        }

        var mounted = isInitialMount.current;

        if (mounted) {
          isAnimating.current = true;
        }

        if (!mounted && !visible && !mountOnEnter) {
          setExtraClass('pre-mount');
        }

        if (visible) {
          setOuterVisible(true);
          nextTick(function () {
            setInnerVisible(true);
            execAfterOpen(function () {
              isAnimating.current = false;
              setExtraClass('');
              mounted && (onOpen === null || onOpen === void 0 ? void 0 : onOpen());
            });
          });
        } else {
          setInnerVisible(false);
          timerRef.current = execAfterClose(function () {
            isAnimating.current = false;
            setOuterVisible(false);
            mounted && (onClose === null || onClose === void 0 ? void 0 : onClose(closeScene.current || void 0));
            closeScene.current = '';
          });
        }

        isInitialMount.current = true;
      }, [visible]);

      function setCloseScene(scene) {
        closeScene.current = scene;
      }

      function execAfterClose(callback) {
        return window.setTimeout(callback, Math.max(getMaxTimeout(maskTransitionTimeout, 'exit'), getMaxTimeout(contentTransitionTimeout, 'exit')));
      }

      function execAfterOpen(callback) {
        return window.setTimeout(callback, Math.max(getMaxTimeout(maskTransitionTimeout, 'enter'), getMaxTimeout(contentTransitionTimeout, 'enter')));
      }

      function getMaxTimeout(timeout, type) {
        return typeof timeout === 'number' ? timeout : timeout[type] || 0;
      }

      function handleMaskAction(e) {
        e.preventDefault();
        e.stopPropagation();
        onMaskClick === null || onMaskClick === void 0 ? void 0 : onMaskClick();

        if (!maskClosable || !animatingClosable && isAnimating.current) {
          return;
        }

        closeScene.current = 'mask';
        close === null || close === void 0 ? void 0 : close(e);
      }

      function renderMasking(_a) {
        var prefixCls = _a.prefixCls;
        return !mountOnEnter || outerVisible || !unmountOnExit ? /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: getContainer
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-masking", 'all-border-box', className),
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: innerVisible,
          timeout: maskTransitionTimeout,
          type: maskTransitionType,
          mountOnEnter: mountOnEnter,
          unmountOnExit: unmountOnExit,
          nodeRef: maskRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          ref: maskRef,
          className: cls(prefixCls + "-masking-mask", extraClass, maskClass),
          onClick: handleMaskAction,
          style: maskStyle
        })), /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: innerVisible,
          timeout: contentTransitionTimeout,
          type: contentTransitionType,
          mountOnEnter: mountOnEnter,
          unmountOnExit: unmountOnExit,
          nodeRef: contentRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          ref: contentRef,
          className: cls(prefixCls + "-masking-content", {
            'at-center': contentAtCenter
          }, extraClass, contentClass),
          style: contentStyle
        }, children)))) : null;
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderMasking);
    });
    function methodsGenerator$6(Comp) {
      return {
        /**
         * 打开模态弹窗
         * @desc {en} Open a Masking
         * @param {MaskingProps} config Configuration
         * @returns {{ close: () => void; update: (newConfig: MaskingProps) => void; }}
         */
        open: open$5(Comp)
      };
    }
    var MaskingWithGlobalContext = CompWithGlobalContext(Masking);
    /**
     * 通用模态弹窗，内部内容自定义。默认做了防滚动穿透处理，如果弹层内容中需要滚动，则需将滚动容器传入`getScrollContainer`属性以在未滚动到顶部或底部时释放滚动。
     * @en Generic modal popup with custom internal content. By default, anti-scroll penetration processing is performed. If scrolling is required in the content of the bullet layer, need to pass the scroll container to the `getScrollContainer` to release scrolling when it is not scrolled to the top or bottom.
     * @type 反馈
     * @type_en Feedback
     * @name 模态弹窗
     * @name_en Masking
     */

    var Masking$1 = componentWrapper(Masking, methodsGenerator$6(MaskingWithGlobalContext));

    function open$4(Component) {
      return open$5(Component, 'ARCO_POPUP');
    }

    var Popup = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var children = props.children,
          maskClass = props.maskClass,
          contentClass = props.contentClass,
          contentTransitionType = props.contentTransitionType,
          className = props.className,
          _a = props.direction,
          direction = _a === void 0 ? 'bottom' : _a,
          _b = props.needBottomOffset,
          needBottomOffset = _b === void 0 ? false : _b,
          _c = props.translateZ,
          translateZ = _c === void 0 ? false : _c,
          _d = props.maskTransitionTimeout,
          maskTransitionTimeout = _d === void 0 ? {
        enter: 450,
        exit: 240
      } : _d,
          _e = props.contentTransitionTimeout,
          contentTransitionTimeout = _e === void 0 ? {
        enter: 450,
        exit: 240
      } : _e,
          restProps = __rest$1(props, ["children", "maskClass", "contentClass", "contentTransitionType", "className", "direction", "needBottomOffset", "translateZ", "maskTransitionTimeout", "contentTransitionTimeout"]);

      var maskingRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return maskingRef.current;
      });

      function renderPopup(_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-popup";
        return /*#__PURE__*/React__default["default"].createElement(Masking$1, __assign$2({
          className: cls(prefix, className),
          ref: maskingRef,
          maskClass: cls(prefix + "-mask", {
            translateZ: translateZ
          }, maskClass),
          contentTransitionType: contentTransitionType || "slide-from-" + direction,
          contentClass: cls(prefix + "-content", direction, {
            'need-bottom-offset': needBottomOffset
          }, {
            translateZ: translateZ
          }, contentClass),
          maskTransitionTimeout: maskTransitionTimeout,
          contentTransitionTimeout: contentTransitionTimeout
        }, restProps), children);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderPopup);
    });
    function methodsGenerator$5(Comp) {
      return {
        /**
         * 打开弹出层
         * @desc {en} Open the popup
         * @param {PopupProps} config Configuration
         * @returns {{ close: () => void; update: (newConfig: PopupProps) => void; }}
         */
        open: open$4(Comp)
      };
    }
    var PopupWithGlobalContext = CompWithGlobalContext(Popup);
    /**
     * 基于模态弹窗的的全屏菜单，支持各个方向。默认做了防滚动穿透处理，如果弹层内容中需要滚动，则需将滚动容器传入`getScrollContainer`属性以在未滚动到顶部或底部时释放滚动。
     * @en A full-screen menu based on a modal popup, supporting all directions. By default, anti-scroll penetration processing is performed. If scrolling is required in the content of the popup layer, you need to pass the scroll container to the `getScrollContainer` property to release scrolling when it is not scrolled to the top or bottom.
     * @type 反馈
     * @type_en Feedback
     * @name 弹出层
     * @name_en Popup
     */

    var Popup$1 = componentWrapper(Popup, methodsGenerator$5(PopupWithGlobalContext));

    function open$3(Component) {
      return open$5(Component, 'ARCO_ACTION_SHEET');
    }

    var ActionSheet = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          items = props.items,
          cancelText = props.cancelText,
          close = props.close,
          title = props.title,
          subTitle = props.subTitle,
          _b = props.needBottomOffset,
          needBottomOffset = _b === void 0 ? true : _b,
          otherProps = __rest$1(props, ["className", "items", "cancelText", "close", "title", "subTitle", "needBottomOffset"]);

      var popupRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return popupRef.current;
      });

      function handleItemClick(e, item) {
        e.stopPropagation();

        if (item.status === 'disabled') {
          return;
        }

        var result = item.onClick ? item.onClick(e) : null;

        if (!result || typeof result === 'boolean') {
          !result && (close === null || close === void 0 ? void 0 : close(e));
        } else if (result && result.then) {
          result.then(function (res) {
            return !res && (close === null || close === void 0 ? void 0 : close(e));
          });
        }
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Popup$1, __assign$2({
          ref: popupRef,
          className: cls(prefixCls + "-action-sheet", className),
          contentClass: prefixCls + "-action-sheet-content",
          close: close,
          direction: "bottom",
          needBottomOffset: needBottomOffset
        }, otherProps), title || subTitle ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-action-sheet-header"
        }, title ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-action-sheet-title"
        }, title) : null, subTitle ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-action-sheet-sub-title"
        }, subTitle) : null) : null, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-action-sheet-list"
        }, (items || []).map(function (item, index) {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-action-sheet-item", item.className, item.status || 'normal'),
            key: index,
            style: item.style,
            onClick: function onClick(e) {
              return handleItemClick(e, item);
            }
          }, item.content);
        })), cancelText ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-action-sheet-item cancel-item",
          onClick: function onClick(e) {
            e.stopPropagation();
            close === null || close === void 0 ? void 0 : close(e);
          }
        }, cancelText) : null);
      });
    });
    function methodsGenerator$4(Comp) {
      return {
        /**
         * 打开动作面板
         * @desc {en} Open actionsheet
         * @param {ActionSheetProps} config setting
         * @returns {{ close: () => void; update: (newConfig: ActionSheetProps) => void; }}
         */
        open: open$3(Comp)
      };
    }
    var ActionSheetWithGlobalContext = CompWithGlobalContext(ActionSheet);
    /**
     * 动作面板组件
     * @en ActionSheet Component
     * @type 反馈
     * @type_en FeedBack
     * @name 动作面板
     * @name_en ActionSheet
     */

    var index$o = componentWrapper(ActionSheet, methodsGenerator$4(ActionSheetWithGlobalContext));

    /**
     * 增强版的 img 标签，提供多种图片填充模式，支持图片加载中提示、加载失败提示。
     * @en Enhanced img tag, provides a variety of image filling modes, and supports image loading prompts and loading failure prompts.
     * @type 信息展示
     * @type_en Data Display
     * @name 图片
     * @name_en Image
     */

    var BaseImage = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var style = props.style,
          className = props.className,
          status = props.status,
          src = props.src,
          width = props.width,
          height = props.height,
          _a = props.alt,
          alt = _a === void 0 ? '' : _a,
          _b = props.fit,
          fit = _b === void 0 ? 'cover' : _b,
          _c = props.position,
          position = _c === void 0 ? 'center' : _c,
          radius = props.radius,
          bordered = props.bordered,
          loadingArea = props.loadingArea,
          errorArea = props.errorArea,
          showLoading = props.showLoading,
          showError = props.showError,
          _d = props.animateDuration,
          animateDuration = _d === void 0 ? 200 : _d,
          _e = props.retryTime,
          retryTime = _e === void 0 ? 0 : _e,
          forceHttps = props.forceHttps,
          _f = props.boxWidth,
          boxWidth = _f === void 0 ? 0 : _f,
          _g = props.boxHeight,
          boxHeight = _g === void 0 ? 0 : _g,
          topOverlap = props.topOverlap,
          bottomOverlap = props.bottomOverlap,
          _h = props.showImage,
          showImage = _h === void 0 ? true : _h,
          staticLabel = props.staticLabel,
          _j = props.nativeProps,
          nativeProps = _j === void 0 ? {} : _j,
          onChange = props.onChange,
          onClick = props.onClick,
          onLoad = props.onLoad,
          onError = props.onError,
          onAutoRetry = props.onAutoRetry;
      var system = useSystem();

      var _k = useWindowSize(),
          windowWidth = _k.windowWidth,
          windowHeight = _k.windowHeight;

      var _l = useMountedState(staticLabel && showLoading ? 'loading' : 'init'),
          imageStatus = _l[0],
          setImageStatus = _l[1];

      var _m = useMountedState(''),
          wrapClass = _m[0],
          setWrapClass = _m[1];

      var _o = useMountedState(false),
          staticRetrying = _o[0],
          setStaticRetrying = _o[1];

      var imageRef = React.useRef(null);
      var imageDomRef = React.useRef(null);
      var wrapRef = React.useRef(null);
      var retryCountRef = React.useRef(0);
      var loadingImageRef = React.useRef(null);
      var hasLoadedRef = React.useRef(false);
      var isPreview = Boolean(fit.indexOf('preview') >= 0);
      var actualBoxWidth = boxWidth || windowWidth;
      var actualBoxHeight = boxHeight || windowHeight;
      var validStatus = status === undefined ? imageStatus : status;
      var attrs = React.useMemo(function () {
        var imageStyle = {};

        if (!isPreview) {
          imageStyle.objectFit = fit;
          imageStyle.objectPosition = position;
        }

        return {
          alt: alt,
          src: forceHttps ? src.replace('http://', 'https://') : src,
          className: "image-content" + (bordered ? ' bordered' : '') + " " + system,
          style: imageStyle
        };
      }, [alt, bordered, fit, forceHttps, isPreview, position, radius, src, system]);

      function retry() {
        loadImage(true);
      }

      React.useImperativeHandle(ref, function () {
        return {
          dom: wrapRef.current,
          image: imageDomRef.current,
          retry: retry
        };
      });
      React.useEffect(function () {
        retryCountRef.current = 0;
        loadImage();
      }, [attrs, width, height, showImage, staticLabel]);
      React.useEffect(function () {
        var _a; // 当使用img标签时，onLoad可能加载完成前已经执行完，此时手动触发一次
        // @en When using the img tag, onLoad may have been executed before loading is complete, and it needs to be triggered manually


        if (staticLabel && !hasLoadedRef.current && ((_a = imageDomRef.current) === null || _a === void 0 ? void 0 : _a.complete)) {
          // 图片有宽高认为正常加载，否则认为加载错误
          // @en If the image has width and height, it is considered to be loaded normally, otherwise it is considered to be a loading error
          if (imageDomRef.current.naturalWidth || imageDomRef.current.naturalHeight) {
            handleImageLoaded(null, imageDomRef.current);
          } else {
            handleStaticImageError(null);
          }
        }
      }, [staticLabel]);

      function changeStatus(newStatus) {
        setImageStatus(newStatus);
        onChange && onChange(newStatus);
      }

      function replaceChild(newChild) {
        var dom = imageRef.current;

        if (!dom) {
          return;
        }

        if (dom.children && dom.children.length) {
          dom.replaceChild(newChild, dom.children[0]);
        } else {
          dom.appendChild(newChild);
        }
      }

      function handleImageLoaded(evt, image) {
        hasLoadedRef.current = true;
        changeStatus('loaded');
        var _a = image.width,
            imageWidth = _a === void 0 ? 0 : _a,
            _b = image.height,
            imageHeight = _b === void 0 ? 0 : _b;
        var extraClass = '';

        if (isPreview) {
          var scale = imageWidth / imageHeight;
          var windowScale = actualBoxWidth / actualBoxHeight;

          if (fit === 'preview-y') {
            if (scale < windowScale) {
              image.style.width = actualBoxWidth + "px";
              image.style.height = actualBoxWidth / scale + "px";
              extraClass = 'preview-overflow-y';
            } else {
              extraClass = 'preview-fit-contain-y';
            }
          } else if (fit === 'preview-x') {
            if (scale > windowScale) {
              image.style.width = actualBoxHeight * scale + "px";
              image.style.height = actualBoxHeight + "px";
              extraClass = 'preview-overflow-x';
            } else {
              extraClass = 'preview-fit-contain-x';
            }
          }
        }

        extraClass && image.classList.add(extraClass);
        setWrapClass(extraClass ? extraClass + "-container" : '');
        onLoad && onLoad(evt, image);
      }

      function loadImage(isFromRetry) {
        // 如果在加载图片前发现上一个图片还没加载完，则抛弃上一个图片的加载
        // @en Abort last image before starting loading new image
        if (loadingImageRef.current) {
          loadingImageRef.current.src = '';
          loadingImageRef.current = null;
        }

        if (!showImage || staticLabel) {
          return;
        }

        changeStatus('loading');
        var image = new Image();
        Object.keys(nativeProps).forEach(function (key) {
          image[key] = nativeProps[key];
        });
        image.className = attrs.className;
        Object.keys(attrs.style).forEach(function (key) {
          image.style[key] = attrs.style[key];
        });

        image.onload = function (evt) {
          loadingImageRef.current = null;
          imageDomRef.current = image;
          handleImageLoaded(evt, image);
          replaceChild(image);
        };

        image.onerror = function (evt) {
          loadingImageRef.current = null;

          if (isFromRetry || retryCountRef.current >= retryTime) {
            changeStatus('error');
            var placeholder = document.createElement('div');
            replaceChild(placeholder);
            onError && onError(evt);
          } else {
            retryCountRef.current += 1;
            onAutoRetry && onAutoRetry(evt);
            loadImage();
          }
        };

        nextTick(function () {
          image.src = attrs.src;
          image.alt = attrs.alt;
          loadingImageRef.current = image;
        });
      }

      function handleStaticImageError(e) {
        var evt = e ? e.nativeEvent : null;

        if (retryCountRef.current >= retryTime) {
          changeStatus('error');
          onError && onError(evt);
        } else {
          retryCountRef.current += 1;
          onAutoRetry && onAutoRetry(evt); // 强制刷新一下<img>使其重新加载
          // @en Force refresh <img> to reload

          setStaticRetrying(true);
          nextTick(function () {
            setStaticRetrying(false);
          });
        }
      }

      function getImageStyle() {
        if (isPreview) {
          var overflow = fit === 'preview-x' ? {
            overflowX: 'auto'
          } : {
            overflowY: 'auto'
          };
          return __assign$2({
            width: actualBoxWidth,
            height: actualBoxHeight
          }, overflow);
        }

        return {
          width: Number(width) || width,
          height: Number(height) || height
        };
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls,
            _b = _a.locale,
            locale = _b === void 0 ? defaultLocale : _b;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-image all-border-box", {
            preview: isPreview
          }, system, wrapClass, className),
          style: __assign$2(__assign$2({}, getImageStyle()), style || {}),
          ref: wrapRef
        }, bottomOverlap !== null ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-content image-bottom-overlap",
          style: {
            borderRadius: radius
          }
        }, bottomOverlap || /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-placeholder"
        })) : null, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls('image-container', validStatus, {
            animate: Boolean(animateDuration),
            'static-label': staticLabel,
            'has-loaded': hasLoadedRef.current
          }),
          style: getStyleWithVendor({
            borderRadius: radius,
            transitionDuration: animateDuration + "ms"
          }),
          onClick: onClick,
          ref: imageRef
        }, staticLabel && showImage && !staticRetrying ? /*#__PURE__*/React__default["default"].createElement("img", __assign$2({}, nativeProps, attrs, {
          ref: imageDomRef,
          onLoad: function onLoad(e) {
            return handleImageLoaded(e.nativeEvent, imageDomRef.current);
          },
          onError: handleStaticImageError
        })) : null), showLoading && validStatus === 'loading' ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-content image-loading-container",
          style: {
            borderRadius: radius
          }
        }, loadingArea || /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-loading"
        }, /*#__PURE__*/React__default["default"].createElement(Loading, {
          type: "circle",
          className: "loading-icon",
          radius: 8.5,
          stroke: 3
        }))) : null, showError && validStatus === 'error' ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-content image-error-container",
          onClick: function onClick(e) {
            e.stopPropagation();
            retry();
          },
          style: {
            borderRadius: radius
          }
        }, errorArea || /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-retry-load"
        }, locale.Image.loadError)) : null, topOverlap ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-content image-top-overlap",
          style: {
            borderRadius: radius
          }
        }, topOverlap) : null);
      });
    });

    function IconUserFill(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-user-fill " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 20 20",
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M12.5 10.833c2.301 0 5 1.786 5 5v2.5c0 .46-.373.834-.833.834H3.333a.833.833 0 01-.833-.834v-2.5c0-3.211 2.699-5 5-5h5zM10 1.25a4.167 4.167 0 110 8.333 4.167 4.167 0 010-8.333z",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    var AvatarGroupContext = /*#__PURE__*/React__default["default"].createContext({
      isGroup: false,
      shape: 'circle',
      size: 'small'
    });
    /**
     * 头像叠层
     * @en Avatar group
     */

    var Group$4 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.style,
          style = _a === void 0 ? {} : _a,
          _b = props.className,
          className = _b === void 0 ? '' : _b,
          _c = props.shape,
          shape = _c === void 0 ? 'circle' : _c,
          _d = props.size,
          size = _d === void 0 ? 'medium' : _d,
          _e = props.zIndexOrder,
          zIndexOrder = _e === void 0 ? 'desc' : _e,
          children = props.children;
      var prefixCls = React.useContext(GlobalContext).prefixCls;
      var childrenArr = React__default["default"].Children.toArray(children);
      var length = childrenArr.length;
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        ref: domRef,
        style: style,
        className: cls(className, prefixCls + "-avatar-group", prefixCls + "-avatar-group-size-" + size, "group-" + size)
      }, /*#__PURE__*/React__default["default"].createElement(AvatarGroupContext.Provider, {
        value: {
          isGroup: true,
          shape: shape,
          size: size
        }
      }, childrenArr.map(function (child, i) {
        var childProps = (child || {}).props;

        var avatarStyle = __assign$2({
          zIndex: zIndexOrder === 'asc' ? i + 1 : length - i
        }, childProps.style);

        return /*#__PURE__*/React__default["default"].cloneElement(child, __assign$2(__assign$2({}, childProps), {
          style: avatarStyle
        }));
      })));
    });

    function componentGenerator$a(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a, _b;

        var prefixCls = React.useContext(GlobalContext).prefixCls;

        var _c = React.useContext(AvatarGroupContext),
            groupShape = _c.shape,
            groupSize = _c.size,
            isGroup = _c.isGroup;

        var _d = props.shape,
            shape = _d === void 0 ? props.shape || (isGroup ? groupShape : 'circle') : _d,
            _e = props.size,
            size = _e === void 0 ? props.size || (isGroup ? groupSize : 'small') : _e,
            src = props.src,
            _f = props.decoration,
            decoration = _f === void 0 ? null : _f,
            _g = props.textAvatar,
            textAvatar = _g === void 0 ? '' : _g,
            _h = props.avatarStyle,
            avatarStyle = _h === void 0 ? {} : _h,
            _j = props.autoFixFontSize,
            autoFixFontSize = _j === void 0 ? true : _j,
            _k = props.autoFixFontOffset,
            autoFixFontOffset = _k === void 0 ? 2 : _k,
            _l = props.avatarName,
            avatarName = _l === void 0 ? '' : _l,
            _m = props.avatarDesc,
            avatarDesc = _m === void 0 ? '' : _m,
            _o = props.children,
            children = _o === void 0 ? null : _o,
            _p = props.renderInfo,
            renderInfo = _p === void 0 ? null : _p,
            _q = props.className,
            className = _q === void 0 ? '' : _q,
            _r = props.style,
            style = _r === void 0 ? {} : _r,
            _s = props.imageProps,
            imageProps = _s === void 0 ? {} : _s,
            defaultOverLap = props.defaultOverLap,
            onClickDecoration = props.onClickDecoration,
            onClick = props.onClick;
        var domRef = React.useRef(null);
        var avatarRef = React.useRef(null);
        var avatarTextRef = React.useRef(null);

        var _t = React.useState(1),
            textScale = _t[0],
            setTextScale = _t[1];

        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        }); // 图片头像
        // @en Picture avatar

        var isImageAvatar = !children && src !== void 0; // 文字头像
        // @en Text avatar

        var isTextAvatar = !children && !isImageAvatar && textAvatar; // 使用默认头像
        // @en Whether to use default avatar

        var useDefaultAvatar = !children && !isImageAvatar && !isTextAvatar;
        React.useEffect(function () {
          getComputedTextScale();
        }, [textAvatar]);
        /**
         * 根据字体元素宽度和头像大小动态调整缩放比例
         * @en Dynamically adjust scaling based on font element width and avatar size
         */

        function getComputedTextScale() {
          var _a, _b;

          if (!isTextAvatar || !autoFixFontSize || !avatarRef || !avatarTextRef) return;
          var _c = (((_a = avatarRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {}).width,
              avatarWidth = _c === void 0 ? 0 : _c;
          var _d = (((_b = avatarTextRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) || {}).width,
              textWidth = _d === void 0 ? 0 : _d;
          if (avatarWidth === 0 || textWidth === 0) return; // 文本节点宽度大于头像元素时进行动态缩放
          // @en Dynamic scaling when the width of the text node is larger than the avatar element

          var maxWidth = avatarWidth - 2 * autoFixFontOffset;

          if (textWidth > maxWidth) {
            var scale = maxWidth / textWidth;
            setTextScale(textScale * scale);
          }
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          ref: domRef,
          style: style,
          className: cls(prefixCls + "-avatar-wrapper", className, size, shape, prefixCls + "-avatar-wrapper-shape-" + shape, (_a = {}, _a[prefixCls + "-avatar-wrapper-with-info " + prefixCls + "-avatar-wrapper-with-info-size-" + size + " with-info"] = Boolean(avatarName), _a)),
          onClick: onClick
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-avatar", prefixCls + "-avatar-size-" + size, size, prefixCls + "-avatar-shape-" + shape, shape, (_b = {}, _b[prefixCls + "-text-avatar " + prefixCls + "-avatar-mode-text"] = isTextAvatar, _b[prefixCls + "-image-avatar " + prefixCls + "-avatar-mode-image"] = isImageAvatar, _b[prefixCls + "-avatar-default-overlap default-overlap"] = useDefaultAvatar, _b)),
          style: avatarStyle,
          ref: avatarRef
        }, children, useDefaultAvatar && (defaultOverLap === void 0 ? /*#__PURE__*/React__default["default"].createElement(IconUserFill, {
          className: prefixCls + "-avatar-default " + prefixCls + "-avatar-default-icon-size-" + size
        }) : defaultOverLap), isImageAvatar && src && /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({}, {
          className: prefixCls + "-avatar-img",
          src: src
        }, imageProps)), isTextAvatar && /*#__PURE__*/React__default["default"].createElement("span", {
          className: prefixCls + "-avatar-text " + prefixCls + "-avatar-text-size-" + size,
          ref: avatarTextRef,
          style: {
            transform: "scale(" + textScale + ")"
          }
        }, textAvatar), decoration && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-avatar-decoration",
          onClick: onClickDecoration
        }, decoration)), renderInfo, !renderInfo && avatarName && /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-avatar-info")
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-avatar-name " + prefixCls + "-avatar-name-size-" + size
        }, avatarName), avatarDesc && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-avatar-desc " + prefixCls + "-avatar-desc-size-" + size
        }, avatarDesc)));
      });
    }
    var Avatar = componentGenerator$a(BaseImage);
    /**
     * 头像展示组件，支持圆形和方形两种形状，支持图片文字头像，支持五种尺寸。
     * @en Avatar component supports two shapes of circle and square, supports pictures or text avatars, with five sizes.
     * @type 信息展示
     * @type_en Data Display
     * @name 头像
     * @name_en Avatar
     */

    var index$n = componentWrapper(Avatar, {
      Group: Group$4
    });

    /**
     * 在右上角展示徽标数字或小红点
     * @en Display the badge number or small red dot in the upper right corner
     * @type 信息展示
     * @type_en Data Display
     * @name 徽标
     * @name_en Badge
     */

    var Badge = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.style,
          style = _b === void 0 ? {} : _b,
          _c = props.visible,
          visible = _c === void 0 ? true : _c,
          text = props.text,
          _d = props.dot,
          dot = _d === void 0 ? false : _d,
          _e = props.maxCount,
          maxCount = _e === void 0 ? 99 : _e,
          _f = props.children,
          children = _f === void 0 ? null : _f,
          _g = props.absolute,
          absolute = _g === void 0 ? false : _g,
          _h = props.bordered,
          bordered = _h === void 0 ? false : _h,
          _j = props.timeout,
          timeout = _j === void 0 ? 300 : _j;
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      function renderInnerBadge(prefix) {
        return dot ? null : /*#__PURE__*/React__default["default"].createElement("span", {
          className: prefix + "-text badge-text"
        }, Number(text) && Number(text) > maxCount ? maxCount + "+" : text);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b;

        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: visible,
          timeout: timeout,
          type: "scale",
          nodeRef: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-badge", className, (_b = {}, _b[prefixCls + "-badge-dot dot"] = dot, _b[prefixCls + "-badge-bordered bordered"] = bordered, _b[prefixCls + "-badge-absolute absolute"] = absolute, _b)),
          style: style,
          ref: domRef
        }, children || renderInnerBadge(prefixCls + "-badge")));
      });
    });

    var formatColorStatus = function formatColorStatus(color) {
      if (!color) return null;
      return typeof color === 'string' ? {
        normal: color,
        active: color,
        disabled: color
      } : color;
    }; // 主要是用来 diff 颜色是否变化，将对象或者字符串的 diff 转换成字符串的 diff
    // @en It is mainly used to judge whether the color has changed, and convert the diff of the object or string into the diff of the string


    var diffColor = function diffColor(color) {
      return color && (typeof color === 'string' ? color : Object.values(color).join('-'));
    }; // 允许传入定制所有颜色，忽略的值会继续走原生的颜色
    // @en Allows to pass in all custom colors, ignored values will continue to use native colors


    var useCustomColor = function useCustomColor(_a) {
      var color = _a.color,
          bgColor = _a.bgColor,
          borderColor = _a.borderColor,
          active = _a.isActive,
          disabled = _a.disabled,
          halfBorder = _a.halfBorder;
      var state = {
        active: active,
        disabled: disabled
      };
      var priority = ['active', 'disabled'];
      var styleConfig = React.useMemo(function () {
        var _a = [color, bgColor, borderColor].map(formatColorStatus),
            fmtColor = _a[0],
            fmtBgColor = _a[1],
            fmtBorderColor = _a[2];

        return {
          color: fmtColor,
          borderColor: fmtBorderColor,
          background: fmtBgColor
        };
      }, [color, bgColor, borderColor].map(diffColor));
      var customColorStyle = React.useMemo(function () {
        var res = {};
        Object.entries(styleConfig).forEach(function (_a) {
          var styleName = _a[0],
              fmtColorConfig = _a[1];

          if (fmtColorConfig) {
            var styleColor_1 = fmtColorConfig.normal;
            priority.forEach(function (key) {
              if (state[key] && fmtColorConfig[key]) {
                styleColor_1 = fmtColorConfig[key];
              }
            });
            res[styleName] = styleColor_1;
          }
        });
        return res;
      }, [styleConfig, active, disabled]);
      var customColorClass = React.useMemo(function () {
        var borderCls = halfBorder ? 'half-border' : '';
        return styleConfig.borderColor ? ['has-custom-border'] : [borderCls];
      }, [styleConfig.borderColor, halfBorder]);
      return {
        customColorStyle: customColorStyle,
        customColorClass: customColorClass
      };
    };

    /**
     * 按钮用于开始一个即时操作。
     * @en Using for starting an immediate action
     * @type 通用
     * @type_en General
     * @name 按钮
     * @name_en Button
     */

    var Button = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a, _b;

      var _c = React.useState(false),
          isActive = _c[0],
          setActive = _c[1];

      var system = useSystem();
      var _d = props.type,
          type = _d === void 0 ? 'primary' : _d,
          _e = props.size,
          size = _e === void 0 ? 'large' : _e,
          _f = props.inline,
          inline = _f === void 0 ? false : _f,
          _g = props.loading,
          loading = _g === void 0 ? false : _g,
          _h = props.disabled,
          disabled = _h === void 0 ? false : _h,
          _j = props.disableWhenLoading,
          disableWhenLoading = _j === void 0 ? true : _j,
          _k = props.shape,
          shape = _k === void 0 ? 'semi' : _k,
          _l = props.halfBorder,
          halfBorder = _l === void 0 ? false : _l,
          icon = props.icon,
          _m = props.showTextWhenLoading,
          showTextWhenLoading = _m === void 0 ? true : _m,
          _o = props.needActive,
          needActive = _o === void 0 ? true : _o,
          _p = props.style,
          style = _p === void 0 ? {} : _p,
          color = props.color,
          bgColor = props.bgColor,
          borderColor = props.borderColor,
          _q = props.className,
          className = _q === void 0 ? '' : _q,
          _r = props.children,
          children = _r === void 0 ? null : _r,
          loadingIcon = props.loadingIcon,
          onClick = props.onClick,
          onClickDisabled = props.onClickDisabled,
          _s = props.coverIconWhenLoading,
          coverIconWhenLoading = _s === void 0 ? true : _s;
      var domRef = React.useRef(null);
      var prefixCls = React.useContext(GlobalContext).prefixCls;
      var prefix = prefixCls + "-button";
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var _t = useCustomColor({
        color: color,
        bgColor: bgColor,
        borderColor: borderColor,
        isActive: isActive,
        disabled: disabled,
        halfBorder: halfBorder
      }),
          customColorClass = _t.customColorClass,
          customColorStyle = _t.customColorStyle;

      var handleTouchStart = function handleTouchStart() {
        if (needActive && !disabled && !loading) {
          setActive(true);
        }
      };

      var handleTouchEnd = function handleTouchEnd() {
        setActive(false);
      };

      var renderIcon = function renderIcon() {
        if (coverIconWhenLoading) {
          return loading ? null : icon;
        }

        return icon;
      };

      return /*#__PURE__*/React__default["default"].createElement("button", {
        type: "button",
        ref: domRef,
        style: __assign$2(__assign$2({}, customColorStyle), style),
        className: cls.apply(void 0, __spreadArrays$1([prefix, prefix + "-type-" + type + " type-" + type, prefix + "-size-" + size + " " + prefix + "-size-" + size + "-is-" + shape + " size-" + size, className, "is-" + shape, system, (_a = {}, _a[prefix + "-inline inline"] = inline, _a[prefix + "-type-" + type + "-disabled disabled"] = disabled, _a.loading = loading, _a[prefix + "-type-" + type + "-active active"] = isActive, _a)], customColorClass)),
        onTouchStart: handleTouchStart,
        onTouchEnd: handleTouchEnd,
        onTouchCancel: handleTouchEnd,
        onClick: disabled || loading && disableWhenLoading ? onClickDisabled : onClick
      }, icon || loading ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefix + "-icon btn-icon"
      }, renderIcon(), loading && (loadingIcon === void 0 ? /*#__PURE__*/React__default["default"].createElement(Loading, {
        className: prefix + "-loading-icon loading-icon",
        radius: 6,
        type: "circle"
      }) : loadingIcon)) : null, (!loading || loading && showTextWhenLoading) && children ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix + "-text", prefix + "-text-" + system, 'btn-text', (_b = {}, _b[prefix + "-text-has-icon has-icon"] = loading || icon, _b))
      }, children) : null);
    });

    /**
     * 轮播组件，支持自定义轮播索引样式及滑块宽度。**需要注意的是，如果正使用`fastclick`，需要为 touchstart 的 target 添加`needsclick`类**（<a href="https://github.com/ftlabs/fastclick#ignore-certain-elements-with-needsclick" target="_blank">详情戳这里</a>），以规避`fastclick`逻辑与组件内部的手势冲突。（如果使用了`list`属性则无需额外添加）
     * @en Carousel component, supports custom carousel index style and slider width. **Note that if you are using `fastclick`, you need to add a `needsclick` class to the touchstart target ** (<a href="https://github.com/ftlabs/fastclick#ignore-certain-elements- with-needsclick" target="_blank">click here for details</a>) to avoid `fastclick` logic conflicts with gestures inside the component. (no need to add if `list` is set)
     * @type 信息展示
     * @type_en Data Display
     * @name 轮播图
     * @name_en Carousel
     */

    var Carousel = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          wrapStyle = props.wrapStyle,
          style = props.style,
          children = props.children,
          _a = props.list,
          list = _a === void 0 ? [] : _a,
          _b = props.animateDuration,
          animateDuration = _b === void 0 ? 500 : _b,
          _c = props.animateDurationSlide,
          animateDurationSlide = _c === void 0 ? 300 : _c,
          _d = props.loop,
          loop = _d === void 0 ? true : _d,
          _e = props.autoPlay,
          autoPlay = _e === void 0 ? true : _e,
          _f = props.autoPlayDirection,
          autoPlayDirection = _f === void 0 ? 'normal' : _f,
          _g = props.swipeable,
          swipeable = _g === void 0 ? true : _g,
          _h = props.stayDuration,
          stayDuration = _h === void 0 ? 4000 : _h,
          boxWidth = props.boxWidth,
          boxHeight = props.boxHeight,
          baseBoxWidth = props.baseBoxWidth,
          baseBoxHeight = props.baseBoxHeight,
          _j = props.width,
          width = _j === void 0 ? 0 : _j,
          height = props.height,
          _k = props.initialIndex,
          initialIndex = _k === void 0 ? 0 : _k,
          renderIndicator = props.renderIndicator,
          _l = props.indicatorPos,
          indicatorPos = _l === void 0 ? 'center' : _l,
          _m = props.indicatorVerticalPos,
          indicatorVerticalPos = _m === void 0 ? 'left' : _m,
          indicatorOutside = props.indicatorOutside,
          _o = props.showIndicator,
          showIndicator = _o === void 0 ? true : _o,
          _p = props.hideSingleIndicator,
          hideSingleIndicator = _p === void 0 ? true : _p,
          _q = props.indicatorType,
          indicatorType = _q === void 0 ? 'square' : _q,
          _r = props.indicatorClass,
          indicatorClass = _r === void 0 ? '' : _r,
          indicatorInverse = props.indicatorInverse,
          _s = props.spaceBetween,
          spaceBetween = _s === void 0 ? 0 : _s,
          _t = props.offsetBetween,
          offsetBetween = _t === void 0 ? 0 : _t,
          currentIndex = props.currentIndex,
          _u = props.autoHeight,
          autoHeight = _u === void 0 ? false : _u,
          _v = props.percentToChange,
          percentToChange = _v === void 0 ? 0.3 : _v,
          _w = props.distanceToChange,
          distanceToChange = _w === void 0 ? 10 : _w,
          _x = props.speedToChange,
          speedToChange = _x === void 0 ? 100 : _x,
          vertical = props.vertical,
          lazyloadCount = props.lazyloadCount,
          _y = props.inactiveScale,
          inactiveScale = _y === void 0 ? 1 : _y,
          _z = props.stopPropagation,
          stopPropagation = _z === void 0 ? true : _z,
          _0 = props.fakeItem,
          fakeItem = _0 === void 0 ? false : _0,
          _1 = props.allowEndBlank,
          allowEndBlank = _1 === void 0 ? false : _1,
          _2 = props.bounceWhenNoLoop,
          bounceWhenNoLoop = _2 === void 0 ? false : _2,
          _3 = props.bounceDampRate,
          bounceDampRate = _3 === void 0 ? 3 : _3,
          _4 = props.iOSVisibleOptimize,
          iOSVisibleOptimize = _4 === void 0 ? true : _4,
          distanceProcessor = props.distanceProcessor,
          getInnerScrollContainer = props.getInnerScrollContainer,
          onChange = props.onChange,
          onAfterChange = props.onAfterChange,
          onTouchStart = props.onTouchStart,
          onTouchMove = props.onTouchMove,
          onTouchEnd = props.onTouchEnd,
          onTransitionStart = props.onTransitionStart,
          onTransitionEnd = props.onTransitionEnd,
          onDistanceChange = props.onDistanceChange,
          _5 = props.stopTouchThreshold,
          stopTouchThreshold = _5 === void 0 ? 0 : _5,
          onTouchStopped = props.onTouchStopped,
          onPageVisibleChange = props.onPageVisibleChange;
      var useRtl = React.useContext(GlobalContext).useRtl;
      var horizontalUseRtl = !vertical && useRtl;
      var domRef = React.useRef(null);
      var wrapRef = React.useRef(null);
      var innerRef = React.useRef(null);
      var itemsRef = React.useRef([]);
      var fakeWrapRef = React.useRef(null);
      var timerRef = React.useRef(null);
      var movedChildRef = React.useRef(-1);
      var touchStartTimeRef = React.useRef(0);
      var touchStartedRef = React.useRef(false);
      var touchMovedRef = React.useRef(false);

      var _6 = React.useState(baseBoxWidth || 0),
          wrapWidth = _6[0],
          setWrapWidth = _6[1];

      var _7 = React.useState(baseBoxHeight || 0),
          wrapHeight = _7[0],
          setWrapHeight = _7[1];

      var touchStartXRef = React.useRef(0);
      var touchStartYRef = React.useRef(0);
      var scrollingRef = React.useRef(null);
      var touchStoppedRef = React.useRef(false);
      var bouncingRef = React.useRef(false);

      var _8 = React.useState('auto'),
          currentItemHeight = _8[0],
          setCurrentItemHeight = _8[1];

      var _9 = useRefState(false),
          posAdjusting = _9[0],
          posAdjustingRef = _9[1],
          setPosAdjusting = _9[2];

      var _10 = useRefState(0),
          distance = _10[0],
          distanceRef = _10[1],
          setDistance = _10[2];

      var _11 = React.useState(true),
          isAutoJump = _11[0],
          setIsAutoJump = _11[1];

      var _12 = useRefState(currentIndex !== void 0 ? currentIndex : initialIndex),
          index = _12[0],
          indexRef = _12[1],
          setIndex = _12[2];

      var _13 = useRefState([]),
          transforms = _13[0],
          transformsRef = _13[1],
          setTransforms = _13[2];

      var _14 = useRefState((autoPlayDirection === 'reverse' || horizontalUseRtl) && autoPlay ? 'right' : 'left'),
          direction = _14[0],
          directionRef = _14[1],
          setStateDirection = _14[2];

      var lastDirectionRef = React.useRef('');
      var lastShownIndexRef = React.useRef(-1);

      var _15 = getAllChildren(),
          allChildren = _15.allChildren,
          fakeTwoChildren = _15.fakeTwoChildren;

      var total = allChildren.length;
      var shownTotal = fakeTwoChildren ? 2 : total;
      var indicatorArr = React.useMemo(function () {
        var arr = [];

        for (var i = 0; i < shownTotal; i += 1) {
          arr.push(i);
        }

        return arr;
      }, [shownTotal]);
      var rtlRatio = horizontalUseRtl ? -1 : 1;
      var leftDirec = horizontalUseRtl ? 'right' : 'left';
      var rightDirec = horizontalUseRtl ? 'left' : 'right';
      var leftOffset = typeof offsetBetween === 'number' ? offsetBetween : offsetBetween.left || 0;
      var rightOffset = typeof offsetBetween === 'number' ? offsetBetween : offsetBetween.right || 0;
      var wrapSize = vertical ? wrapHeight : wrapWidth;
      var childWidth = (width || wrapWidth) - spaceBetween - (leftOffset + rightOffset);
      var childHeight = (height || wrapHeight) - spaceBetween - (leftOffset + rightOffset);
      var childSize = vertical ? childHeight : childWidth;
      var noLoop = !loop || !vertical && Boolean(width) || vertical && Boolean(height) || total < 2 || (leftOffset > 0 || rightOffset > 0) && !fakeItem;
      var shownIndex = getShownIndex(index);
      var dynamicAnimateDuration = getDynamicDuration(isAutoJump);
      var cubic = isAutoJump ? 'auto' : 'slide';
      var indexFixed = currentIndex !== void 0;
      var needTouchEvent = swipeable && !indexFixed && childSize > 0;
      var userSetBoxWidth = boxWidth || baseBoxWidth;
      var userSetBoxHeight = boxHeight || baseBoxHeight;
      var noInterval = noLoop || !autoPlay || indexFixed || childSize <= 0;
      var inactiveValidScale = React.useMemo(function () {
        return Math.max(0, Math.min(inactiveScale, 1));
      }, [inactiveScale]);

      var _16 = React.useState([]),
          fakeIndexes = _16[0],
          setFakeIndexes = _16[1];

      var system = useSystem(); // 开启自动循环时iOS会有渲染问题需要强刷dom，但不需要autoPlay的不用强刷，这里判断下
      // @en When the automatic loop is turned on, there will be rendering problems in iOS. Need to brush the dom, but if you don't need autoPlay, don't need to brush.

      var needRefreshDom = !noInterval && system === 'ios' && iOSVisibleOptimize;
      var setDirection = React.useCallback(function (newDirec) {
        setStateDirection(function (direc) {
          lastDirectionRef.current = direc;
          return newDirec;
        });
      }, []);
      var wrapSizeRef = useLatestRef(wrapSize);
      var updateDataRef = useLatestRef(updateData);
      var setPlayIntervalRef = useLatestRef(setPlayInterval);
      var handleTouchStart = React.useCallback(function (e) {
        if (onTouchStart && onTouchStart(e, shownTotal, getShownIndex(indexRef.current))) {
          return;
        }

        if (posAdjustingRef.current) {
          return;
        }

        touchStartedRef.current = true;
        touchMovedRef.current = false;
        clear();
        var evt = e.touches[0];
        touchStartXRef.current = evt.clientX || 0;
        touchStartYRef.current = evt.clientY || 0;
        scrollingRef.current = null;
        touchStoppedRef.current = false;
        setPosAdjusting(false);
        touchStartTimeRef.current = new Date().getTime();
      }, [shownTotal, onTouchStart]);
      var triggerTouchStopped = React.useCallback(function (posDis) {
        var needStop = Math.abs(posDis) > stopTouchThreshold;

        if (!touchStoppedRef.current && needStop) {
          onTouchStopped && onTouchStopped(posDis >= 0 ? -1 : 1);
        }

        touchStoppedRef.current = needStop;
      }, [stopTouchThreshold, onTouchStopped]);
      var handleTouchMove = React.useCallback(function (e) {
        if (onTouchMove && onTouchMove(e, shownTotal, getShownIndex(indexRef.current))) {
          return;
        }

        stopPropagation && e.stopPropagation();

        if (!touchStartedRef.current || posAdjustingRef.current) {
          e.cancelable && e.preventDefault();
          return;
        }

        touchMovedRef.current = true;
        var evt = e.changedTouches[0];
        var touchMoveX = Math.max(0, evt.clientX || 0);
        var touchMoveY = evt.clientY || 0;
        var posDisX = touchMoveX - touchStartXRef.current;
        var posDisY = touchMoveY - touchStartYRef.current;
        var absDisX = Math.abs(posDisX);
        var absDisY = Math.abs(posDisY);
        var originDis = vertical ? posDisY : posDisX;

        var processor = distanceProcessor || function (dis, size, child) {
          return child * (dis / size);
        };

        var posDis = processor(originDis, wrapSizeRef.current, childSize);

        if (total < 2) {
          triggerTouchStopped(posDis);
          return;
        }

        if (scrollingRef.current === null) {
          scrollingRef.current = vertical ? absDisY < absDisX : absDisX < absDisY;
        } // 如果是在滚动页面则禁用轮播图手势
        // @en Disable carousel gestures if scrolling


        if (scrollingRef.current) {
          setDistance(0); // bugfix: 未触发横滑就不触发touchend逻辑，且这个场景不需要触发onTouchStopped，因此直接设置touchStoppedRef
          // @en bugfix: The touchend event will not be triggered if the horizontal swipe is not triggered, and this scene does not need to trigger onTouchStopped.

          touchStoppedRef.current = true; // 不会触发jumpTo，但touchstart时clear了，所以要手动设置一次interval
          // @en JumpTo will not be triggered, but it is cleared in touchstart event, so need to manually set interval once

          setPlayIntervalRef.current();
          return;
        }

        setDirection(posDis >= 0 ? 'right' : 'left');
        var comparedPos = posDis * rtlRatio;

        if (noLoop && (indexRef.current === 0 && comparedPos > 0 || indexRef.current === total - 1 && comparedPos < 0)) {
          triggerTouchStopped(posDis);

          if (bounceWhenNoLoop && bounceDampRate) {
            e.cancelable && e.preventDefault();
            bouncingRef.current = true;
            setDistance(posDis / bounceDampRate);
          } else {
            setDistance(0);
          }

          return;
        }

        e.cancelable && e.preventDefault();
        touchStoppedRef.current = false;
        var maxDis = childSize;
        setDistance(posDis > 0 ? Math.min(maxDis, posDis) : Math.max(-1 * maxDis, posDis));
      }, [shownTotal, noLoop, vertical, childSize, stopPropagation, bounceWhenNoLoop, bounceDampRate, horizontalUseRtl, onTouchMove, triggerTouchStopped]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          wrap: wrapRef.current,
          items: itemsRef.current,
          noLoop: noLoop,
          updateData: updateData,
          changeIndex: changeIndex
        };
      }, [updateData, changeIndex]);
      useListenResize(updateData, [updateData]);
      useSwiperInnerScroll(getInnerScrollContainer);
      var updateWhenVisible = React.useCallback(function () {
        fakeWrapRef.current && (fakeWrapRef.current.style.display = 'none');
        wrapRef.current && (wrapRef.current.style.display = ''); // 部分情况下页面隐藏后容器宽度变成0，因此页面返回后需重新取一次容器尺寸
        // @en In some cases, the width of the container becomes 0 after the page is invisible, so the container size needs to be resized after the page is visible.

        updateDataRef.current();
      }, []);
      var updateWhenInvisible = React.useCallback(function () {
        clear();

        if (wrapRef.current && fakeWrapRef.current) {
          fakeWrapRef.current.style.height = (wrapRef.current.offsetHeight || 0) + "px";
          fakeWrapRef.current.style.display = 'block';
          wrapRef.current.style.display = 'none';
        }
      }, []);
      React.useEffect(function () {
        if (onPageVisibleChange) {
          return onPageVisibleChange(updateWhenVisible, updateWhenInvisible);
        } // ios 在页面隐藏后返回时会有dom结构正确但渲染错乱的情况，因此在页面隐藏时先用占位符，返回后重新渲染一次dom
        // @en In iOS, When the page is invisible, the DOM will be correct but the rendering is disordered. So use a placeholder when the page is invisible, and re-render the DOM after it is visible.


        var update = function update() {
          if (document.visibilityState === 'visible') {
            updateWhenVisible();
          } else {
            updateWhenInvisible();
          }
        };

        document.addEventListener('visibilitychange', update);
        return function () {
          document.removeEventListener('visibilitychange', update);
        };
      }, [onPageVisibleChange]);
      React.useEffect(function () {
        if (distanceToChange > 0 && distanceToChange < 1) {
          console.warn("[Carousel Props Warning] The value of the prop `distanceToChange` is too small(" + distanceToChange + "). Do you meant to use the prop `percentToChange`?");
        }
      }, [distanceToChange]);
      React.useEffect(function () {
        if (vertical && !boxHeight) {
          console.warn('[Carousel Rendering Warning] When the prop `vertical` is specified and the prop `boxHeight` is not specified, you need to set a fixed `height` style for the outermost element.');
        }
      }, [vertical, boxHeight]);
      React.useEffect(function () {
        if (wrapRef.current && needTouchEvent) {
          wrapRef.current.addEventListener('touchstart', handleTouchStart);
          wrapRef.current.addEventListener('touchmove', handleTouchMove);
        }

        return function () {
          if (wrapRef.current && needTouchEvent) {
            wrapRef.current.removeEventListener('touchstart', handleTouchStart);
            wrapRef.current.removeEventListener('touchmove', handleTouchMove);
          }
        };
      }, [handleTouchStart, handleTouchMove, needTouchEvent]);
      React.useEffect(function () {
        // 布局改变时重新计算
        // @en Recalculate when layout changes
        updateData();
        return function () {
          clear();
        };
      }, [userSetBoxWidth, userSetBoxHeight, childWidth, childHeight, stayDuration, noInterval, autoPlayDirection]);
      useUpdateEffect(function () {
        if (currentIndex !== void 0) {
          jumpTo(currentIndex);
        }
      }, [currentIndex]);
      useUpdateEffect(function () {
        onDistanceChange && onDistanceChange(distance, wrapSize, index);
      }, [distance, wrapSize, index]);
      React.useEffect(function () {
        // children改变，索引超出新children范围时兼容
        // @en When children change, it needs to be compatible when the index exceeds the range of the new children
        if (allChildren.length && indexRef.current >= allChildren.length) {
          jumpTo(allChildren.length - 1, true, true);
        } else if (indexRef.current < 0) {
          jumpTo(0, true, true);
        }
      }, [allChildren.length]);
      React.useEffect(function () {
        // bugfix: 修复ios轮播循环时闪动问题
        // @en bugfix: Fix the flickering problem when the carousel loops in iOS
        if (isAutoJump && posAdjusting) {
          setTimeout(function () {
            getFakeChild();
          }, 100);
        } else {
          getFakeChild();
        }
      }, [index, direction, childSize, total, horizontalUseRtl]);
      React.useEffect(function () {
        nextTick(function () {
          updateLayoutData();
        });
      }, [shownIndex, autoHeight, allChildren]);
      useUpdateEffect(function () {
        if (typeof onChange === 'function') {
          onChange(shownIndex);
        }
      }, [shownIndex]);
      React.useEffect(function () {
        return function () {
          lastShownIndexRef.current = shownIndex;
        };
      }, [shownIndex]);
      React.useEffect(function () {
        if (!fakeItem || posAdjusting) {
          return;
        }

        setCurrentFakeIndex();
      }, [posAdjusting, index, direction, total, childSize, horizontalUseRtl]);

      function getShownIndex(nowIndex) {
        var validIndex = nowIndex === total ? 0 : nowIndex;
        var shownInd = nowIndex === -1 ? total - 1 : validIndex;
        return fakeTwoChildren ? shownInd % 2 : shownInd;
      }

      function getDynamicDuration(autoJump) {
        return autoJump ? animateDuration : animateDurationSlide;
      }

      function setCurrentHeight() {
        if (!innerRef.current || !autoHeight || vertical) {
          return;
        }

        var allItemDom = itemsRef.current;
        var nowIndex = getShownIndex(indexRef.current);
        var currentHeight = (allItemDom[nowIndex] || {}).offsetHeight || 'auto';
        setCurrentItemHeight(currentHeight);
      }

      function getAllChildren() {
        var allChild = [];
        var fakeTwo = false;

        if (list && list.length) {
          var actualList = list;

          if (list.length === 2 && fakeItem) {
            fakeTwo = true;
            actualList = list.concat(list);
          }

          allChild = actualList.map(function (item, i) {
            return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("img", {
              key: i,
              className: "carousel-item-img needsclick",
              src: item.src,
              alt: "",
              onClick: item.onClick
            }), item.text ? /*#__PURE__*/React__default["default"].createElement("div", {
              className: "carousel-item-text"
            }, item.text) : null);
          });
        } else if (children && Object.prototype.toString.call(children) === '[object Array]') {
          allChild = children;

          if (allChild.length === 2 && fakeItem) {
            fakeTwo = true;
            allChild = __spreadArrays$1(allChild, allChild);
          }
        } else {
          allChild = children ? [children] : [];
        }

        return {
          allChildren: allChild,
          fakeTwoChildren: fakeTwo
        };
      }

      function getDefaultDirection() {
        var nowIndex = indexRef.current;

        if (nowIndex === total - 1) {
          return horizontalUseRtl ? 'right' : 'left';
        }

        if (nowIndex === 0) {
          return horizontalUseRtl ? 'left' : 'right';
        }

        return '';
      }

      function changeIndex(newIndex, rightNow, userSetDirec) {
        if (posAdjustingRef.current) {
          return;
        }

        if (userSetDirec) {
          // rtl 模式取反
          var direcMap = {
            left: leftDirec,
            right: rightDirec
          };
          var direc_1 = direcMap[userSetDirec];
          setDirection(direc_1);
          nextTick(function () {
            jumpTo(newIndex, true, rightNow, direc_1);
          });
        } else {
          jumpTo(newIndex, true, rightNow);
        }
      }

      function jumpTo(newIndex, autoJump, rightNow, direc) {
        if (autoJump === void 0) {
          autoJump = true;
        }

        var oldIndex = getShownIndex(indexRef.current);
        var changedIndex = newIndex !== oldIndex ? getShownIndex(newIndex) : -1;

        if (direc) {
          setDirection(direc);
        } else if (autoJump) {
          setDirection(autoPlayDirection === 'reverse' || horizontalUseRtl ? 'right' : 'left');
        } else if (newIndex === indexRef.current) {
          setDirection(distanceRef.current > 0 ? 'right' : 'left');
        } else {
          setDirection('');
        }

        setPosAdjusting(true);
        setIsAutoJump(autoJump);
        setDistance(0);
        setIndex(newIndex);
        touchStartTimeRef.current = 0;
        onTransitionStart && onTransitionStart();
        setTimeout(function () {
          setPosAdjusting(false);
          nextTick(function () {
            setDirection(getDefaultDirection());
            var newTransform = transformsRef.current.slice();
            var transChanged = false;

            if (newIndex === -1 && movedChildRef.current >= 0) {
              newTransform[movedChildRef.current] = 0;
              transChanged = true;
              setIndex(total - 1);
            } else if (newIndex === total && movedChildRef.current >= 0) {
              newTransform[movedChildRef.current] = 0;
              transChanged = true;
              setIndex(0);
            }

            transChanged && setTransforms(newTransform);
            setIsAutoJump(true);
            onTransitionEnd && onTransitionEnd();

            if (changedIndex >= 0) {
              onAfterChange && onAfterChange(changedIndex, oldIndex);
            }

            nextTick(function () {
              setPlayIntervalRef.current();
            });
          });
        }, rightNow ? 0 : getDynamicDuration(autoJump));
        autoJump && setDirection('');
      }

      function setPlayInterval() {
        clear();

        if (noInterval) {
          return;
        }

        timerRef.current = delayTimeout(function () {
          jumpTo(autoPlayDirection === 'reverse' ? indexRef.current - 1 : indexRef.current + 1);
        }, stayDuration);
      }

      function updateLayoutData() {
        if (wrapRef.current) {
          setWrapWidth(wrapRef.current.offsetWidth);
          setWrapHeight(wrapRef.current.offsetHeight);
        }

        setCurrentHeight();
      }

      function updateData() {
        updateLayoutData();
        setPlayIntervalRef.current();
      }

      function clear() {
        if (timerRef.current) {
          clearTimeout(timerRef.current);
          timerRef.current = null;
        }
      }

      function getFakeChild() {
        if (noLoop) {
          return;
        }

        var nowIndex = indexRef.current;
        var newTransform = transformsRef.current.slice();
        var dis = Math.max(0, childSize);
        allChildren.forEach(function (_, childIndex) {
          if (nowIndex === 0 && directionRef.current === rightDirec && childIndex === total - 1) {
            movedChildRef.current = childIndex;
            newTransform[childIndex] = -1 * total * dis * rtlRatio;
          } else if (nowIndex === total - 1 && directionRef.current === leftDirec && childIndex === 0) {
            movedChildRef.current = childIndex;
            newTransform[childIndex] = total * dis * rtlRatio;
          } else if (nowIndex >= 0 && nowIndex < total) {
            newTransform[childIndex] = 0;
          }
        });
        setTransforms(newTransform);
      }

      function delayTimeout(callback, timeout) {
        return setTimeout(callback, timeout);
      }

      function handleTouchEnd(e) {
        if (!needTouchEvent) {
          return;
        }

        if (onTouchEnd && onTouchEnd(e.nativeEvent, shownTotal, getShownIndex(indexRef.current))) {
          return;
        }

        stopPropagation && e.stopPropagation();

        if (bouncingRef.current) {
          bouncingRef.current = false;
          jumpTo(index, false);
          return;
        }

        if (!touchStartedRef.current || !touchMovedRef.current || posAdjustingRef.current || touchStoppedRef.current) {
          return;
        }

        touchStartedRef.current = false;
        touchMovedRef.current = false;
        var touchEndTime = new Date().getTime();
        var dis = Math.abs(distance);
        var speed = dis / (touchEndTime - touchStartTimeRef.current) * 1000;
        var maxSlice = childSize * percentToChange;
        var needJump = dis > maxSlice && dis > distanceToChange || speed > speedToChange;
        var comparedDis = distance * rtlRatio;

        if (comparedDis > 0 && needJump) {
          jumpTo(index - 1, false);
        } else if (comparedDis < 0 && needJump) {
          jumpTo(index + 1, false);
        } else {
          jumpTo(index, false);
        }
      }

      function getSlideTransitionStyle() {
        return {
          transitionProperty: posAdjusting ? 'transform' : 'none',
          transitionDuration: posAdjusting ? dynamicAnimateDuration + "ms" : '0ms'
        };
      }

      function getInnerStyle() {
        var transitionStyle = getStyleWithVendor(getSlideTransitionStyle());
        var innerSize = childSize * total;
        var dis = index * childSize * -1 * rtlRatio + distance + rtlRatio * leftOffset;
        var min = childSize > 0 ? leftOffset : 0;
        var max = allowEndBlank ? dis * rtlRatio : -1 * innerSize + wrapSize - rightOffset;
        var minTransform = horizontalUseRtl ? -1 * max : min;
        var maxTransform = horizontalUseRtl ? -1 * min : max;
        var comparedDis = rtlRatio * distance;
        var noLoopDis = bounceWhenNoLoop && (index === 0 && comparedDis > 0 || index === total - 1 && comparedDis < 0) ? Math.min(minTransform + distance, Math.max(maxTransform + distance, dis)) : Math.min(minTransform, Math.max(maxTransform, dis)); // noLoop时需要在最后也露出spaceBetween的空白，所以当滑到最后一个时transform向左移动相应宽度
        // @en When noLoop is used, the blank space of spaceBetween needs to be exposed at the end, so when sliding to the last one, the transform value moves to the left by the corresponding width

        var translateDis = noLoop ? noLoopDis - (total > 1 && index === total - 1 ? spaceBetween : 0) * rtlRatio : dis;
        var initTranslateDis = -1 * index * 100; // bugfix: prop `style` did not match in ssr

        var transStr = childSize > 0 ? "" + translateDis + (translateDis ? 'px' : '') : "" + initTranslateDis + (initTranslateDis ? '%' : '');

        if (vertical) {
          var translateStyle_1 = getStyleWithVendor({
            transform: "translateY(" + transStr + ") translateZ(0)"
          });
          return __assign$2(__assign$2(__assign$2({}, transitionStyle), translateStyle_1), {
            width: '100%'
          });
        }

        var translateStyle = getStyleWithVendor({
          transform: "translateX(" + transStr + ") translateZ(0)"
        });
        return __assign$2(__assign$2({
          width: Math.max(0, innerSize) || 'auto',
          height: height
        }, transitionStyle), translateStyle);
      }

      function getCarouselStyle() {
        if (vertical) {
          return __assign$2({
            height: userSetBoxHeight
          }, style || {});
        }

        var heightStyle = currentItemHeight && currentItemHeight !== 'auto' ? {
          height: currentItemHeight
        } : {};
        return __assign$2(__assign$2({
          width: userSetBoxWidth
        }, heightStyle), style || {});
      } // 当最前或最后的滑块通过transform手动被放置到最后或最前时，在展示层可以认为是第total个或第-1个模块
      // @en When the front or last slider is manually placed to the rear or the front through transform, it can be considered as the total or -1 module in the display layer


      function getShownChildIndex(curIndex) {
        var childIndex = curIndex;

        if (transforms[childIndex] * rtlRatio > 0) {
          childIndex = total;
        } else if (transforms[childIndex] * rtlRatio < 0) {
          childIndex = -1;
        }

        return childIndex;
      } // 当两侧有露出内容时，为了循环衔接上需要fake前后的dom来做视觉填充
      // @en When there is exposed content on both sides, it is necessary to fake the front and rear dom to make visual filling in order to connect circularly.


      function setCurrentFakeIndex() {
        var newIndexes = fakeIndexes.slice();

        if (childSize <= 0) {
          if (index === 0) {
            newIndexes[0] = {
              index: total - 1,
              side: 'left'
            };
          }

          if (index === total - 1) {
            newIndexes[2] = {
              index: 0,
              side: 'right'
            };
          }

          setFakeIndexes(newIndexes);
          return;
        }

        if (index === 1 && direction === rightDirec || index === 0 && direction !== rightDirec) {
          newIndexes[0] = {
            index: total - 1,
            side: 'left'
          };
        }

        if (index === 0 && direction === rightDirec || index === -1) {
          newIndexes[1] = {
            index: total - 2,
            side: 'left'
          };
        }

        if (index === total - 2 && direction === leftDirec || index === total - 1 && direction !== leftDirec) {
          newIndexes[2] = {
            index: 0,
            side: 'right'
          };
        }

        if (index === total - 1 && direction === leftDirec || index === total) {
          newIndexes[3] = {
            index: 1,
            side: 'right'
          };
        }

        setFakeIndexes(newIndexes);
      }

      function getItemTranslateStyle(childIndex, ratio) {
        var dis = index - childIndex;
        var prefix = dis > 0 ? 1 : -1;
        var transPercent = 1 - inactiveValidScale;
        var ratioWithRtl = ratio * rtlRatio;
        var trans = 0;

        if (Math.abs(dis) > 1) {
          trans = (prefix * (Math.abs(dis) - 1) - ratioWithRtl) * transPercent * rtlRatio;
        } else if (dis === -1 && ratioWithRtl > 0 || dis === 1 && ratioWithRtl < 0) {
          trans = -1 * ratio * transPercent;
        }

        return "translate" + (vertical ? 'Y' : 'X') + "(" + trans * 100 + "%)";
      }

      function getItemScaleStyle(childIndex, ratio) {
        var originScale = inactiveValidScale; // active滑块前后两侧的滑块，根据滑动距离等比放大
        // @en The front and rear sides of the active slider, and zoom in proportionally according to the sliding distance

        if (childIndex === index - 1 && direction === rightDirec || childIndex === index + 1 && direction === leftDirec) {
          return originScale + (1 - originScale) * Math.abs(ratio);
        } // active的滑块，根据滑动距离等比缩小
        // @en The active slider, zoom out proportionally according to the sliding distance


        if (childIndex === index) {
          return 1 - (1 - originScale) * Math.abs(ratio);
        } // 其他保持inactiveScale即可
        // @en Others remain inactiveScale


        return originScale;
      }

      function getItemOriginStyle(childIndex) {
        var origin = 0.5;
        var dis = childIndex - index;

        if (dis === 0) {
          // 当前active的卡片，随滑动方向切换origin
          // @en The currently active card, switch origin with the sliding direction
          origin = direction === 'right' || direction === '' && lastDirectionRef.current === 'left' ? 0 : 1;
        } else if (dis <= -1) {
          // 当前active之前的卡片，origin均靠最右
          // @en The cards in front of the currently active card, the origin is on the far right
          origin = horizontalUseRtl ? 0 : 1;
        } else if (dis >= 1) {
          // 当前active之后的卡片，origin均靠最左
          // @en The cards after the currently active card, the origin is on the far left
          origin = horizontalUseRtl ? 1 : 0;
        }

        var originStr = origin * 100 + "%";
        return vertical ? "center " + originStr : originStr + " center";
      }

      function getItemInnerStyle(curIndex) {
        var transitionStyle = getSlideTransitionStyle();
        var childIndex = getShownChildIndex(curIndex);
        var ratio = distance / childSize || 0; // 有放大效果的item，随着distance变化而变化scale和transform-origin
        // @en Item with magnification effect, scale and transform-origin change with distance
        // transform效果与fake dom时item的transform需隔离，且scale后会影响item的padding展示
        // @en The transform effect of the item needs to be isolated from the fake dom, and the padding display of the item will be affected after scale.
        // 因此需要缩放时多包裹一层item-inner，单独处理缩放逻辑
        // @en Therefore, need to wrap an additional layer of item-inner when scaling, and handle the scaling logic separately

        var scale = getItemScaleStyle(childIndex, ratio);
        var transformStyle = {
          transform: getItemTranslateStyle(childIndex, ratio) + " scale(" + scale + ")",
          transformOrigin: getItemOriginStyle(childIndex)
        };
        return getStyleWithVendor(__assign$2(__assign$2({}, transitionStyle), transformStyle));
      }

      function getItemFakeStyle(childIndex) {
        var _a, _b, _c;

        var styleMap = {
          leftDirec: vertical ? 'top' : leftDirec,
          rightDirec: vertical ? 'bottom' : rightDirec,
          otherDirec: vertical ? 'left' : 'top',
          trans: vertical ? 'Y' : 'X'
        };
        return __assign$2((_a = {
          position: 'absolute'
        }, _a[styleMap.otherDirec] = 0, _a), childIndex >= 0 ? (_b = {}, _b[styleMap.leftDirec] = childSize > 0 ? '100%' : total * 100 + "%", _b.transform = "translate" + styleMap.trans + "(" + (childIndex - total) * rtlRatio * 100 + "%)", _b) : (_c = {}, _c[styleMap.rightDirec] = '100%', _c.transform = "translate" + styleMap.trans + "(" + (childIndex + 1) * rtlRatio * 100 + "%)", _c));
      }

      function getItemStyle(childIndex, isFake) {
        var _a, _b;

        var initialStartSpace = spaceBetween + leftOffset;
        var initialEndSpace = spaceBetween + rightOffset;
        var initalSize = vertical ? userSetBoxHeight : '100%';
        var horizontalPaddingStart = horizontalUseRtl ? 'paddingRight' : 'paddingLeft';
        var horizontalPaddingEnd = horizontalUseRtl ? 'paddingLeft' : 'paddingRight';
        var styleMap = {
          size: vertical ? 'height' : 'width',
          paddingStart: vertical ? 'paddingTop' : horizontalPaddingStart,
          paddingEnd: vertical ? 'paddingBottom' : horizontalPaddingEnd,
          translate: vertical ? 'translateY' : 'translateX'
        }; // bugfix: item 为半透明状态下 fakeItem 和普通 item 重叠露馅问题
        // @en bugfix: Solve the problem of overlapping fakeItem and the normal item when item is translucent

        var transformStyle = isFake ? {
          visibility: childIndex === total && transforms[0] > 0 || childIndex === -1 && transforms[total - 1] < 0 ? 'hidden' : 'initial'
        } : {
          transform: styleMap.translate + "(" + (transforms[childIndex] || 0) + "px)"
        }; // childSize <= 0 说明是未全部加载完成的首屏情况 做一下特殊处理
        // @en childSize <= 0 indicates that the first screen is not fully loaded, so do some special treatment

        var layoutStyle = childSize > 0 ? (_a = {}, _a[styleMap.size] = childSize - spaceBetween, _a[styleMap.paddingStart] = spaceBetween, _a.boxSizing = 'content-box', _a) : (_b = {}, _b[styleMap.size] = initalSize, _b[styleMap.paddingStart] = initialStartSpace, _b[styleMap.paddingEnd] = initialEndSpace, _b.boxSizing = 'border-box', _b.transform = styleMap.translate + "(" + (childIndex === index ? 0 : (index - childIndex) * (spaceBetween + leftOffset + rightOffset)) + "px)", _b);
        var fakeStyle = isFake ? getItemFakeStyle(childIndex) : {};

        if (isFake && childSize < 0) {
          delete fakeStyle.transform;
        }

        return getStyleWithVendor(__assign$2(__assign$2(__assign$2({}, transformStyle), layoutStyle), fakeStyle));
      }

      function renderChild(child, childIndex, prefix) {
        // 兼容线上逻辑，不需要切换放大效果的，不包裹item-inner
        // @en No need to switch the magnification effect, do not wrap item-inner
        return inactiveValidScale === 1 ? child : /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-item-inner",
          style: getItemInnerStyle(childIndex)
        }, child);
      }

      function renderFakeItem(prefix, fakeIndex, side) {
        if (!fakeItem || fakeIndex === void 0) {
          return null;
        }

        var posIndex = side === 'left' ? fakeIndex - total : fakeIndex + total;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: "" + fakeIndex + posIndex,
          "data-fake-index": fakeIndex,
          "data-index": posIndex,
          className: cls(prefix + "-item carousel-item fake-item fake-" + side, {
            vertical: vertical
          }),
          style: getItemStyle(posIndex, true)
        }, renderChild(allChildren[fakeIndex], posIndex, prefix));
      }

      function renderAllFakeItem(prefix) {
        return fakeIndexes.map(function (fakeIndex) {
          return renderFakeItem(prefix, fakeIndex.index, fakeIndex.side);
        });
      }

      function renderCarousel(_a) {
        var _b;

        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-carousel";
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-wrap", className),
          style: wrapStyle,
          ref: domRef
        }, needRefreshDom ? /*#__PURE__*/React__default["default"].createElement("div", {
          key: "fake-carousel",
          className: prefix + " wrap-placeholder",
          ref: fakeWrapRef
        }) : null, /*#__PURE__*/React__default["default"].createElement("div", {
          key: "carousel",
          className: prefix,
          onTouchEnd: handleTouchEnd,
          onTouchCancel: handleTouchEnd,
          ref: wrapRef,
          style: getCarouselStyle()
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-inner " + cubic, {
            vertical: vertical
          }),
          style: getInnerStyle(),
          ref: innerRef
        }, allChildren.map(function (child, childIndex) {
          var inView = lazyloadCount !== void 0 ? childIndex >= index - lazyloadCount && childIndex <= index + lazyloadCount : true;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            key: childIndex,
            className: cls(prefix + "-item carousel-item normal-item", {
              active: childIndex === index,
              vertical: vertical,
              'ssr-float': childSize <= 0 && childIndex !== index
            }),
            style: getItemStyle(childIndex),
            ref: function ref(childRef) {
              itemsRef.current[childIndex] = childRef;
            }
          }, inView || transforms[childIndex] ? renderChild(child, childIndex, prefix) : null);
        }), renderAllFakeItem(prefix))), showIndicator && (total > 1 || !hideSingleIndicator) ? /*#__PURE__*/React__default["default"].createElement("div", {
          key: "carousel-indicator",
          className: cls(prefix + "-indicator pos-" + indicatorPos + " " + prefix + "-indicator-" + (vertical ? 'vertical' : 'horizontal'), (_b = {}, _b["vertical ver-pos-" + indicatorVerticalPos] = vertical, _b), {
            inverse: indicatorInverse === void 0 ? indicatorOutside : indicatorInverse
          }, {
            outside: indicatorOutside
          })
        }, renderIndicator ? renderIndicator(shownIndex, shownTotal, lastShownIndexRef.current) : indicatorArr.map(function (_, i) {
          return /*#__PURE__*/React__default["default"].createElement("i", {
            key: i,
            className: cls('indicator', "type-" + indicatorType, indicatorClass, {
              active: i === shownIndex
            })
          });
        })) : null);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderCarousel);
    });

    var GroupContext = /*#__PURE__*/React__default["default"].createContext({
      isFromGroup: false
    });
    function componentGenerator$9(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.className,
            className = _a === void 0 ? '' : _a,
            style = props.style,
            header = props.header,
            footer = props.footer,
            _b = props.bordered,
            bordered = _b === void 0 ? true : _b,
            options = props.options,
            children = props.children,
            onClick = props.onClick;
        var domRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });

        function handleClick(e) {
          onClick && onClick(e);
        }

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var prefixCls = _a.prefixCls;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-cell-group", 'all-border-box', className),
            ref: domRef,
            onClick: handleClick,
            style: style
          }, header ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-group-header"
          }, header) : null, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls('cell-group-body', {
              bordered: bordered
            })
          }, /*#__PURE__*/React__default["default"].createElement(GroupContext.Provider, {
            value: {
              isFromGroup: true
            }
          }, children, options && options.map(function (option, index) {
            return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
              key: index
            }, option));
          }))), footer ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-group-footer"
          }, footer) : null);
        });
      });
    }

    function Arrow$1() {
      return /*#__PURE__*/React__default["default"].createElement("svg", {
        viewBox: "0 0 8 14",
        fill: "none",
        className: "arrow-icon-svg"
      }, /*#__PURE__*/React__default["default"].createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M0.594858 1.24219C0.399596 1.43745 0.399596 1.75403 0.594859 1.94929L5.59905 6.95348L0.636039 11.9165C0.440776 12.1118 0.440776 12.4283 0.636038 12.6236L0.989592 12.9771C1.18485 13.1724 1.50144 13.1724 1.6967 12.9771L7.35355 7.3203C7.5296 7.14425 7.54692 6.86959 7.40553 6.67413C7.38216 6.62774 7.35111 6.58423 7.31237 6.54549L1.65552 0.888634C1.46026 0.693372 1.14367 0.693372 0.948411 0.888634L0.594858 1.24219Z"
      }));
    }

    var Cell = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          icon = props.icon,
          label = props.label,
          desc = props.desc,
          text = props.text,
          children = props.children,
          showArrow = props.showArrow,
          arrow = props.arrow,
          prepend = props.prepend,
          append = props.append,
          _b = props.bordered,
          bordered = _b === void 0 ? true : _b,
          _onClick = props.onClick;
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(GroupContext.Consumer, null, function (_a) {
          var isFromGroup = _a.isFromGroup;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-cell", 'all-border-box', {
              'without-group': !isFromGroup
            }, {
              bordered: bordered
            }, className),
            style: style,
            ref: domRef,
            onClick: function onClick(e) {
              return _onClick && _onClick(e);
            }
          }, prepend, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-cell-inner", {
              'has-desc': desc
            })
          }, icon ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-label-icon"
          }, icon) : null, label || desc ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-label"
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-title"
          }, label), desc ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-desc"
          }, desc) : null) : null, /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-content " + (label || desc ? 'has-label' : '')
          }, text ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-text"
          }, text) : null, children), showArrow ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "cell-arrow-icon"
          }, arrow || /*#__PURE__*/React__default["default"].createElement(Arrow$1, null)) : null), append);
        });
      });
    });

    var Group$3 = componentGenerator$9(Cell);
    /**
     * 单元格组件，含单元格及单元格组合，常用于设置项、表单等。
     * @en Cell, including cells and cell group, are often used to set items, forms, etc.
     * @type 信息展示
     * @type_en Data Display
     * @name 单元格
     * @name_en Cell
     */

    var index$m = componentWrapper(Cell, {
      Group: Group$3
    });

    var CheckboxGroupContext = /*#__PURE__*/React__default["default"].createContext({
      isGroup: false,
      shape: 'circle',
      layout: 'inline',
      disabled: false,
      value: [],
      onChange: function onChange() {}
    });
    function componentGenerator$8(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.style,
            style = _a === void 0 ? {} : _a,
            _b = props.className,
            className = _b === void 0 ? '' : _b,
            _c = props.defaultValue,
            defaultValue = _c === void 0 ? [] : _c,
            _d = props.disabled,
            disabled = _d === void 0 ? false : _d,
            _e = props.shape,
            shape = _e === void 0 ? 'circle' : _e,
            options = props.options,
            icons = props.icons,
            onChange = props.onChange,
            value = props.value,
            _f = props.children,
            children = _f === void 0 ? null : _f,
            _g = props.layout,
            layout = _g === void 0 ? 'inline' : _g,
            _h = props.min,
            min = _h === void 0 ? 0 : _h,
            _j = props.max,
            max = _j === void 0 ? 0 : _j;

        var _k = React.useState(value || defaultValue),
            groupValue = _k[0],
            setGroupValue = _k[1];

        var domRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });
        React.useEffect(function () {
          value !== void 0 && setGroupValue(value);
        }, [value]);
        /**
         * 切换checkbox状态回调
         * @en callback when toggling checkbox state
         */

        var handleChange = function handleChange(checked, val) {
          if (!checked && groupValue.length <= min || max && checked && groupValue.length >= max) return;
          var newGroupValue = checked ? __spreadArrays$1(groupValue, [val]) : groupValue.filter(function (item) {
            return item !== val;
          });
          onChange && onChange(newGroupValue);

          if (value === void 0) {
            setGroupValue(newGroupValue);
          }
        };

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var prefixCls = _a.prefixCls;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            ref: domRef,
            style: style,
            className: cls(className, prefixCls + "-checkbox-group")
          }, /*#__PURE__*/React__default["default"].createElement(CheckboxGroupContext.Provider, {
            value: {
              isGroup: true,
              shape: shape,
              layout: layout,
              disabled: disabled,
              icons: icons,
              value: groupValue,
              onChange: handleChange
            }
          }, children, !children && options && options.map(function (option) {
            return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
              key: option.value
            }, option));
          })));
        });
      });
    }

    function IconCircleUnchecked(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-circle-unchecked " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M10 19c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9zm0-17c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8z",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    function IconCircleChecked(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-circle-checked " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M10 1c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm4.9 6.3L10 13.2s0 .1-.1.1l-.6.7c-.1.1-.2.1-.3.2-.1 0-.3 0-.4-.1l-.6-.7-.1-.1-2.8-2.4c-.2-.2-.2-.5-.1-.7l.6-.7c.2-.2.5-.2.7-.1l2.5 2.1L13.5 6c.2-.2.5-.2.7-.1l.7.6c.1.3.2.6 0 .8z",
          fillRule: "evenodd",
          clipRule: "evenodd",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    function IconCircleDisabled(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-circle-disabled " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 20 20",
          fill: useCurrentColor ? 'currentColor' : '#F7F8FA',
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M18.375 10a8.375 8.375 0 11-16.75 0 8.375 8.375 0 0116.75 0z",
          stroke: "#E5E6EB",
          strokeWidth: "1.25"
        }));
      });
    }

    function IconSquareChecked(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-square-checked " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M16 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1.1 5.3L10 13.2s0 .1-.1.1l-.6.7c-.1.1-.2.1-.3.2-.1 0-.3 0-.4-.1l-.6-.7-.1-.1-2.8-2.4c-.2-.2-.2-.5-.1-.7l.6-.7c.2-.2.5-.2.7-.1l2.5 2.1L13.5 6c.2-.2.5-.2.7-.1l.7.6c.1.3.2.6 0 .8z",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    function IconSquareUnchecked(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-square-unchecked " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M15.6 18H4.4C3.1 18 2 16.9 2 15.6V4.4C2 3.1 3.1 2 4.4 2h11.2C16.9 2 18 3.1 18 4.4v11.2c0 1.3-1.1 2.4-2.4 2.4zM4.4 3C3.6 3 3 3.6 3 4.4v11.2c0 .8.6 1.4 1.4 1.4h11.2c.8 0 1.4-.6 1.4-1.4V4.4c0-.8-.6-1.4-1.4-1.4H4.4z"
        }));
      });
    }

    function IconSquareDisabled(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-square-disabled " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 20 20",
          fill: useCurrentColor ? 'currentColor' : '#F7F8FA'
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          stroke: "#E5E6EB",
          d: "M15.6 2.5H4.4c-1 0-1.9.8-1.9 1.9v11.2c0 1 .8 1.9 1.9 1.9h11.2c1 0 1.9-.8 1.9-1.9V4.4c0-1.1-.8-1.9-1.9-1.9z"
        }));
      });
    }

    /**
     * 图标状态枚举
     * @en Icon status enum
     *  */
    var IconStatus;

    (function (IconStatus) {
      /**
       * 未选中
       * @en unselected
       */
      IconStatus["NORMAL"] = "normal";
      /**
       * 禁用态
       * @en disabled
       */

      IconStatus["DISABLED"] = "disabled";
      /**
       * 选中态
       * @en active
       */

      IconStatus["ACTIVE"] = "active";
      /**
       * 禁用选中态
       * @en active but disabled
       */

      IconStatus["ACTIVE_DISABLED"] = "activeDisabled";
    })(IconStatus || (IconStatus = {}));

    var useMergeProps = function useMergeProps(props, groupContext) {
      var _a = React.useContext(groupContext),
          disabled = _a.disabled,
          shape = _a.shape,
          layout = _a.layout,
          icons = _a.icons,
          value = _a.value,
          _onChange = _a.onChange,
          isGroup = _a.isGroup;

      if (!isGroup) return props;
      return __assign$2(__assign$2({
        disabled: disabled,
        shape: shape,
        layout: layout,
        icons: icons
      }, props), {
        // 在Group内checkbox的选中状态由GroupValue决定
        // The checked state of the checkbox in the Group is determined by the GroupValue
        checked: value.indexOf(props.value) > -1,
        onChange: function onChange(checked, val, e) {
          _onChange(checked, val, e);

          props.onChange && props.onChange(checked, val, e);
        }
      });
    };

    var getDefaultIcon = function getDefaultIcon(shape, status) {
      var defaultIcons = {
        circle: {
          normal: /*#__PURE__*/React__default["default"].createElement(IconCircleUnchecked, null),
          active: /*#__PURE__*/React__default["default"].createElement(IconCircleChecked, null),
          disabled: /*#__PURE__*/React__default["default"].createElement(IconCircleDisabled, null),
          activeDisabled: /*#__PURE__*/React__default["default"].createElement(IconCircleChecked, null)
        },
        square: {
          normal: /*#__PURE__*/React__default["default"].createElement(IconSquareUnchecked, null),
          active: /*#__PURE__*/React__default["default"].createElement(IconSquareChecked, null),
          disabled: /*#__PURE__*/React__default["default"].createElement(IconSquareDisabled, null),
          activeDisabled: /*#__PURE__*/React__default["default"].createElement(IconSquareChecked, null)
        },
        justify: {
          normal: /*#__PURE__*/React__default["default"].createElement(IconCircleUnchecked, null),
          active: /*#__PURE__*/React__default["default"].createElement(IconCircleChecked, null),
          disabled: /*#__PURE__*/React__default["default"].createElement(IconCircleDisabled, null),
          activeDisabled: /*#__PURE__*/React__default["default"].createElement(IconCircleChecked, null)
        }
      };
      return defaultIcons[shape][status];
    };

    var Checkbox$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = useMergeProps(props, CheckboxGroupContext),
          _b = _a.style,
          style = _b === void 0 ? {} : _b,
          _c = _a.className,
          className = _c === void 0 ? '' : _c,
          _d = _a.children,
          children = _d === void 0 ? null : _d,
          _e = _a.label,
          label = _e === void 0 ? '' : _e,
          _f = _a.layout,
          layout = _f === void 0 ? 'inline' : _f,
          value = _a.value,
          _g = _a.defaultCheck,
          defaultCheck = _g === void 0 ? false : _g,
          _h = _a.disabled,
          disabled = _h === void 0 ? false : _h,
          _j = _a.shape,
          shape = _j === void 0 ? 'circle' : _j,
          icons = _a.icons,
          _k = _a.isRadio,
          isRadio = _k === void 0 ? false : _k,
          propsChecked = _a.checked,
          onChange = _a.onChange;

      var _l = React.useState(propsChecked === void 0 ? defaultCheck : propsChecked),
          checked = _l[0],
          setChecked = _l[1];

      var componentName = React.useState(isRadio ? 'radio' : 'checkbox')[0];
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      React.useEffect(function () {
        if (propsChecked !== void 0) setChecked(Boolean(propsChecked));
      }, [propsChecked]);
      /**
       * 获得图标样式
       * @en Get icon style
       */

      var getStatus = function getStatus() {
        if (checked) {
          if (disabled) return IconStatus.ACTIVE_DISABLED;
          return IconStatus.ACTIVE;
        }

        if (disabled) return IconStatus.DISABLED;
        return IconStatus.NORMAL;
      };
      /**
       * 计算展示的icon
       * @en Calculate the displayed icon
       */


      var renderIcon = function renderIcon() {
        var Icon;
        var iconKey = getStatus();

        if (icons && icons[iconKey] !== void 0) {
          Icon = icons[iconKey];
        } else if (icons === null) {
          Icon = null;
        } else {
          Icon = layout === 'justify' ? getDefaultIcon('justify', iconKey) : getDefaultIcon(shape, iconKey);
        }

        return Icon ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(componentName + "-icon", {
            disabled: disabled,
            checked: checked
          })
        }, Icon) : null;
      };
      /**
       * 处理点击事件
       * @en Handling click events
       */


      var onClick = function onClick(e) {
        if (disabled) return; // Radio组件不支持点击取消选中
        // @en Radio component does not support click to uncheck

        if (isRadio && checked) return;
        onChange && onChange(!checked, value, e);

        if (propsChecked === void 0) {
          setChecked(!checked);
        }
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "checkbox",
          "aria-checked": checked,
          "aria-disabled": disabled,
          tabIndex: 0,
          ref: domRef,
          style: style,
          className: cls(className, prefixCls + "-" + componentName, "shape-" + shape, {
            disabled: disabled
          }, layout),
          onClick: onClick
        }, layout !== 'justify' && renderIcon(), /*#__PURE__*/React__default["default"].createElement("div", {
          className: componentName + "-text"
        }, children || label || value), layout === 'justify' && renderIcon());
      });
    });

    /**
     * 复选项组
     * @en Checkbox group
     * @displayName CheckboxGroup
     */

    var Group$2 = componentWrapper(componentGenerator$8(Checkbox$1), 'CheckboxGroup');
    /**
     * 复选框，可用状态下点击切换选择，支持禁用，支持复选项组。
     * @en Checkbox, click to switch selection when available, support disabled status, support checkbox group.
     * @name 复选框
     * @name_en Checkbox
     * @type 数据录入
     * @type_en Data Entry
     * @displayName Checkbox
     */

    var Checkbox = componentWrapper(Checkbox$1, 'Checkbox', {
      Group: Group$2
    });

    /**
     * 环形进度条组件，以圆环形式表示百分比进度
     * @en Annular progress bar component, representing percentage progress in the form of a circle
     * @type 反馈
     * @type_en Feedback
     * @name 环形进度条
     * @name_en CircleProgress
     */

    var CircleProgress = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.size,
          size = _a === void 0 ? 'default' : _a;
      var _b = props.className,
          className = _b === void 0 ? '' : _b,
          style = props.style,
          _c = props.percentPosition,
          percentPosition = _c === void 0 ? 'center' : _c,
          _d = props.showPercent,
          showPercent = _d === void 0 ? size !== 'mini' : _d,
          renderPercent = props.renderPercent,
          trackColor = props.trackColor,
          progressColor = props.progressColor,
          _e = props.disabled,
          disabled = _e === void 0 ? false : _e,
          _f = props.trackStroke,
          trackStroke = _f === void 0 ? size === 'mini' ? 4 : 2 : _f,
          _g = props.progressStroke,
          progressStroke = _g === void 0 ? 4 : _g,
          progressColorStart = props.progressColorStart,
          progressColorEnd = props.progressColorEnd,
          _h = props.duration,
          duration = _h === void 0 ? 300 : _h,
          _j = props.step,
          step = _j === void 0 ? 1 : _j,
          _k = props.clockwise,
          clockwise = _k === void 0 ? false : _k,
          _l = props.radius,
          radius = _l === void 0 ? size === 'mini' ? 9 : 30 : _l,
          _m = props.filleted,
          filleted = _m === void 0 ? size !== 'mini' : _m,
          _o = props.mountedTransition,
          mountedTransition = _o === void 0 ? true : _o,
          _p = props.mountedBezier,
          mountedBezier = _p === void 0 ? [0.34, 0.69, 0.1, 1] : _p,
          _q = props.svgKey,
          userSetSvgKey = _q === void 0 ? '' : _q;
      var domRef = React.useRef(null);
      var maxStroke = Math.max(progressStroke, trackStroke);
      var circlePos = maxStroke + radius;
      var circleSize = (radius + maxStroke) * 2;
      var circleLen = 2 * Math.PI * radius;
      var percentage = Math.min(100, Math.max(props.percentage, 0));
      var svgKey = useGenSvgKey(userSetSvgKey).svgKey;
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      var isRenderNormal = !(Boolean(progressColorStart) && Boolean(progressColorEnd));

      var _r = useProgress(mountedTransition, percentage, duration, mountedBezier, step),
          currentPercentage = _r[0],
          transitionControl = _r[1];

      var color = React.useMemo(function () {
        if (isRenderNormal) {
          if (progressColorStart) {
            return progressColorStart;
          }

          if (progressColorEnd) {
            return progressColorEnd;
          }

          return progressColor;
        }
      }, [progressColorStart, progressColorEnd, progressColor]);

      function renderNormalProgress() {
        return /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos,
          cy: circlePos,
          r: radius,
          strokeWidth: progressStroke,
          className: cls('color', {
            disabled: disabled
          }),
          strokeDashoffset: circleLen - currentPercentage / 100 * circleLen || 0,
          strokeDasharray: circleLen,
          strokeLinecap: filleted ? 'round' : 'square',
          style: getStyleWithVendor({
            transition: transitionControl ? "stroke-dashoffset " + duration / 1000 + "s linear" : '',
            stroke: color
          }),
          fill: "none"
        });
      }

      function renderLinearGradient() {
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("defs", null, /*#__PURE__*/React__default["default"].createElement("linearGradient", {
          id: svgKey + "-grad-circle-progress",
          x1: "0%",
          y1: "0%",
          x2: "0%",
          y2: "100%"
        }, /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "0%",
          style: {
            stopColor: progressColorEnd
          },
          className: "linear-gradient-end"
        }), /*#__PURE__*/React__default["default"].createElement("stop", {
          offset: "100%",
          style: {
            stopColor: progressColorStart
          },
          className: "linear-gradient-start"
        }))), /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos,
          cy: circlePos,
          r: radius,
          strokeDashoffset: circleLen - currentPercentage / 100 * circleLen || 0,
          strokeDasharray: circleLen,
          strokeWidth: progressStroke,
          strokeLinecap: filleted ? 'round' : 'square',
          style: getStyleWithVendor({
            transition: transitionControl ? "stroke-dashoffset " + duration / 1000 + "s linear" : ''
          }),
          className: cls({
            disabled: disabled
          }),
          stroke: "url(#" + svgKey + "-grad-circle-progress)",
          fill: "none"
        }));
      }

      function renderProgress() {
        return isRenderNormal ? renderNormalProgress() : renderLinearGradient();
      }

      function renderCircleProgress(_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "progressbar",
          "aria-valuemin": 0,
          "aria-valuemax": 100,
          "aria-valuenow": percentage,
          className: cls(prefixCls + "-circle-progress", disabled ? prefixCls + "-circle-progress-disabled" : '', "" + className),
          style: __assign$2({
            width: circleSize,
            height: circleSize
          }, style),
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("svg", {
          style: getStyleWithVendor({
            transform: "rotateY(" + (clockwise ? 180 : 0) + "deg) rotateZ(-90deg)"
          }),
          viewBox: "0 0 " + circleSize + " " + circleSize
        }, /*#__PURE__*/React__default["default"].createElement("circle", {
          cx: circlePos,
          cy: circlePos,
          r: radius,
          style: {
            stroke: trackColor
          },
          className: "" + (size === 'mini' ? 'mini' : 'track-color'),
          strokeWidth: trackStroke,
          fill: "none"
        }), renderProgress()), showPercent ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-circle-progress-text", "" + (isRenderNormal ? 'color' : 'linear-gradient-text'), prefixCls + "-circle-progress-text-" + percentPosition, {
            disabled: disabled
          }),
          style: {
            color: color
          }
        }, renderPercent !== void 0 ? renderPercent(currentPercentage) : currentPercentage + "%") : null);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderCircleProgress);
    });

    function IconArrowDown(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-arrow-down " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          fill: useCurrentColor ? 'currentColor' : '#000',
          d: "M512 676.864l346.944-346.965a21.333 21.333 0 0130.187 0l30.165 30.186a21.333 21.333 0 010 30.166L542.166 767.36a42.667 42.667 0 01-60.331 0L104.704 390.25a21.333 21.333 0 010-30.165l30.165-30.186a21.333 21.333 0 0130.187 0L512 676.864z"
        }));
      });
    }

    var defaultContextKey = '__COLLAPSE_CONTEXT__';
    var allContexts = {};
    function getCollapseContext(key) {
      if (!allContexts[key]) {
        allContexts[key] = /*#__PURE__*/React__default["default"].createContext({
          isGroup: false,
          value: [],
          onCollapse: function onCollapse() {}
        });
      }

      return allContexts[key];
    }
    var CollapseKeyContext = /*#__PURE__*/React__default["default"].createContext({
      key: defaultContextKey
    });

    var Collapse = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.header,
          header = _a === void 0 ? '' : _a,
          icon = props.icon,
          _b = props.hideIcon,
          hideIcon = _b === void 0 ? false : _b,
          _c = props.disabled,
          disabled = _c === void 0 ? false : _c,
          _d = props.content,
          content = _d === void 0 ? null : _d,
          _e = props.defaultActive,
          defaultActive = _e === void 0 ? false : _e,
          _f = props.value,
          value = _f === void 0 ? '' : _f,
          active = props.active,
          animationTimeout = props.animationTimeout,
          animationFunction = props.animationFunction,
          _g = props.className,
          className = _g === void 0 ? '' : _g,
          _h = props.style,
          style = _h === void 0 ? {} : _h;

      var _j = React.useState(defaultActive),
          innerActive = _j[0],
          setInnerActive = _j[1];

      var _k = useRefState(active === void 0 ? innerActive : active),
          itemActive = _k[0],
          itemActiveRef = _k[1],
          setItemActive = _k[2];

      var contentHeightRef = React.useRef(0);
      var collapseHeaderRef = React.useRef(null);
      var domRef = React.useRef(null);
      var contentWrapRef = React.useRef(null);
      var contentRef = React.useRef(null);
      var groupKey = React.useContext(CollapseKeyContext).key;
      var CollapseContext = allContexts[groupKey] || {};
      var groupContext = React.useContext(CollapseContext) || {};

      var _l = useSameRefState(false),
          opened = _l[0],
          openedRef = _l[1],
          setOpened = _l[2];

      React.useEffect(function () {
        var show = false; // 优先级： group > children
        // @en Priority: group > children

        if (groupContext.isGroup) {
          if (active !== void 0) {
            show = active;
          }

          if (groupContext.value) show = groupContext.value.includes(value);
        } else {
          show = itemActive;
        }

        setOpened(show);
      }, [value, active, itemActive, groupContext.isGroup, groupContext.value]);

      var getContentHeight = function getContentHeight() {
        var _a, _b;

        var div = contentRef.current;
        return (_b = (_a = div === null || div === void 0 ? void 0 : div.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
      };

      var resetHeight = function resetHeight(newHeight) {
        if (!contentWrapRef.current) {
          return;
        }

        contentWrapRef.current.style.height = newHeight;
        var transTimeout = convertCssDuration(contentWrapRef.current, 'transitionDuration');
        setTimeout(function () {
          return contentWrapRef.current && (contentWrapRef.current.style.height = openedRef.current ? 'auto' : '0px');
        }, openedRef.current ? transTimeout : 20);
      };

      var toggleOpened = function toggleOpened() {
        var height = getContentHeight();
        var isBeginning = contentHeightRef.current === 0;
        contentHeightRef.current = height;

        if (isBeginning) {
          var initHeight = opened ? 'auto' : '0px';
          contentWrapRef.current && (contentWrapRef.current.style.height = initHeight);
          return;
        }

        resetHeight(height + "px");
      };

      var updateLayout = function updateLayout() {
        if (!contentWrapRef.current) {
          return;
        }

        var height = getContentHeight();
        contentWrapRef.current.style.height = openedRef.current ? contentHeightRef.current + "px" : '0px';
        nextTick(function () {
          contentHeightRef.current = height;
          resetHeight(openedRef.current ? height + "px" : '0px');
        });
      };

      var onCollapse = function onCollapse(val) {
        if (disabled) return;
        props.onCollapse && props.onCollapse(val);

        if (!groupContext.isGroup) {
          setInnerActive(!itemActiveRef.current);
        } else {
          groupContext.onCollapse(value);
        }
      };

      React.useEffect(function () {
        setItemActive(active === void 0 ? innerActive : active);
      }, [active, innerActive]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          head: collapseHeaderRef.current,
          updateLayout: updateLayout
        };
      });
      React.useEffect(function () {
        toggleOpened();
      }, [opened]);
      useUpdateEffect(function () {
        updateLayout();
      }, [content]);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-item", className, {
            disabled: disabled || groupContext.disabled
          }),
          style: style,
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-header"),
          ref: collapseHeaderRef,
          onClick: function onClick() {
            return onCollapse(value);
          }
        }, header, !hideIcon && /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-icon")
        }, icon || /*#__PURE__*/React__default["default"].createElement(IconArrowDown, {
          className: prefixCls + "-collapse-icon-arrow",
          style: {
            transform: "rotate(" + (opened ? '180deg' : '0deg') + ")"
          }
        }))), /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-content"),
          ref: contentWrapRef,
          style: {
            transitionDuration: animationTimeout !== void 0 ? animationTimeout + "ms" : void 0,
            transitionTimingFunction: animationFunction
          }
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-content-container"),
          ref: contentRef
        }, content)));
      });
    });

    function componentGenerator$7(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.items,
            items = _a === void 0 ? [] : _a,
            _b = props.className,
            className = _b === void 0 ? '' : _b,
            _c = props.style,
            style = _c === void 0 ? {} : _c,
            _d = props.defaultActiveItems,
            defaultActiveItems = _d === void 0 ? [] : _d,
            _e = props.useAccordion,
            useAccordion = _e === void 0 ? false : _e,
            _f = props.disabled,
            disabled = _f === void 0 ? false : _f,
            children = props.children,
            groupKey = props.groupKey;

        var _g = React.useState([]),
            innerActiveItems = _g[0],
            setInnerActiveItems = _g[1];

        var _h = React.useState([]),
            activeItems = _h[0],
            setActiveItems = _h[1];
        /** 用于children模式下的active管理 */


        var _j = React.useState([]),
            childActiveItems = _j[0],
            setChildActiveItems = _j[1];

        var contextKey = groupKey || defaultContextKey;
        var CollapseContext = getCollapseContext(contextKey);
        var domRef = React.useRef(null);
        var prefixCls = React.useContext(GlobalContext).prefixCls;

        var formatArray = function formatArray(input) {
          var arr = input;
          return items.map(function (item) {
            return arr.indexOf(item.value) > -1;
          });
        };

        var handleChange = function handleChange(value) {
          if (disabled) return;

          if (props.onCollapse) {
            props.onCollapse(value);
          }

          if (props.activeItems !== void 0) {
            setInnerActiveItems(formatArray(props.activeItems));
            setChildActiveItems(props.activeItems);
            return;
          }

          if (!children) {
            var temp_1 = items.findIndex(function (item) {
              return item.value === value;
            });
            if (temp_1 < 0 || items[temp_1].disabled) return;
            var tempActiveItems = innerActiveItems.map(function (activeItem, index) {
              return index === temp_1 ? !activeItem : !useAccordion && activeItem;
            });
            setInnerActiveItems(tempActiveItems);
          } else {
            var tempValue = childActiveItems.includes(value);
            setChildActiveItems(tempValue ? childActiveItems.filter(function (item) {
              return item !== value;
            }) : useAccordion // 手风琴模式只有一个展开项
            ? [value] : __spreadArrays$1(childActiveItems, [value]));
          }
        };

        React.useEffect(function () {
          setInnerActiveItems(formatArray(defaultActiveItems));
          setChildActiveItems(defaultActiveItems);
        }, []);
        React.useEffect(function () {
          setActiveItems(props.activeItems === void 0 ? innerActiveItems : formatArray(props.activeItems));

          if (children && props.activeItems) {
            setChildActiveItems(props.activeItems);
          }
        }, [props.activeItems, innerActiveItems]);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-collapse-group", className),
          style: style,
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement(CollapseKeyContext.Provider, {
          value: {
            key: contextKey
          }
        }, /*#__PURE__*/React__default["default"].createElement(CollapseContext.Provider, {
          value: {
            isGroup: true,
            onCollapse: handleChange,
            disabled: disabled,
            value: children ? childActiveItems : void 0
          }
        }, children || /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, items.map(function (item, index) {
          var compProps = __assign$2({
            active: activeItems[index],
            disabled: disabled || item.disabled,
            defaultActive: formatArray(defaultActiveItems)[index]
          }, item);

          return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
            key: item.value
          }, compProps));
        })))));
      });
    }
    var Group$1 = componentGenerator$7(Collapse);

    /**
     * 折叠面板组件，支持手风琴模式。
     * @en Collapse supports accordion mode.
     * @type 信息展示
     * @type_en Data Display
     * @name 折叠面板
     * @name_en Collapse
     */

    var index$l = componentWrapper(Collapse, {
      Group: Group$1
    });

    // 定义秒，分，小时，天的转化常量
    // @en Define conversion constants for seconds, minutes, hours, days
    var SECOND = 1000;
    var MINUTE = 60 * SECOND;
    var HOUR = 60 * MINUTE;
    var DAY = 24 * HOUR; // 把毫秒解析成TimeDataType格式
    // @en Parse milliseconds into TimeDataType format

    function parseTime(time) {
      var days = Math.floor(time / DAY);
      var hours = Math.floor(time % DAY / HOUR);
      var minutes = Math.floor(time % HOUR / MINUTE);
      var seconds = Math.floor(time % MINUTE / SECOND);
      var milliseconds = Math.floor(time % SECOND);
      return {
        days: days,
        hours: hours,
        minutes: minutes,
        seconds: seconds,
        milliseconds: milliseconds
      };
    } // 把TimeDataType解析成毫秒
    // @en Parse TimeDataType into milliseconds

    function unParseTime(time) {
      var _a = time.days,
          days = _a === void 0 ? 0 : _a,
          _b = time.hours,
          hours = _b === void 0 ? 0 : _b,
          _c = time.minutes,
          minutes = _c === void 0 ? 0 : _c,
          _d = time.seconds,
          seconds = _d === void 0 ? 0 : _d,
          _e = time.milliseconds,
          milliseconds = _e === void 0 ? 0 : _e;
      return days * DAY + hours * HOUR + minutes * MINUTE + seconds * SECOND + milliseconds;
    } // 判断是否在浏览器中运行
    // @en Determine if it is running in the browser

    var inBrowser = typeof window !== 'undefined'; // 判断根元素
    // @en Determine the root element

    var root = inBrowser ? window : global; // 根据id清除对应的animationFrame
    // @en Clear the corresponding animationFrame according to the id

    function cancelRaf(id) {
      var cancelAnimationFrame = root.cancelAnimationFrame || root.clearTimeout;
      cancelAnimationFrame.call(root, id);
    } // 计算现在时间
    // @en Calculate the current time

    var prev = Date.now(); // requestAnimationFrame不存在时用setTimeout代替，得出id
    // @en When requestAnimationFrame does not exist, use setTimeout instead to get the id

    function rafPolyfill(fn) {
      var curr = Date.now();
      var ms = Math.max(0, 16 - (curr - prev));
      var id = setTimeout(fn, ms);
      prev = curr + ms;
      return id;
    } // 得到animationFrame的id
    // @en Get the id of animationFrame


    function raf(fn) {
      var requestAnimationFrame = root.requestAnimationFrame || rafPolyfill;
      return requestAnimationFrame.call(root, fn);
    } // 补0成需要的格式
    // @en Fill 0 into the required format

    function padZero(num, targetLength) {
      if (targetLength === void 0) {
        targetLength = 2;
      }

      var str = "" + num;

      while (str.length < targetLength) {
        str = "0" + str;
      }

      return str;
    } // 根据传入的格式解析时间成特定格式
    // @en Parse the time into a specific format according to the inputing format

    function parseFormat(formatArg, currentTime) {
      var days = currentTime.days;
      var format = formatArg;
      var hours = currentTime.hours,
          minutes = currentTime.minutes,
          seconds = currentTime.seconds,
          milliseconds = currentTime.milliseconds;

      if (format.includes('D')) {
        format = format.replace('DD', padZero(days)).replace('D', "" + days);
      } else {
        hours += days * 24;
      }

      if (format.includes('H')) {
        format = format.replace('HH', padZero(hours)).replace('H', "" + hours);
      } else {
        minutes += hours * 60;
      }

      if (format.includes('m')) {
        format = format.replace('mm', padZero(minutes)).replace('m', "" + minutes);
      } else {
        seconds += minutes * 60;
      }

      if (format.includes('s')) {
        format = format.replace('ss', padZero(seconds)).replace('s', "" + seconds);
      } else {
        milliseconds += seconds * 1000;
      }

      if (format.includes('S')) {
        var ms = padZero(milliseconds, 3);
        format = format.replace(/S{3}/, ms).replace(/S{2}/, ms.slice(0, 2)).replace(/S{1}/, ms.charAt(0));
      }

      return format;
    }

    var timeoutId = null;
    var rafId = null;
    var taskCount = {
      micro: 0,
      macro: 0
    };
    var taskQueue = {
      micro: [],
      macro: []
    };
    function startTask(type, callback) {
      taskCount[type] += 1;
      taskQueue[type].push({
        id: taskCount[type],
        callback: callback
      }); // 超过1个任务说明定时任务已建，执行时取最新queue即可

      if (taskQueue[type].length <= 1) {
        type === 'micro' ? execMicroTask() : execMacroTask();
      }

      return taskCount[type];
    }
    function execMicroTask() {
      rafId && cancelRaf(rafId);
      rafId = raf(function () {
        execTask('micro');
        taskQueue.micro.length && execMicroTask();
      });
    }
    function execMacroTask() {
      timeoutId && clearTimeout(timeoutId);
      timeoutId = window.setTimeout(function () {
        execTask('macro');
        taskQueue.macro.length && execMacroTask();
      }, 1000);
    }
    function execTask(type) {
      taskQueue[type].forEach(function (item) {
        var needContinue = item.callback();

        if (!needContinue) {
          stopTask(type, item.id);
        }
      });
    }
    function stopTask(type, id) {
      var queue = taskQueue[type];
      var index = queue.findIndex(function (val) {
        return val.id === id;
      });

      if (index >= 0) {
        taskQueue[type].splice(index, 1);
      }
    }

    var useCountDown = function useCountDown(options) {
      var taskIdRef = React.useRef(0);
      var endTimeRef = React.useRef();
      var countingRef = React.useRef();

      var _a = useRefState(options.time),
          remain = _a[0],
          remainRef = _a[1],
          setRemain = _a[2];

      var _b = React.useState(parseTime(options.time)),
          current = _b[0],
          setCurrent = _b[1];

      var taskType = options.millisecond ? 'micro' : 'macro'; // 暂停
      // @en Pause

      var pause = function pause() {
        countingRef.current = false;
        stopTask(taskType, taskIdRef.current);
      }; // 计算当前剩余时间，以毫秒为单位
      // @en Calculate the current remaining time in milliseconds


      var getCurrentRemain = function getCurrentRemain() {
        var leftTime = Math.max(endTimeRef.current - Date.now(), 0);

        if (options.millisecond) {
          return leftTime;
        }

        return Math.round(leftTime / 1000) * 1000;
      };

      var setRemainCallback = function setRemainCallback(value) {
        var _a;

        setRemain(value);
        var time = parseTime(value);

        if (options.onChange && value !== options.time) {
          options.onChange(time, value);
        }

        if (value === 0) {
          setCurrent(time);
          pause();
          (_a = options.onFinish) === null || _a === void 0 ? void 0 : _a.call(options);
        }
      }; // 开启任务
      // @en start tasks


      var tick = function tick() {
        taskIdRef.current = startTask(taskType, function () {
          if (countingRef.current) {
            setRemainCallback(getCurrentRemain());
            return remainRef.current > 0;
          }

          return false;
        });
      }; // 开始
      // @en Start


      var start = function start(reStart) {
        if (reStart === void 0) {
          reStart = false;
        }

        if (!countingRef.current) {
          if (reStart) {
            endTimeRef.current = Date.now() + options.time;
          } else {
            endTimeRef.current = Date.now() + remainRef.current;
          }

          countingRef.current = true;
          tick();
        }
      }; // 重置
      // @en Reset


      var reset = function reset() {
        var totalTime = options.time;
        endTimeRef.current = Date.now() + totalTime;
        pause();
        setRemainCallback(totalTime);

        if (options.autoStart) {
          start(true);
        }
      };

      React.useEffect(function () {
        // ummounted时如果正在运行倒计时则暂停
        // @en Pause if the countdown is running when ummounted
        return function () {
          if (countingRef.current) {
            pause();
          }
        };
      }, []); // 设置自动开始倒计时时自动启动
      // @en Set to start automatically when the countdown starts automatically

      React.useEffect(function () {
        if (options.autoStart) {
          start();
        }
      }, [options.autoStart]); // 倒计时设置变化时重新计时
      // @en Re-time when countdown settings change

      React.useEffect(function () {
        reset();
      }, [options.time]); // remain变化时同步current 即把毫秒转化为TimeDataType类型
      // @en Synchronize current when remain changes, that is, convert milliseconds to TimeDataType

      React.useEffect(function () {
        setCurrent(parseTime(remain));
      }, [remain]);
      return {
        start: start,
        pause: pause,
        reset: reset,
        current: current
      };
    };

    /**
     * 倒计时组件
     * @en Countdown Component
     * @name 倒计时
     * @name_en CountDown
     * @type 信息展示
     * @type_en Data Display
     */

    var CountDown = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.style,
          style = _b === void 0 ? {} : _b,
          _c = props.time,
          time = _c === void 0 ? 0 : _c,
          _d = props.format,
          format = _d === void 0 ? 'HH:mm:ss' : _d,
          _e = props.autoStart,
          autoStart = _e === void 0 ? true : _e,
          _f = props.millisecond,
          millisecond = _f === void 0 ? false : _f,
          onFinish = props.onFinish,
          onChange = props.onChange,
          renderChild = props.renderChild;
      var domRef = React.useRef(null); // 传入倒计时等变量得到开始暂停启动三个方法以及目前所剩时间current(TimeDataType格式)
      // @en get start, pause, reset methods and the current remaining time —— current (TimeDataType format) by inputing variables such as countdown

      var _g = useCountDown({
        time: typeof time === 'number' ? time : unParseTime(time),
        millisecond: millisecond,
        onChange: onChange,
        onFinish: onFinish,
        autoStart: autoStart
      }),
          start = _g.start,
          pause = _g.pause,
          reset = _g.reset,
          current = _g.current; // 导出dom以及start,pause,reset三个方法
      // @en Export dom and three methods of start, pause and reset


      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          start: start,
          pause: pause,
          reset: reset
        };
      });
      var currentStr = React.useMemo(function () {
        return parseFormat(format, current);
      }, [format, current]);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-count-down " + className,
          style: style,
          ref: domRef
        }, renderChild ? renderChild(current) : currentStr);
      });
    });

    function MultiPicker(props) {
      var prefixCls = props.prefixCls,
          onValueChange = props.onValueChange,
          children = props.children,
          itemHeight = props.itemHeight,
          selectedValue = props.selectedValue,
          data = props.data;

      function getCurrentData() {
        return (data || []).map(function (item, itemIndex) {
          var curSelected = selectedValue === null || selectedValue === void 0 ? void 0 : selectedValue[itemIndex];
          var cur = curSelected ? (item || []).find(function (i) {
            return i.value === curSelected;
          }) : undefined;
          return cur || (item === null || item === void 0 ? void 0 : item[0]);
        });
      }

      function onChange(_a) {
        var index = _a.index,
            value = _a.value,
            changedData = _a.changedData,
            callback = _a.callback;
        var newData = getCurrentData().concat();
        newData[index] = changedData;
        var newValue = newData.map(function (d) {
          return d === null || d === void 0 ? void 0 : d.value;
        });
        newValue[index] = value;

        if (callback) {
          callback(newValue, index, newData);
        }
      }

      function _onValueChange(value, index, changedData) {
        onChange({
          index: index,
          value: value,
          callback: onValueChange,
          changedData: changedData
        });
      }

      function renderChild() {
        var curData = getCurrentData();
        var value = curData.map(function (d) {
          return d === null || d === void 0 ? void 0 : d.value;
        });
        return React__default["default"].Children.map(children, function (col, index) {
          return /*#__PURE__*/React__default["default"].cloneElement(col, {
            onValueChange: function onValueChange(val, changedData) {
              return _onValueChange(val, index, changedData);
            },
            selectedValue: value[index]
          });
        });
      }

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-multi",
        style: {
          lineHeight: itemHeight + "px"
        }
      }, renderChild());
    }

    var PickerCell = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var prefixCls = props.prefixCls,
          style = props.style,
          data = props.data,
          clickable = props.clickable,
          itemHeight = props.itemHeight,
          wrapperHeight = props.wrapperHeight,
          selectedValue = props.selectedValue,
          onValueChange = props.onValueChange,
          disabled = props.disabled,
          hideEmptyCols = props.hideEmptyCols,
          _a = props.rows,
          rows = _a === void 0 ? 5 : _a,
          _b = props.touchToStop,
          touchToStop = _b === void 0 ? false : _b;

      var _c = useMountedState(''),
          transitionDuration = _c[0],
          setTransitionDuration = _c[1];

      var _d = React.useState(''),
          bezier = _d[0],
          setBezier = _d[1];

      var _e = useMountedState(0),
          currentIndex = _e[0],
          setCurrentIndex = _e[1];

      var _f = useMountedState(selectedValue),
          currentValue = _f[0],
          setCurrentValue = _f[1]; // 是否开始touch
      // @en whether to start touch


      var _g = useRefState(0),
          transformY = _g[0],
          transformYRef = _g[1],
          setTransformY = _g[2];

      var lastTransformYRef = React.useRef(0);
      var touchStartTimeRef = React.useRef(0);
      var latestCallbackTimer = React.useRef(0);
      var touchStartXRef = React.useRef(0);
      var touchStartYRef = React.useRef(0);
      var touchingRef = React.useRef(false);
      var touchingXRef = React.useRef(null);
      var wrapRef = React.useRef(null);
      var movingStatusRef = React.useRef('normal');
      var rowCount = Math.max(rows % 2 === 0 ? rows + 1 : rows, 3);
      var isTouchMoveRef = React.useRef(false);
      var isTouchStopped = React.useRef(false);
      var unmountCallbackRef = React.useRef();
      var timeRef = React.useRef(null);
      var colStyle = React.useMemo(function () {
        return getStyleWithVendor(__assign$2(__assign$2({
          transform: "translate3d(0px, " + (transformY || 0) + "px, 0px)"
        }, transitionDuration ? {
          transitionDuration: transitionDuration
        } : {}), {
          transitionTimingFunction: bezier,
          paddingBottom: (rowCount - 1) / 2 * itemHeight + "px",
          paddingTop: (rowCount - 1) / 2 * itemHeight + "px"
        }));
      }, [transitionDuration, transformY, bezier, itemHeight, rowCount]);

      function _scrollingComplete(nowItemIndex) {
        // index有改变时再抛出
        // @en Throws again when index changes
        if (currentIndex !== nowItemIndex) {
          setCurrentIndex(Math.max(nowItemIndex, 0));
          var newData = data[nowItemIndex];
          var newValue = newData === null || newData === void 0 ? void 0 : newData.value;

          if (newValue !== currentValue) {
            setCurrentValue(newValue);

            if (onValueChange) {
              onValueChange(newValue, newData);
            }
          }
        }
      }

      function _scrollTo(transY, transDuration, callback) {
        if (transDuration === void 0) {
          transDuration = 0;
        }

        if (callback === void 0) {
          callback = function callback() {};
        }

        setTransitionDuration(transDuration ? transDuration + "ms" : '');
        setTransformY(transY); // 处理连续滑动的情况：如果上一次callback还未执行，先cancel掉上一次回调
        // @en handle the case of continuous sliding: If the last callback has not been executed, cancel the last callback first

        if (latestCallbackTimer.current) {
          clearTimeout(latestCallbackTimer.current);
        }

        var setNormalStatus = function setNormalStatus() {
          // 如果timer顺利执行，则在unmount时不再重复执行
          // @en If the timer is successfully executed, it will not be repeated when unmounting
          unmountCallbackRef.current = undefined;
          movingStatusRef.current = 'normal';
          setTransitionDuration('');
          callback();
        };

        unmountCallbackRef.current = setNormalStatus;
        latestCallbackTimer.current = window.setTimeout(setNormalStatus, transDuration);
      }

      function _scrollToIndex(itemIndex, transDuration, callback) {
        if (transDuration === void 0) {
          transDuration = 0;
        }

        if (callback === void 0) {
          callback = function callback() {};
        }

        _scrollTo(-1 * itemIndex * itemHeight, transDuration, callback);
      }

      function _scrollToIndexWithChange(itemIndex, transDuration) {
        if (transDuration === void 0) {
          transDuration = 0;
        }

        _scrollToIndex(itemIndex, transDuration, function () {
          _scrollingComplete(itemIndex);
        });
      }

      var _handleColumnTouchStart = React.useCallback(function (e) {
        if (disabled) {
          return;
        }

        isTouchMoveRef.current = false;
        movingStatusRef.current = 'moving';
        var x = e.touches[0].screenX;
        var y = e.touches[0].screenY;
        touchStartTimeRef.current = Date.now();
        touchingRef.current = true;
        touchingXRef.current = null;
        touchStartXRef.current = x;
        touchStartYRef.current = y;
        lastTransformYRef.current = transformYRef.current;
      }, [disabled]);

      var _handleColumnTouchMove = React.useCallback(function (e) {
        if (disabled || !touchingRef.current) {
          return;
        }

        isTouchMoveRef.current = true;
        var lastTransformY = lastTransformYRef.current;
        var touchMoveX = e.touches[0].screenX;
        var touchMoveY = e.touches[0].screenY;
        var distanceX = touchMoveX - touchStartXRef.current;
        var distance = touchMoveY - touchStartYRef.current;

        if (touchingXRef.current === null) {
          touchingXRef.current = Math.abs(distanceX) > Math.abs(distance);
        }

        if (touchingXRef.current) {
          return;
        }

        e.cancelable && e.preventDefault();
        var newPos = lastTransformY + distance;
        var maxPos = -1 * (data.length - 1) * itemHeight; // 当滚动到上边界或下边界时增加阻尼效果
        // @en Add damping effect when scrolling to the upper or lower border

        setTransformY(lastTransformY >= 0 && distance > 0 || lastTransformY <= maxPos && distance < 0 ? lastTransformY + distance / 4 : newPos);
      }, [data.length, disabled, itemHeight]);

      function _handleScrollEnd() {
        var maxIndex = data.length - 1;
        var nowIndex = Math.max(0, Math.min(maxIndex, Math.round(-1 * transformY / itemHeight))); // 滚动（包括加动量的滚动）完成之后定位到最近的一个index上
        // @en After scrolling (including scrolling with momentum) is completed, it is positioned on the nearest index

        _scrollToIndexWithChange(nowIndex, 200);
      } // Reference: https://juejin.im/post/6844904185121488910


      function momentum(current, start, duration, minY, maxY) {
        var durationMap = {
          noBounce: 400,
          weekBounce: 100,
          strongBounce: 75
        };
        var bezierMap = {
          noBounce: 'cubic-bezier(.17, .89, .45, 1)',
          weekBounce: 'cubic-bezier(.25, .46, .45, .94)',
          strongBounce: 'cubic-bezier(.25, .46, .45, .94)'
        };
        var type = 'noBounce'; // 惯性滑动加速度
        // @en inertial sliding acceleration

        var deceleration = 0.003; // 回弹阻力
        // @en rebound resistance

        var bounceRate = 5; // 强弱回弹的分割值
        // @en Split value of strong and weak rebound

        var bounceThreshold = 300; // 回弹的最大限度
        // @en maximum rebound

        var maxOverflowY = wrapperHeight / 6;
        var overflowY;
        var distance = current - start;
        var speed = 2 * Math.abs(distance) / duration;
        var destination = current + speed / deceleration * (distance < 0 ? -1 : 1);

        if (destination < minY) {
          overflowY = minY - destination;
          type = overflowY > bounceThreshold ? 'strongBounce' : 'weekBounce';
          destination = Math.max(minY - maxOverflowY, minY - overflowY / bounceRate);
        } else if (destination > maxY) {
          overflowY = destination - maxY;
          type = overflowY > bounceThreshold ? 'strongBounce' : 'weekBounce';
          destination = Math.min(maxY + maxOverflowY, maxY + overflowY / bounceRate);
        }

        return {
          destination: destination,
          duration: durationMap[type],
          bezier: bezierMap[type]
        };
      }

      function _handleColumnTouchEnd() {
        _clearTimer();

        movingStatusRef.current = 'normal';
        var lastTransformY = lastTransformYRef.current;

        if (!isTouchMoveRef.current || transformY === lastTransformY) {
          return;
        }

        touchingRef.current = false;
        var endTime = Date.now();
        var scrollerHeight = (data.length + rowCount - 1) * itemHeight;
        var duration = endTime - touchStartTimeRef.current;
        var absDistY = Math.abs(transformY - lastTransformY); // 计算动量，保证滚动顺畅，条件：手势时间小于300ms && 移动距离绝对值大于30时
        // @en Calculate the momentum to ensure smooth scrolling, condition: the gesture time is less than 300ms && the absolute value of the moving distance is greater than 30

        if (duration < 300 && absDistY > 90) {
          var momentumY = momentum(transformY, lastTransformY, duration, wrapperHeight - scrollerHeight, 0);
          var newItemIndex_1 = Math.max(0, Math.min(data.length - 1, Math.round(-1 * momentumY.destination / itemHeight)));
          setBezier(momentumY.bezier);
          movingStatusRef.current = 'scrolling';

          _scrollToIndex(newItemIndex_1, momentumY.duration, function () {
            _scrollingComplete(newItemIndex_1);
          });
        } else {
          _handleScrollEnd();
        }
      }

      function scrollToCurrentIndex() {
        if (!wrapRef.current) {
          return;
        }

        var curStyle = window.getComputedStyle(wrapRef.current);
        var transformMatrix = curStyle.transform || curStyle.webkitTransform || '';
        var transY = Number(transformMatrix.replace(/matrix\((.*?)\)/, '$1').split(/,\s*/).slice(-1)[0]) || 0;
        var maxIndex = data.length - 1;
        var nowIndex = Math.max(0, Math.min(maxIndex, Math.round(-1 * transY / itemHeight))); // 滚动（包括加动量的滚动）完成之后定位到最近的一个index上
        // @en After scrolling (including scrolling with momentum) is completed, it is positioned on the nearest index

        _scrollToIndexWithChange(nowIndex, 0);
      }

      function getCurrentCellValue() {
        var _a;

        return (_a = data[currentIndex]) === null || _a === void 0 ? void 0 : _a.value;
      }

      function _clearTimer() {
        timeRef.current && clearTimeout(timeRef.current);
        timeRef.current = null;
      }

      function _handleItemTouchStart() {
        if (touchToStop === false) {
          return;
        }

        isTouchStopped.current = false;
        timeRef.current = window.setTimeout(function () {
          if (!isTouchMoveRef.current) {
            isTouchStopped.current = true;
            scrollToCurrentIndex();
          }
        }, touchToStop === true ? 100 : touchToStop);
      }

      function _handleItemClick(itemIndex) {
        if (!clickable || disabled || touchToStop !== false && isTouchStopped.current) {
          return;
        }

        _scrollToIndexWithChange(itemIndex, 200);
      }

      React.useEffect(function () {
        return function () {
          var _a; // 卸载组件时，如果timer中还有未执行的onchange操作，则立刻执行该操作并移除timer
          // @en When unloading the component, if there is an unexecuted onchange operation in the timer, execute it immediately and remove the timer


          var timerId = latestCallbackTimer.current;
          (_a = unmountCallbackRef.current) === null || _a === void 0 ? void 0 : _a.call(unmountCallbackRef);
          timerId && clearTimeout(timerId);
        };
      }, []);
      React.useEffect(function () {
        if (wrapRef.current) {
          wrapRef.current.addEventListener('touchstart', _handleColumnTouchStart);
          wrapRef.current.addEventListener('touchmove', _handleColumnTouchMove);
        }

        return function () {
          if (wrapRef.current) {
            wrapRef.current.removeEventListener('touchstart', _handleColumnTouchStart);
            wrapRef.current.removeEventListener('touchmove', _handleColumnTouchMove);
          }
        };
      }, [_handleColumnTouchStart, _handleColumnTouchMove]);
      React.useLayoutEffect(function () {
        if ('selectedValue' in props) {
          var curIndex = data.findIndex(function (item) {
            return item.value === selectedValue;
          });
          setCurrentIndex(Math.max(curIndex, 0));

          if (curIndex >= 0) {
            _scrollToIndexWithChange(curIndex);
          }
        }
      }, [selectedValue, itemHeight, data]);
      React.useImperativeHandle(ref, function () {
        return {
          movingStatus: movingStatusRef.current,
          scrollToCurrentIndex: scrollToCurrentIndex,
          getCurrentCellValue: getCurrentCellValue
        };
      });
      return !hideEmptyCols || data && data.length ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-column"
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-column-item-wrap",
        style: colStyle,
        ref: wrapRef,
        onTouchStart: _handleItemTouchStart,
        onTouchEnd: _handleColumnTouchEnd,
        onTouchCancel: _handleColumnTouchEnd,
        "aria-disabled": disabled
      }, data.map(function (item, index) {
        var _a;

        var dis = Math.abs(index - currentIndex);
        return /*#__PURE__*/React__default["default"].createElement("div", {
          "aria-label": index === currentIndex ? "" + item.value : '',
          key: index + "_" + item.value,
          className: cls(prefixCls + "-column-item", (_a = {
            selected: index === currentIndex
          }, _a["selected-neighbor-" + dis] = dis && dis <= Math.floor(rowCount / 2), _a)),
          style: style,
          onClick: function onClick() {
            return _handleItemClick(index);
          }
        }, item.label);
      }))) : null;
    });

    var Cascader = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var prefixCls = props.prefixCls,
          itemStyle = props.itemStyle,
          cols = props.cols,
          data = props.data,
          disabled = props.disabled,
          clickable = props.clickable,
          itemHeight = props.itemHeight,
          wrapperHeight = props.wrapperHeight,
          rows = props.rows,
          hideEmptyCols = props.hideEmptyCols,
          onValueChange = props.onValueChange,
          _a = props.selectedValue,
          selectedValue = _a === void 0 ? [] : _a,
          touchToStop = props.touchToStop;
      var pickerCellsRef = React.useRef([]);
      React.useImperativeHandle(ref, function () {
        return {
          getCellMovingStatus: getCellMovingStatus,
          scrollToCurrentIndex: scrollToCurrentIndex,
          getAllCellsValue: getAllCellsValue
        };
      });

      function getCellMovingStatus() {
        return pickerCellsRef.current.map(function (cell) {
          return cell.movingStatus;
        });
      }

      function scrollToCurrentIndex() {
        pickerCellsRef.current.forEach(function (cell) {
          return cell.scrollToCurrentIndex();
        });
      }

      function getAllCellsValue() {
        return pickerCellsRef.current.map(function (cell) {
          return cell.getCurrentCellValue();
        });
      }

      function _onValueChange(value, index, newData) {
        var children = arrayTreeFilter(data, function (item, level) {
          return level <= index && item.value === value[level];
        });
        var child = children[index];
        var i;

        for (i = index + 1; i < cols && child && child.children; i++) {
          child = child.children[0];
          value[i] = child.value;
          newData[i] = child;
        }

        value.length = i;
        newData.length = i;
        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(value, index, newData);
      }

      function _formatData() {
        var childrenTree = arrayTreeFilter(data, function (item, level) {
          return item.value === (selectedValue === null || selectedValue === void 0 ? void 0 : selectedValue[level]);
        }, {
          fallbackChildIndex: 0
        }).map(function (item) {
          return item.children;
        });
        var needPad = cols - childrenTree.length;

        if (needPad > 0) {
          for (var i = 0; i < needPad; i++) {
            childrenTree.push([]);
          }
        }

        childrenTree.length = cols - 1;
        childrenTree.unshift(data);
        return childrenTree;
      }

      var formatData = React.useMemo(function () {
        return _formatData();
      }, [data, selectedValue]);
      return /*#__PURE__*/React__default["default"].createElement(MultiPicker, {
        prefixCls: prefixCls + "-picker",
        data: formatData,
        selectedValue: selectedValue,
        itemHeight: itemHeight,
        onValueChange: _onValueChange
      }, formatData.map(function (item, index) {
        return /*#__PURE__*/React__default["default"].createElement(PickerCell, {
          key: index + "_picker_cell_cascader",
          data: item || [],
          style: itemStyle,
          prefixCls: prefixCls + "-picker",
          clickable: clickable,
          itemHeight: itemHeight,
          wrapperHeight: wrapperHeight,
          disabled: disabled,
          rows: rows,
          hideEmptyCols: hideEmptyCols,
          ref: function ref(cellRef) {
            return cellRef && (pickerCellsRef.current[index] = cellRef);
          },
          touchToStop: touchToStop
        });
      }));
    });

    var PickerView = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          itemStyle = props.itemStyle,
          _b = props.cascade,
          cascade = _b === void 0 ? true : _b,
          _c = props.cols,
          cols = _c === void 0 ? 3 : _c,
          _d = props.rows,
          rows = _d === void 0 ? 5 : _d,
          data = props.data,
          _e = props.disabled,
          disabled = _e === void 0 ? false : _e,
          _f = props.clickable,
          clickable = _f === void 0 ? true : _f,
          value = props.value,
          _g = props.hideEmptyCols,
          hideEmptyCols = _g === void 0 ? false : _g,
          onPickerChange = props.onPickerChange,
          _h = props.touchToStop,
          touchToStop = _h === void 0 ? false : _h;

      var _j = React.useState(0),
          itemHeight = _j[0],
          setItemHeight = _j[1];

      var _k = React.useState(0),
          wrapperHeight = _k[0],
          setWrapperHeight = _k[1];

      var _l = useMountedState(value),
          scrollValue = _l[0],
          setScrollValue = _l[1];

      var wrapperRef = React.useRef(null);
      var domRef = React.useRef(null);
      var barRef = React.useRef(null);
      var pickerCellsRef = React.useRef([]);
      var cascaderRef = React.useRef(null); // itemStyle height 同时对 selection-bar 生效，这里不单独抛出 selection-bar 的高度设置属性
      // @en The height of itemStyle applies to the selection-bar as well, without separately exposing the height setting property for the selection-bar.

      var selectionBarHeight = React.useMemo(function () {
        return (itemStyle === null || itemStyle === void 0 ? void 0 : itemStyle.height) ? {
          height: itemStyle.height
        } : {};
      }, [itemStyle]);
      var innerData = React.useMemo(function () {
        var newData;

        var isArray = function isArray(dt) {
          return dt ? Array.isArray(dt[0]) : false;
        };

        var isStrOrNum = function isStrOrNum(dt) {
          return typeof dt[0][0] === 'string' || typeof dt[0][0] === 'number';
        };

        if (isArray(data)) {
          if (isStrOrNum(data)) {
            newData = data.map(function (item) {
              return item.map(function (cell) {
                return {
                  label: cell,
                  value: cell
                };
              });
            });
          } else {
            newData = data;
          }
        } else {
          newData = [data];
        }

        return newData;
      }, [data]);

      var getAllColumnValues = function getAllColumnValues() {
        var _a;

        var curValues = cascade ? ((_a = cascaderRef.current) === null || _a === void 0 ? void 0 : _a.getAllCellsValue()) || [] : pickerCellsRef.current.map(function (cell) {
          return cell.getCurrentCellValue();
        }); // 移除级联带来的空列值，理论上非首尾列不会有空值
        // @en Remove empty values from cascader

        return curValues.filter(function (v) {
          return v !== undefined;
        });
      };

      function getColumnValue(index) {
        if (index === void 0) {
          index = 0;
        }

        return getAllColumnValues()[index];
      }

      function getCellMovingStatus() {
        var _a;

        return cascade ? ((_a = cascaderRef.current) === null || _a === void 0 ? void 0 : _a.getCellMovingStatus()) || [] : pickerCellsRef.current.map(function (cell) {
          return cell.movingStatus;
        });
      }

      function scrollToCurrentIndex() {
        var _a;

        if (cascade) {
          (_a = cascaderRef.current) === null || _a === void 0 ? void 0 : _a.scrollToCurrentIndex();
          return;
        }

        pickerCellsRef.current.forEach(function (cell) {
          return cell.scrollToCurrentIndex();
        });
      }

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          getCellMovingStatus: getCellMovingStatus,
          getAllColumnValues: getAllColumnValues,
          getColumnValue: getColumnValue,
          updateLayout: updateLayout,
          resetValue: resetValue,
          scrollToCurrentIndex: scrollToCurrentIndex
        };
      });

      function _onValueChange(val, index, newData) {
        setScrollValue(val);

        if (onPickerChange) {
          onPickerChange(val, index, newData);
        }
      }

      React.useEffect(function () {
        setScrollValue(value);
      }, [value]);
      var updateWrapperHeight = React.useCallback(function () {
        if (wrapperRef && wrapperRef.current) {
          setWrapperHeight(wrapperRef.current.offsetHeight);
        }
      }, [wrapperRef, setWrapperHeight]);

      var updateItemHeight = function updateItemHeight() {
        if (barRef.current) {
          setItemHeight(barRef.current.getBoundingClientRect().height);
        }
      };

      React.useEffect(function () {
        updateLayout();
      }, []);

      function updateLayout() {
        updateWrapperHeight();
        updateItemHeight();
      }

      function resetValue() {
        setScrollValue(value);
      }

      var newItemStyle = __assign$2({
        height: itemHeight + "px"
      }, itemStyle);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-view all-border-box " + className,
          style: {
            height: itemHeight * rows + "px"
          },
          ref: wrapperRef
        }, cascade ? /*#__PURE__*/React__default["default"].createElement(Cascader, {
          prefixCls: prefixCls || '',
          cols: cols,
          itemStyle: newItemStyle,
          data: data,
          selectedValue: scrollValue,
          onValueChange: _onValueChange,
          clickable: clickable,
          itemHeight: itemHeight,
          wrapperHeight: wrapperHeight,
          disabled: disabled,
          rows: rows,
          hideEmptyCols: hideEmptyCols,
          ref: cascaderRef,
          touchToStop: touchToStop
        }) : /*#__PURE__*/React__default["default"].createElement(MultiPicker, {
          prefixCls: prefixCls + "-picker",
          data: innerData,
          itemHeight: itemHeight,
          selectedValue: scrollValue,
          onValueChange: _onValueChange
        }, innerData.map(function (item, index) {
          return /*#__PURE__*/React__default["default"].createElement(PickerCell, {
            key: index + "_picker_cell_normal",
            data: item,
            style: newItemStyle,
            prefixCls: prefixCls + "-picker",
            clickable: clickable,
            itemHeight: itemHeight,
            wrapperHeight: wrapperHeight,
            disabled: disabled,
            rows: rows,
            hideEmptyCols: hideEmptyCols,
            ref: function ref(cellRef) {
              return cellRef && (pickerCellsRef.current[index] = cellRef);
            },
            touchToStop: touchToStop
          });
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-selection"
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-selection-mask " + prefixCls + "-picker-selection-mask-top"
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          ref: barRef,
          className: prefixCls + "-picker-selection-bar",
          style: selectionBarHeight
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-selection-mask " + prefixCls + "-picker-selection-mask-bottom"
        })));
      });
    });
    /**
     * 选择器视图组件，不含弹窗，方便使用方灵活定制选择器。
     * @en The picker view component, not has contain popup, which is convenient for the user to flexibly customize the picker.
     * @type 数据录入
     * @type_en Data Entry
     * @name 选择器视图
     * @name_en PickerView
     * @displayName PickerView
     */

    var PickerView$1 = componentWrapper(PickerView, 'PickerView');

    var Picker = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          itemStyle = props.itemStyle,
          _a = props.cascade,
          cascade = _a === void 0 ? true : _a,
          _b = props.cols,
          cols = _b === void 0 ? 3 : _b,
          _c = props.rows,
          rows = _c === void 0 ? 5 : _c,
          data = props.data,
          okText = props.okText,
          dismissText = props.dismissText,
          _d = props.disabled,
          disabled = _d === void 0 ? false : _d,
          _e = props.clickable,
          clickable = _e === void 0 ? true : _e,
          _f = props.hideEmptyCols,
          hideEmptyCols = _f === void 0 ? false : _f,
          _g = props.title,
          title = _g === void 0 ? '' : _g,
          _h = props.visible,
          visible = _h === void 0 ? false : _h,
          value = props.value,
          _j = props.needBottomOffset,
          needBottomOffset = _j === void 0 ? false : _j,
          onDismiss = props.onDismiss,
          onOk = props.onOk,
          onChange = props.onChange,
          _k = props.maskClosable,
          maskClosable = _k === void 0 ? false : _k,
          onHide = props.onHide,
          onPickerChange = props.onPickerChange,
          touchToStop = props.touchToStop,
          _l = props.gestureOutOfControl,
          gestureOutOfControl = _l === void 0 ? true : _l,
          otherProps = __rest$1(props, ["className", "itemStyle", "cascade", "cols", "rows", "data", "okText", "dismissText", "disabled", "clickable", "hideEmptyCols", "title", "visible", "value", "needBottomOffset", "onDismiss", "onOk", "onChange", "maskClosable", "onHide", "onPickerChange", "touchToStop", "gestureOutOfControl"]);

      var scrollValueRef = useLatestRef(value);
      var domRef = React.useRef(null);
      var pickerViewRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          getCellMovingStatus: function getCellMovingStatus() {
            var _a;

            return ((_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.getCellMovingStatus()) || [];
          },
          getAllColumnValues: function getAllColumnValues() {
            var _a;

            return ((_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.getAllColumnValues()) || [];
          },
          getColumnValue: function getColumnValue(index) {
            var _a;

            return ((_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.getColumnValue(index)) || '';
          },
          updateLayout: function updateLayout() {
            var _a;

            return (_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.updateLayout();
          },
          scrollToCurrentIndex: function scrollToCurrentIndex() {
            var _a;

            return (_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.scrollToCurrentIndex();
          }
        };
      });

      function handleDismiss() {
        if (onDismiss) {
          onDismiss();
        }

        if (onHide) {
          onHide('dismiss');
        }
      }

      var handleConfirm = function handleConfirm() {
        var _a;

        (_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.scrollToCurrentIndex();
        nextTick(function () {
          var _a;

          var val = ((_a = pickerViewRef.current) === null || _a === void 0 ? void 0 : _a.getAllColumnValues()) || scrollValueRef.current || [];

          if (onOk) {
            onOk(val);
          }

          if (onChange) {
            onChange(val);
          }

          if (onHide) {
            onHide('confirm');
          }
        });
      };

      useListenResize(updateLayoutByVisible, [visible]); // 每次visible从false变为true时需要重新设置scrollValue的值为当前value的值（初始值）

      function updateLayoutByVisible() {
        if (visible && pickerViewRef.current) {
          pickerViewRef.current.updateLayout();
        }
      }

      React.useEffect(function () {
        updateLayoutByVisible();
      }, [visible]);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls,
            locale = _a.locale;
        return /*#__PURE__*/React__default["default"].createElement(Popup$1, __assign$2({
          visible: visible,
          className: cls(className, prefixCls + "-picker all-border-box"),
          close: function close() {
            return onHide === null || onHide === void 0 ? void 0 : onHide('mask');
          },
          direction: "bottom",
          maskClosable: maskClosable,
          needBottomOffset: needBottomOffset,
          gestureOutOfControl: gestureOutOfControl
        }, otherProps), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-wrap",
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-header"
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-header-btn left",
          onClick: handleDismiss
        }, dismissText || (locale === null || locale === void 0 ? void 0 : locale.Picker.cancelText)), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-header-title"
        }, title), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-picker-header-btn right",
          onClick: handleConfirm
        }, okText || (locale === null || locale === void 0 ? void 0 : locale.Picker.okText))), /*#__PURE__*/React__default["default"].createElement(PickerView$1, {
          ref: pickerViewRef,
          data: data,
          cascade: cascade,
          cols: cols,
          rows: rows,
          disabled: disabled,
          value: value,
          onPickerChange: onPickerChange,
          itemStyle: itemStyle,
          clickable: clickable,
          hideEmptyCols: hideEmptyCols,
          touchToStop: touchToStop
        })));
      });
    });
    /**
     * 选择器组件，形式是弹起的浮层。
     * @en The selector component, in the form of a popup layer.
     * @type 数据录入
     * @type_en Data Entry
     * @name 选择器
     * @name_en Picker
     * @displayName Picker
     */

    var Picker$1 = componentWrapper(Picker, 'Picker');

    function convertTsToDateObj(ts, utc) {
      var date = new DateWithUTC(ts, utc);
      return {
        year: date.getFullYear(),
        month: date.getMonth() + 1,
        date: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
        second: date.getSeconds()
      };
    }
    function convertObjToTs(obj, defaultTs, utc) {
      if (obj === void 0) {
        obj = {};
      }

      var date = new DateWithUTC(defaultTs, utc);
      var defaultDate = date.getDate();
      !isNaN(obj.year) && date.setFullYear(obj.year); // bugfix: setMonth后如果日期超限则会自动顺延到下月，此时返回月份就不准了，因此先设置date为1再设置month
      // @en bugfix: After setMonth, if the date exceeds the limit, it will be automatically extended to the next month. At this time, the return month is not allowed, so first set date to 1 and then set month

      if (!isNaN(obj.month)) {
        date.setDate(1);
        date.setMonth(obj.month - 1);
      } // date的值可能被修改，需要被还原
      // @en The value of date may be modified and needs to be restored


      date.setDate(isNaN(obj.date) ? defaultDate : obj.date);
      !isNaN(obj.hour) && date.setHours(obj.hour);
      !isNaN(obj.minute) && date.setMinutes(obj.minute);
      !isNaN(obj.second) && date.setSeconds(obj.second);
      return date.getTime();
    }
    function oneOf(value, validList) {
      return validList.indexOf(value) !== -1;
    } // 查看两个obj中的keys里的各个值是否都一致
    // @en Check whether the values in the keys in the two obj are consistent

    function judgeObj(dateObj1, dateObj2, keys) {
      if (keys === void 0) {
        keys = [];
      }

      return !keys.some(function (key) {
        return dateObj1[key] !== dateObj2[key];
      });
    }

    var allTypes = ['year', 'month', 'date', 'hour', 'minute', 'second'];

    var defaultFormatter = function defaultFormatter(value) {
      return value < 10 ? "0" + value : String(value);
    };

    var YEAR = 12 * 30 * 24 * 60 * 60 * 1000;
    var initMinDate = Date.now() - 10 * YEAR;
    var initMaxDate = Date.now() + 10 * YEAR;
    var initDate = Date.now();
    var DatePicker = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.currentTs,
          userSetCurrentTs = _a === void 0 ? initDate : _a,
          _b = props.className,
          className = _b === void 0 ? '' : _b,
          _c = props.visible,
          visible = _c === void 0 ? false : _c,
          onOk = props.onOk,
          onChange = props.onChange,
          onValueChange = props.onValueChange,
          _d = props.mode,
          mode = _d === void 0 ? 'datetime' : _d,
          _e = props.typeArr,
          typeArr = _e === void 0 ? [] : _e,
          _f = props.minTs,
          minTs = _f === void 0 ? initMinDate : _f,
          _g = props.maxTs,
          maxTs = _g === void 0 ? initMaxDate : _g,
          _h = props.formatter,
          formatter = _h === void 0 ? defaultFormatter : _h,
          _j = props.valueFilter,
          valueFilter = _j === void 0 ? function () {
        return true;
      } : _j,
          columnsProcessor = props.columnsProcessor,
          touchToStop = props.touchToStop,
          _k = props.useUTC,
          useUTC = _k === void 0 ? false : _k,
          otherProps = __rest$1(props, ["currentTs", "className", "visible", "onOk", "onChange", "onValueChange", "mode", "typeArr", "minTs", "maxTs", "formatter", "valueFilter", "columnsProcessor", "touchToStop", "useUTC"]);

      var currentTs = Math.min(maxTs, Math.max(minTs, userSetCurrentTs));

      var _l = React.useState([[]]),
          data = _l[0],
          setData = _l[1];

      var _m = React.useState([]),
          value = _m[0],
          setValue = _m[1];

      var currentDateObjRef = React.useRef(_convertTsToDateObj(currentTs));
      var minDateObjRef = React.useRef(_convertTsToDateObj(minTs));
      var maxDateObjRef = React.useRef(_convertTsToDateObj(maxTs));
      var keyOptions = React.useMemo(function () {
        return _getKeyOptions();
      }, [mode, typeArr]);
      var pickerRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: pickerRef.current ? pickerRef.current.dom : null
        };
      });

      function _getColumns() {
        var dateObj = {};
        allTypes.forEach(function (type) {
          dateObj[type] = _getActualArray(type, currentDateObjRef.current);
        });
        var columns = keyOptions.map(function (opt) {
          return dateObj[opt];
        });

        if (columnsProcessor) {
          columns = columnsProcessor(columns, currentDateObjRef.current);
        }

        return {
          columns: columns,
          dateObj: dateObj
        };
      }

      function _getSelectValue(columns) {
        var val = keyOptions.map(function (opt, index) {
          var _a;

          var curCol = columns[index] || [];
          var selectIndex = curCol.findIndex(function (col) {
            return col.value === currentDateObjRef.current[opt];
          });
          return (_a = curCol[Math.max(selectIndex, 0)]) === null || _a === void 0 ? void 0 : _a.value;
        });
        return val;
      }

      function _initData() {
        var columns = _getColumns().columns;

        var val = _getSelectValue(columns);

        setData(function () {
          return columns;
        });
        setValue(function () {
          return val;
        });
      } // 根据当前选中的日期动态改变其他列的options
      // @en Dynamically change the options of other columns based on the currently selected date


      function _getActualArray(type, nowDateObj) {
        var normalRange = _getNormalRange(type, nowDateObj);

        var range = [];

        switch (type) {
          case 'year':
            range = [minDateObjRef.current.year, maxDateObjRef.current.year];
            break;

          default:
            {
              var checkKeys = allTypes.slice(0, allTypes.indexOf(type));
              range = normalRange;

              if (judgeObj(nowDateObj, minDateObjRef.current, checkKeys)) {
                range[0] = minDateObjRef.current[type];
              }

              if (judgeObj(nowDateObj, maxDateObjRef.current, checkKeys)) {
                range[range.length - 1] = maxDateObjRef.current[type];
              }
            }
        }

        return _convertRangeToArr(type, range);
      }

      function _convertRangeToArr(type, range) {
        var _a = range[0],
            start = _a === void 0 ? 0 : _a,
            _b = range[1],
            end = _b === void 0 ? 0 : _b;
        var arr = [];

        for (var i = start; i <= end; i += 1) {
          if (valueFilter(type, i)) {
            var text = formatter(i, type);
            arr.push({
              label: text === void 0 ? defaultFormatter(i) : text,
              value: i
            });
          }
        }

        return arr;
      }

      function _getNormalRange(type, nowDateObj) {
        switch (type) {
          case 'month':
            return [1, 12];

          case 'date':
            if (nowDateObj.month === 2) {
              // 闰年2月29天
              // @en February 29th in leap year
              return nowDateObj.year % 4 === 0 ? [1, 29] : [1, 28];
            }

            return oneOf(nowDateObj.month, [1, 3, 5, 7, 8, 10, 12]) ? [1, 31] : [1, 30];

          case 'hour':
            return [0, 23];

          case 'minute':
          case 'second':
            return [0, 59];

          default:
            return [];
        }
      }

      function _convertObjToTs(obj, defaultTs) {
        return convertObjToTs(obj, defaultTs, useUTC);
      }

      function _convertTsToDateObj(ts) {
        return convertTsToDateObj(ts, useUTC);
      }

      function _handlePickerChange(values, index) {
        var type = keyOptions[index];
        var nowDateObj = {};
        values.forEach(function (i, keyIndex) {
          nowDateObj[keyOptions[keyIndex]] = i;
        });

        if (~keyOptions.slice(0, keyOptions.length - 1).indexOf(type)) {
          currentDateObjRef.current = nowDateObj;

          var _a = _getColumns(),
              columns = _a.columns,
              dateObj_1 = _a.dateObj; // 校准选中日期，比如先选中2020-02-29 年份改为2019，则2月没有29日；需要校准
          // @en Calibration selected date, For example, if you first select 2020-02-29 and change the year to 2019, there will be no 29th in February; calibration is required


          keyOptions.forEach(function (key) {
            if (dateObj_1[key].findIndex(function (item) {
              return item.value === nowDateObj[key];
            }) < 0) {
              nowDateObj[key] = dateObj_1[key][dateObj_1[key].length - 1].value;
            }
          });

          var val = _getSelectValue(columns);

          setData(columns);
          setValue(val);
        }

        if (onValueChange) {
          onValueChange(_convertObjToTs(nowDateObj, currentTs), nowDateObj, index);
        }
      }

      function _handlePickerConfirm(values) {
        var nowDateObj = {};
        values.forEach(function (index, keyIndex) {
          nowDateObj[keyOptions[keyIndex]] = index;
        });

        var newTs = _convertObjToTs(nowDateObj, currentTs);

        if (onOk) {
          onOk(newTs, nowDateObj);
        }

        if (onChange) {
          onChange(newTs, nowDateObj);
        }
      }

      function _getKeyOptions() {
        if (typeArr && typeArr.length) {
          return typeArr;
        }

        var options = [];

        switch (mode) {
          case 'date':
            options = allTypes.slice(0, 3);
            break;

          case 'time':
            options = allTypes.slice(3);
            break;

          default:
            options = allTypes;
        }

        return options;
      }

      React.useEffect(function () {
        minDateObjRef.current = _convertTsToDateObj(minTs);
        currentDateObjRef.current = _convertTsToDateObj(currentTs);
        maxDateObjRef.current = _convertTsToDateObj(maxTs);

        _initData();
      }, [currentTs, minTs, maxTs, useUTC]);
      React.useEffect(function () {
        if (visible) {
          currentDateObjRef.current = _convertTsToDateObj(currentTs);

          _initData();
        }
      }, [visible]);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Picker$1, __assign$2({}, otherProps, {
          ref: pickerRef,
          visible: visible,
          className: cls(className, prefixCls + "-date-picker"),
          cascade: false,
          data: data,
          value: value,
          onPickerChange: _handlePickerChange,
          onOk: _handlePickerConfirm,
          touchToStop: touchToStop
        }));
      });
    });
    /**
     * 日期时间选择器，基于`Picker`组件扩展，支持指定范围，单位可精确到秒。
     * @en Date picker, based on the `Picker` component, supports the specified range, the unit can be accurate to seconds.
     * @type 数据录入
     * @type_en Data Entry
     * @name 日期时间选择器
     * @name_en DatePicker
     * @displayName DatePicker
     */

    var index$k = componentWrapper(DatePicker, 'DatePicker');

    function normalizeAlert(config) {
      var _a = config || {},
          onOk = _a.onOk,
          okText = _a.okText,
          restConfig = __rest$1(_a, ["onOk", "okText"]);

      return __assign$2({
        footer: [{
          content: okText || function (locale) {
            return locale.Dialog.okText;
          },
          className: 'confirm',
          onClick: onOk
        }]
      }, restConfig);
    }
    function normalizeConfirm(config) {
      var _a = config || {},
          onOk = _a.onOk,
          okText = _a.okText,
          onCancel = _a.onCancel,
          cancelText = _a.cancelText,
          restConfig = __rest$1(_a, ["onOk", "okText", "onCancel", "cancelText"]);

      return __assign$2({
        footer: [{
          content: cancelText || function (locale) {
            return locale.Dialog.cancelText;
          },
          className: 'cancel',
          onClick: onCancel
        }, {
          content: okText || function (locale) {
            return locale.Dialog.okText;
          },
          className: 'confirm',
          onClick: onOk
        }]
      }, restConfig);
    }
    var dialogId = 'ARCO_DIALOG';
    function alert(Component, normalize) {
      return getOpenMethod(Component, dialogId, normalize || normalizeAlert);
    }
    function confirm(Component, normalize) {
      return getOpenMethod(Component, dialogId, normalize || normalizeConfirm);
    }
    function open$2(Component) {
      return open$5(Component, dialogId);
    }

    var Dialog = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var system = useSystem();
      var nowSystem = props.platform || system;

      var _a = props.close,
          close = _a === void 0 ? function () {} : _a,
          children = props.children,
          title = props.title,
          _b = props.footer,
          footer = _b === void 0 ? [] : _b,
          _c = props.footerType,
          footerType = _c === void 0 ? 'grid' : _c,
          renderFooter = props.renderFooter,
          _d = props.footerCollapseCount,
          footerCollapseCount = _d === void 0 ? 3 : _d,
          _e = props.titleAlign,
          titleAlign = _e === void 0 ? nowSystem === 'android' ? 'left' : 'center' : _e,
          _f = props.contentAlign,
          contentAlign = _f === void 0 ? nowSystem === 'android' ? 'left' : 'center' : _f,
          className = props.className,
          maskClass = props.maskClass,
          contentClass = props.contentClass,
          contentStyle = props.contentStyle,
          _g = props.contentTransitionType,
          contentTransitionType = _g === void 0 ? nowSystem === 'android' ? 'fade' : 'fade-scale' : _g,
          _h = props.maskTransitionTimeout,
          maskTransitionTimeout = _h === void 0 ? 300 : _h,
          _j = props.contentTransitionTimeout,
          contentTransitionTimeout = _j === void 0 ? 450 : _j,
          extra = props.extra,
          restProps = __rest$1(props, ["close", "children", "title", "footer", "footerType", "renderFooter", "footerCollapseCount", "titleAlign", "contentAlign", "className", "maskClass", "contentClass", "contentStyle", "contentTransitionType", "maskTransitionTimeout", "contentTransitionTimeout", "extra"]);

      var maskingRef = React.useRef(null);
      var contentRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        var _a, _b, _c;

        return {
          dom: ((_a = maskingRef.current) === null || _a === void 0 ? void 0 : _a.dom) || null,
          mask: ((_b = maskingRef.current) === null || _b === void 0 ? void 0 : _b.mask) || null,
          content: contentRef.current,
          setCloseScene: ((_c = maskingRef.current) === null || _c === void 0 ? void 0 : _c.setCloseScene) || function () {}
        };
      });

      function handleFooterBtnClick(e, btn) {
        e.preventDefault();
        e.stopPropagation();

        if (btn.disabled) {
          return;
        }

        var result = btn.onClick ? btn.onClick(e) : null;

        if (!result || typeof result === 'boolean') {
          !result && close(e);
        } else if (result && result.then) {
          result.then(function (res) {
            return !res && close(e);
          });
        }
      }

      function renderDialog(_a) {
        var prefixCls = _a.prefixCls,
            locale = _a.locale;
        var prefix = prefixCls + "-dialog";
        return /*#__PURE__*/React__default["default"].createElement(Masking$1, __assign$2({
          close: close,
          className: cls(prefix, nowSystem, className),
          ref: maskingRef,
          maskClass: cls(prefix + "-mask", maskClass),
          contentTransitionType: contentTransitionType,
          contentClass: cls(prefix + "-container"),
          maskTransitionTimeout: maskTransitionTimeout,
          contentTransitionTimeout: contentTransitionTimeout
        }, restProps), /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-content", prefix + "-part", nowSystem, contentClass),
          style: contentStyle,
          ref: contentRef
        }, title ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-header", prefix + "-part", titleAlign, nowSystem, "system-" + system, {
            'only-title': !children
          })
        }, title) : null, children ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-body", prefix + "-part", contentAlign, nowSystem, {
            'sub-title': !title
          })
        }, children) : null, renderFooter || footer.length ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-footer", prefix + "-part", nowSystem, "type-" + footerType, {
            collapsed: footer.length >= footerCollapseCount
          })
        }, renderFooter ? renderFooter() : footer.map(function (btn, index) {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            key: index,
            className: cls('dialog-footer-button', btn.className, "system-" + system, {
              disabled: btn.disabled
            }),
            onClick: function onClick(e) {
              return handleFooterBtnClick(e, btn);
            }
          }, typeof btn.content === 'function' ? btn.content(locale) : btn.content);
        })) : null, extra ? /*#__PURE__*/React__default["default"].createElement("section", null, extra) : null));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderDialog);
    });
    function methodsGenerator$3(Comp) {
      return {
        /**
         * 打开确认框(含一个确认按钮)
         * @desc {en} Open a confirmation dialog (with a confirmation button)
         * @param {AlertOptions & DialogProps} config Configuration
         * @returns {{ close: () => void; update: (newConfig: AlertOptions & DialogProps) => void; }}
         */
        alert: alert(Comp),

        /**
         * 打开提示框(含一个确认按钮和一个取消按钮)
         * @desc {en} Open a prompt dialog (with a confirm button and a cancel button)
         * @param {ConfirmOptions & AlertOptions} config Configuration
         * @returns {{ close: () => void; update: (newConfig: ConfirmOptions & AlertOptions) => void; }}
         */
        confirm: confirm(Comp),

        /**
         * 打开常规对话框
         * @desc {en} Open the general dialog
         * @param {DialogProps} config Configuration
         * @returns {{ close: () => void; update: (newConfig: DialogProps) => void; }}
         */
        open: open$2(Comp)
      };
    }
    var DialogWithGlobalContext = CompWithGlobalContext(Dialog);
    /**
     * 模态对话框，在浮层中显示，引导用户进行相关操作。默认做了防滚动穿透处理，如果弹层内容中需要滚动，则需将滚动容器传入`getScrollContainer`属性以在未滚动到顶部或底部时释放滚动。
     * @en A modal dialog, displayed in a floating layer, guides the user to perform related operations. By default, anti-scroll penetration processing is performed. If scrolling is required in the content of the bullet layer, you need to pass the scroll container to `getScrollContainer` to release scrolling when it is not scrolled to the top or bottom.
     * @type 反馈
     * @type_en FeedBack
     * @name 对话框
     * @name_en Dialog
     */

    var index$j = componentWrapper(Dialog, methodsGenerator$3(DialogWithGlobalContext));

    /**
     * 划分内容的装饰线
     * @en A partitioning line element
     * @type 布局
     * @type_en Layout
     * @name 分割线
     * @name_en Divider
     */

    var Divider = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.hairline,
          hairline = _b === void 0 ? true : _b,
          _c = props.align,
          align = _c === void 0 ? 'center' : _c,
          width = props.width;
      var domRef = React.useRef(null);
      var prefixCls = React.useContext(GlobalContext).prefixCls;
      var prefix = prefixCls + "-divider";
      var children = props.content || props.children;
      var hasCustomWidth = children && width !== undefined && align === 'center';
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function () {
        var _a;

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix, className, (_a = {}, _a[prefix + "--hairline"] = hairline, _a[prefix + "--with-text " + prefix + "--text-" + align] = children, _a[prefix + "--with-width"] = hasCustomWidth, _a)),
          style: __assign$2(__assign$2({}, style), hasCustomWidth ? getStyleWithVendor({
            flexBasis: width
          }) : {}),
          ref: domRef
        }, children);
      });
    });

    function IconCheck(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-check " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 20 20",
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M16.702 4.47a.5.5 0 00-.705.06L8.33 13.596 3.82 9.724a.5.5 0 00-.705.054l-.652.758a.5.5 0 00.054.706L7.361 15.4a.5.5 0 00.054.053l.526.445.22.188a.5.5 0 00.722-.047l8.641-10.218a.5.5 0 00-.059-.705l-.763-.645z",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    var Options = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var options = props.options,
          useColumn = props.useColumn,
          icon = props.icon,
          selectedValue = props.selectedValue,
          defaultSelectedValue = props.defaultSelectedValue,
          multiple = props.multiple;
      var prefixCls = React.useContext(GlobalContext).prefixCls;

      var _a = React.useState(function () {
        var defaultValue = multiple ? [] : 0;
        return defaultSelectedValue !== void 0 ? defaultSelectedValue : defaultValue;
      }),
          innerValue = _a[0],
          setInnerValue = _a[1];

      var value = React.useMemo(function () {
        return selectedValue === void 0 ? innerValue : selectedValue;
      }, [selectedValue, innerValue]);
      var colCount = useColumn === true ? 4 : Number(useColumn) || 0;
      var fakeOpts = new Array(colCount && options.length % colCount ? colCount - options.length % colCount : 0).fill('');
      var minWidthStyle = useColumn ? {
        minWidth: 1 / (colCount + 1) * 100 + "%"
      } : {};
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      /**
       * 当选项改变时触发的回调函数
       * @en callback when options change
       * */

      function handleOptionChange(e, op) {
        var _a, _b, _c, _d;

        if (op.disabled) return;

        if (props.multiple === true) {
          if (!Array.isArray(value)) {
            return;
          }

          var index = value.indexOf(op.value);
          var checked = index >= 0;
          (_a = props.onOptionClick) === null || _a === void 0 ? void 0 : _a.call(props, checked, op.value, op);

          var newValue = __spreadArrays$1(value);

          checked ? newValue.splice(index, 1) : newValue.push(op.value);
          setInnerValue(newValue);
          (_b = props.onOptionChange) === null || _b === void 0 ? void 0 : _b.call(props, newValue, op);
        } else {
          var newValue = op.value;
          (_c = props.onOptionClick) === null || _c === void 0 ? void 0 : _c.call(props, newValue, op);
          setInnerValue(newValue);
          newValue !== value && ((_d = props.onOptionChange) === null || _d === void 0 ? void 0 : _d.call(props, newValue, op));
        }

        e.stopPropagation();
      }

      function checkSelected(op) {
        return multiple && Array.isArray(value) ? value.includes(op.value) : op.value === value;
      }

      return /*#__PURE__*/React__default["default"].createElement("div", {
        ref: domRef,
        className: cls(prefixCls + "-dropdown-options-wrap", {
          'use-column': useColumn
        })
      }, options.map(function (op) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-dropdown-options-item" + (useColumn ? '-col' : ''), {
            disabled: op.disabled,
            selected: checkSelected(op)
          }),
          key: op.value,
          onClick: function onClick(e) {
            return handleOptionChange(e, op);
          },
          style: minWidthStyle
        }, op.label, icon !== void 0 ? icon : /*#__PURE__*/React__default["default"].createElement(IconCheck, {
          className: prefixCls + "-dropdown-options-item-icon"
        }));
      }), fakeOpts.map(function (_, i) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-dropdown-options-item-fake-col"),
          key: i,
          style: minWidthStyle
        });
      }));
    });

    function componentGenerator$6(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var optionsWrapper = React.useRef(null);
        var domRef = React.useRef(null);
        var _a = props.className,
            className = _a === void 0 ? '' : _a,
            _b = props.style,
            style = _b === void 0 ? {} : _b,
            _c = props.options,
            options = _c === void 0 ? [] : _c,
            _d = props.showDropdown,
            showDropdown = _d === void 0 ? false : _d,
            _e = props.showMask,
            showMask = _e === void 0 ? true : _e,
            _f = props.direction,
            direction = _f === void 0 ? 'down' : _f,
            height = props.height,
            _g = props.maxHeight,
            maxHeight = _g === void 0 ? 500 : _g,
            _h = props.touchToClose,
            touchToClose = _h === void 0 ? true : _h,
            useColumn = props.useColumn,
            optionIcon = props.optionIcon,
            multiple = props.multiple,
            defaultSelectedValue = props.defaultSelectedValue,
            onCancel = props.onCancel,
            getAnchorElement = props.getAnchorElement,
            isStopTouchEl = props.isStopTouchEl,
            getStopTouchElements = props.getStopTouchElements,
            _j = props.getScrollContainer,
            getScrollContainer = _j === void 0 ? function () {
          return optionsWrapper.current;
        } : _j,
            getPortalContainer = props.getPortalContainer,
            _k = props.clickOtherToClose,
            clickOtherToClose = _k === void 0 ? true : _k,
            _l = props.dropdownAnimationTimeout,
            dropdownAnimationTimeout = _l === void 0 ? 300 : _l,
            _m = props.dropdownAnimationFunction,
            dropdownAnimationFunction = _m === void 0 ? 'cubic-bezier(0.32, 0.96, 0.6, 1)' : _m,
            // 坑：ios touchstart会停留300ms 导致点击关闭蒙层后出现点击穿透 触发底部可点区域事件 这里设置更长的timeout规避
        // @en In iOS, touchstart will stay for 300ms, resulting in click penetration after clicking to close the mask, triggering the bottom clickable area event, and setting a longer timeout to avoid it
        _o = props.maskAnimationTimeout,
            // 坑：ios touchstart会停留300ms 导致点击关闭蒙层后出现点击穿透 触发底部可点区域事件 这里设置更长的timeout规避
        // @en In iOS, touchstart will stay for 300ms, resulting in click penetration after clicking to close the mask, triggering the bottom clickable area event, and setting a longer timeout to avoid it
        maskAnimationTimeout = _o === void 0 ? 500 : _o,
            _p = props.maskAnimationFunction,
            maskAnimationFunction = _p === void 0 ? 'cubic-bezier(0.32, 0.96, 0.6, 1)' : _p,
            _q = props.mountOnEnter,
            mountOnEnter = _q === void 0 ? true : _q,
            _r = props.unmountOnExit,
            unmountOnExit = _r === void 0 ? true : _r,
            _s = props.preventBodyScroll,
            preventBodyScroll = _s === void 0 ? true : _s,
            initialBodyOverflow = props.initialBodyOverflow;
        var system = useSystem();

        var _t = useWindowSize(),
            windowHeight = _t.windowHeight,
            windowWidth = _t.windowWidth;

        var _u = React.useState({
          top: '',
          bottom: ''
        }),
            positionStyle = _u[0],
            setPositionStyle = _u[1];

        var _v = React.useState(function () {
          var defaultValue = multiple ? [] : 0;
          return defaultSelectedValue !== void 0 ? defaultSelectedValue : defaultValue;
        }),
            innerValue = _v[0],
            setInnerValue = _v[1]; // down=0为向上展开，1为向下展开
        // @en down=0 is to expand upwards, 1 is to expand downwards


        var _w = React.useState(null),
            down = _w[0],
            setDown = _w[1];

        var maskHeight = React.useRef(0);
        var optionsContainer = React.useRef(null);
        var dropdownContainer = React.useRef(null);

        var _x = React.useState(0),
            optionsWrapperHeight = _x[0],
            setOptionsWrapperHeight = _x[1];
        /**
         * 判断是否阻止touch事件
         * @en Determine whether to block touch events
         * */


        var ifStopTouch = function ifStopTouch(el) {
          var _a;

          if (isStopTouchEl) return isStopTouchEl(el);
          var tempEl = el;
          var elements = getStopTouchElements ? getStopTouchElements() : [(_a = dropdownContainer.current) === null || _a === void 0 ? void 0 : _a.parentElement];

          for (var i = 0; i < elements.length; i++) {
            while (tempEl && elements[i]) {
              if (tempEl === elements[i]) {
                return true;
              }

              tempEl = tempEl.parentElement;
            }
          }

          return false;
        };

        usePopupScroll(showDropdown, domRef.current, getScrollContainer);
        usePreventBodyScroll(showDropdown, preventBodyScroll, initialBodyOverflow);
        var updateDown = React.useCallback(function (wrapperHeight) {
          var _a; // 为0的时候不改变
          // @en Does not change when it is 0


          if (wrapperHeight === 0) {
            return;
          }

          var tempEl = getAnchorElement ? getAnchorElement() : (_a = dropdownContainer.current) === null || _a === void 0 ? void 0 : _a.parentElement;

          var _b = (tempEl === null || tempEl === void 0 ? void 0 : tempEl.getBoundingClientRect()) || {
            bottom: 0,
            top: 0
          },
              bottom = _b.bottom,
              top = _b.top;

          var tempTop = props.top || bottom;
          var tempBottom = props.bottom || windowHeight - top;
          var tempMaskHeight = windowHeight - tempTop; // 没有指定方向，且空间足够时，或向上展开的空间不够，向下展开
          // @en If there is no specified direction and there is enough space, or there is not enough space to expand upward, expand downward

          var tempDown = direction !== 'up' && wrapperHeight < tempMaskHeight || wrapperHeight > tempTop;

          if (tempDown) {
            maskHeight.current = tempMaskHeight;
            setPositionStyle({
              top: tempTop + "px",
              bottom: ''
            });
          } else {
            maskHeight.current = windowHeight - tempBottom;
            setPositionStyle({
              top: '',
              bottom: tempBottom + "px"
            });
          }

          setDown(tempDown);
        }, [props.top, props.bottom, Boolean(getAnchorElement), direction, windowHeight]);
        /**
         * 取消选择
         * @en Cancel selection
         * */

        var handleCancel = React.useCallback(function (e) {
          var optionsWrapperDom = optionsWrapper.current;

          if (!e || !optionsWrapperDom) {
            return;
          }

          var target = e.target;

          if (!optionsWrapperDom.contains(target) && !ifStopTouch(target)) {
            onCancel();
          }

          e.stopPropagation();
        }, [ifStopTouch, onCancel]);
        /**
         * 当面板放下时，给body添加事件监听，面板收起时，移除
         * @en When the panel is down, add an event listener to the body, and when the panel is retracted, remove it
         * */

        React.useEffect(function () {
          var needBind = showDropdown && clickOtherToClose;
          var event = touchToClose ? 'touchstart' : 'click';

          if (needBind) {
            document.addEventListener(event, handleCancel);
          }

          return function () {
            if (needBind) {
              document.removeEventListener(event, handleCancel);
            }
          };
        }, [showDropdown, clickOtherToClose, handleCancel]);
        React.useEffect(function () {
          var wrapperHeight = 0;

          if (height !== void 0) {
            // 受控模式下，完全交由外层控制
            // @en In controlled mode, it is completely controlled by the outer layer
            wrapperHeight = height;
          } else {
            if (!optionsContainer.current) return;

            if (!showDropdown) {
              wrapperHeight = 0;
            } else {
              wrapperHeight = optionsContainer.current.getBoundingClientRect().height;
            }
          }

          updateDown(wrapperHeight);
          nextTick(function () {
            setOptionsWrapperHeight(wrapperHeight);
          });
        }, [showDropdown, options.length, height, updateDown]);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });

        function getOptionsStyle() {
          var trans = down ? 'translateY(-100%)' : 'translateY(100%)';
          var transStyle = down === null ? {
            opacity: 0
          } : {
            opacity: 1,
            transform: optionsWrapperHeight ? 'translateY(0)' : trans,
            transition: "all " + dropdownAnimationTimeout + "ms " + dropdownAnimationFunction
          };
          return getStyleWithVendor(__assign$2(__assign$2({}, transStyle), {
            overflow: optionsWrapperHeight > maxHeight || height ? 'auto' : 'hidden',
            maxHeight: maxHeight + "px"
          }));
        }

        function renderInnerOptions() {
          var value = props.selectedValue !== void 0 ? props.selectedValue : innerValue;
          var optionProps = {
            options: options,
            useColumn: useColumn,
            icon: optionIcon,
            selectedValue: value,
            multiple: props.multiple,
            onOptionClick: props.onOptionClick,
            onOptionChange: function onOptionChange(vals, op) {
              var _a;

              setInnerValue(vals);
              (_a = props.onOptionChange) === null || _a === void 0 ? void 0 : _a.call(props, vals, op);
            }
          };
          return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({}, optionProps));
        }

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var prefixCls = _a.prefixCls;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            ref: dropdownContainer
          }, /*#__PURE__*/React__default["default"].createElement(Portal, {
            getContainer: getPortalContainer
          }, /*#__PURE__*/React__default["default"].createElement(CSSTransition, {
            in: showDropdown,
            timeout: Math.max(dropdownAnimationTimeout, maskAnimationTimeout),
            onEnter: function onEnter(el) {
              el.style.visibility = 'visible';
            },
            onExited: function onExited(el) {
              el.style.visibility = 'hidden';
              setDown(null);
            },
            mountOnEnter: mountOnEnter,
            unmountOnExit: unmountOnExit
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-dropdown all-border-box", system, className, {
              'drop-up': !down
            }),
            ref: domRef,
            style: __assign$2(__assign$2({
              height: maskHeight.current + "px",
              maxWidth: windowWidth + "px"
            }, style), positionStyle)
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-dropdown-options"),
            ref: optionsWrapper,
            style: getOptionsStyle()
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-dropdown-options-container"),
            ref: optionsContainer
          }, props.children || renderInnerOptions(), props.extraNode)), showMask && /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-dropdown-mask", {
              'is-show': optionsWrapperHeight
            }),
            style: {
              transition: "opacity " + maskAnimationTimeout + "ms " + maskAnimationFunction
            }
          })))));
        });
      });
    }

    var Dropdown = componentGenerator$6(Options);
    /**
     * 下拉面板，展示供选择的选择项
     * @en Dropdown panel, showing options to choose from
     * @type 导航
     * @type_en Navigation
     * @name 下拉面板
     * @name_en Dropdown
     */

    var Dropdown$1 = componentWrapper(Dropdown, {
      Options: Options
    });

    /**
     * 判断是否为string数组
     * @en Determine whether it is a string array
     * */

    function isStringArray(options) {
      return typeof options[0] === 'string';
    }
    /**
     * 判断是否为嵌套数组
     * @en Determine if it is a nested array
     * */

    function isCascadeArray(options) {
      return typeof options[0] === 'object' && !isArray(options[0]);
    }
    /**
     * 格式化传入的数组
     * @en format the input array
     * @param {OptionsItem[][] | string[] | CascadeOptions[]} options 上层传入的选择项数组
     * @param {OptionsItem[][] | string[] | CascadeOptions[]} options {en} Array of options from the upper layer
     * @param {ValueType} currentValues Current selected value
     * */

    var getFormattedOptions = function getFormattedOptions(options, currentValues) {
      var values = __spreadArrays$1(currentValues);

      var formattedOptions = [];

      if (isStringArray(options)) {
        /**
         * 如果传入的是简单的字符串数组
         * @en If is a simple array of strings
         *  */
        formattedOptions.push(options.map(function (op, index) {
          return {
            label: op,
            value: index,
            disabled: false
          };
        }));
      } else if (isCascadeArray(options)) {
        var ops = options;
        var i = 0;

        var _loop_1 = function _loop_1() {
          formattedOptions.push(ops.map(function (item) {
            return __assign$2(__assign$2({}, item), {
              disabled: item.disabled || false
            });
          }));
          var temp = void 0;
          var val = values[i];
          var valIndex = ops.findIndex(function (op) {
            return op.value === val;
          });

          if (valIndex > -1) {
            temp = ops[valIndex].children;
          } else {
            temp = ops[0].children;
            values[i] = ops[0].value;
          }

          i++;
          ops = temp;
        };

        while (ops) {
          _loop_1();
        }
      } else {
        formattedOptions.push.apply(formattedOptions, options);
      }

      return {
        formattedOptions: formattedOptions,
        formattedValue: values
      };
    };
    /**
     * 判断是否为指定ref内的元素
     * @en Determine whether it is an element within the specified ref
     */

    var isRefDom = function isRefDom(dom, ref) {
      var refDom = ref.current;
      if (!refDom || !dom) return false;
      return refDom.contains(dom);
    };
    /**
     * 判断是否为指定类名下的元素
     * @en Determine whether it is an element under the specified classname
     */

    var isClassNameDom = function isClassNameDom(dom, className) {
      if (!dom) return false;
      var tempEl = dom;

      while (tempEl) {
        if (tempEl.classList.value.indexOf(className) > -1) {
          return true;
        }

        tempEl = tempEl.parentNode;
      }

      return false;
    };

    function IconTriDown(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-tri-down " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("defs", null), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M195.456 341.333h633.088a21.333 21.333 0 0116.235 35.158L528.256 748.885a21.333 21.333 0 01-32.512 0L179.221 376.491a21.333 21.333 0 0116.235-35.158z"
        }));
      });
    }

    function componentGenerator$5(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.className,
            className = _a === void 0 ? '' : _a,
            _b = props.style,
            style = _b === void 0 ? {} : _b,
            _c = props.options,
            options = _c === void 0 ? [] : _c,
            _d = props.disabled,
            disabled = _d === void 0 ? [] : _d,
            _e = props.selectTips,
            selectTips = _e === void 0 ? [] : _e,
            values = props.values,
            _f = props.defaultValues,
            defaultValues = _f === void 0 ? [] : _f,
            icon = props.icon,
            _g = props.chooseAndClose,
            chooseAndClose = _g === void 0 ? true : _g,
            selectIndex = props.selectIndex,
            _h = props.defaultSelectIndex,
            defaultSelectIndex = _h === void 0 ? 0 : _h,
            showDropdown = props.showDropdown,
            _j = props.defaultShowDropdown,
            defaultShowDropdown = _j === void 0 ? false : _j,
            onValuesChange = props.onValuesChange,
            onSelectChange = props.onSelectChange,
            onDropdownChange = props.onDropdownChange,
            _k = props.getFormattedOptions,
            getFormattedOptions$1 = _k === void 0 ? getFormattedOptions : _k,
            getContainer = props.getContainer,
            children = props.children,
            extraForDropdown = props.extraForDropdown;

        var _l = React.useContext(GlobalContext),
            prefixCls = _l.prefixCls,
            locale = _l.locale;

        var _m = React.useState(defaultValues),
            innerValues = _m[0],
            setInnerValues = _m[1];

        var _o = React.useState(0),
            defaultTop = _o[0],
            setDefaultTop = _o[1];

        var currentValues = values !== void 0 ? values : innerValues;

        var _p = React.useState(defaultShowDropdown),
            innerShowDropdown = _p[0],
            setInnerShowDropdown = _p[1];

        var dropdownShown = showDropdown !== void 0 ? showDropdown : innerShowDropdown;

        var _q = React.useState(defaultSelectIndex),
            innerSelectedIndex = _q[0],
            setInnerSelectedIndex = _q[1];

        var selectedIndex = selectIndex !== void 0 ? selectIndex : innerSelectedIndex;
        var selectWrapper = React.useRef(null);
        var domRef = React.useRef(null);
        var defaultOpItem = {
          label: locale === null || locale === void 0 ? void 0 : locale.DropdownMenu.select,
          value: -1
        };
        /**
         * 更新选项数组和选择情况
         * @en Update options list and selection
         */

        var formattedOptions = React.useMemo(function () {
          return getFormattedOptions$1(options, currentValues);
        }, [options, currentValues]).formattedOptions;
        var selectedOptions = React.useMemo(function () {
          return formattedOptions.map(function (ops, index) {
            if (props.multiple) {
              var value_1 = currentValues[index] || [];
              var opItems = ops.reduce(function (acc, op) {
                return __spreadArrays$1(acc, value_1.includes(op.value) ? [op] : []);
              }, []);
              return opItems.length ? opItems : [defaultOpItem];
            }

            var value = currentValues[index];
            return ops.find(function (op) {
              return op.value === value;
            }) || ops[0];
          });
        }, [formattedOptions, currentValues, props.multiple]);
        /**
         * 当下拉框的状态变化
         * @en When the state of the dropdown box changes
         */

        var handleShowDropdownChange = function handleShowDropdownChange(show, index) {
          onDropdownChange && onDropdownChange(show, index);
          setInnerShowDropdown(show);
        };

        var handleSelectedIndexChange = function handleSelectedIndexChange(idx) {
          setInnerSelectedIndex(idx);
          onSelectChange === null || onSelectChange === void 0 ? void 0 : onSelectChange(idx);
        };

        var handleValuesChange = function handleValuesChange(val) {
          var newValue = __spreadArrays$1(currentValues); // 级联情况下 selectedIndex 之后的选项值重置
          // @en Option values are reset after selectedIndex in case of cascade


          if (isCascadeArray(options)) {
            newValue = newValue.slice(0, selectedIndex);
          }

          newValue[selectedIndex] = val;
          newValue = getFormattedOptions$1(options, newValue).formattedValue;
          setInnerValues(newValue);
          onValuesChange === null || onValuesChange === void 0 ? void 0 : onValuesChange(newValue);
        };
        /**
         * 处理选择框的点击事件
         * @en Handle click event of dropdown box
         */


        var handleSelectClick = function handleSelectClick(idx) {
          if (disabled[idx]) return;

          if (Number(idx) === selectedIndex) {
            handleShowDropdownChange(!dropdownShown, idx);
          } else {
            handleSelectedIndexChange(idx);
            if (!dropdownShown) handleShowDropdownChange(true, idx);
          }
        };
        /**
         * 判断是否为当前实例下的选择框
         * @en Determine whether it is the dropdown box under the current instance
         */


        var isCurrentSelectEl = function isCurrentSelectEl(target) {
          var isStopTouchEl = (extraForDropdown || {}).isStopTouchEl;
          return isRefDom(target, selectWrapper) && isClassNameDom(target, 'select-item') || (isStopTouchEl === null || isStopTouchEl === void 0 ? void 0 : isStopTouchEl(target)) || false;
        };

        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });
        React.useEffect(function () {
          var defaultContainer = selectWrapper.current;
          var container = getContainer ? getContainer() || defaultContainer : defaultContainer;
          setDefaultTop((container === null || container === void 0 ? void 0 : container.getBoundingClientRect().bottom) || 0);
        }, [getContainer, dropdownShown]);

        var onCancel = props.onCancel || function () {
          return handleShowDropdownChange(false);
        };

        var dropdownCommonProps = __assign$2(__assign$2({
          showDropdown: dropdownShown,
          top: (extraForDropdown === null || extraForDropdown === void 0 ? void 0 : extraForDropdown.top) || defaultTop,
          onCancel: onCancel
        }, extraForDropdown || {}), {
          isStopTouchEl: isCurrentSelectEl
        });

        var renderSelectedLabel = function renderSelectedLabel(op, index) {
          if (props.multiple === true) {
            var multipleOp = op || [];
            return props.renderSelectLabel ? props.renderSelectLabel(multipleOp, index) : /*#__PURE__*/React__default["default"].createElement("div", {
              className: cls(prefixCls + "-select-item-label-text")
            }, multipleOp.map(function (item) {
              return item.label;
            }).join(','));
          }

          var singleOp = op || [];
          return props.renderSelectLabel ? props.renderSelectLabel(singleOp, index) : /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-select-item-label-text")
          }, singleOp.label);
        };

        return /*#__PURE__*/React__default["default"].createElement("div", {
          ref: domRef,
          className: cls(prefixCls + "-dropdown-menu all-border-box", className, {
            show: dropdownShown
          }),
          style: style
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-select"),
          ref: selectWrapper
        }, selectedOptions.map(function (op, index) {
          var tip = selectTips[index] || '';
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-select-item", {
              'is-disabled': disabled[index],
              'is-selected': dropdownShown && selectedIndex === index
            }),
            key: index,
            "data-idx": index,
            onClick: function onClick() {
              return handleSelectClick(index);
            }
          }, tip.length > 0 && /*#__PURE__*/React__default["default"].createElement("span", {
            className: cls(prefixCls + "-select-item-tip")
          }, tip), /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-select-item-label")
          }, renderSelectedLabel(op, index), icon === void 0 ? /*#__PURE__*/React__default["default"].createElement(IconTriDown, {
            className: cls(prefixCls + "-select-item-icon", {
              'is-show': dropdownShown && selectedIndex === index
            })
          }) : icon));
        }), props.multiple === true ? /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({}, __assign$2(__assign$2({
          multiple: true,
          options: formattedOptions[selectedIndex] || [],
          selectedValue: currentValues[selectedIndex] || [],
          onOptionClick: function onOptionClick(selected, val, op) {
            var _a;

            (_a = props.onOptionClick) === null || _a === void 0 ? void 0 : _a.call(props, selected, val, op, selectedIndex);
          },
          onOptionChange: function onOptionChange(val, op) {
            var _a;

            (_a = props.onOptionChange) === null || _a === void 0 ? void 0 : _a.call(props, val, op, selectedIndex);
            handleValuesChange(val);
          }
        }, dropdownCommonProps), {
          children: children
        }))) : /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({}, __assign$2(__assign$2({
          multiple: props.multiple,
          options: formattedOptions[selectedIndex] || [],
          selectedValue: currentValues[selectedIndex] || 0,
          onOptionClick: function onOptionClick(val, op) {
            var _a;

            (_a = props.onOptionClick) === null || _a === void 0 ? void 0 : _a.call(props, val, op, selectedIndex);

            if (chooseAndClose) {
              handleShowDropdownChange(false, selectedIndex);
            }
          },
          onOptionChange: function onOptionChange(val, op) {
            var _a;

            (_a = props.onOptionChange) === null || _a === void 0 ? void 0 : _a.call(props, val, op, selectedIndex);
            handleValuesChange(val);
          }
        }, dropdownCommonProps), {
          children: children
        })))));
      });
    }

    /**
     * 下拉选择组件，点击选择器(select)展开下拉框(dropdown)，展示选择项(options)，兼容多个选择器的情况。
     * @en Dropdown component, click the selector (select) to expand the dropdown box (dropdown), display the options (options), compatible with multiple selectors.
     * @type 导航
     * @type_en Navigation
     * @name 下拉选择菜单
     * @name_en DropdownMenu
     */

    var DropdownMenu = componentGenerator$5(Dropdown$1);

    var isBrowser$1 = function isBrowser() {
      return typeof window !== 'undefined' && typeof document !== 'undefined';
    };
    /** Whether the environment support -webkit-line-clamp. */

    var isSupportWebkitLineClamp = function isSupportWebkitLineClamp() {
      return isBrowser$1() && typeof document.body.style.webkitLineClamp !== 'undefined';
    };

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index$i = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    function getLineHeight(element) {
      var style = window.getComputedStyle(element, null);
      var lineHeight = style.getPropertyValue('line-height');

      if (lineHeight === 'normal') {
        // Create a temp element to get line-height
        var dom = document.createElement('span');
        dom.style.width = '300px';
        dom.style.position = 'absolute';
        dom.style.visibility = 'hidden';
        dom.innerText = 'Test';
        element.appendChild(dom);
        var height = dom.clientHeight;
        element.removeChild(dom);
        return height;
      }

      return parseFloat(lineHeight);
    }

    function createSpan(text, className) {
      if (className === void 0) {
        className = '';
      }

      var span = document.createElement('span');
      span.className = className;
      span.textContent = text;
      return span;
    }

    function wrapTextChildNodesWithSpan(node, className) {
      var _a;

      if (className === void 0) {
        className = '';
      }

      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(createSpan(node.textContent, className), node);
        }
      } else {
        node.childNodes.forEach(function (item) {
          wrapTextChildNodesWithSpan(item, className);
        });
      }
    }

    var JsEllipsis = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var prefixCls = props.prefixCls,
          text = props.text,
          ellipsis = props.ellipsis,
          dangerouslyUseInnerHTML = props.dangerouslyUseInnerHTML,
          _a = props.maxLine,
          maxLine = _a === void 0 ? 1 : _a,
          maxHeight = props.maxHeight,
          ellipsisNode = props.ellipsisNode,
          collapseNode = props.collapseNode,
          endExcludes = props.endExcludes,
          reflowOnResize = props.reflowOnResize,
          onReflow = props.onReflow,
          onEllipsisNodeClick = props.onEllipsisNodeClick,
          onCollapseNodeClick = props.onCollapseNodeClick;
      var truncating = React.useRef(false);
      var domRef = React.useRef(null);
      var textRef = React.useRef(null);
      var ellipsisRef = React.useRef(null);
      var lineHeightRef = React.useRef(0);
      var setCurLineHeight = React.useCallback(function () {
        if (domRef.current) {
          lineHeightRef.current = getLineHeight(domRef.current);
        }
      }, []);
      React.useEffect(function () {
        setCurLineHeight();
      }, []);

      function handleOnReflow(isEllipsis, result) {
        if (onReflow && typeof onReflow === 'function') {
          onReflow(isEllipsis, result);
        }
      }

      function truncateText(container, textContainer, max) {
        var content = textContainer.textContent || '';
        var currentText = '';
        var l = 0;
        var r = content.length - 1; // Binary truncate text until get the max limit fragment of text.

        while (l < r) {
          var m = Math.floor((l + r) / 2);

          if (l === m) {
            break;
          }

          var temp = content.slice(l, m);
          textContainer.innerText = currentText + temp;
          var height = container.getBoundingClientRect().height;

          if (height > max) {
            r = m;
          } else {
            currentText += temp;
            l = m;
          }
        } // Remove the exclude char at the end of the content.


        while (endExcludes && endExcludes.includes(currentText[currentText.length - 1])) {
          currentText = currentText.slice(0, -1);
        } // Callback after reflow.


        handleOnReflow(true, currentText);
        textContainer.innerText = currentText;
      }

      function truncateHTML(container, textContainer, max) {
        // only enter this function when container overflow.
        var children = textContainer.childNodes;

        if (children.length === 1) {
          var node = children[0];

          if (node.nodeType === Node.TEXT_NODE) {
            truncateText(container, textContainer, max);
          } else {
            var html = node.innerHTML; // clear content to determine whether the empty node can be placed.

            node.innerHTML = '';
            var height = container.getBoundingClientRect().height;

            if (height > max) {
              // return after remove the node, if overflow with empty node.
              textContainer.removeChild(node);
              handleOnReflow(true, textContainer.innerHTML);
              return;
            }

            node.innerHTML = html; // recursive truncate node

            truncateHTML(container, node, max);
          }
        } else {
          var nodes = [].slice.call(children);
          textContainer.innerHTML = '';
          var i = 0; // find the critical node

          while (i < nodes.length) {
            textContainer.appendChild(nodes[i]);
            var height = container.getBoundingClientRect().height;

            if (height > max) {
              if (nodes[i].childNodes && nodes[i].childNodes.length) {
                break;
              } else {
                textContainer.removeChild(nodes[i]);
                handleOnReflow(true, textContainer.innerHTML);
                return;
              }
            }

            i++;
          }

          if (textContainer.childNodes[i]) {
            // truncate the critical node
            truncateHTML(container, textContainer.childNodes[i], max);
          }
        }
      } // reflow when the main props change.


      var reflow = React.useCallback(function () {
        if (!domRef.current || !textRef.current || !ellipsisRef.current || truncating.current) {
          return;
        }

        ellipsisRef.current.style.display = 'none';

        if (dangerouslyUseInnerHTML) {
          textRef.current.innerHTML = text;
          textRef.current.classList.add(prefixCls + "-js-content-text-pre");
        } else {
          textRef.current.innerText = text;
        }

        if (!ellipsis) {
          return;
        }

        textRef.current.classList.remove(prefixCls + "-js-content-text-pre");
        var height = domRef.current.getBoundingClientRect().height;
        var max = isNaN(Number(maxHeight)) ? lineHeightRef.current * maxLine : Number(maxHeight);

        if (height <= max) {
          handleOnReflow(false, text);
          return;
        }

        truncating.current = true;
        ellipsisRef.current.style.display = 'inline';

        if (dangerouslyUseInnerHTML) {
          // wrap the text children node with span element.
          wrapTextChildNodesWithSpan(textRef.current, prefixCls + "-js-content-text");
          truncateHTML(domRef.current, textRef.current, max);
        } else {
          truncateText(domRef.current, textRef.current, max);
        }

        truncating.current = false;
      }, [text, ellipsis, dangerouslyUseInnerHTML, maxLine, maxHeight, ellipsisNode, endExcludes]);
      React.useEffect(function () {
        reflow();
      }, [reflow]);
      var observerRef = React.useRef(null); // Observe resize event of container if reflowOnResize is true.

      React.useEffect(function () {
        if (domRef.current && reflowOnResize) {
          if (!observerRef.current && ellipsis) {
            observerRef.current = new index$i(reflow);
            observerRef.current.observe(domRef.current);
          }
        }

        return function () {
          // Remove observer when component unmounted.
          if (observerRef.current && domRef.current) {
            observerRef.current.unobserve(domRef.current);
            observerRef.current = null;
          }
        };
      }, [ellipsis]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          reflow: reflow
        };
      }, [reflow]);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        ref: domRef,
        className: prefixCls + "-js"
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        ref: textRef,
        className: prefixCls + "-js-content"
      }, dangerouslyUseInnerHTML ? /*#__PURE__*/React__default["default"].createElement("span", {
        className: prefixCls + "-js-content-initial",
        style: {
          WebkitLineClamp: maxLine
        },
        dangerouslySetInnerHTML: {
          __html: text
        }
      }) : /*#__PURE__*/React__default["default"].createElement("span", {
        className: prefixCls + "-js-content-initial",
        style: {
          WebkitLineClamp: maxLine
        }
      }, text)), /*#__PURE__*/React__default["default"].createElement("span", {
        ref: ellipsisRef,
        className: prefixCls + "-js-content-ellipsis",
        onClick: onEllipsisNodeClick
      }, ellipsisNode), !ellipsis && collapseNode && /*#__PURE__*/React__default["default"].createElement("span", {
        className: prefixCls + "-js-content-collapse",
        onClick: onCollapseNodeClick
      }, collapseNode));
    });
    var JsEllipsis$1 = /*#__PURE__*/React__default["default"].memo(JsEllipsis);

    function NativeEllipsis(_a) {
      var prefixCls = _a.prefixCls,
          ellipsis = _a.ellipsis,
          dangerouslyUseInnerHTML = _a.dangerouslyUseInnerHTML,
          text = _a.text,
          maxLine = _a.maxLine,
          ellipsisNode = _a.ellipsisNode,
          _b = _a.collapseNode,
          collapseNode = _b === void 0 ? '' : _b,
          onEllipsisNodeClick = _a.onEllipsisNodeClick,
          onCollapseNodeClick = _a.onCollapseNodeClick;
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-native", {
          ellipsis: ellipsis
        }),
        style: {
          WebkitLineClamp: maxLine
        }
      }, dangerouslyUseInnerHTML ?
      /*#__PURE__*/
      // eslint-disable-next-line react/no-danger,@typescript-eslint/naming-convention
      React__default["default"].createElement("span", {
        dangerouslySetInnerHTML: {
          __html: text
        }
      }) : /*#__PURE__*/React__default["default"].createElement("span", null, text), !ellipsis && collapseNode && /*#__PURE__*/React__default["default"].createElement("span", {
        onClick: onCollapseNodeClick,
        className: cls(prefixCls + "-native-collapse")
      }, collapseNode), ellipsis && (ellipsisNode !== '...' || onEllipsisNodeClick) ? /*#__PURE__*/React__default["default"].createElement("span", {
        onClick: onEllipsisNodeClick,
        className: cls(prefixCls + "-native-ellipsis-node")
      }, ellipsisNode) : null);
    }

    var NativeEllipsis$1 = /*#__PURE__*/React__default["default"].memo(NativeEllipsis);

    /**
     * 文本缩略组件，支持多行缩略、富文本、自定义缩略符、尾字符过滤等。
     * @en Text ellipsis component supports multi-line abbreviations, rich text, custom abbreviations, tail character filtering, etc.
     * @type 信息展示
     * @type_en Data Display
     * @name 文本缩略
     * @name_en Ellipsis
     */

    var Ellipsis = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          text = props.text,
          dangerouslyUseInnerHTML = props.dangerouslyUseInnerHTML,
          _a = props.maxLine,
          maxLine = _a === void 0 ? 1 : _a,
          maxHeight = props.maxHeight,
          _b = props.ellipsis,
          ellipsis = _b === void 0 ? true : _b,
          _c = props.ellipsisNode,
          ellipsisNode = _c === void 0 ? '...' : _c,
          _d = props.collapseNode,
          collapseNode = _d === void 0 ? '' : _d,
          endExcludes = props.endExcludes,
          _e = props.reflowOnResize,
          reflowOnResize = _e === void 0 ? false : _e,
          _f = props.floatEllipsisNode,
          floatEllipsisNode = _f === void 0 ? false : _f,
          onReflow = props.onReflow,
          onCollapseNodeClick = props.onCollapseNodeClick,
          onEllipsisNodeClick = props.onEllipsisNodeClick;
      var domRef = React.useRef(null);
      var jsEllipsisRef = React.useRef(null);
      var useNativeEllipsis = isSupportWebkitLineClamp() && maxHeight === void 0 && (!endExcludes || endExcludes.length === 0) && !onReflow && (floatEllipsisNode || ellipsisNode === '...' && !onEllipsisNodeClick);
      React.useImperativeHandle(ref, function () {
        var _a;

        return {
          dom: domRef.current,
          reflow: (_a = jsEllipsisRef === null || jsEllipsisRef === void 0 ? void 0 : jsEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.reflow
        };
      });
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-ellipsis", className),
          ref: domRef
        }, useNativeEllipsis ? /*#__PURE__*/React__default["default"].createElement(NativeEllipsis$1, {
          prefixCls: prefixCls + "-ellipsis",
          ellipsis: ellipsis,
          dangerouslyUseInnerHTML: dangerouslyUseInnerHTML,
          text: text,
          maxLine: maxLine,
          ellipsisNode: ellipsisNode,
          collapseNode: collapseNode,
          onEllipsisNodeClick: onEllipsisNodeClick,
          onCollapseNodeClick: onCollapseNodeClick
        }) : /*#__PURE__*/React__default["default"].createElement(JsEllipsis$1, {
          ref: jsEllipsisRef,
          prefixCls: prefixCls + "-ellipsis",
          text: text,
          ellipsis: ellipsis,
          dangerouslyUseInnerHTML: dangerouslyUseInnerHTML,
          maxLine: maxLine,
          maxHeight: maxHeight,
          ellipsisNode: ellipsisNode,
          collapseNode: collapseNode,
          endExcludes: endExcludes,
          reflowOnResize: reflowOnResize,
          onReflow: onReflow,
          onEllipsisNodeClick: onEllipsisNodeClick,
          onCollapseNodeClick: onCollapseNodeClick
        }));
      });
    });

    var defaultFunc = function defaultFunc() {};

    var defaultFormDataMethods = {
      getFieldValue: function getFieldValue(name) {
        return name;
      },
      getFieldsValue: function getFieldsValue(_names) {
        return {};
      },
      getFieldError: function getFieldError(_name) {
        return [];
      },
      setFieldValue: function setFieldValue(_name, _value) {
        return true;
      },
      setFieldsValue: function setFieldsValue(_values) {
        return true;
      },
      registerField: function registerField(_name, _self) {
        return function () {};
      },
      resetFields: defaultFunc,
      validateFields: defaultFunc,
      submit: defaultFunc,
      getInternalHooks: function getInternalHooks() {
        return {
          registerField: defaultFunc,
          setInitialValues: defaultFunc,
          setCallbacks: defaultFunc
        };
      }
    }; // 在field的静态的状态下设置

    var FormData =
    /** @class */
    function () {
      function FormData() {
        var _this = this;

        this._formData = {}; // 数据源

        this._fieldsList = {}; // 字段列表

        this._initialValues = {}; // 初始值

        this._callbacks = {};

        this.setFieldsValue = function (values) {
          _this._formData = __assign$2(__assign$2({}, _this._formData), values);

          _this.notifyField(values);

          Object.keys(values).forEach(function (key) {
            var _a;

            if (key in _this._fieldsList) {
              (_a = _this._fieldsList[key]) === null || _a === void 0 ? void 0 : _a.onValueChange();
            }
          });
          return true;
        };

        this.setFieldValue = function (name, value) {
          var _a, _b, _c;

          _this._formData = __assign$2(__assign$2({}, _this._formData), (_a = {}, _a[name] = value, _a));
          var onValuesChange = _this._callbacks.onValuesChange;
          onValuesChange && onValuesChange((_b = {}, _b[name] = value, _b), _this._formData);

          _this.notifyField((_c = {}, _c[name] = value, _c));

          return true;
        };

        this.notifyField = function (values) {
          Object.keys(values).map(function (fieldName) {
            var _a;

            var fieldObj = ((_a = _this._fieldsList) === null || _a === void 0 ? void 0 : _a[fieldName]) || null;

            if (fieldObj) {
              fieldObj.onValueChange(values[fieldName]);
            }
          });
        };

        this.getFieldsValue = function (names) {
          if (names) {
            return names.map(function (name) {
              return _this.getFieldValue(name);
            });
          }

          return _this._formData;
        };

        this.getFieldValue = function (name) {
          var _a;

          return (_a = _this._formData) === null || _a === void 0 ? void 0 : _a[name];
        };

        this.getFieldError = function (name) {
          var _a;

          var field = ((_a = _this._fieldsList) === null || _a === void 0 ? void 0 : _a[name]) || null;

          if (field) {
            return field.getFieldError();
          }

          return [];
        };

        this.getFieldsError = function (names) {
          var fields = names || Object.keys(_this._fieldsList);
          return fields.reduce(function (pre, name) {
            var _a;

            var theField = (_a = _this._fieldsList) === null || _a === void 0 ? void 0 : _a[name];

            if (theField) {
              pre[name] = theField === null || theField === void 0 ? void 0 : theField.getFieldError();
            }

            return pre;
          }, {});
        };

        this.isFieldTouched = function (name) {
          var _a;

          var field = ((_a = _this._fieldsList) === null || _a === void 0 ? void 0 : _a[name]) || null;

          if (field) {
            return field.isFieldTouched();
          }

          return false;
        };

        this.registerField = function (name, self) {
          var _a, _b;

          _this._fieldsList[name] = self;
          var initialValue = self.props.initialValue;

          if (initialValue !== undefined && name) {
            _this._initialValues = __assign$2(__assign$2({}, _this._initialValues), (_a = {}, _a[name] = initialValue, _a));

            _this.setFieldsValue(__assign$2(__assign$2({}, _this._formData), (_b = {}, _b[name] = initialValue, _b)));
          }

          return function () {
            if (name in _this._fieldsList) {
              delete _this._fieldsList[name];
              delete _this._formData[name];
            }
          };
        };

        this.setInitialValues = function (initVal) {
          _this._initialValues = __assign$2({}, initVal || {});

          _this.setFieldsValue(initVal);
        };

        this.resetFields = function () {
          _this.setFieldsValue(_this._initialValues);
        };

        this.validateFields = function () {
          var promiseList = [];
          Object.values(_this._fieldsList).forEach(function (entity) {
            var promise = entity.validateField();
            promiseList.push(promise.then(function (errors) {
              return errors;
            }));
          });
          var summaryPromise = new Promise(function (resolve, reject) {
            Promise.all(promiseList).then(function (res) {
              var errorResults = res.filter(function (item) {
                var _a;

                return (_a = item === null || item === void 0 ? void 0 : item.errors) === null || _a === void 0 ? void 0 : _a.length;
              });

              if (errorResults.length) {
                reject(errorResults);
              } else {
                resolve(res);
              }
            });
          });
          return summaryPromise;
        };

        this.submit = function () {
          return __awaiter(_this, void 0, void 0, function () {
            var _this = this;

            return __generator(this, function (_a) {
              this.validateFields().then(function (result) {
                var onSubmit = _this._callbacks.onSubmit;
                onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(_this._formData, result);
              }).catch(function (e) {
                var onSubmitFailed = _this._callbacks.onSubmitFailed;

                if (!onSubmitFailed) {
                  return;
                }

                onSubmitFailed(_this._formData, e);
              });
              return [2
              /*return*/
              ];
            });
          });
        };

        this.setCallbacks = function (callbacks) {
          _this._callbacks = callbacks;
        };

        this.getMethods = function () {
          return {
            setFieldsValue: _this.setFieldsValue,
            setFieldValue: _this.setFieldValue,
            getFieldsValue: _this.getFieldsValue,
            getFieldValue: _this.getFieldValue,
            getFieldError: _this.getFieldError,
            getFieldsError: _this.getFieldsError,
            isFieldTouched: _this.isFieldTouched,
            registerField: _this.registerField,
            resetFields: _this.resetFields,
            submit: _this.submit,
            getInternalHooks: _this.getInternalHooks,
            validateFields: _this.validateFields
          };
        };

        this.getInternalHooks = function () {
          return {
            registerField: _this.registerField,
            setInitialValues: _this.setInitialValues,
            setCallbacks: _this.setCallbacks
          };
        };
      }

      return FormData;
    }();

    function useForm(form) {
      var formInstanceRef = React.useRef(defaultFormDataMethods);
      var isSingletonRef = React.useRef(false);

      if (!isSingletonRef.current) {
        if (form) {
          formInstanceRef.current = form;
        } else {
          var formIns = new FormData();
          formInstanceRef.current = formIns.getMethods();
        }

        isSingletonRef.current = true;
      }

      return [formInstanceRef.current];
    }

    var FormItemContext = /*#__PURE__*/React__default["default"].createContext({
      form: defaultFormDataMethods,
      layout: 'horizontal'
    });

    // 注意：自动识别form关联组件的依据，请勿轻易改变代码结构
    // Notice: Automatically identify the basis of the associated component of the form, DO NOT change the code structure.
    var FormInternalComponentType;

    (function (FormInternalComponentType) {
      FormInternalComponentType["Input"] = "Input";
      FormInternalComponentType["Textarea"] = "Textarea";
      FormInternalComponentType["Checkbox"] = "Checkbox";
      FormInternalComponentType["CheckboxGroup"] = "CheckboxGroup";
      FormInternalComponentType["DatePicker"] = "DatePicker";
      FormInternalComponentType["Picker"] = "Picker";
      FormInternalComponentType["Radio"] = "Radio";
      FormInternalComponentType["RadioGroup"] = "RadioGroup";
      FormInternalComponentType["Slider"] = "Slider";
      FormInternalComponentType["Switch"] = "Switch";
      FormInternalComponentType["ImagePicker"] = "ImagePicker";
      FormInternalComponentType["Rate"] = "Rate";
      FormInternalComponentType["Stepper"] = "Stepper";
    })(FormInternalComponentType || (FormInternalComponentType = {}));

    var ValidateStatus;

    (function (ValidateStatus) {
      ValidateStatus["Init"] = "init";
      ValidateStatus["Error"] = "error";
      ValidateStatus["Warning"] = "warning";
      ValidateStatus["Validating"] = "validating";
      ValidateStatus["Success"] = "success";
    })(ValidateStatus || (ValidateStatus = {}));

    var isFieldRequired = function isFieldRequired(rules) {
      if (rules === void 0) {
        rules = [];
      }

      return (rules || []).some(function (rule) {
        return rule === null || rule === void 0 ? void 0 : rule.required;
      });
    };
    var getErrorAndWarnings = function getErrorAndWarnings(result) {
      var errors = [];
      var warnings = [];
      var errorTypes = [];
      result.map(function (_a) {
        var _b = _a.message,
            message = _b === void 0 ? [] : _b,
            _c = _a.validateLevel,
            validateLevel = _c === void 0 ? 'error' : _c,
            resultErrorTypes = _a.errorTypes;

        if (!(message === null || message === void 0 ? void 0 : message.length)) {
          return;
        }

        if (validateLevel === 'warning') {
          warnings = __spreadArrays$1(warnings, message);
        } else {
          errors = __spreadArrays$1(errors, message);
          errorTypes = __spreadArrays$1(errorTypes, resultErrorTypes);
        }
      });
      return {
        warnings: warnings,
        errors: errors,
        errorTypes: errorTypes
      };
    };

    var FormItemInner =
    /** @class */
    function (_super) {
      __extends$1(FormItemInner, _super);

      function FormItemInner(props, context) {
        var _a;

        var _this = _super.call(this, props) || this;

        _this._errors = [];
        _this._touched = false;

        _this.onValueChange = function (preStore, curStore) {
          _this._touched = true;
          var shouldUpdate = _this.props.shouldUpdate;

          if (typeof shouldUpdate === 'function') {
            shouldUpdate({
              preStore: preStore,
              curStore: curStore
            }) && _this.forceUpdate();
            return;
          }

          _this.forceUpdate();
        };

        _this.getFieldError = function () {
          return _this._errors;
        };

        _this.isFieldTouched = function () {
          return _this._touched;
        };

        _this.validateField = function () {
          var _a;

          var validateMessages = _this.context.validateMessages;
          var getFieldValue = _this.context.form.getFieldValue;
          var _b = _this.props,
              field = _b.field,
              rules = _b.rules,
              onValidateStatusChange = _b.onValidateStatusChange;
          var value = getFieldValue(field);

          if ((rules === null || rules === void 0 ? void 0 : rules.length) && field) {
            var fieldDom_1 = _this.props.getFormItemRef();

            var fieldValidator_1 = new Validator((_a = {}, _a[field] = rules, _a), {
              validateMessages: validateMessages
            });
            return new Promise(function (resolve) {
              var _a;

              fieldValidator_1.validate((_a = {}, _a[field] = value, _a), function (errorsMap) {
                var _a = getErrorAndWarnings((errorsMap === null || errorsMap === void 0 ? void 0 : errorsMap[field]) || []),
                    errors = _a.errors,
                    warnings = _a.warnings,
                    errorTypes = _a.errorTypes;

                _this._errors = errors;
                onValidateStatusChange({
                  errors: _this._errors,
                  warnings: warnings,
                  errorTypes: errorTypes
                });
                return resolve({
                  errors: _this._errors,
                  warnings: warnings,
                  value: value,
                  field: field,
                  dom: fieldDom_1
                });
              });
            });
          }

          return Promise.resolve({
            errors: [],
            warnings: [],
            value: value,
            field: field,
            dom: null
          });
        };

        _this.setFieldData = function (value) {
          var field = _this.props.field;
          var setFieldValue = _this.context.form.setFieldValue;
          setFieldValue(field, value);

          _this.validateField();
        };

        _this.innerTriggerFunction = function (_, value) {
          var _a, _b;

          var args = [];

          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }

          _this.setFieldData(value);

          var _c = _this.props,
              children = _c.children,
              _d = _c.trigger,
              trigger = _d === void 0 ? 'onChange' : _d;

          if (trigger && ((_a = children.props) === null || _a === void 0 ? void 0 : _a[trigger])) {
            (_b = children.props) === null || _b === void 0 ? void 0 : _b[trigger].apply(_b, __spreadArrays$1([_, value], args));
          }
        };

        _this.innerTriggerFunctionWithValueFirst = function (value) {
          var _a, _b;

          var args = [];

          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }

          _this.setFieldData(value);

          var _c = _this.props,
              children = _c.children,
              _d = _c.trigger,
              trigger = _d === void 0 ? 'onChange' : _d;

          if (trigger && ((_a = children.props) === null || _a === void 0 ? void 0 : _a[trigger])) {
            (_b = children.props) === null || _b === void 0 ? void 0 : _b[trigger].apply(_b, __spreadArrays$1([value], args));
          }
        };

        _this.innerClearFunction = function () {
          var _a, _b;

          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          var children = _this.props.children;

          _this.setFieldData('');

          if ((_a = children.props) === null || _a === void 0 ? void 0 : _a.onClear) {
            (_b = children.props) === null || _b === void 0 ? void 0 : _b.onClear.apply(_b, args);
          }
        };

        _this.destroyField = function () {};

        if ((props === null || props === void 0 ? void 0 : props.initialValue) && props.field) {
          var setInitialValues = context.form.getInternalHooks().setInitialValues;
          setInitialValues((_a = {}, _a[props.field] = props.initialValue, _a));
        }

        return _this;
      }

      FormItemInner.prototype.componentDidMount = function () {
        var registerField = this.context.form.getInternalHooks().registerField;
        this.destroyField = registerField(this.props.field, this);
      };

      FormItemInner.prototype.componentWillUnmount = function () {
        this.destroyField();
      };

      FormItemInner.prototype.renderChildren = function () {
        var _a;

        var _this = this;

        var _b;

        var _c = this.props,
            children = _c.children,
            field = _c.field,
            _d = _c.trigger,
            trigger = _d === void 0 ? 'onChange' : _d,
            _e = _c.triggerPropsField,
            triggerPropsField = _e === void 0 ? 'value' : _e,
            displayType = _c.displayType;
        var getFieldValue = this.context.form.getFieldValue;
        var props = (_a = {}, _a[triggerPropsField] = getFieldValue(field), _a.disabled = this.props.disabled, _a);
        var childrenType = displayType || ((_b = children.type) === null || _b === void 0 ? void 0 : _b.displayName);

        switch (childrenType) {
          case FormInternalComponentType.Input:
          case FormInternalComponentType.Textarea:
            props = {
              value: getFieldValue(field) || '',
              onInput: this.innerTriggerFunction,
              onClear: this.innerClearFunction,
              disabled: this.props.disabled
            };
            break;

          case FormInternalComponentType.Checkbox:
          case FormInternalComponentType.Radio:
          case FormInternalComponentType.Slider:
          case FormInternalComponentType.RadioGroup:
          case FormInternalComponentType.CheckboxGroup:
            props = {
              value: getFieldValue(field),
              onChange: this.innerTriggerFunctionWithValueFirst,
              disabled: this.props.disabled
            };
            break;

          case FormInternalComponentType.DatePicker:
            props = {
              currentTs: getFieldValue(field),
              onChange: this.innerTriggerFunction,
              disabled: this.props.disabled
            };
            break;

          case FormInternalComponentType.Picker:
            props = {
              data: getFieldValue(field),
              onPickerChange: this.innerTriggerFunction,
              disabled: this.props.disabled
            };
            break;

          case FormInternalComponentType.Switch:
            props = {
              checked: Boolean(getFieldValue(field)),
              onChange: this.innerTriggerFunctionWithValueFirst,
              disabled: this.props.disabled
            };
            break;

          case FormInternalComponentType.ImagePicker:
            props = {
              images: getFieldValue(field),
              onChange: this.innerTriggerFunctionWithValueFirst,
              disabled: this.props.disabled
            };
            break;

          default:
            var originTrigger_1 = children.props[trigger]; // inject the validated result

            props.error = this._errors;

            props[trigger] = function (newValue) {
              var args = [];

              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }

              _this.setFieldData(newValue);

              originTrigger_1 && originTrigger_1.apply(void 0, __spreadArrays$1([newValue], args));
            };

        }

        return /*#__PURE__*/React__default["default"].cloneElement(children, props);
      };

      FormItemInner.prototype.render = function () {
        return this.renderChildren();
      };

      return FormItemInner;
    }(React.PureComponent);

    FormItemInner.contextType = FormItemContext;
    var Item$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var label = props.label,
          field = props.field,
          _b = props.disabled,
          disabled = _b === void 0 ? false : _b,
          itemLayout = props.layout,
          style = props.style,
          extra = props.extra,
          requiredIcon = props.requiredIcon,
          rules = props.rules,
          _c = props.className,
          className = _c === void 0 ? '' : _c,
          rest = __rest$1(props, ["label", "field", "disabled", "layout", "style", "extra", "requiredIcon", "rules", "className"]);

      var prefixCls = React.useContext(GlobalContext).prefixCls;

      var _d = React.useContext(FormItemContext),
          layout = _d.layout,
          propsDisabled = _d.disabled;

      var _e = React.useState(null),
          errors = _e[0],
          setErrors = _e[1];

      var _f = React.useState(null),
          errorTypes = _f[0],
          setErrorTypes = _f[1];

      var _g = React.useState([]),
          warnings = _g[0],
          setWarnings = _g[1];

      var formItemRef = React.useRef(null);

      var onValidateStatusChange = function onValidateStatusChange(validateResult) {
        var _errors = validateResult.errors,
            _warnings = validateResult.warnings,
            _errorTypes = validateResult.errorTypes;
        setErrors(_errors.length ? _errors[0] : null);
        setErrorTypes(_errorTypes.length ? _errorTypes[0] : null);
        setWarnings(_warnings);
      };

      var getFormItemRef = function getFormItemRef() {
        return formItemRef.current;
      };

      var fieldDisabled = disabled || propsDisabled;
      var fieldRules = (rest === null || rest === void 0 ? void 0 : rest.required) ? __spreadArrays$1([{
        type: ValidatorType.String,
        required: true
      }], rules || []) : rules;
      var isRequired = isFieldRequired(rules) || (rest === null || rest === void 0 ? void 0 : rest.required);
      React.useImperativeHandle(ref, function () {
        return {
          dom: formItemRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-form-item", prefixCls + "-form-item-" + (itemLayout || layout), className, (_a = {
          disabled: fieldDisabled
        }, _a[prefixCls + "-form-item-error"] = !!errors, _a[prefixCls + "-form-item-warning"] = Boolean(!errors && warnings), _a[prefixCls + "-form-item-error-" + errorTypes] = errorTypes, _a)),
        style: style,
        ref: formItemRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-form-label-item")
      }, isRequired ? requiredIcon || /*#__PURE__*/React__default["default"].createElement("span", {
        className: cls(prefixCls + "-form-label-item-required-asterisk")
      }, "*") : null, label), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-form-item-control-wrapper")
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-form-item-control")
      }, /*#__PURE__*/React__default["default"].createElement(FormItemInner, __assign$2({}, rest, {
        rules: fieldRules,
        disabled: fieldDisabled,
        field: field,
        onValidateStatusChange: onValidateStatusChange,
        getFormItemRef: getFormItemRef
      }))), errors && /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-form-item-message " + prefixCls + "-form-item-error-message")
      }, errors), (warnings || []).map(function (node, key) {
        return typeof node === 'string' ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-form-item-message " + prefixCls + "-form-item-warning-message"),
          key: key
        }, node) : node;
      })), extra);
    });

    var Form = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.layout,
          layout = _b === void 0 ? 'horizontal' : _b,
          initialValues = props.initialValues,
          formInstance = props.form,
          children = props.children,
          onValuesChange = props.onValuesChange,
          onSubmit = props.onSubmit,
          onSubmitFailed = props.onSubmitFailed,
          disabled = props.disabled;
      var domRef = React.useRef(null);
      var form = useForm(formInstance)[0];

      var _c = form.getInternalHooks(),
          setCallbacks = _c.setCallbacks,
          setInitialValues = _c.setInitialValues;

      setCallbacks({
        onValuesChange: onValuesChange,
        onSubmit: onSubmit,
        onSubmitFailed: onSubmitFailed
      });
      React.useEffect(function () {
        setInitialValues(initialValues || {});
      }, []);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          form: form
        };
      });
      var contextValue = {
        form: form,
        layout: layout,
        disabled: disabled
      };
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls,
            _b = _a.locale,
            locale = _b === void 0 ? defaultLocale : _b;
        return /*#__PURE__*/React__default["default"].createElement("form", {
          className: prefixCls + "-form " + className,
          style: style,
          ref: domRef,
          onSubmit: function onSubmit(e) {
            e.preventDefault();
            e.stopPropagation();
            form.submit();
          }
        }, /*#__PURE__*/React__default["default"].createElement(FormItemContext.Provider, {
          value: __assign$2(__assign$2({}, contextValue), {
            validateMessages: (locale === null || locale === void 0 ? void 0 : locale.Form) || {}
          })
        }, children));
      });
    });
    /**
     * 表单组件用于集合数据录入
     * @en Form, Form for collecting data input
     * @type 数据录入
     * @type_en Data Entry
     * @name 表单
     * @name_en Form
     */

    var index$h = componentWrapper(Form, {
      Item: Item$1
    });

    /**
     * 宫格可以在水平方向上把页面分隔成等宽度的区块，用于展示内容或进行页面导航。
     * @en The grid can divide the page into equal-width blocks in the horizontal direction for displaying content or for page navigation.
     * @type 布局
     * @type_en Layout
     * @name 宫格
     * @name_en Grid
     */

    var Grid = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          data = props.data,
          _b = props.columns,
          columns = _b === void 0 ? 3 : _b,
          _c = props.border,
          border = _c === void 0 ? false : _c,
          _d = props.gutter,
          gutter = _d === void 0 ? 0 : _d,
          _e = props.shape,
          shape = _e === void 0 ? 'square' : _e,
          _f = props.direction,
          direction = _f === void 0 ? 'vertical' : _f,
          _g = props.isSliding,
          isSliding = _g === void 0 ? false : _g;
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var getRows = function getRows(prefix, rowsData, rows, row) {
        var placeholders = !isSliding && rowsData.length % columns;
        var renderData = rowsData;

        if (placeholders) {
          var fakeGrids = new Array(columns - placeholders).fill({
            img: null,
            title: ''
          });
          renderData = rowsData.concat(fakeGrids);
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-rows",
          key: row
        }, renderData.map(function (item, index) {
          var img = item.img,
              title = item.title,
              content = item.content,
              itemClassName = item.className,
              _onClick = item.onClick,
              itemStyle = item.itemStyle,
              renderGrid = item.renderGrid;

          if (renderGrid) {
            return renderGrid(item, index, row);
          }

          var marginBottom = row + 1 === rows ? 0 : typeof gutter === 'number' ? gutter : (gutter === null || gutter === void 0 ? void 0 : gutter.y) || 0;
          var rowLen = renderData.length;
          var marginRight = index + 1 === rowLen ? 0 : typeof gutter === 'number' ? gutter : (gutter === null || gutter === void 0 ? void 0 : gutter.x) || 0;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            key: index,
            style: __assign$2({
              marginBottom: marginBottom,
              marginRight: marginRight
            }, itemStyle),
            onClick: function onClick() {
              _onClick && _onClick(item);
            },
            className: cls(prefix + "-rows-item", {
              horizontal: direction === 'horizontal',
              border: border && gutter === 0
            }, itemClassName)
          }, typeof img === 'string' ? /*#__PURE__*/React__default["default"].createElement("img", {
            src: img,
            className: prefix + "-rows-item-icon " + (shape === 'circle' ? 'circle' : '')
          }) : img, title || content ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: prefix + "-rows-item-text"
          }, title ? /*#__PURE__*/React__default["default"].createElement("span", {
            className: prefix + "-rows-item-title"
          }, title) : null, content ? /*#__PURE__*/React__default["default"].createElement("span", {
            className: prefix + "-rows-item-content"
          }, content) : null) : null, (index + 1) % columns !== 0 ? /*#__PURE__*/React__default["default"].createElement("i", {
            className: "vertical-border"
          }) : null, (row + 1) % rows !== 0 ? /*#__PURE__*/React__default["default"].createElement("i", {
            className: "horizontal-border"
          }) : null);
        }));
      };

      var getGrid = function getGrid(prefix, dataArr) {
        var rows = dataArr.length || 1;
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, dataArr.map(function (item, index) {
          return getRows(prefix, item, rows, index);
        }));
      };

      var renderEl = function renderEl(_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-grid";
        var dataLength = (data === null || data === void 0 ? void 0 : data.length) || 0;

        if (dataLength === 0) {
          return null;
        }

        var index = 0;
        var newArr = [];

        while (index < dataLength) {
          newArr.push(data.slice(index, isSliding ? index += dataLength : index += columns));
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix, className, isSliding ? 'sliding' : ''),
          style: style,
          ref: domRef
        }, getGrid(prefix, newArr));
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderEl);
    });

    var es6Promise = createCommonjsModule(function (module, exports) {
    /*!
     * @overview es6-promise - a tiny implementation of Promises/A+.
     * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
     * @license   Licensed under MIT license
     *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
     * @version   v4.2.8+1e68dce6
     */

    (function (global, factory) {
    	module.exports = factory() ;
    }(commonjsGlobal, (function () {
    function objectOrFunction(x) {
      var type = typeof x;
      return x !== null && (type === 'object' || type === 'function');
    }

    function isFunction(x) {
      return typeof x === 'function';
    }



    var _isArray = void 0;
    if (Array.isArray) {
      _isArray = Array.isArray;
    } else {
      _isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    }

    var isArray = _isArray;

    var len = 0;
    var vertxNext = void 0;
    var customSchedulerFn = void 0;

    var asap = function asap(callback, arg) {
      queue[len] = callback;
      queue[len + 1] = arg;
      len += 2;
      if (len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (customSchedulerFn) {
          customSchedulerFn(flush);
        } else {
          scheduleFlush();
        }
      }
    };

    function setScheduler(scheduleFn) {
      customSchedulerFn = scheduleFn;
    }

    function setAsap(asapFn) {
      asap = asapFn;
    }

    var browserWindow = typeof window !== 'undefined' ? window : undefined;
    var browserGlobal = browserWindow || {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

    // node
    function useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function () {
        return process.nextTick(flush);
      };
    }

    // vertx
    function useVertxTimer() {
      if (typeof vertxNext !== 'undefined') {
        return function () {
          vertxNext(flush);
        };
      }

      return useSetTimeout();
    }

    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function () {
        node.data = iterations = ++iterations % 2;
      };
    }

    // web worker
    function useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = flush;
      return function () {
        return channel.port2.postMessage(0);
      };
    }

    function useSetTimeout() {
      // Store setTimeout reference so es6-promise will be unaffected by
      // other code modifying setTimeout (like sinon.useFakeTimers())
      var globalSetTimeout = setTimeout;
      return function () {
        return globalSetTimeout(flush, 1);
      };
    }

    var queue = new Array(1000);
    function flush() {
      for (var i = 0; i < len; i += 2) {
        var callback = queue[i];
        var arg = queue[i + 1];

        callback(arg);

        queue[i] = undefined;
        queue[i + 1] = undefined;
      }

      len = 0;
    }

    function attemptVertx() {
      try {
        var vertx = Function('return this')().require('vertx');
        vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return useVertxTimer();
      } catch (e) {
        return useSetTimeout();
      }
    }

    var scheduleFlush = void 0;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (isNode) {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else if (isWorker) {
      scheduleFlush = useMessageChannel();
    } else if (browserWindow === undefined && typeof commonjsRequire === 'function') {
      scheduleFlush = attemptVertx();
    } else {
      scheduleFlush = useSetTimeout();
    }

    function then(onFulfillment, onRejection) {
      var parent = this;

      var child = new this.constructor(noop);

      if (child[PROMISE_ID] === undefined) {
        makePromise(child);
      }

      var _state = parent._state;


      if (_state) {
        var callback = arguments[_state - 1];
        asap(function () {
          return invokeCallback(_state, child, callback, parent._result);
        });
      } else {
        subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }

    /**
      `Promise.resolve` returns a promise that will become resolved with the
      passed `value`. It is shorthand for the following:

      ```javascript
      let promise = new Promise(function(resolve, reject){
        resolve(1);
      });

      promise.then(function(value){
        // value === 1
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      let promise = Promise.resolve(1);

      promise.then(function(value){
        // value === 1
      });
      ```

      @method resolve
      @static
      @param {Any} value value that the returned promise will be resolved with
      Useful for tooling.
      @return {Promise} a promise that will become fulfilled with the given
      `value`
    */
    function resolve$1(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(noop);
      resolve(promise, object);
      return promise;
    }

    var PROMISE_ID = Math.random().toString(36).substring(2);

    function noop() {}

    var PENDING = void 0;
    var FULFILLED = 1;
    var REJECTED = 2;

    function selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
      try {
        then$$1.call(value, fulfillmentHandler, rejectionHandler);
      } catch (e) {
        return e;
      }
    }

    function handleForeignThenable(promise, thenable, then$$1) {
      asap(function (promise) {
        var sealed = false;
        var error = tryThen(then$$1, thenable, function (value) {
          if (sealed) {
            return;
          }
          sealed = true;
          if (thenable !== value) {
            resolve(promise, value);
          } else {
            fulfill(promise, value);
          }
        }, function (reason) {
          if (sealed) {
            return;
          }
          sealed = true;

          reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          reject(promise, error);
        }
      }, promise);
    }

    function handleOwnThenable(promise, thenable) {
      if (thenable._state === FULFILLED) {
        fulfill(promise, thenable._result);
      } else if (thenable._state === REJECTED) {
        reject(promise, thenable._result);
      } else {
        subscribe(thenable, undefined, function (value) {
          return resolve(promise, value);
        }, function (reason) {
          return reject(promise, reason);
        });
      }
    }

    function handleMaybeThenable(promise, maybeThenable, then$$1) {
      if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
        handleOwnThenable(promise, maybeThenable);
      } else {
        if (then$$1 === undefined) {
          fulfill(promise, maybeThenable);
        } else if (isFunction(then$$1)) {
          handleForeignThenable(promise, maybeThenable, then$$1);
        } else {
          fulfill(promise, maybeThenable);
        }
      }
    }

    function resolve(promise, value) {
      if (promise === value) {
        reject(promise, selfFulfillment());
      } else if (objectOrFunction(value)) {
        var then$$1 = void 0;
        try {
          then$$1 = value.then;
        } catch (error) {
          reject(promise, error);
          return;
        }
        handleMaybeThenable(promise, value, then$$1);
      } else {
        fulfill(promise, value);
      }
    }

    function publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      publish(promise);
    }

    function fulfill(promise, value) {
      if (promise._state !== PENDING) {
        return;
      }

      promise._result = value;
      promise._state = FULFILLED;

      if (promise._subscribers.length !== 0) {
        asap(publish, promise);
      }
    }

    function reject(promise, reason) {
      if (promise._state !== PENDING) {
        return;
      }
      promise._state = REJECTED;
      promise._result = reason;

      asap(publishRejection, promise);
    }

    function subscribe(parent, child, onFulfillment, onRejection) {
      var _subscribers = parent._subscribers;
      var length = _subscribers.length;


      parent._onerror = null;

      _subscribers[length] = child;
      _subscribers[length + FULFILLED] = onFulfillment;
      _subscribers[length + REJECTED] = onRejection;

      if (length === 0 && parent._state) {
        asap(publish, parent);
      }
    }

    function publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) {
        return;
      }

      var child = void 0,
          callback = void 0,
          detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback),
          value = void 0,
          error = void 0,
          succeeded = true;

      if (hasCallback) {
        try {
          value = callback(detail);
        } catch (e) {
          succeeded = false;
          error = e;
        }

        if (promise === value) {
          reject(promise, cannotReturnOwn());
          return;
        }
      } else {
        value = detail;
      }

      if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (succeeded === false) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        fulfill(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }

    function initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value) {
          resolve(promise, value);
        }, function rejectPromise(reason) {
          reject(promise, reason);
        });
      } catch (e) {
        reject(promise, e);
      }
    }

    var id = 0;
    function nextId() {
      return id++;
    }

    function makePromise(promise) {
      promise[PROMISE_ID] = id++;
      promise._state = undefined;
      promise._result = undefined;
      promise._subscribers = [];
    }

    function validationError() {
      return new Error('Array Methods must be provided an Array');
    }

    var Enumerator = function () {
      function Enumerator(Constructor, input) {
        this._instanceConstructor = Constructor;
        this.promise = new Constructor(noop);

        if (!this.promise[PROMISE_ID]) {
          makePromise(this.promise);
        }

        if (isArray(input)) {
          this.length = input.length;
          this._remaining = input.length;

          this._result = new Array(this.length);

          if (this.length === 0) {
            fulfill(this.promise, this._result);
          } else {
            this.length = this.length || 0;
            this._enumerate(input);
            if (this._remaining === 0) {
              fulfill(this.promise, this._result);
            }
          }
        } else {
          reject(this.promise, validationError());
        }
      }

      Enumerator.prototype._enumerate = function _enumerate(input) {
        for (var i = 0; this._state === PENDING && i < input.length; i++) {
          this._eachEntry(input[i], i);
        }
      };

      Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
        var c = this._instanceConstructor;
        var resolve$$1 = c.resolve;


        if (resolve$$1 === resolve$1) {
          var _then = void 0;
          var error = void 0;
          var didError = false;
          try {
            _then = entry.then;
          } catch (e) {
            didError = true;
            error = e;
          }

          if (_then === then && entry._state !== PENDING) {
            this._settledAt(entry._state, i, entry._result);
          } else if (typeof _then !== 'function') {
            this._remaining--;
            this._result[i] = entry;
          } else if (c === Promise$1) {
            var promise = new c(noop);
            if (didError) {
              reject(promise, error);
            } else {
              handleMaybeThenable(promise, entry, _then);
            }
            this._willSettleAt(promise, i);
          } else {
            this._willSettleAt(new c(function (resolve$$1) {
              return resolve$$1(entry);
            }), i);
          }
        } else {
          this._willSettleAt(resolve$$1(entry), i);
        }
      };

      Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
        var promise = this.promise;


        if (promise._state === PENDING) {
          this._remaining--;

          if (state === REJECTED) {
            reject(promise, value);
          } else {
            this._result[i] = value;
          }
        }

        if (this._remaining === 0) {
          fulfill(promise, this._result);
        }
      };

      Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
        var enumerator = this;

        subscribe(promise, undefined, function (value) {
          return enumerator._settledAt(FULFILLED, i, value);
        }, function (reason) {
          return enumerator._settledAt(REJECTED, i, reason);
        });
      };

      return Enumerator;
    }();

    /**
      `Promise.all` accepts an array of promises, and returns a new promise which
      is fulfilled with an array of fulfillment values for the passed promises, or
      rejected with the reason of the first passed promise to be rejected. It casts all
      elements of the passed iterable to promises as it runs this algorithm.

      Example:

      ```javascript
      let promise1 = resolve(1);
      let promise2 = resolve(2);
      let promise3 = resolve(3);
      let promises = [ promise1, promise2, promise3 ];

      Promise.all(promises).then(function(array){
        // The array here would be [ 1, 2, 3 ];
      });
      ```

      If any of the `promises` given to `all` are rejected, the first promise
      that is rejected will be given as an argument to the returned promises's
      rejection handler. For example:

      Example:

      ```javascript
      let promise1 = resolve(1);
      let promise2 = reject(new Error("2"));
      let promise3 = reject(new Error("3"));
      let promises = [ promise1, promise2, promise3 ];

      Promise.all(promises).then(function(array){
        // Code here never runs because there are rejected promises!
      }, function(error) {
        // error.message === "2"
      });
      ```

      @method all
      @static
      @param {Array} entries array of promises
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise} promise that is fulfilled when all `promises` have been
      fulfilled, or rejected if any of them become rejected.
      @static
    */
    function all(entries) {
      return new Enumerator(this, entries).promise;
    }

    /**
      `Promise.race` returns a new promise which is settled in the same way as the
      first passed promise to settle.

      Example:

      ```javascript
      let promise1 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 1');
        }, 200);
      });

      let promise2 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 2');
        }, 100);
      });

      Promise.race([promise1, promise2]).then(function(result){
        // result === 'promise 2' because it was resolved before promise1
        // was resolved.
      });
      ```

      `Promise.race` is deterministic in that only the state of the first
      settled promise matters. For example, even if other promises given to the
      `promises` array argument are resolved, but the first settled promise has
      become rejected before the other promises became fulfilled, the returned
      promise will become rejected:

      ```javascript
      let promise1 = new Promise(function(resolve, reject){
        setTimeout(function(){
          resolve('promise 1');
        }, 200);
      });

      let promise2 = new Promise(function(resolve, reject){
        setTimeout(function(){
          reject(new Error('promise 2'));
        }, 100);
      });

      Promise.race([promise1, promise2]).then(function(result){
        // Code here never runs
      }, function(reason){
        // reason.message === 'promise 2' because promise 2 became rejected before
        // promise 1 became fulfilled
      });
      ```

      An example real-world use case is implementing timeouts:

      ```javascript
      Promise.race([ajax('foo.json'), timeout(5000)])
      ```

      @method race
      @static
      @param {Array} promises array of promises to observe
      Useful for tooling.
      @return {Promise} a promise which settles in the same way as the first passed
      promise to settle.
    */
    function race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      if (!isArray(entries)) {
        return new Constructor(function (_, reject) {
          return reject(new TypeError('You must pass an array to race.'));
        });
      } else {
        return new Constructor(function (resolve, reject) {
          var length = entries.length;
          for (var i = 0; i < length; i++) {
            Constructor.resolve(entries[i]).then(resolve, reject);
          }
        });
      }
    }

    /**
      `Promise.reject` returns a promise rejected with the passed `reason`.
      It is shorthand for the following:

      ```javascript
      let promise = new Promise(function(resolve, reject){
        reject(new Error('WHOOPS'));
      });

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      let promise = Promise.reject(new Error('WHOOPS'));

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      @method reject
      @static
      @param {Any} reason value that the returned promise will be rejected with.
      Useful for tooling.
      @return {Promise} a promise rejected with the given `reason`.
    */
    function reject$1(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(noop);
      reject(promise, reason);
      return promise;
    }

    function needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      let promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          let xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {Function} resolver
      Useful for tooling.
      @constructor
    */

    var Promise$1 = function () {
      function Promise(resolver) {
        this[PROMISE_ID] = nextId();
        this._result = this._state = undefined;
        this._subscribers = [];

        if (noop !== resolver) {
          typeof resolver !== 'function' && needsResolver();
          this instanceof Promise ? initializePromise(this, resolver) : needsNew();
        }
      }

      /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.
       ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```
       Chaining
      --------
       The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.
       ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });
       findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
       ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```
       Assimilation
      ------------
       Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.
       ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```
       If the assimliated promise rejects, then the downstream promise will also reject.
       ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```
       Simple Example
      --------------
       Synchronous Example
       ```javascript
      let result;
       try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```
       Errback Example
       ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```
       Promise Example;
       ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```
       Advanced Example
      --------------
       Synchronous Example
       ```javascript
      let author, books;
       try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```
       Errback Example
       ```js
       function foundBooks(books) {
       }
       function failure(reason) {
       }
       findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```
       Promise Example;
       ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```
       @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
      */

      /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.
      ```js
      function findAuthor(){
      throw new Error('couldn't find that author');
      }
      // synchronous
      try {
      findAuthor();
      } catch(reason) {
      // something went wrong
      }
      // async with promises
      findAuthor().catch(function(reason){
      // something went wrong
      });
      ```
      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
      */


      Promise.prototype.catch = function _catch(onRejection) {
        return this.then(null, onRejection);
      };

      /**
        `finally` will be invoked regardless of the promise's fate just as native
        try/catch/finally behaves
      
        Synchronous example:
      
        ```js
        findAuthor() {
          if (Math.random() > 0.5) {
            throw new Error();
          }
          return new Author();
        }
      
        try {
          return findAuthor(); // succeed or fail
        } catch(error) {
          return findOtherAuther();
        } finally {
          // always runs
          // doesn't affect the return value
        }
        ```
      
        Asynchronous example:
      
        ```js
        findAuthor().catch(function(reason){
          return findOtherAuther();
        }).finally(function(){
          // author was either found, or not
        });
        ```
      
        @method finally
        @param {Function} callback
        @return {Promise}
      */


      Promise.prototype.finally = function _finally(callback) {
        var promise = this;
        var constructor = promise.constructor;

        if (isFunction(callback)) {
          return promise.then(function (value) {
            return constructor.resolve(callback()).then(function () {
              return value;
            });
          }, function (reason) {
            return constructor.resolve(callback()).then(function () {
              throw reason;
            });
          });
        }

        return promise.then(callback, callback);
      };

      return Promise;
    }();

    Promise$1.prototype.then = then;
    Promise$1.all = all;
    Promise$1.race = race;
    Promise$1.resolve = resolve$1;
    Promise$1.reject = reject$1;
    Promise$1._setScheduler = setScheduler;
    Promise$1._setAsap = setAsap;
    Promise$1._asap = asap;

    /*global self*/
    function polyfill() {
      var local = void 0;

      if (typeof commonjsGlobal !== 'undefined') {
        local = commonjsGlobal;
      } else if (typeof self !== 'undefined') {
        local = self;
      } else {
        try {
          local = Function('return this')();
        } catch (e) {
          throw new Error('polyfill failed because global object is unavailable in this environment');
        }
      }

      var P = local.Promise;

      if (P) {
        var promiseToString = null;
        try {
          promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
          // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
          return;
        }
      }

      local.Promise = Promise$1;
    }

    // Strange compat..
    Promise$1.polyfill = polyfill;
    Promise$1.Promise = Promise$1;

    return Promise$1;

    })));




    });

    function IconMinus(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-minus " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("defs", null), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M115.2 467.2h819.2c6.4 0 6.4 6.4 6.4 6.4V544c0 6.4-6.4 6.4-6.4 6.4H96c-6.4 0-6.4-6.4-6.4-6.4v-64c0-6.4 6.4-6.4 6.4-6.4 6.4-6.4 6.4-6.4 19.2-6.4z"
        }));
      });
    }

    function IconStarFill(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-star-fill " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("defs", null), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M497.371 826.514L270.63 936.23c-18.286 7.314-40.229 0-47.543-18.286-3.657-3.657-7.315-10.972-3.657-18.286l25.6-248.686c0-10.971-3.658-18.285-7.315-29.257L69.486 435.2c-14.629-14.629-10.972-36.571 3.657-51.2 3.657-3.657 10.971-7.314 14.628-7.314l245.029-51.2c10.971-3.657 18.286-7.315 21.943-18.286l128-219.429C490.057 73.143 512 65.83 530.286 76.8c3.657 3.657 10.971 7.314 14.628 14.629l128 219.428c3.657 7.314 14.629 14.629 21.943 18.286l245.029 51.2c18.285 3.657 32.914 21.943 25.6 43.886 0 7.314-3.657 10.971-7.315 14.628L789.943 621.714c-7.314 7.315-10.972 18.286-7.314 29.257l25.6 248.686c3.657 18.286-10.972 36.572-32.915 40.229-7.314 0-14.628 0-18.285-3.657L530.286 826.514c-10.972-7.314-25.6-7.314-32.915 0z"
        }));
      });
    }

    function IconSearch(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-search " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          fill: useCurrentColor ? 'currentColor' : '#000',
          d: "M469.333 106.667C669.632 106.667 832 269.035 832 469.333c0 75.712-23.19 146.006-62.87 204.16l144.683 144.683a21.333 21.333 0 010 30.165l-36.202 36.203a21.333 21.333 0 01-30.166 0L706.56 743.68A361.259 361.259 0 01469.333 832c-200.298 0-362.666-162.368-362.666-362.667s162.368-362.666 362.666-362.666zm0 89.6c-150.826 0-273.066 122.24-273.066 273.066S318.507 742.4 469.333 742.4 742.4 620.16 742.4 469.333 620.16 196.267 469.333 196.267z"
        }));
      });
    }

    function IconClose(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-close " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          fill: useCurrentColor ? 'currentColor' : '#000',
          d: "M509.568 447.083L796.16 160.469a21.333 21.333 0 0130.165 0l30.166 30.166a21.333 21.333 0 010 30.186L569.899 507.435l286.613 286.592a21.333 21.333 0 010 30.165l-30.165 30.165a21.333 21.333 0 01-30.166 0L509.568 567.765 222.933 854.38a21.333 21.333 0 01-30.186 0l-30.166-30.166a21.333 21.333 0 010-30.165l286.614-286.613L162.603 220.8a21.333 21.333 0 010-30.187l30.165-30.165a21.333 21.333 0 0130.187 0l286.613 286.613z"
        }));
      });
    }

    function IconAdd(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-add " + className,
          width: "1em",
          height: "1em",
          style: style,
          viewBox: "0 0 1024 1024",
          xmlns: "http://www.w3.org/2000/svg"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          fill: useCurrentColor ? 'currentColor' : '#000',
          d: "M527.317 85.333c9.515 0 12.95.982 16.427 2.859a19.337 19.337 0 018.064 8.064c1.877 3.477 2.859 6.912 2.859 16.427v356.65h356.65c9.515 0 12.95.982 16.427 2.859a19.337 19.337 0 018.064 8.064c1.877 3.477 2.859 6.912 2.859 16.427v30.634c0 9.515-.982 12.95-2.859 16.427a19.392 19.392 0 01-8.064 8.064c-3.477 1.877-6.912 2.859-16.427 2.859h-356.65v356.65c0 9.515-.982 12.95-2.859 16.427a19.392 19.392 0 01-8.064 8.064c-3.477 1.877-6.912 2.859-16.427 2.859h-30.634c-9.515 0-12.95-.982-16.427-2.859a19.392 19.392 0 01-8.064-8.064c-1.877-3.477-2.859-6.912-2.859-16.427l-.021-356.65h-356.63c-9.514 0-12.949-.982-16.426-2.859a19.392 19.392 0 01-8.064-8.064c-1.877-3.477-2.859-6.912-2.859-16.427v-30.634c0-9.515.982-12.95 2.859-16.427a19.392 19.392 0 018.064-8.064c3.477-1.877 6.912-2.859 16.427-2.859l356.65-.021v-356.63c0-9.514.982-12.949 2.859-16.426a19.392 19.392 0 018.064-8.064c3.477-1.877 6.912-2.859 16.427-2.859h30.634z"
        }));
      });
    }

    function IconClear(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-clear " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 18 18"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M9 1.1C4.7 1.1 1.1 4.7 1.1 9s3.5 7.9 7.9 7.9 7.9-3.5 7.9-7.9S13.3 1.1 9 1.1zm3.4 10.2c.2.2.2.5 0 .7l-.5.5c-.2.2-.5.2-.7 0L9 10.3l-2.2 2.2c-.2.2-.5.2-.7 0l-.6-.5c-.2-.2-.2-.5 0-.7l2.2-2.2-2.2-2.3c-.2-.2-.2-.5 0-.7l.5-.5c.2-.2.5-.2.7 0l2.2 2.2 2.2-2.2c.2-.2.5-.2.7 0l.5.5c.2.2.2.5 0 .7L10.1 9l2.3 2.3z",
          fill: useCurrentColor ? 'currentColor' : '#000'
        }));
      });
    }

    function IconCheckBold(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-check-bold " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 -0.97 10.07 10.07"
        }, other), /*#__PURE__*/React__default["default"].createElement("g", {
          "data-name": "\u56FE\u5C42 2"
        }, /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M9.22.12a.49.49 0 00-.7.06L3.86 5.69 1.4 3.57a.51.51 0 00-.71.06l-.57.66A.49.49 0 00.17 5L3 7.38v.07l.69.55a.53.53 0 00.71 0l.6-.71a.22.22 0 000-.08l5-5.82a.51.51 0 00-.11-.71z",
          fill: useCurrentColor ? 'currentColor' : '#000',
          fillRule: "evenodd",
          "data-name": "\u56FE\u5C42 1"
        })));
      });
    }

    function IconCloseBold(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-close-bold " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 6.92 6.92"
        }, other), /*#__PURE__*/React__default["default"].createElement("g", {
          "data-name": "\u56FE\u5C42 2"
        }, /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M6.16.15l.62.62a.5.5 0 010 .7l-2 2 2 2a.51.51 0 010 .71l-.62.62a.51.51 0 01-.71 0l-2-2-2 2a.5.5 0 01-.7 0l-.6-.64a.5.5 0 010-.71l2-2-2-2a.48.48 0 010-.7l.62-.6a.48.48 0 01.7 0l2 2 2-2a.5.5 0 01.69 0z",
          fill: useCurrentColor ? 'currentColor' : '#000',
          fillRule: "evenodd",
          "data-name": "\u56FE\u5C42 1"
        })));
      });
    }

    function IconStarHalf(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-star-half " + className,
          width: "1em",
          height: "1em",
          style: style,
          fill: useCurrentColor ? 'currentColor' : '#000',
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M513.8 71.6c-13.4-.9-25.9 5.8-31 16.2l-128 219.4c-3.7 11-11 14.6-21.9 18.3l-245 51.2c-3.7 0-11 3.7-14.6 7.3-14.6 14.6-18.3 36.6-3.7 51.2l168.2 186.5c3.7 11 7.3 18.3 7.3 29.3l-25.6 248.7c-3.7 7.3 0 14.6 3.7 18.3 7.3 18.3 29.3 25.6 47.5 18.3l226.7-109.7c3.9-3.9 10-5.7 16.4-5.4V71.6z"
        }));
      });
    }

    function IconKeyboard(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-keyboard " + className,
          width: "1em",
          height: "1em",
          style: style,
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg",
          x: "0",
          y: "0",
          viewBox: "0 0 26 26",
          xmlSpace: "preserve"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M15.9 21.7l-2.5 2.5c-.2.2-.5.2-.7 0l-2.5-2.5c-.3-.3-.1-.9.4-.9h5C16 20.9 16.2 21.4 15.9 21.7zM23.1 19.5H2.9c-1.1 0-2-.9-2-2V4.8c0-1.1.9-2 2-2h20.1c1.1 0 2 .9 2 2v12.7C25.1 18.6 24.2 19.5 23.1 19.5zM2.9 4.8L2.9 4.8v12.7h20.1V4.8H2.9z",
          fill: useCurrentColor ? 'currentColor' : '#1d2129'
        }), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M10.6,6.6H8.2V9h2.4V6.6z M4.5,6.6H7V9H4.5V6.6z M8.8,10.2H6.4v2.4h2.4V10.2z M16,10.2h-2.4v2.4H16V10.2z M10,10.2h2.4v2.4H10V10.2z M19.6,10.2h-2.4v2.4h2.4V10.2z M11.8,6.6h2.4V9h-2.4V6.6z M17.8,6.6h-2.4V9h2.4V6.6z M19,6.6h2.4V9H19\tV6.6z M17.8,13.8H8.2v1.8h9.7V13.8z",
          fillRule: "evenodd",
          clipRule: "evenodd",
          fill: useCurrentColor ? 'currentColor' : '#1d2129'
        }));
      });
    }

    function IconKeyboardDelete(props) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.useCurrentColor,
          useCurrentColor = _b === void 0 ? true : _b,
          style = props.style,
          other = __rest$1(props, ["className", "useCurrentColor", "style"]);

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("svg", __assign$2({
          className: prefixCls + "-icon " + prefixCls + "-icon-keyboard-delete " + className,
          width: "1em",
          height: "1em",
          style: style,
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 26 26"
        }, other), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M23.1,21.4H8.3c-0.6,0-1.2-0.3-1.6-0.8l-4.9-6.4c-0.5-0.7-0.5-1.7,0-2.4l4.9-6.4c0.4-0.5,1-0.8,1.6-0.8h14.8\tc1.1,0,2,0.9,2,2v12.7C25.1,20.5,24.2,21.4,23.1,21.4z M8.3,6.6L3.4,13l4.9,6.4h14.8V6.6H8.3z",
          fill: useCurrentColor ? 'currentColor' : '#1d2129'
        }), /*#__PURE__*/React__default["default"].createElement("path", {
          d: "M11.3,9.4c0.4-0.4,1-0.4,1.3,0l2.5,2.5l2.5-2.5c0.4-0.4,1-0.4,1.3,0c0.4,0.4,0.4,1,0,1.3l-2.5,2.5l2.3,2.3\tc0.4,0.4,0.4,1,0,1.3c-0.4,0.4-1,0.4-1.3,0l-2.3-2.3L12.7,17c-0.4,0.4-1,0.4-1.3,0c-0.4-0.4-0.4-1,0-1.3l2.4-2.4l-2.5-2.5\tC10.9,10.4,10.9,9.8,11.3,9.4z",
          fillRule: "evenodd",
          clipRule: "evenodd",
          fill: useCurrentColor ? 'currentColor' : '#1d2129'
        }));
      });
    }

    function AddIcon() {
      return /*#__PURE__*/React__default["default"].createElement("svg", {
        width: "30",
        height: "30",
        viewBox: "0 0 30 30",
        fill: "none"
      }, /*#__PURE__*/React__default["default"].createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M14.5 0C14.2239 0 14 0.223857 14 0.5V14H0.5C0.223858 14 0 14.2239 0 14.5V15.5C0 15.7761 0.223857 16 0.5 16H14V29.5C14 29.7761 14.2239 30 14.5 30H15.5C15.7761 30 16 29.7761 16 29.5V16H29.5C29.7761 16 30 15.7761 30 15.5V14.5C30 14.2239 29.7761 14 29.5 14H16V0.5C16 0.223858 15.7761 0 15.5 0H14.5Z",
        fill: "#C9CDD4"
      }));
    }

    var ImagePicker = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.accept,
          accept = _b === void 0 ? 'image/*' : _b,
          _c = props.multiple,
          multiple = _c === void 0 ? false : _c,
          capture = props.capture,
          _d = props.columns,
          columns = _d === void 0 ? 3 : _d,
          _e = props.gutter,
          gutter = _e === void 0 ? 8 : _e,
          _f = props.limit,
          limit = _f === void 0 ? 0 : _f,
          _g = props.images,
          images = _g === void 0 ? [] : _g,
          maxSize = props.maxSize,
          disabled = props.disabled,
          deleteIcon = props.deleteIcon,
          selectIcon = props.selectIcon,
          _h = props.hideDelete,
          hideDelete = _h === void 0 ? false : _h,
          _j = props.hideSelect,
          hideSelect = _j === void 0 ? false : _j,
          _k = props.alwaysShowSelect,
          alwaysShowSelect = _k === void 0 ? false : _k,
          imageProps = props.imageProps,
          renderLoading = props.renderLoading,
          renderError = props.renderError,
          onLongPress = props.onLongPress,
          onClick = props.onClick,
          _l = props.onChange,
          onChange = _l === void 0 ? function () {
        return null;
      } : _l,
          onMaxSizeExceed = props.onMaxSizeExceed,
          onLimitExceed = props.onLimitExceed,
          upload = props.upload,
          selectAdapter = props.selectAdapter,
          onSelectClick = props.onSelectClick,
          onDeleteClick = props.onDeleteClick;
      var domRef = React.useRef(null);
      var fileRef = React.useRef(null);
      var cacheRef = useLatestRef(images);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var parseFile = function parseFile(file) {
        return new es6Promise.Promise(function (resolve, reject) {
          if (file.url) {
            resolve(file.url);
          } else {
            var reader = new FileReader();

            reader.onload = function (e) {
              var _a;

              var dataURL = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;

              if (!dataURL) {
                reject(new Error('file parse error'));
              }

              resolve(dataURL);
            };

            reader.onerror = function () {
              reject(new Error('file parse error'));
            };

            reader.readAsDataURL(file);
          }
        });
      };

      var handleChange = function handleChange(event, fromAdapter) {
        var files = Array.prototype.filter.call(event.target.files || [], function (file) {
          // 过滤maxSize
          if (maxSize && file.size > maxSize * 1024) {
            onMaxSizeExceed && onMaxSizeExceed(file);
            return false;
          }

          return true;
        }) || [];

        if (!fromAdapter) {
          event.target.value = '';
        } // 截断limit


        if (limit !== 0 && files.length + images.length > limit) {
          onLimitExceed && onLimitExceed(files);
          files.length = limit - images.length;
        } // 解析文件生成预览


        es6Promise.Promise.all(files.map(function (file) {
          return parseFile(file);
        })).then(function (parseFiles) {
          var res = parseFiles.map(function (url, index) {
            return {
              url: url,
              status: typeof upload === 'function' ? 'loading' : 'loaded',
              file: files[index]
            };
          });
          cacheRef.current = __spreadArrays$1(cacheRef.current, res);
          onChange(__spreadArrays$1(cacheRef.current)); // 执行upload

          if (typeof upload === 'function') {
            files.forEach(function (_file) {
              upload(cacheRef.current.find(function (_a) {
                var file = _a.file;
                return file === _file;
              })).then(function (data) {
                var index = cacheRef.current.findIndex(function (_a) {
                  var file = _a.file;
                  return file === _file;
                });

                if (index !== -1) {
                  cacheRef.current[index] = __assign$2(__assign$2(__assign$2({}, cacheRef.current[index]), data), {
                    status: undefined
                  });
                }
              }).catch(function () {
                var index = cacheRef.current.findIndex(function (_a) {
                  var file = _a.file;
                  return file === _file;
                });

                if (index !== -1) {
                  cacheRef.current[index].status = 'error';
                }
              }).finally(function () {
                onChange(__spreadArrays$1(cacheRef.current));
              });
            });
          }
        });
      };

      var handleDelete = function handleDelete(index) {
        onDeleteClick && onDeleteClick(index);
        onChange(images.filter(function (_i, j) {
          return j !== index;
        }));
      }; // click && longPress


      var timeOutEvent;

      var handleTouchStart = function handleTouchStart(e, image, index) {
        timeOutEvent = setTimeout(function () {
          timeOutEvent = 0;
          onLongPress === null || onLongPress === void 0 ? void 0 : onLongPress(e, image, index);
        }, 750);
      };

      var handleClick = function handleClick(e, image, index) {
        clearTimeout(timeOutEvent);

        if (timeOutEvent !== 0) {
          onClick === null || onClick === void 0 ? void 0 : onClick(e, image, index);
        }
      };

      var handleSelect = function handleSelect(e) {
        var _a;

        if (e.target !== fileRef.current) {
          onSelectClick && onSelectClick();
          selectAdapter ? selectAdapter().then(function (_a) {
            var files = _a.files;
            return handleChange({
              target: {
                files: files
              }
            }, true);
          }) : (_a = fileRef.current) === null || _a === void 0 ? void 0 : _a.click();
        }
      };

      var getGridData = function getGridData(prefixCls, locale) {
        var _a;

        var errorNode = function errorNode(index) {
          if (renderError) {
            return typeof renderError === 'function' ? renderError(index) : renderError;
          }

          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: prefixCls + "-image-picker-error"
          }, /*#__PURE__*/React__default["default"].createElement("p", null, locale.ImagePicker.loadError));
        };

        var loadingNode = function loadingNode(index) {
          if (renderLoading) {
            return typeof renderLoading === 'function' ? renderLoading(index) : renderLoading;
          }

          return null;
        };

        var data = (limit && limit < images.length ? images.slice(0, limit) : images).map(function (image, index) {
          var url = image.url,
              status = image.status;
          return {
            img: /*#__PURE__*/React__default["default"].createElement("div", {
              key: index + "-" + url,
              className: prefixCls + "-image-picker-image"
            }, /*#__PURE__*/React__default["default"].createElement("div", {
              onTouchStart: function onTouchStart(e) {
                return handleTouchStart(e, image, index);
              },
              onClick: function onClick(e) {
                return handleClick(e, image, index);
              },
              className: prefixCls + "-image-picker-image-container"
            }, /*#__PURE__*/React__default["default"].createElement(BaseImage, __assign$2({
              showLoading: true,
              showError: true
            }, imageProps || {}, {
              src: url,
              errorArea: errorNode(index),
              loadingArea: loadingNode(index),
              status: status || (imageProps === null || imageProps === void 0 ? void 0 : imageProps.status)
            })), /*#__PURE__*/React__default["default"].createElement("div", {
              className: prefixCls + "-image-picker-image-mask"
            })), !hideDelete && /*#__PURE__*/React__default["default"].createElement("div", {
              className: prefixCls + "-image-picker-close",
              onClick: function onClick() {
                return handleDelete(index);
              }
            }, deleteIcon || /*#__PURE__*/React__default["default"].createElement("div", {
              className: prefixCls + "-image-picker-close-icon"
            }, /*#__PURE__*/React__default["default"].createElement(IconClose, null)))),
            title: ''
          };
        });
        var showSelect = !hideSelect && images.length < (limit || Infinity);
        var disableSelect = disabled || alwaysShowSelect && !showSelect;

        if (showSelect || alwaysShowSelect) {
          data.push({
            img: /*#__PURE__*/React__default["default"].createElement("div", {
              className: cls(prefixCls + "-image-picker-add", (_a = {}, _a[prefixCls + "-image-picker-add-disabled"] = disableSelect, _a)),
              onClick: handleSelect
            }, /*#__PURE__*/React__default["default"].createElement("div", {
              className: prefixCls + "-image-picker-add-container"
            }, selectIcon || /*#__PURE__*/React__default["default"].createElement("div", {
              className: prefixCls + "-image-picker-add-icon"
            }, /*#__PURE__*/React__default["default"].createElement(AddIcon, null)), !selectAdapter ? /*#__PURE__*/React__default["default"].createElement("input", {
              capture: capture,
              accept: accept,
              multiple: multiple,
              type: "file",
              onChange: function onChange(e) {
                return handleChange(e);
              },
              ref: fileRef
            }) : null)),
            title: ''
          });
        }

        return data;
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b;

        var prefixCls = _a.prefixCls,
            _c = _a.locale,
            locale = _c === void 0 ? defaultLocale : _c;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-image-picker", className, (_b = {}, _b[prefixCls + "-image-picker-disabled"] = disabled, _b)),
          style: style,
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-image-picker-container"
        }, /*#__PURE__*/React__default["default"].createElement(Grid, {
          data: getGridData(prefixCls, locale),
          gutter: gutter,
          columns: columns
        })));
      });
    });
    /**
     * 图片选择器组件
     * @en ImagePicker Component
     * @type 数据录入
     * @type_en Data Entry
     * @name 图片选择器
     * @name_en ImagePicker
     * @displayName ImagePicker
     */

    var index$g = componentWrapper(ImagePicker, 'ImagePicker');

    /*!
    * @arco-design/transformable v1.0.2
    * (c) 2022 ludan.kibbon
    */
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };
      return _extends.apply(this, arguments);
    }

    var DRAG_SWIPE_TIMEOUT = 1e2;
    var DRAG_SWIPE_BOUNCE_MIN_RATE = 0.1;
    var DRAG_SWIPE_BOUNCE_MAX_DIS = 0.33;
    var FRAME_SPAN = 17;
    var DRAG_MODE = {
      ALWAYS: 'always',
      HYBRID: 'hybrid',
      NONE: 'none'
    };
    var SWIPE_MODE = {
      ANIM: 'animation',
      TRANS: 'transition'
    };
    var TRANSFORM_MODE = {
      TRANS_FIRST: 'translate-first',
      SCALE_FIRST: 'scale-first'
    };

    function getDistance(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    }

    function convert(arr) {
      if (arr instanceof Number) {
        return [arr];
      } else if (arr instanceof Array) {
        return [].concat(arr);
      } else {
        return [].concat(arr.valueOf());
      }
    }

    var Vector = /*#__PURE__*/function () {
      function Vector(arr) {
        var _this = this;

        _defineProperty(this, "operatorAdd", function (x) {
          x = convert(x);
          var val = x.length >= _this.x.length ? [x, _this.x] : [_this.x, x];
          return new Vector(val[0].map(function (v, i) {
            return v + (val[1][i] !== void 0 ? val[1][i] : val[1][0]);
          }));
        });

        _defineProperty(this, "operatorSub", function (x) {
          x = convert(x);
          var val = x.length > _this.x.length ? [x, _this.x] : [_this.x, x];
          return new Vector(val[0].map(function (v, i) {
            return v - (val[1][i] !== void 0 ? val[1][i] : val[1][0]);
          }));
        });

        _defineProperty(this, "operatorMul", function (x) {
          x = convert(x);
          var val = x.length > _this.x.length ? [x, _this.x] : [_this.x, x];
          return new Vector(val[0].map(function (v, i) {
            return v * (val[1][i] !== void 0 ? val[1][i] : val[1][0]);
          }));
        });

        _defineProperty(this, "operatorDiv", function (x) {
          x = convert(x);
          var val = x.length > _this.x.length ? [x, _this.x] : [_this.x, x];
          return new Vector(val[0].map(function (v, i) {
            return v / (val[1][i] !== void 0 ? val[1][i] : val[1][0]);
          }));
        });

        this.x = convert(arr) || [];
      }

      var _proto = Vector.prototype;

      _proto.get = function get(pos) {
        return this.x[pos];
      };

      _proto.v = function v() {
        return [].concat(this.x);
      };

      _proto.size = function size() {
        return this.x.length;
      };

      _proto.valueOf = function valueOf() {
        return this.x.valueOf();
      };

      _proto.toString = function toString() {
        return this.x.toString();
      };

      _proto.mul = function mul(x) {
        x = this.convert(x);

        if (x.length !== this.x.length) {
          throw new Error("Can not process vector inner-product, input vector dim " + x.length + " don't match resource vector dim " + this.x.length);
        }

        var sum = 0;
        this.x.forEach(function (v, i) {
          return sum += v + x[i];
        });
        return sum;
      };

      return Vector;
    }();

    function convert$1(x, _init) {
      if (typeof x === 'number') {
        return {
          R: x,
          I: 0
        };
      } else if (x.isComplex) {
        return x;
      } else {
        return {
          R: _init,
          I: 0
        };
      }
    }

    var Complex = /*#__PURE__*/function () {
      function Complex(_R, _I) {
        var _this = this;

        if (_I === void 0) {
          _I = 0;
        }

        _defineProperty(this, "operatorAdd", function (x) {
          x = convert$1(x, 0);
          var R = _this.R + x.R;
          var I = _this.I + x.I;
          return new Complex(R, I);
        });

        _defineProperty(this, "operatorSub", function (x) {
          x = convert$1(x, 0);
          var R = _this.R - x.R;
          var I = _this.I - x.I;
          return new Complex(R, I);
        });

        _defineProperty(this, "operatorMul", function (x) {
          x = convert$1(x, 1);
          var R = _this.R * x.R - _this.I * x.I;
          var I = _this.I * x.R + _this.R * x.I;
          return new Complex(R, I);
        });

        _defineProperty(this, "operatorDiv", function (x) {
          x = convert$1(x, 1);
          var D = Math.pow(x.R, 2) + Math.pow(x.I, 2);
          var R = (_this.R * x.R + _this.I * x.I) / D;
          var I = (_this.I * x.R - _this.R * x.I) / D;
          return new Complex(R, I);
        });

        _defineProperty(this, "operatorPow", function (x) {
          var Z = _this.z();

          if (Z === 0) {
            return new Complex(0);
          }

          var theta = Math.acos(_this.R / Z) * x;
          Z = Math.pow(Z, x);
          var R = Z * Math.cos(theta);
          var I = Z * Math.sin(theta);
          return new Complex(R, I);
        });

        if (typeof _R === 'number') {
          this.R = Number(_R);
          this.I = Number(_I);
        } else if (_R.isComplex) {
          this.R = _R.r();
          this.I = _R.i();
        }

        this.isComplex = true;
      }

      var _proto = Complex.prototype;

      _proto.valueOf = function valueOf() {
        return this.R.valueOf();
      };

      _proto.toString = function toString() {
        return this.R.toFixed(3) + "+" + this.I.toFixed(3) + "i";
      };

      _proto.isNaN = function (_isNaN) {
        function isNaN() {
          return _isNaN.apply(this, arguments);
        }

        isNaN.toString = function () {
          return _isNaN.toString();
        };

        return isNaN;
      }(function () {
        return isNaN(this.R) || isNaN(this.I);
      });

      _proto.isReal = function isReal() {
        return this.I === 0 && !this.isNaN();
      };

      _proto.inRangeR = function inRangeR(a, b) {
        return this.R <= b && this.R >= a;
      };

      _proto.inRangeI = function inRangeI(a, b) {
        return this.I <= b && this.I >= a;
      };

      _proto.setR = function setR(r) {
        this.R = Number(r);
      };

      _proto.setI = function setI(i) {
        this.I = Number(i);
      };

      _proto.r = function r() {
        return this.R;
      };

      _proto.i = function i() {
        return this.I;
      };

      _proto.z = function z() {
        return Math.sqrt(Math.pow(this.R, 2) + Math.pow(this.I, 2));
      };

      _proto.theta = function theta() {
        var Z = this.z();
        return Math.acos(this.R / Z);
      };

      return Complex;
    }();

    var _Op = function () {
      'bpo disable';

      return {
        add: function add(a, b) {
          if (a.operatorAdd) return a.operatorAdd(b);else return a + b;
        },
        sub: function sub(a, b) {
          if (a.operatorSub) return a.operatorSub(b);else return a - b;
        },
        mul: function mul(a, b) {
          if (a.operatorMul) return a.operatorMul(b);else return a * b;
        },
        div: function div(a, b) {
          if (a.operatorDiv) return a.operatorDiv(b);else return a / b;
        },
        pow: function pow(a, b) {
          if (a.operatorPow) return a.operatorPow(b);else return Math.pow(a, b);
        },
        binaryAnd: function binaryAnd(a, b) {
          if (a.operatorBinaryAnd) return a.operatorBinaryAnd(b);else return a & b;
        },
        binaryOr: function binaryOr(a, b) {
          if (a.operatorBinaryOr) return a.operatorBinaryOr(b);else return a | b;
        },
        binaryXor: function binaryXor(a, b) {
          if (a.operatorBinaryXor) return a.operatorBinaryXor(b);else return a ^ b;
        },
        binaryLShift: function binaryLShift(a, b) {
          if (a.operatorBinaryLShift) return a.operatorBinaryLShift(b);else return a << b;
        },
        binaryRShift: function binaryRShift(a, b) {
          if (a.operatorBinaryRShift) return a.operatorBinaryRShift(b);else return a >> b;
        },
        less: function less(a, b) {
          if (a.operatorLess) return a.operatorLess(b);else if (b.operatorGreater) return b.operatorGreater(a);else if (a.operatorGreaterEqual) return !a.operatorGreaterEqual(b);else return a < b;
        },
        greater: function greater(a, b) {
          if (a.operatorGreater) return a.operatorGreater(b);else if (b.operatorLess) return b.operatorLess(a);else if (a.operatorLessEqual) return !a.operatorLessEqual(b);else return a > b;
        },
        lessEqual: function lessEqual(a, b) {
          if (a.operatorLessEqual) return a.operatorLessEqual(b);else if (b.operatorGreaterEqual) return b.operatorGreaterEqual(a);else if (a.operatorGreater) return !a.operatorGreater(b);else return a <= b;
        },
        greaterEqual: function greaterEqual(a, b) {
          if (a.operatorGreaterEqual) return a.operatorGreaterEqual(b);else if (b.operatorLessEqual) return b.operatorLessEqual(a);else if (a.operatorLess) return !a.operatorLess(b);else return a >= b;
        },
        equal: function equal(a, b) {
          if (a.operatorEqual) return a.operatorEqual(b);else if (a.operatorNotEqual) return !a.operatorNotEqual(b);else if (b.operatorEqual) return b.operatorEqual(a);else if (b.operatorNotEqual) return !b.operatorNotEqual(a);else return a == b;
        },
        notEqual: function notEqual(a, b) {
          if (a.operatorNotEqual) return a.operatorNotEqual(b);else if (a.operatorEqual) return !a.operatorEqual(b);else if (b.operatorNotEqual) return b.operatorNotEqual(a);else if (b.operatorEqual) return !b.operatorEqual(a);else return a != b;
        }
      };
    }();

    function Sqrt(k) {
      if (k >= 0) {
        return Math.sqrt(k);
      } else {
        return new Complex(0, Math.sqrt(-k));
      }
    }

    var POW_3_1_2 = Math.sqrt(3);
    var POW_2_1_3 = Math.pow(2, 1 / 3);
    var I = Sqrt(-1);

    var _I = new Complex(0).operatorSub(I);

    var epsilon = 1e-12;

    function getParam(T, x1, x2) {
      var a = -3 * x1 + 3 * x2 - 1;
      var b = -(2 * x1 - x2) / a;
      var c = -9 * Math.pow(x1, 2) + 9 * x2 * x1 + 9 * x1 - 9 * Math.pow(x2, 2);
      var d = 3 * a;
      var e = POW_2_1_3 * d;
      var subDelta = 54 * Math.pow(x1, 3) - 243 * T * Math.pow(x1, 2) - 81 * x2 * Math.pow(x1, 2) + 162 * Math.pow(x1, 2) - 81 * Math.pow(x2, 2) * x1 - 162 * T * x1 + 486 * T * x2 * x1 - 81 * x2 * x1 + 54 * Math.pow(x2, 3) - 243 * T * Math.pow(x2, 2) - 27 * T + 162 * T * x2;
      var delta = 4 * Math.pow(c, 3) + Math.pow(subDelta, 2);
      return [delta, subDelta, b, c, d, e];
    }

    function solveCubicBezier(T, x1, x2, firstAnswer) {
      'bpo enable';

      if (firstAnswer === void 0) {
        firstAnswer = true;
      }

      if (x1 === x2 && x1 === 0) {
        return Math.pow(T, _Op.div(1, 3));
      }

      var _getParam = getParam(T, x1, x2),
          delta = _getParam[0],
          subDelta = _getParam[1],
          b = _getParam[2],
          c = _getParam[3],
          d = _getParam[4],
          e = _getParam[5];

      var a = _Op.pow(new Complex(_Op.add(Sqrt(delta), subDelta)), _Op.div(1, 3));

      var t1 = _Op.add(_Op.sub(_Op.div(a, e), _Op.div(new Complex(_Op.mul(POW_2_1_3, c)), _Op.mul(a, d))), b);

      var answers = [];

      if (_Op.lessEqual(delta, epsilon)) {
        var t2 = _Op.add(_Op.add(_Op.div(_Op.mul(_Op.sub(_Op.mul(I, POW_3_1_2), 1), a), _Op.mul(2, e)), _Op.div(_Op.mul(_Op.add(_Op.mul(I, POW_3_1_2), 1), c), _Op.mul(_Op.mul(a, e), POW_2_1_3))), b);

        var t3 = _Op.add(_Op.add(_Op.div(_Op.mul(_Op.sub(_Op.mul(_I, POW_3_1_2), 1), a), _Op.mul(2, e)), _Op.div(_Op.mul(_Op.add(_Op.mul(_I, POW_3_1_2), 1), c), _Op.mul(_Op.mul(a, e), POW_2_1_3))), b);

        [t1, t2, t3].forEach(function (k) {
          k.inRangeR(0, 1) && answers.push(k.r());
        });
        answers.sort();
      } else {
        answers.push(t1.r());
      }

      return firstAnswer ? answers[0] : answers;
    }

    var _Op$1 = function () {
      'bpo disable';

      return {
        add: function add(a, b) {
          if (a.operatorAdd) return a.operatorAdd(b);else return a + b;
        },
        sub: function sub(a, b) {
          if (a.operatorSub) return a.operatorSub(b);else return a - b;
        },
        mul: function mul(a, b) {
          if (a.operatorMul) return a.operatorMul(b);else return a * b;
        },
        div: function div(a, b) {
          if (a.operatorDiv) return a.operatorDiv(b);else return a / b;
        },
        pow: function pow(a, b) {
          if (a.operatorPow) return a.operatorPow(b);else return Math.pow(a, b);
        },
        binaryAnd: function binaryAnd(a, b) {
          if (a.operatorBinaryAnd) return a.operatorBinaryAnd(b);else return a & b;
        },
        binaryOr: function binaryOr(a, b) {
          if (a.operatorBinaryOr) return a.operatorBinaryOr(b);else return a | b;
        },
        binaryXor: function binaryXor(a, b) {
          if (a.operatorBinaryXor) return a.operatorBinaryXor(b);else return a ^ b;
        },
        binaryLShift: function binaryLShift(a, b) {
          if (a.operatorBinaryLShift) return a.operatorBinaryLShift(b);else return a << b;
        },
        binaryRShift: function binaryRShift(a, b) {
          if (a.operatorBinaryRShift) return a.operatorBinaryRShift(b);else return a >> b;
        },
        less: function less(a, b) {
          if (a.operatorLess) return a.operatorLess(b);else if (b.operatorGreater) return b.operatorGreater(a);else if (a.operatorGreaterEqual) return !a.operatorGreaterEqual(b);else return a < b;
        },
        greater: function greater(a, b) {
          if (a.operatorGreater) return a.operatorGreater(b);else if (b.operatorLess) return b.operatorLess(a);else if (a.operatorLessEqual) return !a.operatorLessEqual(b);else return a > b;
        },
        lessEqual: function lessEqual(a, b) {
          if (a.operatorLessEqual) return a.operatorLessEqual(b);else if (b.operatorGreaterEqual) return b.operatorGreaterEqual(a);else if (a.operatorGreater) return !a.operatorGreater(b);else return a <= b;
        },
        greaterEqual: function greaterEqual(a, b) {
          if (a.operatorGreaterEqual) return a.operatorGreaterEqual(b);else if (b.operatorLessEqual) return b.operatorLessEqual(a);else if (a.operatorLess) return !a.operatorLess(b);else return a >= b;
        },
        equal: function equal(a, b) {
          if (a.operatorEqual) return a.operatorEqual(b);else if (a.operatorNotEqual) return !a.operatorNotEqual(b);else if (b.operatorEqual) return b.operatorEqual(a);else if (b.operatorNotEqual) return !b.operatorNotEqual(a);else return a == b;
        },
        notEqual: function notEqual(a, b) {
          if (a.operatorNotEqual) return a.operatorNotEqual(b);else if (a.operatorEqual) return !a.operatorEqual(b);else if (b.operatorNotEqual) return b.operatorNotEqual(a);else if (b.operatorEqual) return !b.operatorEqual(a);else return a != b;
        }
      };
    }();
    function splitCubicBezier(cubic, p, axis) {
      'bpo enable';

      if (axis === void 0) {
        axis = 'x';
      }

      var x1 = cubic[0],
          y1 = cubic[1],
          x2 = cubic[2],
          y2 = cubic[3];
      var t = axis === 'x' ? solveCubicBezier(p, x1, x2) : axis === 'y' ? solveCubicBezier(p, y1, y2) : p;

      var f = function f(x, y) {
        return _Op$1.add(_Op$1.mul(_Op$1.sub(y, x), t), x);
      };

      var A = new Vector([0, 0]);
      var B = new Vector([x1, y1]);
      var C = new Vector([x2, y2]);
      var D = new Vector([1, 1]);
      var E = f(A, B);
      var F = f(B, C);
      var G = f(C, D);
      var H = f(E, F);
      var J = f(F, G);
      var K = f(H, J);

      var _map = [E, H].map(function (v) {
        return _Op$1.div(v, _Op$1.add(K, 1e-9));
      }),
          B_1 = _map[0],
          C_1 = _map[1];

      var _map2 = [J, G].map(function (v) {
        return _Op$1.div(_Op$1.sub(v, K), _Op$1.add(_Op$1.sub(D, K), 1e-9));
      }),
          B_2 = _map2[0],
          C_2 = _map2[1];

      return [[].concat(B_1.v(), C_1.v()), [].concat(B_2.v(), C_2.v())];
    }

    function getCubicBezierVbyT(v1, v2, t) {
      return 3 * v1 * t * Math.pow(1 - t, 2) + 3 * v2 * (1 - t) * Math.pow(t, 2) + Math.pow(t, 3);
    }

    function getCubicBezierPoint(cubic, p, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var x1 = cubic[0],
          y1 = cubic[1],
          x2 = cubic[2],
          y2 = cubic[3];
      var t = p === 0 ? 0 : p === 1 ? 1 : axis === 'x' ? solveCubicBezier(p, x1, x2) : axis === 'y' ? solveCubicBezier(p, y1, y2) : p;
      return [axis === 'x' ? p : getCubicBezierVbyT(x1, x2, t), axis === 'y' ? p : getCubicBezierVbyT(y1, y2, t)];
    }

    function _raf(cb) {
      return window.requestAnimationFrame ? window.requestAnimationFrame(cb) : setTimeout(cb, FRAME_SPAN);
    }

    function _caf(cb) {
      return window.requestAnimationFrame ? window.cancelAnimationFrame(cb) : clearTimeout(cb, FRAME_SPAN);
    }

    var TransformAble = /*#__PURE__*/function () {
      function TransformAble(_options) {
        var _this = this;

        if (_options === void 0) {
          _options = {};
        }

        _defineProperty(this, "setBounce", function (bounce) {
          !isNaN(bounce) && (_this.bouncing = Number(bounce));
        });

        _defineProperty(this, "setDamp", function (damp) {
          if (damp === void 0) {
            damp = 0;
          }

          !isNaN(damp) && (_this.damp = Number(damp));
        });

        _defineProperty(this, "setTransform", function (transform, options) {
          if (transform === void 0) {
            transform = {};
          }

          if (options === void 0) {
            options = {};
          }

          if (_this.fixedX && transform.translateX) {
            delete transform.translateX;
          }

          if (_this.fixedY && transform.translateY) {
            delete transform.translateY;
          }

          if (!options.merge) {
            _this.transform = _extends({}, transform);
          } else {
            ['translateX', 'translateY', 'scale'].forEach(function (k) {
              transform[k] !== void 0 && (_this.transform[k] = parseFloat(transform[k]));
            });
            var _transform = transform,
                transformOrigin = _transform.transformOrigin;

            if (transformOrigin instanceof Array && transformOrigin.length === 2) {
              _this.transform.transformOrigin = transformOrigin.map(function (k) {
                return parseFloat(k);
              });
            }
          }

          if (!options.silent) {
            _this.update();
          }

          return _this;
        });

        _defineProperty(this, "on", function (event, f) {
          if (f && typeof f === 'function') {
            var evt = "on" + event[0].toUpperCase() + event.slice(1);

            if (_this[evt]) {
              if (evt === 'onTransform') {
                _this[evt] = function () {
                  return f(_extends({}, _this.transform), {
                    complete: !_this.busy(),
                    dirty: _this.dirty()
                  });
                };
              } else {
                _this[evt] = f;
              }
            } else {
              console.warn('[Transform]Unsupport event:', event);
            }
          }

          return _this;
        });

        _defineProperty(this, "restore", function (silent) {
          if (!silent) {
            var transform = _this.transform;

            _raf(function () {
              _this.onRestore(transform);
            });
          }

          if (_this.dragMode === DRAG_MODE.ALWAYS) {
            _this.zoomTo(1, {
              fitEdge: true
            });
          } else {
            _this.setTransform({}, {
              merge: false,
              silent: silent
            });
          }
        });

        _defineProperty(this, "getTransform", function (type) {
          switch (type) {
            case 'css':
              return _this.toCSS();

            case 'style':
              return _this.toStyle();

            default:
              return _extends({}, _this.transform);
          }
        });

        _defineProperty(this, "dirty", function () {
          var _this$transform = _this.transform,
              _this$transform$trans = _this$transform.translateX,
              translateX = _this$transform$trans === void 0 ? 0 : _this$transform$trans,
              _this$transform$trans2 = _this$transform.translateY,
              translateY = _this$transform$trans2 === void 0 ? 0 : _this$transform$trans2,
              _this$transform$scale = _this$transform.scale,
              scale = _this$transform$scale === void 0 ? 1 : _this$transform$scale;
          return translateX !== 0 || translateY !== 0 || scale !== 1;
        });

        _defineProperty(this, "busy", function () {
          return !_this.disableContentTouch || _this.cancelSwipe || _this.animating;
        });

        _defineProperty(this, "isTapStop", function () {
          return _this.isTapStopped;
        });

        _defineProperty(this, "apply", function () {
          if (_this.dom) {
            var css = _this.toCSS();

            _this.dom.style.transform = css.transform || '';
            _this.dom.style.webkitTransform = css.transform || '';
            _this.dom.style.transformOrigin = css.transformOrigin || 'center center';
            _this.dom.style.webkitTransformOrigin = css.transformOrigin || 'center center';
          }

          _this.onTransform();

          _this.timer = 0;
        });

        _defineProperty(this, "update", function () {
          _caf(_this.timer);

          _this.timer = _raf(_this.apply);
          _this.lastTransform = _extends({}, _this.transform);
        });

        _defineProperty(this, "cancel", function () {
          _caf(_this.timer);

          _this.transform = _extends({}, _this.lastTransform);
        });

        _defineProperty(this, "toTop", function () {
          var _this$transform$scale2 = _this.transform.scale,
              scale = _this$transform$scale2 === void 0 ? 1 : _this$transform$scale2;

          var _this$_remainToEdge = _this._remainToEdge(1, 1),
              remainY = _this$_remainToEdge[1];

          return Math.round(Math.abs(remainY / scale));
        });

        _defineProperty(this, "toBottom", function () {
          var _this$transform$scale3 = _this.transform.scale,
              scale = _this$transform$scale3 === void 0 ? 1 : _this$transform$scale3;

          var _this$_remainToEdge2 = _this._remainToEdge(1, -1),
              remainY = _this$_remainToEdge2[1];

          return Math.round(Math.abs(remainY / scale));
        });

        _defineProperty(this, "toLeft", function () {
          var _this$transform$scale4 = _this.transform.scale,
              scale = _this$transform$scale4 === void 0 ? 1 : _this$transform$scale4;

          var _this$_remainToEdge3 = _this._remainToEdge(1, 1),
              remainX = _this$_remainToEdge3[0];

          return Math.round(Math.abs(remainX / scale));
        });

        _defineProperty(this, "toRight", function () {
          var _this$transform$scale5 = _this.transform.scale,
              scale = _this$transform$scale5 === void 0 ? 1 : _this$transform$scale5;

          var _this$_remainToEdge4 = _this._remainToEdge(-1, 1),
              remainX = _this$_remainToEdge4[0];

          return Math.round(Math.abs(remainX / scale));
        });

        _defineProperty(this, "getOriginXY", function (touchAxis) {
          var clientX = touchAxis[0],
              clientY = touchAxis[1];

          var _this$_getTransformed = _this._getTransformedBounding(),
              left = _this$_getTransformed.left,
              top = _this$_getTransformed.top;

          var _this$transform$scale6 = _this.transform.scale,
              scale = _this$transform$scale6 === void 0 ? 1 : _this$transform$scale6;
          return [(clientX - left) / scale, (clientY - top) / scale];
        });

        _defineProperty(this, "setScreenCenter", function (clientX, clientY, forceUpdate) {
          var _this$getOriginXY = _this.getOriginXY([clientX, clientY]),
              originX = _this$getOriginXY[0],
              originY = _this$getOriginXY[1];

          return _this.setCenter(originX, originY, forceUpdate);
        });

        _defineProperty(this, "setCenter", function (x, y, forceUpdate) {
          var transform = _this.transform,
              fixedX = _this.fixedX,
              fixedY = _this.fixedY,
              boundingRect = _this.boundingRect,
              viewport = _this.viewport;
          var _transform$translateX = transform.translateX,
              translateX = _transform$translateX === void 0 ? 0 : _transform$translateX,
              _transform$translateY = transform.translateY,
              translateY = _transform$translateY === void 0 ? 0 : _transform$translateY,
              _transform$scale = transform.scale,
              scale = _transform$scale === void 0 ? 1 : _transform$scale;
          var transformOrigin = transform.transformOrigin;

          var _ref = boundingRect || viewport,
              top = _ref.top,
              bottom = _ref.bottom,
              left = _ref.left,
              right = _ref.right;

          if (!transformOrigin) {
            transformOrigin = [(right - left) / 2, (bottom - top) / 2];
          }

          if (!fixedX) {
            var disX = x - transformOrigin[0];
            x = transformOrigin[0] + disX;
            transform.translateX = translateX + disX * (scale - 1) / scale;
            transformOrigin[0] = x;
          }

          if (!fixedY) {
            var disY = y - transformOrigin[1];
            y = transformOrigin[1] + disY;
            transform.translateY = translateY + disY * (scale - 1) / scale;
            transformOrigin[1] = y;
          }

          transform.transformOrigin = transformOrigin;
          forceUpdate && _this.update();
        });

        _defineProperty(this, "zoomToScreenCenter", function (rate, center, options) {
          if (options === void 0) {
            options = {};
          }

          var x = center[0],
              y = center[1];

          _this.setScreenCenter(x, y, true);

          _raf(function () {
            return _raf(function () {
              _this.zoomTo(rate, _extends({
                fitEdge: true
              }, options));
            });
          });
        });

        _defineProperty(this, "zoomToCenter", function (rate, center, options) {
          if (options === void 0) {
            options = {};
          }

          var x = center[0],
              y = center[1];

          _this.setCenter(x, y, true);

          _raf(function () {
            return _raf(function () {
              _this.zoomTo(rate, _extends({
                fitEdge: true
              }, options));
            });
          });
        });

        _defineProperty(this, "zoomTo", function (rate, options) {
          if (options === void 0) {
            options = {};
          }

          var _options2 = options,
              _options2$transition = _options2.transition,
              transition = _options2$transition === void 0 ? 'all' : _options2$transition,
              _options2$easingFunc = _options2.easingFunc,
              easingFunc = _options2$easingFunc === void 0 ? 'ease-out' : _options2$easingFunc,
              _options2$duration = _options2.duration,
              duration = _options2$duration === void 0 ? 0 : _options2$duration,
              _options2$silent = _options2.silent,
              silent = _options2$silent === void 0 ? true : _options2$silent,
              _options2$fitEdge = _options2.fitEdge,
              fitEdge = _options2$fitEdge === void 0 ? false : _options2$fitEdge,
              callback = _options2.callback;
          var _this$maxScale = _this.maxScale,
              maxScale = _this$maxScale === void 0 ? 1 : _this$maxScale,
              _this$minScale = _this.minScale,
              minScale = _this$minScale === void 0 ? 1 : _this$minScale,
              transform = _this.transform;
          var _transform$scale2 = transform.scale,
              scale = _transform$scale2 === void 0 ? 1 : _transform$scale2,
              _transform$translateX2 = transform.translateX,
              translateX = _transform$translateX2 === void 0 ? 0 : _transform$translateX2,
              _transform$translateY2 = transform.translateY,
              translateY = _transform$translateY2 === void 0 ? 0 : _transform$translateY2;
          var newScale = Math.max(Math.min(rate, maxScale), minScale);
          var r = newScale / scale;
          _this.transform.scale = newScale;
          _this.transform.translateX = translateX / r;
          _this.transform.translateY = translateY / r;
          fitEdge && _this.fit(false);

          if (_this.dom && duration) {
            _this.dom.style.transition = transition + " " + duration + "ms " + easingFunc;
            _this.animating = true;
            setTimeout(function () {
              _this.dom.style.transition = '';
              _this.animating = false;
              !silent && _this.onZoomEnd(null, newScale);
              typeof callback === 'function' && callback(newScale);
            }, duration);
          } else {
            typeof callback === 'function' && callback(newScale);
          }

          _this.update();
        });

        _defineProperty(this, "zoom", function (rate, options) {
          if (rate === void 0) {
            rate = 1;
          }

          if (options === void 0) {
            options = {};
          }

          var _this$transform$scale7 = _this.transform.scale,
              scale = _this$transform$scale7 === void 0 ? 1 : _this$transform$scale7;

          _this.zoomTo(scale * rate, options);
        });

        _defineProperty(this, "drag", function (disX, disY, useBounce, ignoreEdgeX, ignoreEdgeY) {
          var transform = _this.transform,
              interActBound = _this.interActBound,
              fixedX = _this.fixedX,
              fixedY = _this.fixedY,
              bounceRateX = _this.bounceRateX,
              bounceRateY = _this.bounceRateY;
          var _transform$translateX3 = transform.translateX,
              translateX = _transform$translateX3 === void 0 ? 0 : _transform$translateX3,
              _transform$translateY3 = transform.translateY,
              translateY = _transform$translateY3 === void 0 ? 0 : _transform$translateY3,
              _transform$scale3 = transform.scale,
              scale = _transform$scale3 === void 0 ? 1 : _transform$scale3;
          fixedX && (disX = 0);
          fixedY && (disY = 0);

          var _this$_remainToEdge5 = _this._remainToEdge(disX, disY, interActBound),
              edgeX = _this$_remainToEdge5[0],
              edgeY = _this$_remainToEdge5[1];

          var overEdgeX = (edgeX + disX) * disX > 0;
          var overEdgeY = (edgeY + disY) * disY > 0;
          var offsetX = 0;
          var offsetY = 0;
          var slideX = Math.abs(disX) > Math.abs(disY);
          var toEdge = slideX && overEdgeX || !slideX && overEdgeY;

          if (disX) {
            if (ignoreEdgeX) {
              offsetX = disX;
            } else {
              offsetX = _this._getDragV(disX, edgeX, overEdgeX, useBounce ? bounceRateX : 0);
            }

            _this.transform.translateX = translateX + offsetX / scale;
          }

          if (disY) {
            if (ignoreEdgeY) {
              offsetY = disY;
            } else {
              offsetY = _this._getDragV(disY, edgeY, overEdgeY, useBounce ? bounceRateY : 0);
            }

            _this.transform.translateY = translateY + offsetY / scale;
          }

          var remain = [!fixedX ? -edgeX : 0, !fixedY ? -edgeY : 0];

          _this.update();

          if (_this.interActBound) {
            var left = interActBound.left,
                right = interActBound.right,
                top = interActBound.top,
                bottom = interActBound.bottom;
            _this.interActBound = {
              left: left + offsetX,
              right: right + offsetX,
              top: top + offsetY,
              bottom: bottom + offsetY
            };
          }

          return {
            toEdge: toEdge,
            remain: remain
          };
        });

        _defineProperty(this, "fit", function (useBounce, ignoreX, ignoreY) {
          if (useBounce === void 0) {
            useBounce = true;
          }

          var changed = false;
          var _this$transform2 = _this.transform,
              _this$transform2$tran = _this$transform2.translateX,
              translateX = _this$transform2$tran === void 0 ? 0 : _this$transform2$tran,
              _this$transform2$tran2 = _this$transform2.translateY,
              translateY = _this$transform2$tran2 === void 0 ? 0 : _this$transform2$tran2,
              _this$transform2$scal = _this$transform2.scale,
              scale = _this$transform2$scal === void 0 ? 1 : _this$transform2$scal;

          var _this$_outOfEdge = _this._outOfEdge(),
              outX = _this$_outOfEdge.outX,
              outY = _this$_outOfEdge.outY,
              outLeft = _this$_outOfEdge.outLeft,
              outRight = _this$_outOfEdge.outRight,
              outTop = _this$_outOfEdge.outTop,
              outBottom = _this$_outOfEdge.outBottom;

          if (!ignoreX && outX) {
            outRight && (_this.transform.translateX = translateX + outRight / scale);
            outLeft && (_this.transform.translateX = translateX + outLeft / scale);
            changed = true;
          }

          if (!ignoreY && outY) {
            outBottom && (_this.transform.translateY = translateY + outBottom / scale);
            outTop && (_this.transform.translateY = translateY + outTop / scale);
            changed = true;
          }

          changed && useBounce && _this.bounce();

          _this.update();

          return changed;
        });

        _defineProperty(this, "fitX", function (useBounce) {
          if (useBounce === void 0) {
            useBounce = true;
          }

          return _this.fit(useBounce, false, true);
        });

        _defineProperty(this, "fitY", function (useBounce) {
          if (useBounce === void 0) {
            useBounce = true;
          }

          return _this.fit(useBounce, true, false);
        });

        _defineProperty(this, "swipe", function (v) {
          var damp = _this.damp;

          if (damp) {
            var l = getDistance(v);

            if (isNaN(l)) {
              return;
            }

            if (_this.cancelSwipe) {
              _this.cancelSwipe();
            }

            var timer = 0;
            var steps = Math.ceil(l / _this.damp);
            var _this$transform3 = _this.transform,
                _this$transform3$tran = _this$transform3.translateX,
                translateX = _this$transform3$tran === void 0 ? 0 : _this$transform3$tran,
                _this$transform3$tran2 = _this$transform3.translateY,
                translateY = _this$transform3$tran2 === void 0 ? 0 : _this$transform3$tran2,
                _this$transform3$scal = _this$transform3.scale,
                scale = _this$transform3$scal === void 0 ? 1 : _this$transform3$scal;
            var scrollCubic = [].concat(_this.cubic.scroll),
                bounceCubic = [].concat(_this.cubic.bounce);

            if (_this.dom) {
              var swipeSpan = 50 * FRAME_SPAN;
              var cubicBezier = [null, scrollCubic];
              var timeout = 0;
              var bounceXTimer = 0;
              var bounceYTimer = 0;
              var baseFrame = [[0, [translateX * scale, translateY * scale]]];

              var finishSwipe = function finishSwipe() {
                timeout = 0;

                _this.cancelSwipe();
              };

              var swipeX = v[0] * steps / 2,
                  swipeY = v[1] * steps / 2;
              var bounceRateX = _this.bounceRateX,
                  bounceRateY = _this.bounceRateY;

              var _this$_outOfEdge2 = _this._outOfEdge(),
                  outX = _this$_outOfEdge2.outX,
                  outY = _this$_outOfEdge2.outY;

              var _this$drag = _this.drag(swipeX, swipeY, false, bounceRateX, bounceRateY),
                  remain = _this$drag.remain;

              var _this$_outOfEdge3 = _this._outOfEdge(),
                  overEdgeX = _this$_outOfEdge3.outX,
                  overEdgeY = _this$_outOfEdge3.outY;

              if (overEdgeX || overEdgeY) {
                cubicBezier[1] = bounceCubic;
              }

              var bounceMaxX = window.innerWidth * DRAG_SWIPE_BOUNCE_MAX_DIS,
                  bounceMaxY = window.innerHeight * DRAG_SWIPE_BOUNCE_MAX_DIS;

              if (_this.swipeMode === SWIPE_MODE.ANIM) {
                _this.cancel();

                var yFrame = _this._setSwipeBounceByAnimation(swipeY, remain[1], overEdgeY, outY, bounceRateY, swipeSpan, cubicBezier[1], bounceMaxY);

                var xFrame = _this._setSwipeBounceByAnimation(swipeX, remain[0], overEdgeX, outX, bounceRateX, swipeSpan, cubicBezier[1], bounceMaxX);

                var bouncedX = xFrame.length > 1;
                var bouncedY = yFrame.length > 1;
                [xFrame, yFrame].forEach(function (frame, idx) {
                  return frame.forEach(function (keyFrame) {
                    keyFrame[1] += baseFrame[0][1][idx];

                    for (var i = 0; i < baseFrame.length; i += 1) {
                      if (keyFrame[0] === baseFrame[i][0]) {
                        baseFrame[i][1][idx] = keyFrame[1];
                        return;
                      } else if (keyFrame[0] < baseFrame[i][0]) {
                        var _pos = [null, null];
                        _pos[idx] = keyFrame[1];
                        baseFrame.splice(i, 0, [keyFrame[0], _pos]);
                        return;
                      }
                    }

                    var pos = [null, null];
                    pos[idx] = keyFrame[1];
                    baseFrame.push([keyFrame[0], pos]);
                  });
                });
                var duration = baseFrame[baseFrame.length - 1][0];
                var pointCache = {};
                baseFrame.forEach(function (frame, i) {
                  var t = frame[0],
                      pos = frame[1];
                  pos.map(function (p, idx) {
                    if (p === null) {
                      var lastP = baseFrame[i - 1][1][idx];
                      var lastT = baseFrame[i - 1][0];
                      var nextP = lastP;
                      var nextT = lastT;

                      for (var j = i + 1; j < baseFrame.length; j += 1) {
                        if (baseFrame[j][1][idx] !== null) {
                          nextP = baseFrame[j][1][idx];
                          nextT = baseFrame[j][0];
                          break;
                        }
                      }

                      if (lastT !== nextT) {
                        var y = [];
                        [lastT, t, nextT].forEach(function (_t, j) {
                          if (pointCache[_t]) {
                            y[j] = pointCache[_t];
                          } else {
                            y[j] = getCubicBezierPoint(cubicBezier[1], _t / duration, 'x')[1];
                          }
                        });
                        frame[1][idx] = lastP + (nextP - lastP) * (y[1] - y[0]) / (y[2] - y[0]);
                      } else {
                        frame[1][idx] = lastP;
                      }
                    }
                  });
                });
                baseFrame.forEach(function (frame) {
                  frame[1] = "transform: " + _this.toCSS({
                    translateX: frame[1][0] / scale,
                    translateY: frame[1][1] / scale,
                    scale: scale
                  }).transform;
                });

                _this._appendAnimation(baseFrame, "cubic-bezier(" + cubicBezier[1].join(','), duration);

                timeout = setTimeout(finishSwipe, duration + FRAME_SPAN);

                _this.cancelSwipe = function () {
                  _this._stopAnimation();

                  _this._syncDom();

                  _this.dom.style.animation = '';

                  if (timeout) {
                    clearTimeout(timeout);
                    (bouncedX || bouncedY) && _this.fit(false);
                  }

                  _this.cancelSwipe = null;

                  _this.onSwipeEnd(_this.transform);
                };
              } else {
                _this.dom.style.transition = "transform " + swipeSpan + "ms cubic-bezier(" + cubicBezier[1].join(',') + ")";
                timer = _raf(function () {
                  timeout = setTimeout(finishSwipe, swipeSpan);

                  var syncContext = function syncContext(f) {
                    var resp = f(swipeSpan, cubicBezier) || {};
                    swipeSpan = resp.swipeSpan || swipeSpan;
                    cubicBezier = resp.cubicBezier || cubicBezier;
                    clearTimeout(timeout);
                    timeout = setTimeout(finishSwipe, swipeSpan);
                  };

                  if (overEdgeX) {
                    if (outX && swipeX * remain[0] > 0) {
                      _this.fitX(false);
                    } else {
                      cubicBezier[1] = [].concat(bounceCubic);
                      bounceXTimer = _this._setSwipeBounce(swipeX, remain[0], bounceRateX, syncContext, 'x', bounceMaxX);
                    }
                  }

                  if (overEdgeY) {
                    if (outY && swipeY * remain[1] > 0) {
                      _this.fitY(false);
                    } else {
                      cubicBezier[1] = [].concat(bounceCubic);
                      bounceYTimer = _this._setSwipeBounce(swipeY, remain[1], bounceRateY, syncContext, 'y', bounceMaxY);
                    }
                  }
                });

                _this.cancelSwipe = function () {
                  timer && _caf(timer);

                  if (timeout) {
                    bounceXTimer && clearTimeout(bounceXTimer);
                    bounceYTimer && clearTimeout(bounceYTimer);
                    clearTimeout(timeout);

                    _this._syncDom();

                    (bounceXTimer || bounceYTimer) && _this.fit(false);
                  }

                  _this.dom.style.transition = '';
                  _this.cancelSwipe = null;

                  _this.onSwipeEnd(_this.transform);
                };
              }
            } else {
              var dx = v[0] / steps;
              var dy = v[1] / steps;

              var animate = function animate() {
                var disX = (steps - 0.5) * dx,
                    disY = (steps - 0.5) * dy;

                _this.drag(disX, disY);

                steps -= 1;

                if (steps > 0) {
                  timer = _raf(animate);

                  _this.cancelSwipe = function () {
                    timer && _caf(timer);
                    _this.cancelSwipe = null;

                    _this.onSwipeEnd(_this.transform);
                  };
                } else {
                  timer = 0;

                  _this.cancelSwipe();
                }
              };

              timer = _raf(animate);
            }
          }
        });

        _defineProperty(this, "bounce", function () {
          var bouncing = _this.bouncing;

          if (bouncing && _this.dom) {
            _this.dom.style.transition = "all " + bouncing + "ms cubic-bezier(.14, 1, .34, 1)";
            _this.animating = true;
            setTimeout(function () {
              _this.animating = false;
              _this.dom.style.transition = '';
            }, bouncing);
          }
        });

        _defineProperty(this, "touchStart", function (e) {
          _this.disableContentTouch = true;

          if (_this.active && !_this.animating) {
            _this.scaling = false;
            _this.dragging = false;

            if (_this.cancelSwipe) {
              _this.cancelSwipe();

              _this.isTapStopped = true;
            } else if (!_this.dirty()) {
              if (_this.useDomBoundary) {
                _this.setBoundary(_this.dom.getBoundingClientRect());
              }

              _this.onSchedule();
            }

            if (e.touches.length > 1) {
              var _this$transform$scale8 = _this.transform.scale,
                  scale = _this$transform$scale8 === void 0 ? 1 : _this$transform$scale8;
              _this.disableContentTouch = false;

              var _this$getOriginXY2 = _this.getOriginXY([(e.touches[1].clientX + e.touches[0].clientX) / 2, (e.touches[1].clientY + e.touches[0].clientY) / 2]),
                  x = _this$getOriginXY2[0],
                  y = _this$getOriginXY2[1];

              _this.pinchStartCenter = [x, y];

              _this.setCenter(x, y);

              _this.pinchStartLen = getDistance([e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY]);
              _this.scaling = true;

              _this.onZoomStart(e, scale, _this.pinchStartCenter);
            } else if (_this.dragMode === DRAG_MODE.ALWAYS || _this.dragMode === DRAG_MODE.HYBRID && _this.dirty()) {
              _this.disableContentTouch = false;
              _this.dragStartTime = +new Date();
              _this.lastDragStartTime = 0;

              var _x = e.touches && e.touches[0] ? e.touches[0].clientX : 0,
                  _y = e.touches && e.touches[0] ? e.touches[0].clientY : 0;

              _this.dragStartV = [_x, _y];
              _this.lastDragStartV = [];
              _this.dragX = _x;
              _this.dragY = _y;
            }
          }
        });

        _defineProperty(this, "touchMove", function (e) {
          if (!_this.disableContentTouch) {
            var _e$changedTouches = e.changedTouches,
                changedTouches = _e$changedTouches === void 0 ? [] : _e$changedTouches;

            if (_this.scaling) {
              if (e.touches.length > 1) {
                var pinchLen = getDistance([e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY]);

                _this.zoom(pinchLen / _this.pinchStartLen);

                _this.pinchStartLen = pinchLen;
              }
            } else {
              var touchMoveX = changedTouches[0] ? changedTouches[0].clientX : 0;
              var touchMoveY = changedTouches[0] ? changedTouches[0].clientY : 0;
              var disX = touchMoveX - _this.dragX;
              var disY = touchMoveY - _this.dragY;

              var _this$drag2 = _this.drag(disX, disY, _this.dragging),
                  toEdge = _this$drag2.toEdge;

              _this.dragX = touchMoveX;
              _this.dragY = touchMoveY;
              var dragStartTime = +new Date();

              if (dragStartTime > _this.dragStartTime + DRAG_SWIPE_TIMEOUT) {
                _this.lastDragStartV = _this.dragStartV;
                _this.lastDragStartTime = _this.dragStartTime;
                _this.dragStartTime = dragStartTime;
                _this.dragStartV = [touchMoveX, touchMoveY];
              }

              if (!_this.dragging) {
                _this.dragging = true;

                if (toEdge) {
                  _this.disableContentTouch = true;
                } else {
                  _this.onDragStart(e);

                  _this.interActBound = _this._getTransformedBounding(true);
                }
              }
            }

            _this.preventScroll && e.preventDefault();
          }
        });

        _defineProperty(this, "touchEnd", function (e) {
          if (!_this.disableContentTouch) {
            if (e.touches.length === 0) {
              var _this$transform$scale9 = _this.transform.scale,
                  scale = _this$transform$scale9 === void 0 ? 1 : _this$transform$scale9;

              if (_this.scaling) {
                _this.onZoomEnd(e, scale, _this.pinchStartCenter);

                if (scale < 1) {
                  _this.restore();
                } else {
                  _this.fit();
                }
              } else if (_this.dragging) {
                var dragCostTime = +new Date() - _this.dragStartTime;
                var dragStartV = _this.dragStartV;

                if (dragCostTime < 50 && _this.lastDragStartTime) {
                  dragCostTime = +new Date() - _this.lastDragStartTime;
                  dragStartV = _this.lastDragStartV;
                }

                var dragEndV = [e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0, e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientY : 0];
                var swipeV = [FRAME_SPAN * (dragEndV[0] - dragStartV[0]) / dragCostTime, FRAME_SPAN * (dragEndV[1] - dragStartV[1]) / dragCostTime];

                _this.onDragEnd(e);

                if (getDistance(swipeV) > _this.motionThreshold) {
                  _this.swipe(swipeV);
                } else {
                  _this.fit();
                }
              }

              _raf(function () {
                _this.disableContentTouch = true;
                _this.pinchStartLen = 0;
                _this.interActBound = null;
                _this.isTapStopped = false;
              });
            }
          }
        });

        _defineProperty(this, "_outOfEdge", function () {
          var _this$_getTransformed2 = _this._getTransformedBounding(),
              left = _this$_getTransformed2.left,
              right = _this$_getTransformed2.right,
              top = _this$_getTransformed2.top,
              bottom = _this$_getTransformed2.bottom;

          var edges = _this.edges;
          var toLeft = edges.left - left;
          var toRight = edges.right - right;
          var toTop = edges.top - top;
          var toBottom = edges.bottom - bottom;
          var outLeft = toLeft < 0 ? toLeft : 0;
          var outRight = toRight > 0 ? toRight : 0;
          var outTop = toTop < 0 ? toTop : 0;
          var outBottom = toBottom > 0 ? toBottom : 0;
          return {
            outX: !!(outLeft || outRight),
            outY: !!(outTop || outBottom),
            outLeft: outLeft,
            outRight: outRight,
            outTop: outTop,
            outBottom: outBottom
          };
        });

        _defineProperty(this, "_remainToEdge", function (disX, disY, boundingRect) {
          var remain = [0, 0];
          var edges = _this.edges;

          var _ref2 = boundingRect || _this._getTransformedBounding(),
              left = _ref2.left,
              right = _ref2.right,
              top = _ref2.top,
              bottom = _ref2.bottom;

          var srcEdgeX = disX > 0 ? edges.left : edges.right;
          var srcEdgeY = disY > 0 ? edges.top : edges.bottom;
          var edgeX = disX > 0 ? left : right;
          var edgeY = disY > 0 ? top : bottom;
          remain[0] = edgeX - srcEdgeX;
          remain[1] = edgeY - srcEdgeY;
          return remain;
        });

        _defineProperty(this, "_computeEdge", function () {
          var _this$viewport = _this.viewport,
              l = _this$viewport.left,
              r = _this$viewport.right,
              t = _this$viewport.top,
              b = _this$viewport.bottom;

          if (_this.boundingRect) {
            var _this$boundingRect = _this.boundingRect,
                left = _this$boundingRect.left,
                right = _this$boundingRect.right,
                top = _this$boundingRect.top,
                bottom = _this$boundingRect.bottom;
            _this.edges = {
              left: Math.max(left, l),
              top: Math.max(top, t),
              right: Math.min(right, r),
              bottom: Math.min(bottom, b)
            };
          } else {
            _this.edges = _extends({}, _this.viewport);
          }
        });

        this.dom = null;
        this.useDomBoundary = false;
        this.viewport = {
          left: 0,
          right: window.innerWidth,
          top: 0,
          bottom: window.innerHeight
        };
        this.maxScale = 2;
        this.minScale = 0.5;
        this.fixedX = false;
        this.fixedY = false;
        this.active = true;
        this.preventScroll = true;
        this.dragMode = DRAG_MODE.HYBRID;
        this.swipeMode = SWIPE_MODE.ANIM;
        this.transformMode = TRANSFORM_MODE.TRANS_FIRST;
        this.transform = {};

        this.onZoomStart = function () {};

        this.onZoomEnd = function () {};

        this.onDragStart = function () {};

        this.onDragEnd = function () {};

        this.onSwipeEnd = function () {};

        this.onTransform = function () {};

        this.onRestore = function () {};

        this.onSchedule = function () {};

        this.cubic = {
          scroll: [.33, 1, .66, 1],
          bounce: [.17, 1, .17, 1]
        };
        this.bouncing = 3e2;
        this.bounceRateX = 0;
        this.bounceRateY = 0;
        this.damp = 2;
        this.motionThreshold = 10;
        this.config(_options);
        this.boundingRect = null;
        this.disableContentTouch = true;
        this.scaling = false;
        this.pinchStartCenter = [];
        this.pinchStartLen = 0;
        this.dragging = false;
        this.dragX = 0;
        this.dragY = 0;
        this.dragStartTime = 0;
        this.dragStartV = [0, 0];
        this.edges = {};
        this.timer = 0;
        this.animating = false;
        this.cancelSwipe = null;
        this.isTapStopped = false;
        this.interActBound = null;

        this._computeEdge();

        this.lastTransform = {};
        this.animationStyleDom = null;
      }

      var _proto = TransformAble.prototype;

      _proto.enable = function enable() {
        this.active = true;
        return this;
      };

      _proto.disable = function disable() {
        this.active = false;
        return this;
      };

      _proto.config = function config(options) {
        if (options === void 0) {
          options = {};
        }

        var _options3 = options,
            viewport = _options3.viewport,
            dom = _options3.dom,
            useDomBoundary = _options3.useDomBoundary,
            maxScale = _options3.maxScale,
            minScale = _options3.minScale,
            fixedX = _options3.fixedX,
            fixedY = _options3.fixedY,
            bounceRateX = _options3.bounceRateX,
            bounceRateY = _options3.bounceRateY,
            active = _options3.active,
            preventScroll = _options3.preventScroll,
            transform = _options3.transform,
            damp = _options3.damp,
            dragMode = _options3.dragMode,
            swipeMode = _options3.swipeMode,
            cubic = _options3.cubic,
            transformMode = _options3.transformMode,
            motionThreshold = _options3.motionThreshold,
            bounce = _options3.bounce,
            onZoomStart = _options3.onZoomStart,
            onZoomEnd = _options3.onZoomEnd,
            onDragStart = _options3.onDragStart,
            onDragEnd = _options3.onDragEnd,
            onSwipeEnd = _options3.onSwipeEnd,
            onTransform = _options3.onTransform,
            onRestore = _options3.onRestore,
            onSchedule = _options3.onSchedule;
        viewport && this.setViewport(viewport);
        dom && this.setDom(dom, useDomBoundary);
        maxScale && this.setMaxScale(maxScale);
        minScale && this.setMinScale(minScale);
        dragMode && this.setDragMode(dragMode);
        swipeMode && this.setSwipeMode(swipeMode);
        transformMode && this.setTransformMode(transformMode);
        cubic && this.setCubic(cubic);
        motionThreshold !== void 0 && this.setMotionThreshold(motionThreshold);
        bounceRateX !== void 0 && this.setBounceRateX(bounceRateX);
        bounceRateY !== void 0 && this.setBounceRateY(bounceRateY);
        fixedX !== void 0 && this.setFixedX(fixedX);
        fixedY !== void 0 && this.setFixedY(fixedY);
        active !== void 0 && (this.active = Boolean(active));
        preventScroll !== void 0 && (this.preventScroll = Boolean(preventScroll));
        transform && this.setTransform(transform);
        damp !== void 0 && this.setDamp(damp);
        bounce !== void 0 && this.setBounce(bounce);
        this.on('transform', onTransform).on('restore', onRestore).on('schedule', onSchedule).on('zoomStart', onZoomStart).on('zoomEnd', onZoomEnd).on('dragStart', onDragStart).on('dragEnd', onDragEnd).on('swipeEnd', onSwipeEnd);
        return this;
      };

      _proto.setDom = function setDom(dom, useDomBoundary) {
        var _this2 = this;

        if (useDomBoundary === void 0) {
          useDomBoundary = true;
        }

        if (dom) {
          this.useDomBoundary = useDomBoundary;

          if (this.dom !== dom) {
            this.removeDom();
            this.dom = dom;
            dom.addEventListener('touchstart', this.touchStart);
            dom.addEventListener('touchmove', this.touchMove);
            dom.addEventListener('touchend', this.touchEnd);
            dom.addEventListener('touchcancel', this.touchEnd);
            dom.style.willChange = 'transform';
            dom.style.transition = '';
            dom.style.transform = '';
            dom.style.webkitTransform = '';
            dom.style.transformOrigin = '';
            dom.style.webkitTransformOrigin = '';
            this.transform = {};
            this.lastTransform = {};

            if (useDomBoundary) {
              _raf(function () {
                if (!_this2.boundingRect) {
                  _this2.setBoundary(dom.getBoundingClientRect());
                }
              });
            }
          }
        }

        return this;
      };

      _proto.setBoundary = function setBoundary(bounding, transformed) {
        if (transformed === void 0) {
          transformed = false;
        }

        var _ref3 = !transformed ? bounding : this._getRawBounding(bounding),
            left = _ref3.left,
            right = _ref3.right,
            top = _ref3.top,
            bottom = _ref3.bottom;

        this.boundingRect = _extends({}, this.boundingRect || this.viewport, {
          left: left,
          right: right,
          top: top,
          bottom: bottom
        });

        this._computeEdge();

        return this;
      };

      _proto.removeDom = function removeDom() {
        if (this.dom) {
          this.dom.removeEventListener('touchstart', this.touchStart);
          this.dom.removeEventListener('touchmove', this.touchMove);
          this.dom.removeEventListener('touchend', this.touchEnd);
          this.dom.removeEventListener('touchcancel', this.touchEnd);
        }

        return this;
      };

      _proto.setMaxScale = function setMaxScale(maxScale) {
        if (!isNaN(maxScale)) {
          this.maxScale = Math.max(Number(maxScale), 1);
        }

        return this;
      };

      _proto.setMinScale = function setMinScale(minScale) {
        if (!isNaN(minScale)) {
          this.minScale = Math.min(Number(minScale), 1);
        }

        return this;
      };

      _proto.setMotionThreshold = function setMotionThreshold(motionThreshold) {
        if (!isNaN(motionThreshold)) {
          this.motionThreshold = motionThreshold;
        }

        return this;
      };

      _proto.setCubic = function setCubic(cubic) {
        if (cubic === void 0) {
          cubic = {};
        }

        for (var k in cubic) {
          if (cubic[k] instanceof Array && cubic[k].length === 4) {
            this.cubic[k] = cubic[k].map(function (k) {
              return isNaN(Number(k)) ? Number(k) : 0;
            });
          }
        }

        return this;
      };

      _proto.setDragMode = function setDragMode(mode) {
        this.dragMode = mode;
      };

      _proto.setSwipeMode = function setSwipeMode(mode) {
        this.swipeMode = mode;
      };

      _proto.setTransformMode = function setTransformMode(mode) {
        this.transformMode = mode;
      };

      _proto.setBounceRateX = function setBounceRateX(bounceRateX) {
        if (!isNaN(bounceRateX)) {
          this.bounceRateX = Math.min(Number(bounceRateX), 1);
        }

        return this;
      };

      _proto.setBounceRateY = function setBounceRateY(bounceRateY) {
        if (!isNaN(bounceRateY)) {
          this.bounceRateY = Math.min(Number(bounceRateY), 1);
        }

        return this;
      };

      _proto.setViewport = function setViewport(viewport) {
        var _this3 = this;

        if (viewport === void 0) {
          viewport = {};
        }

        var changed = false;
        ['left', 'right', 'top', 'bottom'].forEach(function (k) {
          var val = Number(viewport[k]);

          if (!isNaN(val)) {
            _this3.viewport[k] = val;
            changed = true;
          }
        });
        changed && this._computeEdge();
        return this;
      };

      _proto.setFixedX = function setFixedX(fixedX) {
        this.fixedX = !!fixedX;

        if (fixedX) {
          var transformOrigin = this.transform.transformOrigin;

          if (transformOrigin) {
            var _ref4 = this.boundingRect || this.viewport,
                left = _ref4.left,
                right = _ref4.right;

            transformOrigin[0] = (right - left) / 2;
          }

          this.setTransform({
            translateX: 0
          }, {
            merge: true
          });
        }

        return this;
      };

      _proto.setFixedY = function setFixedY(fixedY) {
        this.fixedY = !!fixedY;

        if (fixedY) {
          var transformOrigin = this.transform.transformOrigin;

          if (transformOrigin) {
            var _ref5 = this.boundingRect || this.viewport,
                top = _ref5.top,
                bottom = _ref5.bottom;

            transformOrigin[1] = (bottom - top) / 2;
          }

          this.setTransform({
            translateY: 0
          }, {
            merge: true
          });
        }

        return this;
      };

      _proto.toStyle = function toStyle() {
        var _this$toCSS = this.toCSS(),
            transform = _this$toCSS.transform,
            transformOrigin = _this$toCSS.transformOrigin;

        var styleStr = '';
        transform && (styleStr += "transform: " + transform);
        transformOrigin && (styleStr += "transform-origin: " + transformOrigin);
        return styleStr;
      };

      _proto.toCSS = function toCSS(t) {
        var transform = '';
        var transformOrigin = 'center';

        if (t || this.dirty()) {
          var trans = t || this.transform;

          if (this.transformMode === TRANSFORM_MODE.TRANS_FIRST) {
            var _this$transform$scale10 = this.transform.scale,
                scale = _this$transform$scale10 === void 0 ? 1 : _this$transform$scale10;
            ['translateX', 'translateY'].forEach(function (key) {
              trans[key] !== void 0 && (transform += key + "(" + trans[key] * scale + "px)");
            });
            transform += "scale(" + scale + ")";
          } else if (this.transformMode === TRANSFORM_MODE.SCALE_FIRST) {
            ['scale', 'translateX', 'translateY'].forEach(function (key, isTranslate) {
              var unit = isTranslate ? 'px' : '';
              trans[key] !== void 0 && (transform += key + "(" + trans[key] + unit + ")");
            });
          } else {
            var _trans$scale = trans.scale,
                _scale = _trans$scale === void 0 ? 1 : _trans$scale,
                _trans$translateX = trans.translateX,
                translateX = _trans$translateX === void 0 ? 0 : _trans$translateX,
                _trans$translateY = trans.translateY,
                translateY = _trans$translateY === void 0 ? 0 : _trans$translateY;

            transform = "matrix(" + _scale + ", 0, 0, " + _scale + ", " + translateX * _scale + ", " + translateY * _scale + ")";
          }
        }

        if (this.transform.transformOrigin) {
          transformOrigin = this.transform.transformOrigin.map(function (i) {
            return Math.round(i) + "px";
          }).join(' ');
        }

        return {
          transform: transform,
          transformOrigin: transformOrigin
        };
      };

      _proto._getTransformedBounding = function _getTransformedBounding() {
        var boundingRect = this.boundingRect,
            viewport = this.viewport,
            transform = this.transform;

        var _ref6 = boundingRect || viewport,
            left = _ref6.left,
            top = _ref6.top,
            right = _ref6.right,
            bottom = _ref6.bottom;

        var _transform$scale4 = transform.scale,
            scale = _transform$scale4 === void 0 ? 1 : _transform$scale4,
            _transform$transformO = transform.transformOrigin,
            transformOrigin = _transform$transformO === void 0 ? [(right - left) / 2, (bottom - top) / 2] : _transform$transformO,
            _transform$translateX4 = transform.translateX,
            translateX = _transform$translateX4 === void 0 ? 0 : _transform$translateX4,
            _transform$translateY4 = transform.translateY,
            translateY = _transform$translateY4 === void 0 ? 0 : _transform$translateY4;
        var x = transformOrigin[0],
            y = transformOrigin[1];
        var offsetX = (translateX - x) * scale + x;
        var offsetY = (translateY - y) * scale + y;
        return {
          left: left + offsetX,
          right: left + offsetX + (right - left) * scale,
          top: top + offsetY,
          bottom: top + offsetY + (bottom - top) * scale
        };
      };

      _proto._getRawBounding = function _getRawBounding(boundingRect) {
        var transform = this.transform;
        var left = boundingRect.left,
            top = boundingRect.top,
            right = boundingRect.right,
            bottom = boundingRect.bottom;
        var _transform$scale5 = transform.scale,
            scale = _transform$scale5 === void 0 ? 1 : _transform$scale5,
            _transform$transformO2 = transform.transformOrigin,
            transformOrigin = _transform$transformO2 === void 0 ? [(right - left) / 2, (bottom - top) / 2] : _transform$transformO2,
            _transform$translateX5 = transform.translateX,
            translateX = _transform$translateX5 === void 0 ? 0 : _transform$translateX5,
            _transform$translateY5 = transform.translateY,
            translateY = _transform$translateY5 === void 0 ? 0 : _transform$translateY5;
        var x = transformOrigin[0],
            y = transformOrigin[1];
        var offsetX = (translateX - x) * scale + x;
        var offsetY = (translateY - y) * scale + y;
        return {
          left: left - offsetX,
          right: left - offsetX + (right - left) / scale,
          top: top - offsetY,
          bottom: top - offsetY + (bottom - top) / scale
        };
      };

      _proto._getDragV = function _getDragV(dis, edge, overEdge, bounceRate) {
        var bounce = 0;
        var offset = 0;

        if (overEdge) {
          if (bounceRate) {
            var bounceEdge = edge * dis > 0;
            bounce = bounceEdge ? dis * bounceRate : (edge + dis) * bounceRate;
            offset = bounceEdge ? bounce : -edge + bounce;
          } else {
            offset = -edge;
          }
        } else {
          offset = dis;
        }

        return offset;
      };

      _proto._setSwipeBounceByAnimation = function _setSwipeBounceByAnimation(swipe, remain, over, out, bounceRate, duration, cubicBezier, max) {
        if (max === void 0) {
          max = Infinity;
        }

        var frames = [];
        var outSwipe = swipe * remain < 0;

        if (over) {
          if (out && !outSwipe) {
            frames.push([duration, remain]);
          } else {
            var bounceActDis = (outSwipe ? swipe * bounceRate : (swipe - remain) * bounceRate) / 2;

            if (Math.abs(bounceActDis) > max) {
              bounceActDis *= Math.abs(max / bounceActDis);
            }

            var firstDis = bounceActDis + (outSwipe ? 0 : remain);
            var totalDis = Math.abs(bounceActDis) * 2 + Math.abs(remain);
            var bounce = Math.abs(firstDis) / totalDis;
            var t = getCubicBezierPoint(cubicBezier, bounce, 'y')[0];
            var delay = Math.floor(duration * t);

            if (t > DRAG_SWIPE_BOUNCE_MIN_RATE) {
              frames.push([duration, remain]);
            } else {
              frames.push([delay, firstDis]);
              frames.push([duration, remain]);
            }
          }
        } else {
          swipe = Math.min(Math.abs(swipe), Math.abs(remain)) * Math.abs(swipe) / swipe;
          frames.push([duration, swipe]);
        }

        return frames;
      };

      _proto._setSwipeBounce = function _setSwipeBounce(swipe, remain, bounceRate, syncCb, direction, max) {
        var _this4 = this;

        if (direction === void 0) {
          direction = 'x';
        }

        if (max === void 0) {
          max = Infinity;
        }

        var overEdge = swipe * remain < 0;
        var bounceActDis = overEdge ? swipe * bounceRate : (swipe - remain) * bounceRate;

        if (Math.abs(bounceActDis) > max) {
          bounceActDis *= Math.abs(max / bounceActDis);
        }

        var bounce = (bounceActDis + (overEdge ? 0 : remain)) / swipe;
        var timer = 0;
        syncCb(function (swipeSpan, cubicBezier) {
          var point = getCubicBezierPoint(cubicBezier[1], bounce, 'y');
          var delay = Math.max(Math.floor(point[0] * swipeSpan / FRAME_SPAN), 2) * FRAME_SPAN;
          var nextSpan = swipeSpan - delay;
          timer = setTimeout(function () {
            syncCb(function (swipeSpan, cubicBezier) {
              var t = 1 - nextSpan / swipeSpan;
              var offsetSpan = 0;

              var update = function update() {
                if (direction === 'x') {
                  _this4.fitX(false);
                } else if (direction === 'y') {
                  _this4.fitY(false);
                }

                if (_this4.dom) {
                  _this4.dom.style.transition = "transform " + (nextSpan - offsetSpan) + "ms cubic-bezier(" + cubicBezier[1].map(function (k) {
                    return k.toFixed(3);
                  }).join(',') + ")";
                }
              };

              if (t > 0) {
                cubicBezier = splitCubicBezier(cubicBezier[1], t, 'x');
                update();
              } else {
                t = FRAME_SPAN / swipeSpan;
                offsetSpan = FRAME_SPAN;
                cubicBezier = splitCubicBezier(cubicBezier[1], t, 'x');

                _raf(update);
              }

              return {
                cubicBezier: cubicBezier,
                swipeSpan: nextSpan
              };
            });
          }, delay);
        });
        return timer;
      };

      _proto._syncDom = function _syncDom() {
        if (this.dom) {
          var matrix = window.getComputedStyle(this.dom).getPropertyValue('transform');

          var _matrix$split$0$split = matrix.split(')')[0].split(', ').map(function (k) {
            return parseFloat(k);
          }),
              _matrix$split$0$split2 = _matrix$split$0$split[3],
              scale = _matrix$split$0$split2 === void 0 ? 1 : _matrix$split$0$split2,
              _matrix$split$0$split3 = _matrix$split$0$split[4],
              translateX = _matrix$split$0$split3 === void 0 ? 0 : _matrix$split$0$split3,
              _matrix$split$0$split4 = _matrix$split$0$split[5],
              translateY = _matrix$split$0$split4 === void 0 ? 0 : _matrix$split$0$split4;

          this.setTransform({
            scale: scale,
            translateX: Math.round(translateX) / scale,
            translateY: Math.round(translateY) / scale
          }, {
            merge: true
          });
        }
      };

      _proto._appendStyle = function _appendStyle(css) {
        if (!this.animationStyleDom) {
          var head = document.head || document.getElementsByTagName('head')[0];
          var style = document.createElement('style');
          head.appendChild(style);
          style.type = 'text/css';
          this.animationStyleDom = style;
        } else {
          var node = this.animationStyleDom.firstChild;
          node && this.animationStyleDom.removeChild(node);
        }

        if (this.animationStyleDom.styleSheet) {
          this.animationStyleDom.styleSheet.cssText = css;
        } else {
          this.animationStyleDom.appendChild(document.createTextNode(css));
        }
      };

      _proto._appendAnimation = function _appendAnimation(keyFrames, easingFunc, duration) {
        var _this5 = this;

        var hash = parseInt((0.5 + 0.5 * Math.random()) * 1e16).toString(16);
        var key = "__transformable_key_" + hash;
        var frame = [];

        for (var i = 0; i < keyFrames.length; i += 1) {
          var _keyFrames$i = keyFrames[i],
              current = _keyFrames$i[0],
              style = _keyFrames$i[1];
          var percent = Math.floor(1e2 * (current / duration));
          frame.push(percent + "% { " + style + " }");
        }

        var styleTxt = "@keyframes " + key + " {\n            " + frame.join('\n') + "\n        }";

        this._appendStyle(styleTxt);

        if (this.dom) {
          _raf(function () {
            _this5.dom.style.animation = key + " " + duration + "ms " + easingFunc;
            _this5.dom.style.animationFillMode = 'forwards';
          });
        }
      };

      _proto._stopAnimation = function _stopAnimation() {
        if (this.dom) {
          this.dom.style.animationPlayState = 'paused';
        }
      };

      return TransformAble;
    }();

    function open$1(Component) {
      return function (config, context) {
        var baseProps = __assign$2(__assign$2({
          unmountOnExit: true
        }, config || {}), {
          close: function close() {}
        }); // 不同的key用不同的容器挂载
        // @en Different keys are mounted in different containers


        var id = "_ARCO_IMAGE_PREVIEW_DIV_" + (baseProps.key || '') + "_";
        var div = appendElementById(id, baseProps.getContainer).child;
        var leaving = false;
        var render = new ReactDOMRender(Component, div, context).render;

        var dynamicProps = __assign$2(__assign$2({}, baseProps), {
          getContainer: function getContainer() {
            return div;
          }
        });

        function update(newConfig) {
          dynamicProps = __assign$2(__assign$2({}, dynamicProps), newConfig || {});
          render(dynamicProps);
        }

        function close() {
          leaving = true;
          dynamicProps.openIndex = -1;
          render(dynamicProps);
        }

        dynamicProps.close = close;

        dynamicProps.onClose = function () {
          baseProps.onClose && baseProps.onClose();

          if (baseProps.unmountOnExit) {
            removeElement(div);
          }
        };

        dynamicProps.openIndex = -1;
        render(dynamicProps);
        setTimeout(function () {
          if (leaving) return;
          dynamicProps.openIndex = baseProps.openIndex;
          render(dynamicProps);
        }, 20);
        return {
          close: close,
          update: update
        };
      };
    }

    var MAX_ZOOM = 5;
    var MIN_ZOOM = 0.7;
    var ImagePreview = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a, _b;

      var style = props.style,
          className = props.className,
          images = props.images,
          _c = props.loop,
          loop = _c === void 0 ? false : _c,
          openIndex = props.openIndex,
          fit = props.fit,
          _d = props.noselect,
          noselect = _d === void 0 ? true : _d,
          _e = props.displayDuration,
          displayDuration = _e === void 0 ? 350 : _e,
          _f = props.spaceBetween,
          spaceBetween = _f === void 0 ? 0 : _f,
          _g = props.showLoading,
          showLoading = _g === void 0 ? true : _g,
          loadingArea = props.loadingArea,
          errorArea = props.errorArea,
          _h = props.showError,
          showError = _h === void 0 ? true : _h,
          retryTime = props.retryTime,
          staticLabel = props.staticLabel,
          replaceFallbackWhenLoaded = props.replaceFallbackWhenLoaded,
          scrollBezier = props.scrollBezier,
          _j = props.lazyloadCount,
          lazyloadCount = _j === void 0 ? 1 : _j,
          _k = props.swipeToClose,
          swipeToClose = _k === void 0 ? true : _k,
          extra = props.extra,
          getMinScale = props.getMinScale,
          getMaxScale = props.getMaxScale,
          getDoubleClickScale = props.getDoubleClickScale,
          getContainer = props.getContainer,
          getThumbBounds = props.getThumbBounds,
          renderIndicator = props.renderIndicator,
          _onChange = props.onChange,
          _onAfterChange = props.onAfterChange,
          onImageClick = props.onImageClick,
          onImageDoubleClick = props.onImageDoubleClick,
          onImageLongTap = props.onImageLongTap,
          close = props.close,
          onClose = props.onClose,
          onTouchStart = props.onTouchStart,
          onTouchMove = props.onTouchMove,
          onTouchEnd = props.onTouchEnd,
          _l = props.indicatorPos,
          indicatorPos = _l === void 0 ? 'start' : _l,
          otherProps = __rest$1(props, ["style", "className", "images", "loop", "openIndex", "fit", "noselect", "displayDuration", "spaceBetween", "showLoading", "loadingArea", "errorArea", "showError", "retryTime", "staticLabel", "replaceFallbackWhenLoaded", "scrollBezier", "lazyloadCount", "swipeToClose", "extra", "getMinScale", "getMaxScale", "getDoubleClickScale", "getContainer", "getThumbBounds", "renderIndicator", "onChange", "onAfterChange", "onImageClick", "onImageDoubleClick", "onImageLongTap", "close", "onClose", "onTouchStart", "onTouchMove", "onTouchEnd", "indicatorPos"]);

      var system = useSystem();
      var domRef = React.useRef(null);
      var imagesRef = React.useRef([]);
      var carouselRef = React.useRef(null);
      var transformersRef = React.useRef([]);
      var longTimerRef = React.useRef(null);
      var transImageRef = React.useRef(null);
      var imageDomsRef = React.useRef([]);
      var touchStartXRef = React.useRef(0);
      var startTouchingSideRef = React.useRef(false);
      var movedRef = React.useRef(false);
      var dblClickingRef = React.useRef(false);
      var longTapCheckingRef = React.useRef(false);
      var innerIndexRef = React.useRef(openIndex);
      var touchingSideDisRef = React.useRef(0);
      var lastScaleRef = React.useRef(0);
      var closingRef = React.useRef(false);
      var isInitialMount = React.useRef(false);

      var _m = React.useState({}),
          showPlaceholders = _m[0],
          setPlaceholders = _m[1];

      var _o = useRefState([]),
          imagesStatus = _o[0],
          imagesStatusRef = _o[1],
          setImagesStatus = _o[2];

      var _p = React.useState(null),
          transImageInfo = _p[0],
          setTransImageInfo = _p[1];

      var openLoaded = (_a = imagesStatus[openIndex]) === null || _a === void 0 ? void 0 : _a.loaded;
      var openAnimated = (_b = imagesStatus[openIndex]) === null || _b === void 0 ? void 0 : _b.animated;
      var visible = openIndex >= 0 && openIndex < images.length;

      var _q = useWindowSize(true),
          windowWidth = _q.windowWidth,
          windowHeight = _q.windowHeight;

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          imageDoms: imageDomsRef.current
        };
      });
      usePopupScroll(visible, domRef.current, function () {
        return [];
      }, 'top', handlePreventCallback);
      React.useEffect(function () {
        if (visible) {
          innerIndexRef.current = openIndex;
          closingRef.current = false;
          carouselRef.current && carouselRef.current.changeIndex(openIndex, true);
          setImagesStatus(images.map(function (_, index) {
            var _a;

            return {
              firstLoaded: ((_a = imagesStatusRef.current[index]) === null || _a === void 0 ? void 0 : _a.firstLoaded) || false,
              animated: index !== openIndex
            };
          }));
          setDisplayAnimation(openIndex);
        } else {
          // 移除长按事件监听
          // @en Remove long press event listener
          longTimerRef.current && clearTimeout(longTimerRef.current);
          longTapCheckingRef.current = false; // 图片状态重置
          // @en Reset image state

          setImagesStatus(imagesStatusRef.current.map(function (status) {
            return __assign$2(__assign$2({}, status), {
              animated: false,
              loaded: false
            });
          }));
          transformersRef.current = []; // 移除过渡图片
          // @en Remove transition image

          removeChild(transImageRef.current);
          setTransImageInfo(null);
          setPlaceholders({});
          var mounted_1 = isInitialMount.current;
          setTimeout(function () {
            mounted_1 && onClose && onClose();
          }, displayDuration);
        }

        isInitialMount.current = true;
      }, [visible]);
      React.useEffect(function () {
        if (visible && openLoaded && openAnimated) {
          setTimeout(function () {
            removeChild(transImageRef.current);
            transImageRef.current = null;
          }, 100);
        }
      }, [visible, openLoaded, openAnimated]);
      React.useEffect(function () {
        // 执行过渡动画时避免滚动穿透
        // @en Avoid scroll penetration when performing transition animation
        if (transImageInfo) {
          preventEleScroll();
        } else {
          nextTick(function () {
            freeEleScroll();
          });
        }
      }, [transImageInfo]);
      React.useEffect(function () {
        (transformersRef.current || []).forEach(function (transformer, index) {
          transformer && transformer.setMinScale(getImageMinScale(index));
        });
      }, [getMinScale]);
      React.useEffect(function () {
        (transformersRef.current || []).forEach(function (transformer, index) {
          transformer && transformer.setMaxScale(getImageMaxScale(index));
        });
      }, [getMaxScale]);

      function removeChild(child) {
        var _a, _b, _c;

        try {
          child && ((_c = (_b = (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.carousel-item')) === null || _b === void 0 ? void 0 : _b[innerIndexRef.current]) === null || _c === void 0 ? void 0 : _c.removeChild(child));
        } catch (e) {}
      } // 监听滑动到上下边缘后还在往外滑动的操作，则关闭弹窗
      // @en Monitor the operation of sliding out after sliding to the upper and lower edges, then close the popup


      function handlePreventCallback(_, dir) {
        if (!isTransforming() && dir === 'y') {
          touchingSideDisRef.current += 1;
        }
      }
      /**
       * 缩放插件初始化
       * @en Zoom plugin initialization
       */


      function initTransformer(index) {
        var _a;

        var imageDom = (_a = imagesRef.current[index]) === null || _a === void 0 ? void 0 : _a.dom;
        var wrapDom = imageDom === null || imageDom === void 0 ? void 0 : imageDom.parentElement;

        if (!imageDom || !wrapDom) {
          return;
        }

        if (transformersRef.current[index]) {
          transformersRef.current[index].setDom(wrapDom);
        } else {
          // 缩放插件中对长图的处理：放大状态为模拟手势滚动，还原状态为真实滚动
          // @en The processing of long images in the zoom plugin: the zoomed state is simulated gesture scrolling, and the restored state is real scrolling
          transformersRef.current[index] = new TransformAble({
            // wrapDom为无transform和transition的纯净容器
            // @en wrapDom is a pure container without transform and transition
            dom: wrapDom,
            motionThreshold: 0,
            dragMode: 'always',
            transformMode: 'matrix',
            useDomBoundary: false,
            cubic: {
              scroll: scrollBezier
            },
            onTransform: function onTransform() {
              var _a, _b, _c, _d; // 图片放大再缩小，解决ios图片放大后模糊的问题
              // @en The image is zoomed in and then zoomed out to solve the problem of blurring after zooming in on ios images


              var img = imageDomsRef.current[index];
              var trans = ((_b = (_a = transformersRef.current[index]) === null || _a === void 0 ? void 0 : _a.getTransform) === null || _b === void 0 ? void 0 : _b.call(_a)) || {};
              var width = (_c = imagesStatusRef.current[index]) === null || _c === void 0 ? void 0 : _c.originWidth;
              var height = (_d = imagesStatusRef.current[index]) === null || _d === void 0 ? void 0 : _d.originHeight;
              var scale = trans.scale || 1; // 判断下只有图片缩放发生改变时重写图片样式
              // @en It is judged that only the image style is rewritten when the zoom of the image changes.

              if (img && width && height && lastScaleRef.current !== scale) {
                lastScaleRef.current = scale;
                var atCenter = !imageHasOverflow(img) ? ' translateY(-50%)' : '';
                img.style.width = width * scale + "px";
                img.style.height = height * scale + "px";
                var transform = "scale(" + 1 / scale + ") translateZ(0)" + atCenter;
                img.style.transform = transform;
                img.style.webkitTransform = transform;
                img.style.transformOrigin = 'top left';
                img.style.webkitTransformOrigin = 'top left';
              }
            },
            onRestore: function onRestore() {
              lastScaleRef.current = 0;
            },
            onZoomEnd: function onZoomEnd(_1, _2, pinchStartCenter) {
              setPlaceholders(function (holders) {
                var _a;

                return __assign$2(__assign$2({}, holders), (_a = {}, _a[index] = false, _a));
              });
              var image = imageDomsRef.current[index];
              var transformer = transformersRef.current[index];

              if (!image || !transformer || transformer.getTransform().scale < 1) {
                return;
              }

              var imageRect = image.getBoundingClientRect();

              if (imageRect.width > windowWidth && imageRect.height > windowHeight) {
                if (pinchStartCenter && pinchStartCenter.length) {
                  transformer.setCenter.apply(transformer, pinchStartCenter);
                }

                transformer.setFixedX(false);
                transformer.setFixedY(false);
              } else if (imageRect.height <= windowHeight) {
                if (!transformer.fixedY) {
                  transformer.setFixedY(true);
                  transformer.bounce();
                }
              } else if (imageRect.width <= windowWidth) {
                if (!transformer.fixedX) {
                  transformer.setFixedX(true);
                  transformer.bounce();
                }
              }
            },
            minScale: getImageMinScale(index),
            maxScale: getImageMaxScale(index)
          });
        }

        setOriginBoundary(index);
      }

      function imageHasOverflow(img) {
        return Boolean(img && !img.classList.contains('preview-fit-contain-y'));
      }

      function setOriginBoundary(index) {
        var imageEle = imagesRef.current[index];
        var imageDom = imageEle === null || imageEle === void 0 ? void 0 : imageEle.dom; // 边界范围变为图片范围和容器范围的并集
        // @en The bounding range becomes the union of the image range and the container range

        if ((imageDom === null || imageDom === void 0 ? void 0 : imageDom.parentElement) && (imageEle === null || imageEle === void 0 ? void 0 : imageEle.image)) {
          var rect = imageEle.image.getBoundingClientRect();
          var eleRect = imageDom.parentElement.getBoundingClientRect();

          if (transformersRef.current[index]) {
            transformersRef.current[index].setBoundary({
              left: Math.min(rect.left, eleRect.left),
              right: Math.max(rect.right, eleRect.right),
              top: Math.min(rect.top, eleRect.top),
              bottom: Math.max(rect.bottom, eleRect.bottom)
            }, true);
          }
        }
      }
      /**
       * 获取最小缩放倍数
       * @en Get the minimum zoom factor
       */


      function getImageMinScale(index) {
        var currentIndex = index === void 0 ? innerIndexRef.current : index;
        var imageDom = imageDomsRef.current[currentIndex];

        if (!imageDom) {
          return 1;
        }

        if (getMinScale) {
          return getMinScale(imageDom, currentIndex);
        }

        return MIN_ZOOM;
      }
      /**
       * 获取最大缩放倍数
       * @en Get the maximum zoom factor
       */


      function getImageMaxScale(index) {
        var currentIndex = index === void 0 ? innerIndexRef.current : index;
        var imageDom = imageDomsRef.current[currentIndex];

        if (!imageDom) {
          return 1;
        }

        if (getMaxScale) {
          return getMaxScale(imageDom, currentIndex);
        }

        var imageWidth = imageDom.naturalWidth;
        var imageHeight = imageDom.naturalHeight;
        var maxScale = 1;

        if (imageWidth > imageHeight) {
          maxScale = imageWidth / windowWidth * MAX_ZOOM;
        } else {
          maxScale = Math.max(MAX_ZOOM, imageWidth / windowWidth);
        }

        return maxScale;
      }
      /**
       * 计算双击时图片缩放倍数
       * @en Calculate the zoom factor of the image when double-clicking
       */


      function getImageDoubleClickScale(currentScale) {
        var index = innerIndexRef.current;
        var imageDom = imageDomsRef.current[index];

        if (!imageDom) {
          return 1;
        }

        var maxScale = getImageMaxScale(index);

        if (getDoubleClickScale) {
          return getDoubleClickScale(currentScale, maxScale, imageDom, index);
        }

        var imageWidth = imageDom.naturalWidth;
        var imageHeight = imageDom.naturalHeight;
        var fitScale = imageWidth > imageHeight ? imageWidth / windowWidth * windowHeight / imageHeight : 1;
        var dblScale = 2;

        if (fitScale >= 2) {
          dblScale = Math.min(maxScale, fitScale);
        }

        var current = Number(currentScale.toFixed(3));
        var dbl = Number(dblScale.toFixed(3));
        return current >= 1 && current < dbl ? dbl : 1;
      }
      /**
       * 还原缩放至原始位置
       * @en Revert zoom to original position
       */


      function restoreTransformer(index) {
        var transformer = transformersRef.current[index];

        if (transformer) {
          transformer.restore();
        }
      }
      /**
       * 是否正处于缩放状态
       * @en Whether it is zooming
       */


      function isTransforming(index) {
        var _a, _b;

        var currentIndex = index === void 0 ? innerIndexRef.current : index;
        return (_b = (_a = transformersRef.current[currentIndex]) === null || _a === void 0 ? void 0 : _a.busy) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * 是否已经放大过
       * @en Whether is has been zoomed in
       */


      function isTransformed() {
        var _a, _b;

        return (_b = (_a = transformersRef.current[innerIndexRef.current]) === null || _a === void 0 ? void 0 : _a.dirty) === null || _b === void 0 ? void 0 : _b.call(_a);
      }

      function isTapStop() {
        var _a, _b;

        return (_b = (_a = transformersRef.current[innerIndexRef.current]) === null || _a === void 0 ? void 0 : _a.isTapStop) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * 计算距离左右侧的距离，如果为0说明到边缘了，可以进行正常轮播操作
       * @en Calculate the distance from the left and right sides. If it is 0, it means that the edge is reached, and the normal rotation operation can be performed.
       */


      function transformTouchSide() {
        var _a, _b;

        var transformer = transformersRef.current[innerIndexRef.current];
        var toLeft = (_a = transformer === null || transformer === void 0 ? void 0 : transformer.toLeft) === null || _a === void 0 ? void 0 : _a.call(transformer);
        var toRight = (_b = transformer === null || transformer === void 0 ? void 0 : transformer.toRight) === null || _b === void 0 ? void 0 : _b.call(transformer);
        return {
          side: !toLeft || !toRight,
          left: !toLeft,
          right: !toRight
        };
      }

      function handleImageWrapTouchStart(e) {
        if (onTouchStart && onTouchStart(e, innerIndexRef.current)) {
          return true;
        }

        var touches = e.touches;
        touchStartXRef.current = e.touches && e.touches[0] ? e.touches[0].clientX : 0;
        movedRef.current = false;
        dblClickingRef.current = false; // 单点长按才触发长按
        // @en A single long press triggers a long press

        if (touches.length === 1) {
          if (!closingRef.current) {
            longTapCheckingRef.current = true;
          }

          longTimerRef.current = window.setTimeout(function () {
            if (longTapCheckingRef.current) {
              longTapCheckingRef.current = false;
              movedRef.current = true;
              onImageLongTap && onImageLongTap(innerIndexRef.current, imageDomsRef.current[innerIndexRef.current], e);
            }
          }, 300);
        } else {
          longTapCheckingRef.current = false;
        }

        if (isTapStop()) {
          movedRef.current = true;
        } // 缩放状态下，未到边缘时不触发轮播手势
        // @en In the zoomed state, the carousel gesture is not triggered when the edge is not reached


        if (isTransforming()) {
          startTouchingSideRef.current = transformTouchSide().side;
          return !startTouchingSideRef.current;
        }
      }

      function handleImageWrapTouchMove(e) {
        movedRef.current = true;
        longTapCheckingRef.current = false;
        longTimerRef.current && clearTimeout(longTimerRef.current);

        if (onTouchMove && onTouchMove(e, innerIndexRef.current)) {
          return true;
        }

        var evt = e.changedTouches[0];
        var touchMoveX = evt.clientX || 0;
        var posDisX = touchMoveX - touchStartXRef.current; // 缩放状态下，到边缘时如果还在往外滑动，则触发轮播手势
        // @en In the zoomed state, if it is still swiped out when reaching the edge, the carousel gesture is triggered

        if (isTransforming()) {
          var sideInfo = transformTouchSide();
          return !startTouchingSideRef.current || !(sideInfo.left && posDisX > 0 || sideInfo.right && posDisX < 0);
        }
      }

      function handleImageWrapTouchEnd(e) {
        if (onTouchEnd && onTouchEnd(e, innerIndexRef.current)) {
          return true;
        } // 滑动到上下边缘后还在往外滑动，则关闭弹窗
        // @en After sliding to the upper and lower edges and still sliding outwards, close the popup box
        // needClose为触发touchmove的次数，6和3是相对值，表示判断在往外滑动的敏感度，当未放大时对向外滑动手势更敏感
        // @en needClose is the number of times the touchmove is triggered, 6 and 3 are relative values, indicating the sensitivity of judging the outward sliding, and it is more sensitive to the outward sliding gesture when it is not zoomed in


        var needClose = swipeToClose && touchingSideDisRef.current >= (isTransformed() ? 6 : 3);
        touchingSideDisRef.current = 0;
        longTapCheckingRef.current = false;
        longTimerRef.current && clearTimeout(longTimerRef.current);

        if (needClose) {
          goClose(e);
          return true;
        } // 缩放状态下，未到边缘时不触发轮播手势
        // @en In the zoomed state, the carousel gesture is not triggered when the edge is not reached


        if (isTransforming() && !transformTouchSide().side) {
          return true;
        }
      }

      function handleImageClick(e) {
        if (movedRef.current) {
          return;
        } // 如果正在触发doubleClick就不触发click
        // @en If doubleClick is being triggered, click will not be triggered


        if (!dblClickingRef.current) {
          if (!onImageClick || !onImageClick(innerIndexRef.current, e)) {
            goClose(e);
          }
        }
      }

      function handleImageDoubleClick(e) {
        if (dblClickingRef.current) {
          // 防止重复触发dblclick
          return;
        }

        dblClickingRef.current = true;
        var index = innerIndexRef.current;
        onImageDoubleClick && onImageDoubleClick(index, e); // 双击时根据配置放大或缩小
        // @en Zoom in or out according to configuration when double-clicking

        var transformer = transformersRef.current[index];

        if (transformer) {
          var trans = transformer.getTransform();
          var rate = trans.scale || 1;
          var dblScale = getImageDoubleClickScale(rate);

          if (dblScale === 1) {
            var img = imageDomsRef.current[index]; // 长图双击还原缩放特殊处理，因为transform和scroll不能完全同步，所以先zoomTo到原点再restore
            // @en Double-click the long image to restore zoom special processing, because transform and scroll cannot be completely synchronized, so first zoomTo to the origin and then restore

            if (imageHasOverflow(img)) {
              transformer.zoomToScreenCenter(1, [windowWidth / 2, windowHeight / 2], {
                duration: 200,
                callback: function callback() {
                  return transformer.restore();
                }
              });
            } else {
              transformer.bounce();
              transformer.restore();
            }
          } else {
            transformer.zoomToScreenCenter(dblScale, [windowWidth / 2, windowHeight / 2], {
              duration: 200,
              silent: false
            });
          }
        }
      }

      var handleClick = useSingleAndDoubleClick(handleImageClick, handleImageDoubleClick); // 当使用 getThumbBounds 时，关闭图片预览有缩小效果
      // @en When using getThumbBounds, closing the image preview has a shrinking effect

      function animateBeforeClose() {
        var _a;

        var index = innerIndexRef.current;
        var imageDom = (_a = imagesRef.current[index]) === null || _a === void 0 ? void 0 : _a.image;
        var thumbBounds = getThumbBounds === null || getThumbBounds === void 0 ? void 0 : getThumbBounds(index);

        if (!imageDom || !thumbBounds || !thumbBounds.width || !thumbBounds.height) {
          return;
        } // 小图超过一半在视野外时，不展示缩小效果
        // @en When more than half of the thumbnail is outside the field of view, the zoom effect will not be displayed


        if (thumbBounds.top < -1 * thumbBounds.height / 2 || thumbBounds.top > windowHeight - thumbBounds.height / 2 || thumbBounds.left < -1 * thumbBounds.width / 2 || thumbBounds.left > windowWidth - thumbBounds.width / 2) {
          return;
        }

        var imageDomRect = imageDom.getBoundingClientRect();

        if (!imageDomRect.width || !imageDomRect.height) {
          return;
        }

        imageDom.classList.add('closing-animation');
        setImageBounds(imageDom, imageDomRect, imageDomRect);
        imageDom.style.objectPosition = images[index].thumbPosition || 'top center';
        nextTick(function () {
          imageDom.style.transitionDuration = displayDuration + "ms";
          imageDom.style.webkitTransitionDuration = displayDuration + "ms";
          setImageBounds(imageDom, thumbBounds, imageDomRect);
        });
      }

      function goClose(e) {
        if (closingRef.current) {
          return;
        }

        closingRef.current = true;
        animateBeforeClose();
        close(e);
      }
      /**
       * 更改指定图片状态
       * @en Change specified image status
       */


      function setImagesStatusByIndex(index, data) {
        setImagesStatus(function (current) {
          var newStatus = current.slice();
          newStatus[index] = __assign$2(__assign$2({}, newStatus[index] || {}), data);
          return newStatus;
        });
      }
      /**
       * 缩略图放大过渡动画设置
       * @en Set thumbnail zoom transition animation
       */


      function setDisplayAnimation(index) {
        var _a, _b, _c, _d;

        var firstLoaded = (_a = imagesStatusRef.current[index]) === null || _a === void 0 ? void 0 : _a.firstLoaded;
        var fallbackSrc = replaceFallbackWhenLoaded && firstLoaded ? images[index].src : images[index].fallbackSrc; // 用户设置了getThumbBounds和images的fallbackSrc属性才有放大过渡效果
        // @en Set the fallbackSrc attribute of getThumbBounds and images to have a zoom-in transition effect

        if (!getThumbBounds || !images[index] || !fallbackSrc) {
          resetAnimation(index);
          return;
        } // 获取缩略图的rect，如果没获取到就取消放大过渡效果
        // @en Get the rect of the thumbnail, if it is gotten, cancel the zoom transition effect


        var thumbBounds = getThumbBounds(index);

        if (!thumbBounds || !thumbBounds.width || !thumbBounds.height) {
          resetAnimation(index);
          return;
        } // 伪造一个fixed的图做小图放大效果
        // @en Forge a fixed image to make a small image enlargement effect


        var transImage = new Image();
        transImageRef.current = transImage;
        transImage.classList.add('image-preview-fake-trans-image');
        setImageBounds(transImage, thumbBounds, thumbBounds);
        transImage.src = fallbackSrc;
        transImage.style.objectPosition = images[index].thumbPosition || 'top center';
        transImage.style.opacity = '0';
        transImage.style.transitionDuration = displayDuration + "ms";
        transImage.style.webkitTransitionDuration = displayDuration + "ms";
        (_d = (_c = (_b = domRef.current) === null || _b === void 0 ? void 0 : _b.querySelectorAll('.carousel-item')) === null || _c === void 0 ? void 0 : _c[index]) === null || _d === void 0 ? void 0 : _d.prepend(transImage); // 拿到放大之后的位置rect，没拿到就取消小图放大效果
        // @en Get the zoomed-in position rect, and cancel the zoom-in effect if not getting it

        getNewImageBounds(index, fallbackSrc, transImage, function (rect) {
          if (!rect || !rect.width || !rect.height) {
            removeChild(transImage);
            resetAnimation(index);
            return;
          } // 通过小图rect变换到大图rect加transition做放大效果
          // @en Transform the small image rect to the large image rect and add transition to make a magnification effect


          nextTick(function () {
            transImage.style.opacity = '1';
            setImageBounds(transImage, rect, thumbBounds);
            setTimeout(function () {
              setPlaceholders(function (holders) {
                var _a;

                return __assign$2(__assign$2({}, holders), (_a = {}, _a[index] = true, _a));
              });
            }, Math.max(0, displayDuration - 80));
            var transitionEndDelay = images[index].transitionEndDelay || 30;
            setTimeout(function () {
              resetAnimation(index);
            }, displayDuration + transitionEndDelay);
          });
        });
      }
      /**
       * 取消小图放大过渡效果
       * @en Cancel the thumbnail zoom transition effect
       */


      function resetAnimation(index) {
        setImagesStatusByIndex(index, {
          animated: true
        });
        setTransImageInfo(null);
      }
      /**
       * 根据rect设置图片的位置
       * @en Set the position of the image according to the rect
       */


      function setImageBounds(image, rect, thumbRect) {
        // 这里为保持原有比例，只设置宽度变化，高度会随宽度等比变化
        image.style.width = thumbRect.width + "px";
        var transform = "translate3d(" + rect.left + "px, " + rect.top + "px, 0) scale(" + rect.width / thumbRect.width;
        image.style.transform = transform;
        image.style.webkitTransform = transform;
        image.style.transformOrigin = 'left top';
        image.style.webkitTransformOrigin = 'left top';
      }
      /**
       * 计算放大之后的位置rect
       * @en Calculate the position rect after zooming in
       */


      function getNewImageBounds(index, transSrc, transImage, callback) {
        if (!transSrc) {
          callback(null);
          return;
        }

        setTransImageInfo({
          src: transSrc,
          fit: images[index].fit,
          index: index,
          movingImage: transImage,
          onLoad: function onLoad(_, image) {
            setTimeout(function () {
              callback(image.getBoundingClientRect());
            }, 20);
          },
          onError: function onError() {
            return callback(null);
          }
        });
      }
      /**
       * @en 渲染轮播+图片展示
       * Rendering carousel + displaying image
       */


      function renderContent(carouselProps, allImages, getImageProps) {
        return /*#__PURE__*/React__default["default"].createElement(Carousel, __assign$2({
          autoPlay: false,
          loop: loop,
          lazyloadCount: lazyloadCount,
          stopPropagation: false
        }, carouselProps), (allImages || []).map(function (image, index) {
          var innerNode = /*#__PURE__*/React__default["default"].createElement("div", {
            key: index,
            className: "preview-image-wrap",
            style: {
              padding: "0 " + spaceBetween + "px"
            }
          }, /*#__PURE__*/React__default["default"].createElement(BaseImage, __assign$2({
            className: "preview-image",
            fit: image.fit || fit || 'preview-y',
            boxWidth: windowWidth - spaceBetween * 2,
            boxHeight: windowHeight,
            bottomOverlap: null
          }, getImageProps(image, index))));
          return image.extraNode ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "preview-image-wrap-container",
            key: "outer-" + index
          }, innerNode, image.extraNode) : innerNode;
        }));
      }

      function getImageClass(index) {
        var _a = imagesStatus[index] || {},
            loaded = _a.loaded,
            animated = _a.animated;

        return cls('preview-image', {
          'preview-hidden': index === openIndex && (!loaded || !animated)
        });
      }
      /**
       * 每张图片的样式
       * @en style of each image
       */


      function getImageStyle() {
        // 因为缩放的容器必须是没有transform和transition的纯净元素
        // @en Because the scaled container must be a pure element without transform and transition
        // 所以这里强制设置overflow为visible，溢出滚动的部分交由外层来做
        // @en So it is forced to set overflow to visible, and the part of overflow scrolling is left to the outer layer.
        return {
          overflow: 'visible'
        };
      } // 渲染轮播指引器


      function renderPreviewIndicator(currentIndex, total, lastIndex) {
        if (renderIndicator) {
          return renderIndicator(currentIndex, total, lastIndex);
        }

        return openLoaded ? /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: getContainer
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-preview-indicator"
        }, currentIndex + 1, "/", total)) : null;
      } // ios在重设style时图片会消失一下造成闪动，因此在底下垫一张图
      // @en In iOS when resetting the style, the image will disappear and cause flickering, so put a image at the bottom
      // 优先过渡图，其次用原图
      // @en Prioritize the transition image, followed by the original image


      function renderImagePlaceholder(src, index, fitCss) {
        var _a = imagesStatus[index] || {},
            originWidth = _a.originWidth,
            originHeight = _a.originHeight,
            originLeft = _a.originLeft,
            originTop = _a.originTop,
            hasOverflow = _a.hasOverflow;

        var trans = hasOverflow ? {} : getStyleWithVendor({
          transform: 'translateY(-50%)'
        });
        var fitObj = fitCss ? {
          objectFit: fitCss
        } : {};
        return system === 'ios' && showPlaceholders[index] && originWidth && originHeight ? /*#__PURE__*/React__default["default"].createElement("img", {
          src: src,
          style: __assign$2(__assign$2({
            position: 'absolute',
            width: originWidth,
            height: originHeight,
            left: originLeft,
            top: originTop
          }, fitObj), trans)
        }) : null;
      }

      function renderLoadingArea() {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-preview-loading-area"
        }, loadingArea || /*#__PURE__*/React__default["default"].createElement(Loading, {
          type: "circle",
          className: "loading-icon",
          radius: 7
        }));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: getContainer
        }, /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: visible,
          timeout: displayDuration,
          type: "fade",
          mountOnEnter: true,
          unmountOnExit: true,
          nodeRef: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-image-preview", 'all-border-box', {
            noselect: noselect
          }, className),
          style: style,
          ref: domRef,
          onClick: handleClick,
          onDoubleClick: handleImageDoubleClick
        }, renderContent(__assign$2({
          indicatorPos: indicatorPos,
          initialIndex: openIndex,
          ref: carouselRef,
          renderIndicator: renderPreviewIndicator,
          onChange: function onChange(index) {
            innerIndexRef.current = index;
            _onChange && _onChange(index);
          },
          onAfterChange: function onAfterChange(index, oldIndex) {
            _onAfterChange && _onAfterChange(index);
            restoreTransformer(oldIndex);
            nextTick(function () {
              initTransformer(innerIndexRef.current);
            });
          },
          onTouchMove: handleImageWrapTouchMove,
          onTouchStart: handleImageWrapTouchStart,
          onTouchEnd: handleImageWrapTouchEnd
        }, otherProps), images, function (image, index) {
          return {
            src: image.src,
            ref: function ref(r) {
              imagesRef.current[index] = r;
            },
            showLoading: showLoading,
            loadingArea: renderLoadingArea(),
            errorArea: errorArea,
            showError: showError,
            retryTime: retryTime,
            staticLabel: staticLabel,
            animateDuration: transImageInfo ? 0 : void 0,
            style: getImageStyle(),
            className: getImageClass(index),
            bottomOverlap: renderImagePlaceholder(image.fallbackSrc || image.src, index, image.fit || fit),
            onLoad: function onLoad(_, imageEle) {
              imageDomsRef.current[index] = imageEle;
              setImagesStatusByIndex(index, {
                loaded: true,
                firstLoaded: true,
                originWidth: imageEle.offsetWidth,
                originHeight: imageEle.offsetHeight,
                originTop: imageEle.offsetTop,
                originLeft: imageEle.offsetLeft,
                hasOverflow: imageHasOverflow(imageEle)
              });

              if (index === openIndex) {
                initTransformer(index);
              } else {
                setPlaceholders(function (holders) {
                  var _a;

                  return __assign$2(__assign$2({}, holders), (_a = {}, _a[index] = true, _a));
                });
              }
            },
            onError: function onError() {
              imageDomsRef.current[index] = null;

              if (index === openIndex) {
                var transImage = transImageInfo === null || transImageInfo === void 0 ? void 0 : transImageInfo.movingImage;
                removeChild(transImage);
                setImagesStatusByIndex(index, {
                  animated: true,
                  loaded: true
                });
                setTransImageInfo(null);
              }
            }
          };
        }), transImageInfo ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-preview-fake-rect"
        }, renderContent({
          initialIndex: 0
        }, [{
          src: transImageInfo.src,
          fit: transImageInfo.fit
        }], function () {
          return {
            staticLabel: staticLabel,
            src: transImageInfo.src,
            animateDuration: 0,
            onLoad: transImageInfo.onLoad,
            onError: transImageInfo.onError
          };
        })) : null, extra)), transImageInfo ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "image-preview-lock-modal",
          onClick: goClose
        }) : null);
      });
    });
    function methodsGenerator$2(Comp) {
      return {
        /**
         * 打开图片预览
         * @desc {en} Open image preview
         * @param {ImagePreviewProps} config configuration
         * @returns {{ close: () => void; update: (newConfig: ImagePreviewProps) => void; }}
         */
        open: open$1(Comp)
      };
    }
    var ImagePreviewWithGlobalContext = CompWithGlobalContext(ImagePreview);
    /**
     * 图片预览组件，支持循环轮播、双指/双击缩放、缩略图放大效果。
     * @en The image preview, supports circular rotation, two-finger/double-tap zoom, and thumbnail zoom effects.
     * @type 信息展示
     * @type_en Data Display
     * @name 图片预览
     * @name_en ImagePreview
     */

    var index$f = componentWrapper(ImagePreview, methodsGenerator$2(ImagePreviewWithGlobalContext));

    var IndexBarContext = /*#__PURE__*/React.createContext({
      sticky: true,
      getScrollContainer: function getScrollContainer() {
        return null;
      },
      updateRef: function updateRef() {}
    });

    var IndexBarGroup = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var groupIndex = props.index,
          list = props.list,
          className = props.className,
          style = props.style,
          children = props.children,
          listKey = props.listKey,
          onGroupItemClick = props.onGroupItemClick,
          renderGroupItem = props.renderGroupItem,
          renderStickyItem = props.renderStickyItem;
      var prefixCls = React.useContext(GlobalContext).prefixCls; // 有可能是IndexBar.Group的写法，因此sticky从context中获得

      var _a = React.useContext(IndexBarContext),
          sticky = _a.sticky,
          getScrollContainer = _a.getScrollContainer,
          activeIndex = _a.activeIndex,
          updateRef = _a.updateRef;

      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      }); // 用户自定义列表元素vnode的key

      var formatGetListKey = function formatGetListKey(data, index) {
        var _a;

        return (_a = listKey === null || listKey === void 0 ? void 0 : listKey(data, index)) !== null && _a !== void 0 ? _a : index;
      };

      var renderChildren = function renderChildren() {
        var _a;

        return (_a = children !== null && children !== void 0 ? children : list === null || list === void 0 ? void 0 : list.map(function (data, index) {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: prefixCls + "-index-bar-group-item",
            key: formatGetListKey(data, index),
            onClick: function onClick() {
              return onGroupItemClick === null || onGroupItemClick === void 0 ? void 0 : onGroupItemClick(groupIndex, data, index);
            }
          }, renderGroupItem ? renderGroupItem(groupIndex, data, index) : data.content);
        })) !== null && _a !== void 0 ? _a : null;
      };

      var renderIndexTitle = function renderIndexTitle() {
        var _a;

        if (renderStickyItem) {
          return renderStickyItem(groupIndex);
        }

        var titleDom = /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-index-bar-group-title", (_a = {}, _a[prefixCls + "-index-bar-group-active"] = activeIndex === groupIndex, _a))
        }, groupIndex);
        var groupDom = domRef.current;
        return sticky ? /*#__PURE__*/React__default["default"].createElement(Sticky, {
          getContainer: function getContainer() {
            return groupDom;
          },
          stickyStyle: "absolute",
          getScrollContainer: getScrollContainer,
          ref: function ref(stickyRef) {
            return stickyRef && updateRef(groupIndex, stickyRef);
          }
        }, titleDom) : titleDom;
      };

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-index-bar-group", className),
        style: style,
        "data-index": groupIndex,
        ref: domRef
      }, renderIndexTitle(), renderChildren());
    });

    function IndexBarSideBar(props) {
      var _a;

      var indexes = props.indexes,
          prefixCls = props.prefixCls,
          onTouching = props.onTouching,
          onClick = props.onClick,
          activeIndex = props.activeIndex,
          tipType = props.tipType,
          renderSideBar = props.renderSideBar,
          _b = props.renderSideBarItem,
          renderSideBarItem = _b === void 0 ? function (index) {
        return index;
      } : _b,
          propsRenderTip = props.renderTip;

      var _c = React.useState(false),
          isTouching = _c[0],
          originSetIsTouching = _c[1];

      var setIsTouching = function setIsTouching(touching) {
        originSetIsTouching(touching);
        onTouching(touching);
      };

      var handleTouchingStart = function handleTouchingStart() {
        return setIsTouching(true);
      };

      var handleTouchingStop = function handleTouchingStop() {
        return setIsTouching(false);
      };

      var handleTouchMove = function handleTouchMove(e) {
        var _a, _b;

        if (!isTouching || !((_a = e.touches) === null || _a === void 0 ? void 0 : _a.length)) {
          return;
        }

        var _c = e.touches[0],
            clientX = _c.clientX,
            clientY = _c.clientY;
        var target = document.elementFromPoint(clientX, clientY);

        if (target && ((_b = target.dataset) === null || _b === void 0 ? void 0 : _b.index)) {
          onClick(target.dataset.index);
        }
      };

      var renderSideBarTip = function renderSideBarTip(index, type) {
        if (propsRenderTip) {
          return propsRenderTip(index);
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-index-bar-sidebar-" + type
        }, index);
      };

      var node = /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-index-bar-sidebar", (_a = {}, _a[prefixCls + "-index-bar-sidebar-touching"] = isTouching, _a)),
        onTouchStart: function onTouchStart() {
          return handleTouchingStart();
        },
        onTouchEnd: function onTouchEnd() {
          return handleTouchingStop();
        },
        onTouchCancel: function onTouchCancel() {
          return handleTouchingStop();
        },
        onTouchMove: handleTouchMove
      }, tipType === 'toast' && isTouching && activeIndex && renderSideBarTip(activeIndex, 'toast'), indexes.map(function (index) {
        var _a;

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-index-bar-sidebar-item", (_a = {}, _a[prefixCls + "-index-bar-sidebar-active"] = activeIndex === index, _a)),
          key: index,
          onTouchStart: function onTouchStart() {
            return onClick(index);
          },
          "data-index": index
        }, tipType === 'sweat' && isTouching && activeIndex === index && renderSideBarTip(index, 'sweat'), /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-index-bar-sidebar-item-wrapper"
        }, renderSideBarItem(index)));
      }));
      return renderSideBar ? renderSideBar(node) : node;
    }

    function filterValidIndexBarChild(children) {
      var validChildren = [];
      React.Children.forEach(children, function (child) {
        if (! /*#__PURE__*/React.isValidElement(child)) {
          console.warn('<IndexBar /> only accept <IndexBar.Group /> as the children');
          return;
        }

        validChildren.push(child);
      });
      return validChildren;
    } // index有可能是number或者string，但是绑在data-index的attr上后
    // 通过滑动事件得到的都是string，需要处理下

    function getFormatIndex(index, activeIndex) {
      var activeIndexType = typeof activeIndex;
      var indexType = typeof index;

      if (indexType === activeIndexType) {
        return index;
      }

      if (activeIndexType === 'number') {
        return Number(index);
      }

      return index.toString();
    }
    function isValidIndex(index) {
      return typeof index === 'number' || typeof index === 'string';
    }
    function getGroupDomFromIndex(containerDom, activeIndex) {
      var targetDom = null;
      var containerChildren = containerDom.children;

      for (var i = 0; i < containerChildren.length; i++) {
        var dom = containerChildren[i];
        var dataset = dom === null || dom === void 0 ? void 0 : dom.dataset;

        if (dataset && dataset.index) {
          var formatIndex = getFormatIndex(dataset.index, activeIndex);

          if (formatIndex === activeIndex) {
            targetDom = dom;
            break;
          }
        }
      }

      return targetDom;
    }

    var IndexBar = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          children = props.children,
          _b = props.sticky,
          sticky = _b === void 0 ? true : _b,
          _c = props.groups,
          groups = _c === void 0 ? [] : _c,
          _d = props.tipType,
          tipType = _d === void 0 ? 'toast' : _d,
          defaultIndex = props.defaultIndex,
          scrollBezier = props.scrollBezier,
          _e = props.scrollDuration,
          scrollDuration = _e === void 0 ? 0 : _e,
          _f = props.disableSidebar,
          disableSidebar = _f === void 0 ? false : _f,
          onChange = props.onChange,
          onGroupItemClick = props.onGroupItemClick,
          renderSideBar = props.renderSideBar,
          renderSideBarItem = props.renderSideBarItem,
          renderTip = props.renderTip,
          renderStickyItem = props.renderStickyItem,
          renderGroupItem = props.renderGroupItem; // 最外层dom元素的ref

      var domRef = React.useRef(null); // 所有group的容器dom，domRef的内容就是contanerRef和sidebar的内容

      var containerRef = React.useRef(null); // 过滤掉jsx写法中，奇怪的child

      var formatChildren = filterValidIndexBarChild(children); // 所有的索引内容，优先从props.groups中获取，再从formatChildren中获取

      var indexes = React.useMemo(function () {
        if (groups.length) {
          return groups.map(function (group) {
            return group.index;
          });
        }

        return formatChildren.map(function (child) {
          return child.props.index;
        });
      }, [children, groups]);
      var groupRefs = React.useRef({}); // 当前激活的Index

      var _g = React.useState(function () {
        return defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : indexes === null || indexes === void 0 ? void 0 : indexes[0];
      }),
          activeIndex = _g[0],
          setActiveIndex = _g[1]; // 给IndexBarGroup用的上下文，主要是为了兼容jsx的写法


      var contextValue = React.useMemo(function () {
        return {
          sticky: sticky,
          getScrollContainer: function getScrollContainer() {
            return containerRef.current;
          },
          activeIndex: activeIndex,
          updateRef: function updateRef(groupIndex, stickyRef) {
            groupRefs.current[groupIndex] = stickyRef;
          }
        };
      }, [sticky, activeIndex]); // 用户是否正在触碰sidebar, 如果为true的话，禁用handleScroll的处理

      var isScrollHandlerDisabledRef = React.useRef(false);

      var handleChangeActiveIndex = function handleChangeActiveIndex(index, type) {
        setActiveIndex(function (oldActiveIndex) {
          var newActiveIndex = getFormatIndex(index, oldActiveIndex); // 和上一次激活的acitveIndex不同，再触发onChange事件

          if (newActiveIndex !== oldActiveIndex) {
            onChange === null || onChange === void 0 ? void 0 : onChange(newActiveIndex, type);
          }

          return newActiveIndex;
        });
      }; // 要滚动到哪个指定的index


      var handleScrollIntoIndex = function handleScrollIntoIndex(params) {
        var index = params.index,
            type = params.type,
            _a = params.rightNow,
            rightNow = _a === void 0 ? false : _a; // 不传index默认走第一个index

        var formatIndex = index !== null && index !== void 0 ? index : indexes === null || indexes === void 0 ? void 0 : indexes[0];
        var containerDom = containerRef.current;

        if (!isValidIndex(index) || !containerDom) {
          return;
        } // 寻找Index对应的groupDom


        var groupDom = getGroupDomFromIndex(containerDom, formatIndex);

        if (groupDom) {
          handleChangeActiveIndex(formatIndex, type);
          var duration = rightNow ? 0 : scrollDuration;
          var targetScrollTop = groupDom.offsetTop; // 将屏幕滚动到groupDom
          // 手动触发需要禁用handleScroll事件

          if (type === 'manual') {
            isScrollHandlerDisabledRef.current = true;
            setTimeout(function () {
              isScrollHandlerDisabledRef.current = false;
            }, duration);
          }

          if (duration > 0) {
            scrollWithAnimation(containerDom.scrollTop, targetScrollTop, function (top) {
              return containerDom.scrollTop = top;
            }, duration, scrollBezier);
          } else {
            containerDom.scrollTop = targetScrollTop;
          }
        }
      };

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          scrollToIndex: function scrollToIndex(index, rightNow) {
            if (isValidIndex(index)) {
              handleScrollIntoIndex({
                index: index,
                rightNow: rightNow,
                type: 'manual'
              });
            }
          },
          recalculatePosition: function recalculatePosition(targetIndex) {
            var formatIndex = targetIndex !== null && targetIndex !== void 0 ? targetIndex : activeIndex;

            if (formatIndex) {
              var targetStickyRef = groupRefs.current[formatIndex];

              if (targetStickyRef && targetStickyRef.recalculatePosition) {
                targetStickyRef.recalculatePosition();
              }
            }
          }
        };
      });

      var renderChildren = function renderChildren() {
        if (formatChildren.length) {
          return formatChildren;
        }

        return groups === null || groups === void 0 ? void 0 : groups.map(function (group) {
          return /*#__PURE__*/React__default["default"].createElement(IndexBarGroup, {
            index: group.index,
            key: group.index,
            list: group.list,
            onGroupItemClick: onGroupItemClick,
            renderGroupItem: renderGroupItem,
            renderStickyItem: renderStickyItem
          });
        });
      };

      React.useEffect(function () {
        var _a;

        var handleScroll = lodash_throttle(function () {
          // 用户正在触碰sidebar和手动触发scroll时禁用滚动事件的处理
          if (!containerRef.current || isScrollHandlerDisabledRef.current) {
            return;
          } // 根据滚动的距离，获取处于屏幕最顶部的group是哪个


          var scrollTop = containerRef.current.scrollTop;

          for (var i = 0; i < containerRef.current.children.length; i++) {
            var child = containerRef.current.children[i];

            if (!child || !child.dataset || typeof child.dataset.index === 'undefined') {
              continue;
            }

            if (child.offsetTop + child.clientHeight >= scrollTop) {
              handleChangeActiveIndex(child.dataset.index, 'swipe');
              break;
            }
          }
        }, 100); // 页面挂载时，如果是传入了defaultIndex，则滚动到对应位置

        if (activeIndex) {
          handleScrollIntoIndex({
            index: activeIndex,
            rightNow: true,
            type: 'manual'
          });
        }

        (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', handleScroll);
        return function () {
          var _a;

          (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', handleScroll);
        };
      }, []);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(IndexBarContext.Provider, {
          value: contextValue
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-index-bar", className),
          style: style,
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-index-bar-container",
          ref: containerRef
        }, renderChildren()), !disableSidebar && /*#__PURE__*/React__default["default"].createElement(IndexBarSideBar, {
          tipType: tipType,
          activeIndex: activeIndex,
          prefixCls: prefixCls,
          indexes: indexes,
          onTouching: function onTouching(isTouching) {
            return isScrollHandlerDisabledRef.current = isTouching;
          },
          onClick: function onClick(newIndex) {
            return handleScrollIntoIndex({
              index: newIndex,
              type: 'sidebar'
            });
          },
          renderSideBar: renderSideBar,
          renderSideBarItem: renderSideBarItem,
          renderTip: renderTip
        })));
      });
    });
    /**
     * 索引栏组件
     * @en IndexBar component
     * @type 导航
     * @type_en Navigation
     * @name 索引栏
     * @name_en SearchBar
     */

    var index$e = componentWrapper(IndexBar, {
      Group: IndexBarGroup
    });

    function useInputLogic(props, inputRef) {
      var value = props.value,
          defaultValue = props.defaultValue,
          validator = props.validator,
          onChange = props.onChange,
          onInput = props.onInput,
          className = props.className,
          style = props.style,
          label = props.label,
          required = props.required,
          prepend = props.prepend,
          append = props.append,
          blurBeforeFocus = props.blurBeforeFocus,
          onKeyDown = props.onKeyDown,
          onPressEnter = props.onPressEnter,
          onFocus = props.onFocus,
          onBlur = props.onBlur,
          onClick = props.onClick,
          disabled = props.disabled,
          _a = props.border,
          border = _a === void 0 ? 'half' : _a,
          prefix = props.prefix,
          suffix = props.suffix,
          clearable = props.clearable,
          _b = props.clearShowType,
          clearShowType = _b === void 0 ? 'focus' : _b,
          _c = props.clearIcon,
          clearIcon = _c === void 0 ? /*#__PURE__*/React__default["default"].createElement(IconClear, null) : _c,
          _d = props.preventEventWhenClearing,
          preventEventWhenClearing = _d === void 0 ? true : _d,
          onClear = props.onClear,
          autoFocus = props.autoFocus,
          blockChangeWhenCompositing = props.blockChangeWhenCompositing;

      var _e = React.useState(value || defaultValue || ''),
          inputValue = _e[0],
          setInputValue = _e[1];

      var _f = React.useState(function () {
        return clearShowType === 'always' || clearShowType === 'value' && Boolean(value || defaultValue);
      }),
          showClear = _f[0],
          toggleClear = _f[1];

      var compositingRef = React.useRef(false);

      var _g = React.useState(false),
          isFocusing = _g[0],
          setIsFocusing = _g[1];

      var shouldPreventEvent = React.useRef(false);
      var actualInputValue = value !== void 0 ? value : inputValue;
      var system = useSystem();
      var wrapRef = React.useRef(null);
      var needComposition = system === 'ios' && blockChangeWhenCompositing;
      React.useEffect(function () {
        if (autoFocus) {
          setTimeout(function () {
            inputRef.current && inputRef.current.focus();
          }, 200);
        }
      }, []);
      React.useEffect(function () {
        var handleCompositionStart = function handleCompositionStart() {
          compositingRef.current = true;
        };

        var handleCompositionEnd = function handleCompositionEnd(e) {
          compositingRef.current = false;
          handleChange(e);
        };

        if (inputRef.current && needComposition) {
          inputRef.current.addEventListener('compositionstart', handleCompositionStart);
          inputRef.current.addEventListener('compositionend', handleCompositionEnd);
        }

        return function () {
          if (inputRef.current && needComposition) {
            inputRef.current.removeEventListener('compositionstart', handleCompositionStart);
            inputRef.current.removeEventListener('compositionend', handleCompositionEnd);
          }
        };
      }, [needComposition]);
      React.useEffect(function () {
        // 处理受控模式下的showClear
        // @en Handling showClear in controlled mode
        if (clearShowType === 'value' && value !== void 0) {
          toggleClear(Boolean(value));
        }
      }, [value]);

      function changeValue(nowValue, callback) {
        if (callback === void 0) {
          callback = function callback() {};
        }

        if (nowValue && validator) {
          if (typeof validator === 'function') {
            if (!validator(nowValue)) {
              return;
            }
          } else if (!validator.test(nowValue)) {
            return;
          }
        } // 处理非受控模式下的showClear
        // @en Handling showClear in uncontrolled mode


        if (clearShowType === 'value' && value === void 0) {
          toggleClear(Boolean(nowValue));
        }

        setInputValue(nowValue);
        callback();
      }

      function handleChange(e) {
        if (needComposition && compositingRef.current) {
          return;
        }

        var newValue = e.target.value;
        changeValue(newValue, function () {
          onChange && onChange(e, newValue);
        });
      }

      function handleInput(e) {
        var newValue = e.target.value;
        changeValue(newValue, function () {
          onInput && onInput(e, newValue);
        });
      }

      function handleKeyDown(e) {
        if (e.keyCode === 13) {
          onPressEnter && onPressEnter(e);
        }

        onKeyDown && onKeyDown(e);
      }

      function handleFocus(e) {
        if (preventEventWhenClearing && shouldPreventEvent.current) {
          shouldPreventEvent.current = false;
          return;
        }

        setIsFocusing(true);
        clearShowType === 'focus' && toggleClear(true);
        onFocus && onFocus(e);
      }

      function handleBlur(e) {
        if (preventEventWhenClearing && shouldPreventEvent.current) {
          return;
        }

        setIsFocusing(false);
        clearShowType === 'focus' && toggleClear(false);
        onBlur && onBlur(e);
      }

      function handleClick(e) {
        // 安卓才会有键盘切换不过来的问题，ios不开启此项，因为blur之后不能再自动focus
        // @en Android will have the problem that the keyboard cannot be switched. iOS does not enable this, because it can no longer automatically focus after blur.
        if (blurBeforeFocus && system === 'android' && !isFocusing) {
          inputRef.current && inputRef.current.blur();
          nextTick(function () {
            inputRef.current && inputRef.current.focus();
          });
        } else {
          inputRef.current && inputRef.current.focus();
        }

        onClick && onClick(e);
      }

      function handleClear(e) {
        // 不展示清除按钮时不触发事件
        // @en No event fired when clear button is not displayed
        if (!clearable || !showClear) {
          return;
        }

        changeValue('', function () {
          onClear && onClear(e); // 当点击clear前是focus时强制执行focus
          // @en Enforce focus when focus is before clicking clear

          if (isFocusing) {
            if (preventEventWhenClearing) {
              shouldPreventEvent.current = true; // 一段时间未执行blur或focus则重置，避免对下次事件循环造成影响
              // @en If blur or focus is not executed for a period of time, it will be reset to avoid affecting the next event loop

              setTimeout(function () {
                shouldPreventEvent.current = false;
              }, 200);
            }

            nextTick(function () {
              inputRef.current && inputRef.current.focus();
            });
          }
        });
      }

      function renderPendNode(pend) {
        return typeof pend === 'function' ? pend(isFocusing, actualInputValue) : pend;
      }

      function renderWrapper(prefixCls, type, children) {
        var _a; // handleClear必须早于handleBlur执行，pc端仅mousedown事件触发早于blur，移动端touch相关事件均早于blur
        // @en handleClear must be executed earlier than handleBlur
        // @en only the mousedown event on the PC side is triggered earlier than blur, and the touch-related events on the mobile side are all earlier than blur


        var clearEvent = (_a = {}, _a[system === 'pc' ? 'onMouseDown' : 'onTouchEnd'] = handleClear, _a);
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "search",
          className: prefixCls + "-container all-border-box " + (className || ''),
          style: style,
          ref: wrapRef
        }, renderPendNode(prepend), /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-wrap", type, "border-" + border, system, {
            disabled: disabled
          }, {
            prefix: prefix
          }, {
            suffix: suffix
          })
        }, label || prefix ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-prefix"
        }, label ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-label", {
            required: required
          })
        }, label) : prefix) : null, children, clearable && showClear ? /*#__PURE__*/React__default["default"].createElement("div", __assign$2({
          className: prefixCls + "-clear"
        }, clearEvent), clearIcon) : null, suffix ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-suffix"
        }, suffix) : null), renderPendNode(append));
      }

      return {
        inputValue: actualInputValue,
        handleChange: handleChange,
        handleInput: handleInput,
        handleKeyDown: handleKeyDown,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleClick: handleClick,
        renderWrapper: renderWrapper,
        wrapRef: wrapRef
      };
    }

    var Input = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var id = props.id,
          name = props.name,
          maxLength = props.maxLength,
          placeholder = props.placeholder,
          readOnly = props.readOnly,
          onKeyUp = props.onKeyUp,
          onKeyPress = props.onKeyPress,
          _a = props.type,
          type = _a === void 0 ? 'text' : _a,
          disabled = props.disabled,
          pattern = props.pattern,
          inputClass = props.inputClass,
          inputStyle = props.inputStyle,
          _b = props.nativeProps,
          nativeProps = _b === void 0 ? {} : _b,
          _c = props.ariaLabel,
          ariaLabel = _c === void 0 ? '' : _c;
      var inputRef = React.useRef(null);

      var _d = useInputLogic(props, inputRef),
          inputValue = _d.inputValue,
          handleChange = _d.handleChange,
          handleInput = _d.handleInput,
          handleKeyDown = _d.handleKeyDown,
          handleFocus = _d.handleFocus,
          handleBlur = _d.handleBlur,
          handleClick = _d.handleClick,
          renderWrapper = _d.renderWrapper,
          wrapRef = _d.wrapRef;

      React.useImperativeHandle(ref, function () {
        return {
          dom: wrapRef.current,
          input: inputRef.current
        };
      });

      function renderInput(_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-input";
        return renderWrapper(prefix, type, /*#__PURE__*/React__default["default"].createElement("input", __assign$2({}, nativeProps, {
          id: id,
          name: name,
          maxLength: maxLength,
          placeholder: placeholder,
          readOnly: readOnly,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyUp: onKeyUp,
          onKeyPress: onKeyPress,
          ref: inputRef,
          className: cls(prefix, inputClass),
          style: inputStyle,
          value: inputValue,
          type: type,
          disabled: disabled,
          pattern: pattern,
          onChange: handleChange,
          onInput: handleInput,
          onKeyDown: handleKeyDown,
          onClick: handleClick,
          "aria-disabled": disabled,
          "aria-label": ariaLabel
        })));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderInput);
    });
    /**
     * 输入框组件，支持添加前后缀。
     * @en The input box, supports adding prefixes and suffixes.
     * @type 数据录入
     * @type_en Data Entry
     * @name 输入框
     * @name_en Input
     * @displayName Input
     */

    var index$d = componentWrapper(Input, 'Input');

    // @en let keyboard random

    var makeArrayRandom = function makeArrayRandom(targetArray) {
      var randomFn = function randomFn() {
        return Math.random() - 0.5;
      };

      return targetArray.sort(randomFn);
    };

    var splitArray = function splitArray(target) {
      return target.reduce(function (acc, cur) {
        if (!acc[acc.length - 1] || acc[acc.length - 1].length >= 3) {
          acc.push([]);
        }

        acc[acc.length - 1].push(cur);
        return acc;
      }, []);
    }; // 纯数字类字符
    // @en Pure numeric characters


    var contentArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    /**
     * 数字键盘组件
     * @en Keyboard component
     * @type 数据录入
     * @type_en Data Entry
     * @name 数字键盘
     * @name_en Keyboard
     */

    var Keyboard = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var normalKeyClass = props.normalKeyClass,
          normalKeyStyle = props.normalKeyStyle,
          _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.type,
          type = _b === void 0 ? 'number' : _b,
          _c = props.randomOrder,
          randomOrder = _c === void 0 ? false : _c,
          title = props.title,
          rightColumns = props.rightColumns,
          confirmClosable = props.confirmClosable,
          confirmButton = props.confirmButton,
          deleteButton = props.deleteButton,
          keyboardButton = props.keyboardButton,
          close = props.close,
          onConfirm = props.onConfirm,
          onDelete = props.onDelete,
          onChange = props.onChange,
          resetProps = __rest$1(props, ["normalKeyClass", "normalKeyStyle", "className", "style", "type", "randomOrder", "title", "rightColumns", "confirmClosable", "confirmButton", "deleteButton", "keyboardButton", "close", "onConfirm", "onDelete", "onChange"]);

      var popupRef = React.useRef(null);
      var keyboardRef = React.useRef(null);

      var _d = React.useContext(GlobalContext),
          prefixCls = _d.prefixCls,
          _e = _d.locale,
          locale = _e === void 0 ? defaultLocale : _e;

      var prefix = prefixCls + "-keyboard"; // 3x4键盘的按键内容
      // @en 3x4 Keyboard button content

      var displayData = React.useMemo(function () {
        var numberArr = randomOrder ? makeArrayRandom(contentArray) : contentArray;
        var lastNum = numberArr.slice(-1)[0];
        var finalData = splitArray(numberArr.slice(0, -1));

        switch (type) {
          case 'confirm':
            finalData.push([lastNum, '.']);
            break;

          case 'tool':
            finalData.push(['.', lastNum, {
              type: 'delete'
            }]);
            break;

          case 'number':
          default:
            finalData.push([{
              type: 'keyboard'
            }, lastNum, {
              type: 'delete'
            }]);
            break;
        }

        return finalData;
      }, [type]); // 右边一列
      // @en Right column

      var rightColumn = React.useMemo(function () {
        switch (type) {
          case 'number':
            return [];

          case 'confirm':
            {
              return [{
                type: 'delete'
              }];
            }

          case 'tool':
            return ['+', '-', '×', '÷'];

          default:
            return [];
        }
      }, [type]); // 确认按钮需要在type为confirm时展示
      // @en Display then confirm button when type is confirm

      var getConfirmButton = React.useCallback(function () {
        if (type !== 'confirm') {
          return null;
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          onClick: function onClick() {
            confirmClosable && close();
            onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm();
          },
          className: cls(prefix + "-key", prefix + "-key-confirm")
        }, confirmButton || locale.Keyboard.confirm);
      }, [type]); // 点击空白处关闭键盘
      // @en Close keyboard when clicked the blank space

      React.useEffect(function () {
        var handlerDocumentClick = function handlerDocumentClick(e) {
          if (!keyboardRef.current) {
            return;
          }

          if (!keyboardRef.current.contains(e.target) && e.target !== keyboardRef.current) {
            close();
          }
        };

        document.addEventListener('click', handlerDocumentClick);
        return function () {
          document.removeEventListener('click', handlerDocumentClick);
        };
      }, []);
      React.useImperativeHandle(ref, function () {
        return __assign$2({
          keyboard: keyboardRef.current
        }, popupRef.current);
      });

      var handleButtonClick = function handleButtonClick(ele) {
        switch (ele.type) {
          case 'delete':
            onDelete === null || onDelete === void 0 ? void 0 : onDelete();
            break;

          case 'keyboard':
            close();
            break;

          default:
            onChange === null || onChange === void 0 ? void 0 : onChange(ele.value);
        }
      };

      var renderButtonContent = function renderButtonContent(ele) {
        switch (ele.type) {
          case 'delete':
            return deleteButton || /*#__PURE__*/React__default["default"].createElement(IconKeyboardDelete, null);

          case 'keyboard':
            return keyboardButton || /*#__PURE__*/React__default["default"].createElement(IconKeyboard, null);

          default:
            return ele.content;
        }
      };

      var renderButton = function renderButton(data, key, extraClass) {
        var ele = typeof data === 'string' || typeof data === 'number' ? {
          type: 'content',
          content: data,
          value: data
        } : data;
        return /*#__PURE__*/React__default["default"].createElement("button", {
          onClick: function onClick() {
            return handleButtonClick(ele);
          },
          className: cls(prefix + "-key", normalKeyClass, extraClass),
          key: key,
          style: normalKeyStyle
        }, renderButtonContent(ele));
      };

      var renderKeyboardRightColumns = function renderKeyboardRightColumns() {
        if (rightColumns) {
          return rightColumns;
        }

        return rightColumn.length > 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-col"
        }, rightColumn.map(function (item, index) {
          return renderButton(item, String(index));
        }), getConfirmButton()) : null;
      };

      return /*#__PURE__*/React__default["default"].createElement(Popup$1, __assign$2({
        ref: popupRef,
        maskClass: prefix + "-popup",
        close: close
      }, resetProps), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix, "" + className),
        style: style,
        ref: keyboardRef
      }, title, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefix + "-wrapper"
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefix + "-key-wrapper"
      }, displayData.map(function (item, index) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-row",
          key: index
        }, item.map(function (e, idx) {
          var _a;

          return renderButton(e, String(idx), (_a = {}, _a[prefix + "-key-special"] = type === 'confirm' && index === displayData.length - 1 && idx === 0, _a));
        }));
      })), renderKeyboardRightColumns())));
    });

    /**
     * 上拉加载组件，支持`scroll`和`click`两种触发加载方式，支持滚动监听。支持受控与不受控两种形式。<br>如果引入组件后发现仅触发了初始的`getData`，请确认是否在`getData`方法内没有调用`callback`移除 loading 状态，且未设置`blockWhenLoading`属性为 false。
     * @en Pull-up loading component, supports `scroll` and `click` two trigger loading methods, supports scroll monitoring. Both controlled and uncontrolled forms are supported. <br>If only the initial `getData` is triggered after the component is introduced, please make sure that the `callback` is not called in the `getData` method to remove the loading state, and the `blockWhenLoading` property is not set to false.
     * @type 反馈
     * @type_en Feedback
     * @name 加载更多
     * @name_en LoadMore
     */

    var LoadMore = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          disabled = props.disabled,
          beforeReadyArea = props.beforeReadyArea,
          loadingArea = props.loadingArea,
          noMoreArea = props.noMoreArea,
          prepareArea = props.prepareArea,
          retryArea = props.retryArea,
          _b = props.defaultStatus,
          defaultStatus = _b === void 0 ? 'prepare' : _b,
          status = props.status,
          getScrollContainer = props.getScrollContainer,
          getOffsetNode = props.getOffsetNode,
          _c = props.trigger,
          trigger = _c === void 0 ? 'scroll' : _c,
          _d = props.threshold,
          threshold = _d === void 0 ? 200 : _d,
          _e = props.throttle,
          throttle = _e === void 0 ? 0 : _e,
          _f = props.getDataAtFirst,
          getDataAtFirst = _f === void 0 ? true : _f,
          getData = props.getData,
          _g = props.blockWhenLoading,
          blockWhenLoading = _g === void 0 ? true : _g,
          onStatusChange = props.onStatusChange,
          onClick = props.onClick,
          onEndReached = props.onEndReached,
          _h = props.getDataWhenNoScrollAtFirst,
          getDataWhenNoScrollAtFirst = _h === void 0 ? false : _h;
      var domRef = React.useRef(null);
      var requestAtFirst = trigger === 'scroll' ? getDataAtFirst : false;

      var _j = React.useState(defaultStatus),
          innerStatus = _j[0],
          setInnerStatus = _j[1];

      var lastScrollEndRef = React.useRef(false);
      var nowStatus = status || innerStatus;
      var statusRef = React.useRef(nowStatus);
      var disabledRef = useLatestRef(disabled);
      var changeStatus = React.useCallback(function (st, scene) {
        setInnerStatus(st);
        onStatusChange && onStatusChange(st, scene);
      }, [onStatusChange]);
      var triggerGetData = React.useCallback(function (scene) {
        if (disabledRef.current) {
          return;
        }

        if (blockWhenLoading && statusRef.current === 'loading') {
          return;
        }

        changeStatus('loading', scene);
        getData === null || getData === void 0 ? void 0 : getData(function (st) {
          changeStatus(st, 'manual');
        });
      }, [blockWhenLoading, changeStatus, getData]);
      React.useEffect(function () {
        if (!blockWhenLoading || nowStatus !== 'loading') {
          lastScrollEndRef.current = false;
        }

        statusRef.current = nowStatus;
      }, [nowStatus]);
      useUpdateEffect(function () {
        // 当状态被设置为 prepare ，且页面总长度不足一屏时，再触发一次 getData
        // @en When the state is set to prepare and the total page length is less than one screen, trigger getData again
        if (trigger === 'scroll' && nowStatus === 'prepare' && checkNeedTrigger(0, threshold)) {
          triggerGetData('pageEnd');
        }
      }, [nowStatus]);
      React.useEffect(function () {
        if (requestAtFirst) {
          if (statusRef.current === 'prepare' && !disabled) {
            triggerGetData('requestAtFirst');
          }
        } else {
          if (trigger === 'scroll' && nowStatus === 'prepare' && checkNeedTrigger(0, threshold) && !disabled && getDataWhenNoScrollAtFirst) {
            triggerGetData('pageEnd');
          }
        }
      }, [trigger, disabled]);
      var handleContainerScroll = React.useCallback(function () {
        var scrollTop = getScrollContainerAttribute('scrollTop', getScrollContainer);

        if (checkNeedTrigger(scrollTop, threshold + 1)) {
          if (!lastScrollEndRef.current) {
            lastScrollEndRef.current = true;
            onEndReached && onEndReached();

            if (!['nomore', 'retry', 'before-ready'].includes(statusRef.current)) {
              triggerGetData('scrollEnd');
            }
          }
        } else {
          lastScrollEndRef.current = false;
        }
      }, [getScrollContainer, threshold, triggerGetData, onEndReached]);
      React.useEffect(function () {
        var binded = null;
        var scrollFunc = throttle ? lodash_throttle(handleContainerScroll, throttle) : handleContainerScroll;

        if (trigger === 'scroll' && !disabled) {
          var container = getValidScrollContainer(getScrollContainer);

          if (container) {
            container.addEventListener('scroll', scrollFunc);
            binded = container;
          }
        }

        return function () {
          if (binded) {
            binded.removeEventListener('scroll', scrollFunc);
          }
        };
      }, [trigger, disabled, getScrollContainer, handleContainerScroll, throttle]);

      var getDataWithEndReachCheck = function getDataWithEndReachCheck() {
        if (checkNeedTrigger(0, threshold)) {
          triggerGetData('pageEnd');
        }
      };

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          changeStatus: changeStatus,
          getDataWithEndReachCheck: getDataWithEndReachCheck
        };
      }, [changeStatus]);

      function checkNeedTrigger(top, ths) {
        var scrollHeight = getOffsetNode ? getScrollContainerAttribute('offsetHeight', getOffsetNode) + getScrollContainerAttribute('offsetTop', getOffsetNode) : getScrollContainerAttribute('scrollHeight', getScrollContainer);
        var clientHeight = getScrollContainerAttribute('clientHeight', getScrollContainer);
        return scrollHeight - top - clientHeight <= ths;
      }

      function handleClick(e) {
        if (trigger === 'click' && statusRef.current === 'prepare' || statusRef.current === 'retry') {
          triggerGetData('click');
        }

        onClick && onClick(e);
      }

      function renderArea(locale) {
        switch (nowStatus) {
          case 'before-ready':
            return beforeReadyArea;

          case 'prepare':
            return prepareArea === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
              className: "load-more-text prepare"
            }, trigger === 'scroll' ? locale.LoadMore.prepareScrollText : locale.LoadMore.prepareClickText, locale.LoadMore.loadMoreText) : prepareArea;

          case 'loading':
            return loadingArea === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
              className: "load-more-text loading"
            }, locale.LoadMore.loadingText) : loadingArea;

          case 'nomore':
            return noMoreArea === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
              className: "load-more-text nomore"
            }, locale.LoadMore.noDataText) : noMoreArea;

          case 'retry':
            return retryArea === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
              className: "load-more-text retry"
            }, locale.LoadMore.failLoadText) : retryArea;

          default:
            return null;
        }
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b;

        var prefixCls = _a.prefixCls,
            _c = _a.locale,
            locale = _c === void 0 ? defaultLocale : _c;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-load-more status-" + nowStatus, className, (_b = {}, _b[prefixCls + "-load-more-disabled"] = disabled, _b)),
          ref: domRef,
          style: style,
          onClick: handleClick
        }, renderArea(locale));
      });
    });

    function BackArrow(_a) {
      var _b = _a.color,
          color = _b === void 0 ? 'currentColor' : _b;
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b = _a.locale,
            locale = _b === void 0 ? defaultLocale : _b;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "button",
          className: "c-svg-arrow nav-bar-back",
          "aria-label": locale.NavBar.backBtnAriaLabel
        }, /*#__PURE__*/React__default["default"].createElement("svg", {
          height: "100%",
          viewBox: "0 0 16 16"
        }, /*#__PURE__*/React__default["default"].createElement("path", {
          id: "path-1_1_",
          d: "M2.1,8l5.4,5.4c0.1,0.1,0.1,0.3,0,0.5L7,14.4c-0.1,0.1-0.3,0.1-0.5,0L0.7,8.5c-0.3-0.3-0.3-0.7,0-0.9\n                l5.9-5.9c0.1-0.1,0.3-0.1,0.5,0l0.5,0.5c0.1,0.1,0.1,0.3,0,0.5L2.1,8z",
          fill: color
        })));
      });
    }

    /**
     * 导航栏组件，支持吸顶和沉浸式，支持在指定滚动位置展示，支持根据滚动位置实时更新style。
     * @en Navigation bar, supports ceiling and immersion, supports display at specified scroll position, and supports real-time update of style according to scroll position.
     * @type 导航
     * @type_en Navigation
     * @name 导航栏
     * @name_en NavBar
     */

    var NavBar = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var children = props.children,
          _a = props.title,
          title = _a === void 0 ? '' : _a,
          onClickLeft = props.onClickLeft,
          _b = props.leftContent,
          leftContent = _b === void 0 ? /*#__PURE__*/React__default["default"].createElement(BackArrow, null) : _b,
          onClickRight = props.onClickRight,
          rightContent = props.rightContent,
          onShowChange = props.onShowChange,
          style = props.style,
          _c = props.className,
          className = _c === void 0 ? '' : _c,
          wrapClass = props.wrapClass,
          _d = props.placeholder,
          placeholder = _d === void 0 ? true : _d,
          _e = props.fixed,
          fixed = _e === void 0 ? true : _e,
          _f = props.hasBottomLine,
          hasBottomLine = _f === void 0 ? true : _f,
          _g = props.statusBarHeight,
          statusBarHeight = _g === void 0 ? 0 : _g,
          extra = props.extra,
          getScrollContainer = props.getScrollContainer,
          _h = props.showOffset,
          showOffset = _h === void 0 ? 0 : _h,
          onScrollChange = props.onScrollChange,
          getComputedStyleByScroll = props.getComputedStyleByScroll,
          _j = props.ariaLabel,
          ariaLabel = _j === void 0 ? '' : _j,
          _k = props.ariaRole,
          ariaRole = _k === void 0 ? 'banner' : _k;
      var navBarRef = React.useRef(null);

      var _l = React.useState(showOffset > 0),
          scrollToggleHide = _l[0],
          setScrollToggleHide = _l[1];

      var relBackground = scrollToggleHide ? 'transparent' : '';

      var _m = React.useState({}),
          customStyle = _m[0],
          setCustomStyle = _m[1];

      var system = useSystem();

      var onElementScroll = function onElementScroll(curOffset) {
        setScrollToggleHide(curOffset < showOffset);
        onScrollChange === null || onScrollChange === void 0 ? void 0 : onScrollChange(curOffset);

        if (getComputedStyleByScroll) {
          var cstyle = getComputedStyleByScroll(curOffset);
          setCustomStyle(cstyle);
        }
      };

      React.useImperativeHandle(ref, function () {
        return {
          navBar: navBarRef.current,
          dom: navBarRef.current
        };
      });
      React.useEffect(function () {
        onShowChange === null || onShowChange === void 0 ? void 0 : onShowChange(!scrollToggleHide);
      }, [scrollToggleHide]);

      var handleEleScroll = function handleEleScroll() {
        var top = getScrollContainerAttribute('scrollTop', getScrollContainer) || 0;
        onElementScroll(top);
      };

      React.useEffect(function () {
        var needBind = showOffset || getComputedStyleByScroll || onScrollChange;
        var container = getValidScrollContainer(getScrollContainer);
        handleEleScroll();

        if (needBind && container) {
          container.addEventListener('scroll', handleEleScroll, false);
        }

        return function () {
          if (needBind && container) {
            container.removeEventListener('scroll', handleEleScroll, false);
          }
        };
      }, [showOffset, getComputedStyleByScroll, onScrollChange, getScrollContainer]);

      function handleClickLeft(e) {
        if (onClickLeft) {
          onClickLeft(e);
        }
      }

      function handleClickRight(e) {
        if (onClickRight) {
          onClickRight(e);
        }
      } // 最外层div是为了fixed时占位
      // @en The outermost div is a placeholder for fixed
      // 第二层div是为了沉浸式paddingTop
      // @en The second layer of div is for immersive paddingTop
      // 第三层是为了保证内容高度始终是44px
      // @en The third layer is to ensure that the content height is always 44px
      // 背景色放到wrapper层是为了兼容iOS下拉回弹的背景色
      // @en The background color is placed on the wrapper layer to be compatible with the background color of the pull-down rebound in iOS
      // fixed时用height+padding撑开nav-bar最外层高度；不fixed时内部wrapper元素撑开最外层高度
      // @en When fixed, use height+padding to stretch the outermost height of nav-bar; when not fixed, the inner wrapper element stretches the outermost height


      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b, _c;

        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          ref: navBarRef,
          className: cls(wrapClass, prefixCls + "-nav-bar", (_b = {}, _b[prefixCls + "-nav-bar-fixed"] = fixed, _b[prefixCls + "-nav-bar-float"] = !placeholder, _b[prefixCls + "-nav-bar-hide"] = scrollToggleHide, _b)),
          style: __assign$2(__assign$2({
            paddingTop: fixed && statusBarHeight ? statusBarHeight + "px" : '0px'
          }, style || {}), relBackground ? {
            background: relBackground
          } : {}),
          "aria-label": ariaLabel,
          role: ariaRole
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(className, system, prefixCls + "-nav-bar-wrapper", (_c = {}, _c[prefixCls + "-nav-bar-wrapper-fixed"] = fixed, _c[prefixCls + "-nav-bar-wrapper-border"] = hasBottomLine, _c)),
          style: __assign$2({
            paddingTop: statusBarHeight ? statusBarHeight + "px" : '0px'
          }, customStyle)
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-nav-bar-inner all-border-box"
        }, leftContent ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-nav-bar-left",
          onClick: handleClickLeft
        }, leftContent) : null, children || /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-nav-bar-title"
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-nav-bar-title-text"
        }, title)), rightContent ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-nav-bar-right",
          onClick: handleClickRight
        }, rightContent) : null), extra));
      });
    });

    /**
     * 可自定义换行或滚动效果，支持循环滚动。
     * @en Line wrapping or scrolling effects can be customized, and circular scrolling is supported.
     * @type 信息展示
     * @type_en Data Display
     * @name 通知栏
     * @name_en NoticeBar
     */

    var NoticeBar = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          children = props.children,
          leftContent = props.leftContent,
          rightContent = props.rightContent,
          _b = props.marquee,
          marquee = _b === void 0 ? 'overflow' : _b,
          _c = props.closeable,
          closeable = _c === void 0 ? true : _c,
          _d = props.closeIcon,
          closeIcon = _d === void 0 ? /*#__PURE__*/React__default["default"].createElement(IconClose, null) : _d,
          _e = props.wrapable,
          wrapable = _e === void 0 ? true : _e,
          _f = props.speed,
          speed = _f === void 0 ? 50 : _f,
          _g = props.delay,
          delay = _g === void 0 ? 1000 : _g,
          _h = props.autoSetGradientStyle,
          autoSetGradientStyle = _h === void 0 ? true : _h,
          onClick = props.onClick,
          onClose = props.onClose;
      var useRtl = React.useContext(GlobalContext).useRtl;
      var domRef = React.useRef(null);
      var wrapRef = React.useRef(null);
      var contentRef = React.useRef(null);
      var timerRef = React.useRef(null);

      var _j = React.useState(false),
          needMarquee = _j[0],
          setNeedMarquee = _j[1];

      var extraClass = React.useMemo(function () {
        var classList = []; // 字幕可滚动时，或不可滚动且不可以换行时，添加不换行效果
        // @en When the subtitle is scrollable, or when it is not scrollable and cannot wrap, add no wrapping effect

        if (marquee !== 'none' || !wrapable) {
          classList.push('no-wrap');
        } // 字幕不可滚动时，根据是否可换行决定换行或省略效果
        // @en When the subtitle is not scrollable, decide whether to wrap or omit the effect according to whether it can wrap


        if (marquee === 'none') {
          classList.push(wrapable ? 'wrapable' : 'ellipsis');
        }

        return classList;
      }, [marquee, wrapable]);
      var gradientStyle = React.useMemo(function () {
        if (!autoSetGradientStyle) {
          return {};
        }

        var curBg = (style === null || style === void 0 ? void 0 : style.backgroundColor) || (style === null || style === void 0 ? void 0 : style.background);
        var fadeBg = fadeColor(String(curBg) || '');
        return fadeBg ? {
          background: "linear-gradient(to right, " + curBg + ", " + fadeBg + ")"
        } : {};
      }, [style]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          close: close,
          updateData: updateData
        };
      }, [updateData]);
      React.useEffect(function () {
        updateData();
      }, [useRtl]);

      function close() {
        if (domRef.current) {
          removeElement(domRef.current);
        }
      }

      function handleClose(e) {
        e.stopPropagation();
        onClose === null || onClose === void 0 ? void 0 : onClose(e);
        close();
      }

      function updateData() {
        nextTick(function () {
          setTimeout(function () {
            updateLayoutData();
          }, needMarquee ? 0 : delay);
        });
      }

      function updateLayoutData() {
        if (!wrapRef.current || !contentRef.current) {
          return;
        }

        var contentDom = contentRef.current;
        var needMarq = marquee === 'always';
        var wrapWidth = wrapRef.current.offsetWidth;
        var contentWidth = contentRef.current.offsetWidth; // 如果为overflow类型，则当文字溢出时再开始滚动
        // @en If it is overflow type, start scrolling when the text overflows

        if (marquee === 'overflow') {
          if (wrapWidth < contentWidth) {
            needMarq = true;
          }
        }

        setNeedMarquee(needMarq);
        clear();

        if (needMarq) {
          var duration_1 = contentWidth / speed;
          contentDom.style.animationDuration = duration_1 + "s"; // 第一次没有padding，第二次及以后为了从容器右边缘无缝滑入需要加上padding
          // @en The first time without padding, the second time and later need to add padding in order to seamlessly slide in from the right edge of the container

          timerRef.current = window.setTimeout(function () {
            // 这里暂时把animate类去掉，准备下一次从头开始
            // @en Temporarily remove the animate classname, and prepare to start from scratch next time
            setNeedMarquee(false);
            contentDom.style.animationDuration = wrapWidth / speed + duration_1 + "s";
            contentDom.style.animationIterationCount = 'infinite';
            var paddingAttr = useRtl ? 'paddingRight' : 'paddingLeft';
            contentDom.style[paddingAttr] = wrapWidth + "px";
            nextTick(function () {
              setNeedMarquee(true);
            });
          }, duration_1 * 1000);
        }
      }

      function clear() {
        if (timerRef.current) {
          clearTimeout(timerRef.current);
          timerRef.current = null;
        }
      }

      function renderNoticeBar(prefix) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix, className, extraClass),
          style: style,
          ref: domRef,
          onClick: onClick
        }, leftContent ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-left-part"
        }, leftContent) : null, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-content",
          ref: wrapRef
        }, needMarquee ? /*#__PURE__*/React__default["default"].createElement("i", {
          className: prefix + "-gradient left",
          style: gradientStyle
        }) : null, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix + "-content-inner", {
            animate: needMarquee
          }),
          ref: contentRef
        }, children), needMarquee ? /*#__PURE__*/React__default["default"].createElement("i", {
          className: prefix + "-gradient right",
          style: gradientStyle
        }) : null), rightContent ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-right-part"
        }, rightContent) : null, closeable ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefix + "-close",
          onClick: handleClose
        }, closeIcon) : null);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return renderNoticeBar(prefixCls + "-notice-bar");
      });
    });

    function notify(Component, type) {
      return function (originConfig, context) {
        var config = typeof originConfig === 'string' ? {
          content: originConfig,
          type: 'info'
        } : originConfig;

        if (type !== void 0) {
          config.type = type;
        }

        var div = document.createElement('div');
        var getContainer = config.getContainer;

        if (getContainer) {
          getContainer().appendChild(div);
        } else {
          document.body.appendChild(div);
        }

        var _a = new ReactDOMRender(Component, div, context),
            render = _a.render,
            unmount = _a.unmount;

        function destroy() {
          var onClose = config.onClose;
          onClose && onClose();
          unmount();

          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
        }

        var dynamicProps = __assign$2(__assign$2({}, config), {
          close: close,
          onClose: destroy,
          getContainer: function getContainer() {
            return div;
          },
          visible: false
        });

        var leaving = false;

        function update(newConfig) {
          dynamicProps = __assign$2(__assign$2({}, dynamicProps), newConfig);
          render(dynamicProps);
        }

        function close() {
          leaving = true;
          dynamicProps.visible = false;
          render(dynamicProps);
        }

        render(dynamicProps);
        nextTick(function () {
          if (leaving) return;
          dynamicProps.visible = true;
          render(dynamicProps);
        });
        return {
          update: update,
          close: close
        };
      };
    }

    var Notify = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.visible,
          visible = _b === void 0 ? false : _b,
          _c = props.transitionDuration,
          transitionDuration = _c === void 0 ? 300 : _c,
          content = props.content,
          _d = props.duration,
          duration = _d === void 0 ? 3000 : _d,
          onClose = props.onClose,
          _e = props.type,
          type = _e === void 0 ? 'info' : _e,
          close = props.close,
          getContainer = props.getContainer;
      var domRef = React.useRef(null);
      var innerRef = React.useRef(null);
      var closeTimerRef = React.useRef();
      var onCloseTimeRef = React.useRef();

      var _f = React.useState(!visible),
          hasTrans = _f[0],
          setHasTrans = _f[1];

      var _g = React.useState(0),
          innerHeight = _g[0],
          setInnerHeight = _g[1];

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          updateLayout: updateLayout
        };
      });

      function startCloseTimer() {
        if (duration) {
          clearTimeout(closeTimerRef.current);
          closeTimerRef.current = window.setTimeout(function () {
            close === null || close === void 0 ? void 0 : close();
          }, duration);
        }
      }

      function updateLayout() {
        if (innerRef.current) {
          var height = innerRef.current.getBoundingClientRect().height;
          setInnerHeight(height);
        }
      }

      React.useEffect(function () {
        visible && updateLayout();
        visible && startCloseTimer();
        return function () {
          visible && clearTimeout(closeTimerRef.current);
        };
      }, [visible, duration]);
      useUpdateEffect(function () {
        if (!visible) {
          onCloseTimeRef.current = window.setTimeout(function () {
            onClose && onClose();
          }, transitionDuration);
        }
      }, [visible]);
      React.useEffect(function () {
        nextTick(function () {
          setHasTrans(true);
        });
        return function () {
          clearTimeout(onCloseTimeRef.current);
        };
      }, []);

      function renderComponent(prefixClass) {
        return content ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixClass + "-content " + (visible ? prefixClass + "-content-transition-Y0" : prefixClass + "-content-transition-Y100"),
          ref: innerRef,
          style: __assign$2({}, hasTrans ? getStyleWithVendor({
            transitionDuration: transitionDuration + "ms"
          }) : {})
        }, content) : null;
      }

      var render = function render(prefixCls) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-notify " + prefixCls + "-notify-" + type + " " + className,
          style: __assign$2(__assign$2(__assign$2({}, style), hasTrans ? getStyleWithVendor({
            transitionDuration: transitionDuration + "ms"
          }) : {}), {
            height: visible ? innerHeight : 0
          }),
          ref: domRef
        }, renderComponent(prefixCls + "-notify"));
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return getContainer ? /*#__PURE__*/ReactDOM__default["default"].createPortal(render(prefixCls), getContainer()) : render(prefixCls);
      });
    });
    function methodsGenerator$1(Comp) {
      return {
        /**
         * 展示常规通知
         * @desc {en} Show regular notification
         * @param {string | NotifyProps} config
         * @returns {{ update: (config: NotifyProps) => void; close: () => void }}
         */
        info: notify(Comp),

        /**
         * 展示成功通知
         * @desc {en} Show success notification
         * @param {string | NotifyProps} config
         * @returns {{ update: (config: NotifyProps) => void; close: () => void }}
         */
        success: notify(Comp, 'success'),

        /**
         * 展示错误的通知
         * @desc {en} Show error notification
         * @param {string | NotifyProps} config
         * @returns {{ update: (config: NotifyProps) => void; close: () => void }}
         */
        error: notify(Comp, 'error'),

        /**
         * 展示警告的通知
         * @desc {en} Show warning notification
         * @param {string | NotifyProps} config
         * @returns {{ update: (config: NotifyProps) => void; close: () => void }}
         */
        warn: notify(Comp, 'warn')
      };
    }
    var NotifyWithGlobalContext = CompWithGlobalContext(Notify);
    /**
     * 主动操作后显示的反馈信息横条，可采用方法调用或者组件调用的方式
     * @en The feedback information bar displayed after active operation can be called by method or by component.
     * @type 反馈
     * @type_en Feedback
     * @name 消息通知
     * @name_en Notify
     */

    var index$c = componentWrapper(Notify, methodsGenerator$1(NotifyWithGlobalContext));

    function Arrow() {
      return /*#__PURE__*/React__default["default"].createElement("svg", {
        width: "8",
        height: "14",
        viewBox: "0 0 8 14",
        fill: "none"
      }, /*#__PURE__*/React__default["default"].createElement("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7.40514 12.7583C7.6004 12.563 7.6004 12.2465 7.40514 12.0512L2.40095 7.04701L7.36396 2.084C7.55922 1.88874 7.55922 1.57216 7.36396 1.37689L7.01041 1.02334C6.81515 0.828077 6.49856 0.828077 6.3033 1.02334L0.646447 6.68019C0.470402 6.85624 0.453075 7.1309 0.594469 7.32636C0.617837 7.37275 0.64889 7.41626 0.687628 7.455L6.34448 13.1119C6.53974 13.3071 6.85633 13.3071 7.05159 13.1119L7.40514 12.7583Z",
        fill: "currentColor"
      }));
    }

    /**
     * 用于数据分页，为完全受控组件
     * @en The pagination component is used for data paging and is a fully controlled component.
     * @type 导航
     * @type_en Navigation
     * @name 分页器
     * @name_en Pagination
     */

    var Pagination = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var _b = React.useContext(GlobalContext),
          prefixCls = _b.prefixCls,
          locale = _b.locale;

      var _c = props.className,
          className = _c === void 0 ? '' : _c,
          style = props.style,
          _d = props.current,
          current = _d === void 0 ? 1 : _d,
          _e = props.pageSize,
          pageSize = _e === void 0 ? 10 : _e,
          _f = props.total,
          total = _f === void 0 ? 5 : _f,
          _g = props.icon,
          icon = _g === void 0 ? false : _g,
          _h = props.justify,
          justify = _h === void 0 ? 'side' : _h,
          _j = props.hideOnOnePage,
          hideOnOnePage = _j === void 0 ? false : _j,
          _k = props.nextFieldType,
          nextFieldType = _k === void 0 ? 'default' : _k,
          renderPrevField = props.renderPrevField,
          renderNextField = props.renderNextField,
          _l = props.type,
          type = _l === void 0 ? 'default' : _l,
          _m = props.prevFieldText,
          prevFieldText = _m === void 0 ? locale === null || locale === void 0 ? void 0 : locale.Pagination.previousPage : _m,
          _o = props.nextFieldText,
          nextFieldText = _o === void 0 ? locale === null || locale === void 0 ? void 0 : locale.Pagination.nextPage : _o,
          onChange = props.onChange;
      var system = useSystem();
      var pageNum = React.useMemo(function () {
        return Math.ceil(total / pageSize);
      }, [total, pageSize]);
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var iconRender = function iconRender(iconType) {
        if (iconType === 'prev') {
          if (Array.isArray(icon) && Boolean(icon.length)) {
            return /*#__PURE__*/React__default["default"].createElement("span", {
              className: "btn-icon"
            }, icon[0]);
          }

          if (Object.prototype.toString.call(icon) === '[object Object]') {
            return /*#__PURE__*/React__default["default"].createElement("span", {
              className: "btn-icon"
            }, icon);
          }

          return icon ? /*#__PURE__*/React__default["default"].createElement("span", {
            className: "btn-icon"
          }, /*#__PURE__*/React__default["default"].createElement(Arrow, null)) : null;
        }

        if (Array.isArray(icon) && Boolean(icon.length)) {
          return /*#__PURE__*/React__default["default"].createElement("span", {
            className: "btn-icon"
          }, icon.length >= 2 ? icon[1] : icon[0]);
        }

        if (Object.prototype.toString.call(icon) === '[object Object]') {
          return /*#__PURE__*/React__default["default"].createElement("span", {
            className: "btn-icon next"
          }, icon);
        }

        return icon ? /*#__PURE__*/React__default["default"].createElement("span", {
          className: "btn-icon next"
        }, /*#__PURE__*/React__default["default"].createElement(Arrow, null)) : null;
      };

      var prevRender = function prevRender(prefix) {
        var _a;

        if (type === 'none') {
          return null;
        }

        var prevFieldCls = cls(prefix + "-prev-field", (_a = {}, _a["flex-" + justify] = true, _a));

        if (typeof renderPrevField === 'undefined') {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: prevFieldCls
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefix + "-field", 'prev', {
              text: type === 'text',
              button: type !== 'text',
              disabled: current === 1
            }),
            onClick: function onClick() {
              if (current <= 1) {
                return;
              }

              onChange === null || onChange === void 0 ? void 0 : onChange({
                pageSize: pageSize,
                pageNum: pageNum,
                current: Math.max(1, current - 1)
              });
            }
          }, iconRender('prev'), Boolean(prevFieldText) && /*#__PURE__*/React__default["default"].createElement("span", {
            className: "btn-text"
          }, prevFieldText)));
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prevFieldCls
        }, renderPrevField ? renderPrevField({
          current: current,
          pageSize: pageSize,
          pageNum: pageNum
        }) : null);
      };

      var nextRender = function nextRender(prefix) {
        var _a, _b;

        if (type === 'none') {
          return null;
        }

        var nextFieldCls = cls(prefix + "-next-field", (_a = {}, _a["flex-" + justify] = true, _a));

        if (typeof renderNextField === 'undefined') {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: nextFieldCls
          }, /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefix + "-field", 'next', (_b = {
              text: type === 'text',
              button: type !== 'text'
            }, _b[nextFieldType === 'default' ? type : 'primary'] = current < pageNum, _b.disabled = current >= pageNum, _b)),
            onClick: function onClick() {
              if (current >= pageNum) {
                return;
              }

              onChange === null || onChange === void 0 ? void 0 : onChange({
                pageSize: pageSize,
                pageNum: pageNum,
                current: Math.min(current + 1, pageNum)
              });
            }
          }, Boolean(nextFieldText) && /*#__PURE__*/React__default["default"].createElement("span", {
            className: "btn-text"
          }, nextFieldText), iconRender('next')));
        }

        var nextItem = renderNextField && renderNextField({
          current: current,
          pageSize: pageSize,
          pageNum: pageNum
        });
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: nextFieldCls
        }, nextItem);
      };

      var prefix = prefixCls + "-pagination";
      return !(hideOnOnePage && pageNum === 1) ? /*#__PURE__*/React__default["default"].createElement("div", {
        ref: domRef,
        className: cls(prefix, system, (_a = {}, _a[prefix + "-simple"] = type === 'none', _a), className),
        style: style
      }, prevRender(prefix), /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefix + "-item"
      }, /*#__PURE__*/React__default["default"].createElement("span", {
        className: prefix + "-item-active"
      }, current), " / ", pageNum), nextRender(prefix)) : /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefix, className)
      });
    });

    function componentGenerator$4(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var menu = props.menu,
            _a = props.menuLayout,
            menuLayout = _a === void 0 ? 'vertical' : _a,
            onSelect = props.onSelect,
            onClickMenuItem = props.onClickMenuItem,
            _b = props.className,
            className = _b === void 0 ? '' : _b,
            _c = props.useClickStatus,
            useClickStatus = _c === void 0 ? false : _c,
            _d = props.clickStatusDuration,
            clickStatusDuration = _d === void 0 ? 300 : _d,
            _e = props.clickSelfToClose,
            clickSelfToClose = _e === void 0 ? true : _e,
            _f = props.touchSelfToClose,
            touchSelfToClose = _f === void 0 ? props.touchToClose === void 0 ? false : props.touchToClose : _f,
            _g = props.defaultVisible,
            defaultVisible = _g === void 0 ? false : _g,
            visible = props.visible,
            onChange = props.onChange,
            restProps = __rest$1(props, ["menu", "menuLayout", "onSelect", "onClickMenuItem", "className", "useClickStatus", "clickStatusDuration", "clickSelfToClose", "touchSelfToClose", "defaultVisible", "visible", "onChange"]);

        var prefixCls = React.useContext(GlobalContext).prefixCls;

        var _h = React.useState(-1),
            activeIndex = _h[0],
            setActiveIndex = _h[1];

        var activeTimer = React.useRef(0);
        var formattedMenu = React.useMemo(function () {
          return menu.map(function (item) {
            if (typeof item === 'string') {
              return {
                text: item
              };
            }

            return item;
          });
        }, [menu]);

        var _j = React.useState(visible === void 0 ? defaultVisible : visible),
            visibleState = _j[0],
            setVisibleState = _j[1];

        useUpdateEffect(function () {
          setVisibleState(Boolean(visible));
        }, [visible]);
        var popoverRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return popoverRef.current;
        });

        var onVisibleChange = function onVisibleChange(newVisible) {
          var handleVisibleChange = function handleVisibleChange() {
            if (onChange && typeof onChange === 'function') {
              onChange(newVisible);
            }

            if (visible === void 0) {
              setVisibleState(newVisible);
            }
          }; // 如果设置了点击效果则延时回调onChange函数，留出点击效果的时间
          // @en If the click effect is set, the onChange function is delayed and called back, leaving time for the click effect


          if (!newVisible && useClickStatus) {
            window.setTimeout(handleVisibleChange, Math.max(0, clickStatusDuration - 300));
          } else {
            handleVisibleChange();
          }
        };

        var content = React.useMemo(function () {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-popover-menu-content", menuLayout + "-menu")
          }, formattedMenu.map(function (item, index) {
            var defaultValue = typeof item.text === 'string' ? item.text : "menu_item_" + index;
            var text = item.text,
                _a = item.value,
                value = _a === void 0 ? defaultValue : _a,
                _b = item.disabled,
                disabled = _b === void 0 ? false : _b,
                icon = item.icon;
            return /*#__PURE__*/React__default["default"].createElement("div", {
              className: cls(prefixCls + "-popover-menu-item", {
                disabled: disabled,
                active: activeIndex === index
              }),
              key: value,
              onTouchStart: function onTouchStart() {
                if (useClickStatus && !disabled) {
                  clearTimeout(activeTimer.current);
                  setActiveIndex(index);
                  activeTimer.current = window.setTimeout(function () {
                    setActiveIndex(-1);
                    activeTimer.current = 0;
                  }, clickStatusDuration);
                }
              },
              onClick: function onClick() {
                onClickMenuItem && onClickMenuItem(value, menu[index]);
                if (disabled) return;
                onSelect && onSelect(value, menu[index]);
              }
            }, icon && /*#__PURE__*/React__default["default"].createElement("div", {
              className: cls(prefixCls + "-popover-menu-icon")
            }, icon), /*#__PURE__*/React__default["default"].createElement("div", {
              className: cls(prefixCls + "-popover-menu-text")
            }, text));
          }));
        }, [prefixCls, menuLayout, formattedMenu, activeIndex, useClickStatus, clickStatusDuration, onClickMenuItem, onSelect]);
        return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
          ref: popoverRef,
          visible: visibleState,
          clickSelfToClose: clickSelfToClose,
          touchSelfToClose: touchSelfToClose,
          onChange: onVisibleChange
        }, restProps, {
          content: content,
          className: cls(className, prefixCls + "-popover-menu")
        }));
      });
    }

    var PopoverInner = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var prefixCls = React.useContext(GlobalContext).prefixCls;
      var className = props.className,
          needShadow = props.needShadow,
          content = props.content,
          direction = props.direction,
          position = props.position,
          minWidth = props.minWidth,
          maxWidth = props.maxWidth,
          arrowWidth = props.arrowWidth,
          transformOrigin = props.transformOrigin,
          mode = props.mode,
          _a = props.showCloseIcon,
          showCloseIcon = _a === void 0 ? false : _a,
          _b = props.textSuffix,
          textSuffix = _b === void 0 ? null : _b,
          renderArrow = props.renderArrow,
          onClickCloseIcon = props.onClickCloseIcon,
          onClickTextSuffix = props.onClickTextSuffix;
      var domRef = React.useRef(null);
      var contentRef = React.useRef(null);

      var _c = useMountedState(false),
          show = _c[0],
          setShow = _c[1];

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          content: contentRef.current
        };
      });
      React.useEffect(function () {
        var top = position.top,
            bottom = position.bottom,
            height = position.height,
            left = position.left,
            width = position.width;

        if (left || width || top || height || bottom) {
          if (!show) {
            setTimeout(function () {
              setShow(true);
            }, 0);
          }
        }
      }, [position, show]);
      /**
       * 计算容器的样式
       * @en Calculate the stylesheet of the container
       */

      var getWrapperStyle = function getWrapperStyle() {
        var top = position.top,
            bottom = position.bottom,
            height = position.height,
            left = position.left;
        var obj = {
          height: height + "px",
          left: left + "px",
          minWidth: minWidth,
          maxWidth: maxWidth
        };

        if (top) {
          obj.top = top + "px";
        } else if (bottom) {
          obj.bottom = bottom + "px";
        } // 用于执行缩放动画
        // @en Used to perform zoom animations


        obj.transformOrigin = transformOrigin.x + " " + transformOrigin.y;
        return getStyleWithVendor(obj);
      };
      /**
       * 计算icon的样式
       * @en Calculate the stylesheet of the icon
       */


      var getArrowStyle = function getArrowStyle() {
        var arrowLeft = position.arrowLeft;
        return {
          width: arrowWidth,
          height: arrowWidth,
          marginLeft: arrowLeft ? arrowLeft + "px" : null,
          marginRight: arrowLeft ? arrowLeft + "px" : null
        };
      };

      return /*#__PURE__*/React__default["default"].createElement("div", {
        ref: domRef,
        className: cls(prefixCls + "-popover-inner", 'popover-inner', 'all-border-box', mode + "-mode", className, {
          show: show,
          'with-shadow': needShadow,
          'with-suffix': showCloseIcon || textSuffix,
          'custom-content': typeof content !== 'string'
        }),
        style: getWrapperStyle()
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "popover-bg"
      }, renderArrow ? renderArrow({
        arrowWidth: arrowWidth,
        arrowLeft: position.arrowLeft,
        direction: direction
      }) : /*#__PURE__*/React__default["default"].createElement("div", {
        className: "popover-arrow " + direction,
        style: getArrowStyle()
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "popover-arrow-content"
      }))), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls('popover-content', direction, {
          'show-close-icon': showCloseIcon
        }),
        ref: contentRef
      }, typeof content === 'string' ? /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "content-text"
      }, content), showCloseIcon && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
        className: "icon-divider"
      }), /*#__PURE__*/React__default["default"].createElement("div", {
        className: "text-close-icon",
        onClick: onClickCloseIcon
      }, /*#__PURE__*/React__default["default"].createElement(IconClose, null))), textSuffix && /*#__PURE__*/React__default["default"].createElement("div", {
        className: "text-suffix",
        onClick: onClickTextSuffix
      }, textSuffix)) : content));
    });

    var defaultPosition = {
      left: null,
      top: null,
      bottom: null,
      width: null,
      height: null,
      arrowLeft: 0
    };
    /**
     * 安全边界距离默认值
     * @en Default safe boundary distance
     */

    var defaultEdgeOffsetValue = 14;
    /**
     * 安全距离默认值
     * @en Default safe distance
     */

    var defaultEdgeOffset = {
      top: defaultEdgeOffsetValue,
      right: defaultEdgeOffsetValue,
      bottom: defaultEdgeOffsetValue,
      left: defaultEdgeOffsetValue
    };
    /**
     * 自适应默认值
     * @en Default autoDirection
     */

    var defaultAutoDirection = true;
    var usePosition = function usePosition(props, popoverRef, childRef, wrapperRef) {
      var _a = props.direction,
          direction = _a === void 0 ? 'topRight' : _a,
          _b = props.verticalOffset,
          verticalOffset = _b === void 0 ? 10 : _b,
          _c = props.horizontalOffset,
          horizontalOffset = _c === void 0 ? 8 : _c,
          _d = props.edgeOffset,
          edgeOffset = _d === void 0 ? defaultEdgeOffsetValue : _d,
          _e = props.arrowWidth,
          arrowWidth = _e === void 0 ? 9 : _e,
          _f = props.mode,
          mode = _f === void 0 ? 'follow' : _f,
          _g = props.useAutoDirection,
          useAutoDirection = _g === void 0 ? defaultAutoDirection : _g;
      /**
       * 气泡的位置信息
       * @en Position information of the bubbles
       */

      var _h = React.useState(defaultPosition),
          position = _h[0],
          setPosition = _h[1];
      /**
       * 是否在计算气泡位置
       * @en Whether to calculate the bubble position
       */


      var isCalcPosition = React.useMemo(function () {
        var top = position.top,
            bottom = position.bottom,
            height = position.height,
            left = position.left,
            width = position.width;

        if (left || width || top || height || bottom) {
          return false;
        }

        return true;
      }, [position]);
      /**
       * 缩放动画中心，尖角的顶部
       * @en Scale animation center, top of sharp corners
       */

      var _j = React.useState({
        x: '0',
        y: '0'
      }),
          transformOrigin = _j[0],
          setTransformOrigin = _j[1];
      /**
       * 气泡方向，可以会自适应变化
       * @en Bubble direction, can be adaptively changed
       */


      var _k = useRefState(direction),
          directionState = _k[0],
          directionStateRef = _k[1],
          setDirectionState = _k[2];

      var getOffset = React.useCallback(function (dir) {
        return getDefaultValue(isObject$2(edgeOffset) ? edgeOffset[dir] : edgeOffset, defaultEdgeOffset[dir]);
      }, [edgeOffset]);
      var getAutoDirection = React.useCallback(function (dir) {
        return getDefaultValue(isObject$2(useAutoDirection) ? useAutoDirection[dir] : useAutoDirection, defaultAutoDirection);
      }, [useAutoDirection]);
      React.useEffect(function () {
        setDirectionState(direction);
      }, [direction]);
      /**
       * 调整尖角图标的位置
       * @en Adjust the position of the sharp corner icon
       */

      function adjustArrow(_a) {
        var childRect = _a.childRect,
            config = _a.config;

        if (directionState.indexOf('Left') !== -1 || directionState.indexOf('Right') !== -1) {
          return (childRect.width - arrowWidth) / 2 + horizontalOffset;
        }

        return (config.width - arrowWidth) / 2;
      }
      /**
       * 如果提示框超出屏幕，则向屏幕中间调整一下
       * @en If the prompt box is beyond the screen, adjust it to the middle of the screen
       */


      function adjustEdge(_a) {
        var childRect = _a.childRect,
            config = _a.config;

        var newConfig = __assign$2(__assign$2({}, config), {
          adjustOffset: 0
        });

        newConfig.arrowLeft = adjustArrow({
          childRect: childRect,
          config: config
        });
        var screenWidth = screen.availWidth;
        var _b = [getOffset('top'), getOffset('right'), getOffset('bottom'), getOffset('left')],
            topOffset = _b[0],
            rightOffset = _b[1],
            bottomOffset = _b[2],
            leftOffset = _b[3];
        var _c = [getAutoDirection('vertical'), getAutoDirection('horizontal')],
            verticalAuto = _c[0],
            horizontalAuto = _c[1]; // 水平方向安全距离自动调整
        // @en Automatic adjustment of safety distance in horizontal direction

        if (horizontalAuto) {
          if (directionState.indexOf('Right') !== -1) {
            var overflow = Number(config.width) - childRect.left - childRect.width; // 左边是否溢出，向右平移安全距离
            // @en Whether the left overflows, pan to the right by a safe distance

            if (overflow > 0) {
              var adjustOffset = overflow + leftOffset;
              newConfig.left = Number(newConfig.left) + adjustOffset;
              newConfig.arrowLeft += adjustOffset;
              newConfig.adjustOffset = adjustOffset;
            } // 右边是否溢出，向左平移
            // @en Whether to overflow on the right, pan to the left


            if (screenWidth - childRect.right < rightOffset) {
              overflow = rightOffset;
              var adjustOffset = -(overflow - (screenWidth - childRect.right));
              newConfig.left = Number(newConfig.left) + adjustOffset;
              newConfig.adjustOffset = adjustOffset;
            }
          } else if (directionState.indexOf('Center') !== -1) {
            var beyondChildEdge = (Number(config.width) - childRect.width) / 2;
            var rightOverflow = beyondChildEdge - (screenWidth - childRect.right);
            var leftOverflow = beyondChildEdge - childRect.left; // 右边是否溢出
            // @en Whether to overflow on the right

            if (rightOverflow > 0) {
              var adjustOffset = -(rightOverflow + rightOffset);
              newConfig.left = Number(newConfig.left) + adjustOffset;
              newConfig.arrowLeft -= adjustOffset;
              newConfig.adjustOffset = adjustOffset;
            } // 左边是否溢出
            // @en Whether the left overflow


            if (leftOverflow > 0) {
              var adjustOffset = leftOverflow + leftOffset;
              newConfig.left = Number(newConfig.left) + adjustOffset;
              newConfig.arrowLeft -= adjustOffset;
              newConfig.adjustOffset = adjustOffset;
            }
          } else if (directionState.indexOf('Left') !== -1) {
            var overflow = Number(config.width) - childRect.width - (screenWidth - childRect.right); // 右边是否溢出
            // @en Whether to overflow on the right

            if (overflow > 0) {
              var adjustOffset = -(overflow + rightOffset);
              newConfig.left = Number(newConfig.left) + adjustOffset;
              newConfig.arrowLeft -= adjustOffset;
              newConfig.adjustOffset = adjustOffset;
            }

            if (childRect.left < leftOffset) {
              // 左边是否不够
              // @en Whether the left is not enough
              overflow = leftOffset;
              newConfig.left = Number(newConfig.left) + overflow;
              newConfig.adjustOffset = leftOffset;
            }
          }
        } // 垂直方向安全距离调整
        // @en Vertical safety distance adjustment


        if (verticalAuto) {
          var popoverTop = childRect.bottom - (newConfig.bottom && newConfig.height ? newConfig.bottom + newConfig.height : 0);
          var popoverBottom = childRect.top + (newConfig.top && newConfig.height ? newConfig.top + newConfig.height : 0); // 顶部安全距离不够，调整到底部
          // @en The top safety distance is not enough, adjust to the bottom

          if (directionState.indexOf('top') !== -1 && popoverTop < topOffset) {
            newConfig.top = verticalOffset + childRect.height;
            newConfig.bottom = null;
            onAdjustDirection('bottom');
          } else if (directionState.indexOf('bottom') !== -1 && popoverBottom + bottomOffset > window.innerHeight) {
            // 底部安全距离不够，调整到顶部
            // @en The bottom safety distance is not enough, adjust to the top
            newConfig.top = null;
            newConfig.bottom = verticalOffset + childRect.height;
            onAdjustDirection('top');
          }
        } // 挂载在全局的气泡需要计算相对屏幕的位置
        // @en Bubble mounted in the global needs to calculate the position relative to the screen


        if (mode === 'global') {
          var wrapperEl = wrapperRef.current;
          if (!wrapperEl) return newConfig;

          var _d = wrapperEl.getBoundingClientRect(),
              top_1 = _d.top,
              left = _d.left,
              bottom = _d.bottom;

          if (newConfig.left !== null) newConfig.left += left;
          if (newConfig.top !== null) newConfig.top += top_1;

          if (newConfig.bottom !== null) {
            var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
            newConfig.bottom = windowInnerHeight - (bottom - newConfig.bottom);
          }
        }

        return newConfig;
      }
      /**
       * 计算缩放动画中心尖角顶部的位置
       */


      function getOrigin(config, adjustOffset) {
        var arrowLeft = config.arrowLeft;
        var width = config.width || 0;
        var height = config.height || 0;
        var halfArrowWidth = arrowWidth / 2;
        var x = width / 2 + "px";
        var y = directionStateRef.current.indexOf('top') > -1 ? halfArrowWidth + height + "px" : "-" + halfArrowWidth + "px";

        if (directionStateRef.current.indexOf('Left') > -1) {
          x = arrowLeft + halfArrowWidth + "px";
        } else if (directionStateRef.current.indexOf('Right') > -1) {
          x = width - (arrowLeft + halfArrowWidth) + "px";
        } else {
          x = width / 2 - adjustOffset + "px";
        }

        return {
          x: x,
          y: y
        };
      }
      /**
       * 调整边界并更新气泡位置
       * @en Adjust bounds and update bubble position
       */


      function judgeAndUpdatePosition(childRect, config) {
        var _a = adjustEdge({
          childRect: childRect,
          config: config
        }),
            adjustOffset = _a.adjustOffset,
            newConfig = __rest$1(_a, ["adjustOffset"]);

        var newTransformOrigin = getOrigin(newConfig, adjustOffset);
        setTransformOrigin(newTransformOrigin);
        setPosition(newConfig);
      }
      /* eslint-disable react-hooks/exhaustive-deps */


      var setTopRightOffset = function setTopRightOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -(popoverWidth - childRect.width - horizontalOffset);
        var bottom = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          top: null,
          height: popoverHeight,
          bottom: bottom,
          arrowLeft: 0
        };
        judgeAndUpdatePosition(childRect, config);
      };

      var setTopCenterOffset = function setTopCenterOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -(popoverWidth - childRect.width) / 2;
        var bottom = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          top: null,
          height: popoverHeight,
          bottom: bottom,
          arrowLeft: 0
        };
        judgeAndUpdatePosition(childRect, config);
      };

      var setTopLeftOffset = function setTopLeftOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -horizontalOffset;
        var bottom = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          top: null,
          height: popoverHeight,
          bottom: bottom,
          arrowLeft: 0
        };
        judgeAndUpdatePosition(childRect, config);
      };

      var setBottomRightOffset = function setBottomRightOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -(popoverWidth - childRect.width - horizontalOffset);
        var top = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          bottom: null,
          height: popoverHeight,
          top: top,
          arrowLeft: 0
        };
        judgeAndUpdatePosition(childRect, config);
      };

      var setBottomCenterOffset = function setBottomCenterOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -(popoverWidth - childRect.width) / 2;
        var top = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          bottom: null,
          height: popoverHeight,
          top: top,
          arrowLeft: 0
        };
        judgeAndUpdatePosition(childRect, config);
      };

      var setBottomLeftOffset = function setBottomLeftOffset(_a) {
        var popoverWidth = _a.popoverWidth,
            popoverHeight = _a.popoverHeight,
            childRect = _a.childRect;
        var left = -horizontalOffset;
        var top = verticalOffset + childRect.height;
        var config = {
          left: left,
          width: popoverWidth,
          bottom: null,
          height: popoverHeight,
          arrowLeft: 0,
          top: top
        };
        judgeAndUpdatePosition(childRect, config);
      };
      /**
       * 计算气泡内容的位置
       * @en Calculate the position of the content of the bubble
       */


      var computedChildAndPopoverOffset = React.useCallback(function () {
        var _a;

        var popoverEle = (_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.content;
        if (!popoverEle) return;
        var popoverWidth = popoverEle.offsetWidth;
        var popoverHeight = popoverEle.offsetHeight;
        if (popoverWidth === 0 || popoverHeight === 0) return;
        var childEle = childRef.current;

        if (!childEle) {
          return;
        }

        var childRect = childEle.getBoundingClientRect();
        var config = {
          popoverWidth: popoverWidth,
          popoverHeight: popoverHeight,
          childRect: childRect
        };

        switch (directionState) {
          case 'topRight':
            setTopRightOffset(config);
            break;

          case 'topCenter':
            setTopCenterOffset(config);
            break;

          case 'topLeft':
            setTopLeftOffset(config);
            break;

          case 'bottomRight':
            setBottomRightOffset(config);
            break;

          case 'bottomCenter':
            setBottomCenterOffset(config);
            break;

          case 'bottomLeft':
            setBottomLeftOffset(config);
            break;
        }
      }, [childRef, directionState, popoverRef, setTopRightOffset, setTopCenterOffset, setTopLeftOffset, setBottomRightOffset, setBottomCenterOffset, setBottomLeftOffset]);

      var resetPosition = function resetPosition() {
        setPosition(defaultPosition);
        setDirectionState(direction);
      };
      /**
       * 调整气泡垂直方向回调
       * @en Callback when adjusting the vertical direction of the bubble
       */


      var onAdjustDirection = function onAdjustDirection(vertical) {
        if (directionState.indexOf(vertical) === -1) {
          var newDirection = directionState.replace(/top|bottom/, vertical);
          setDirectionState(newDirection);
          directionStateRef.current = newDirection;
        }
      };
      /**
       * 判断垂直方向是否需要调整
       * @en Determine whether the vertical direction needs to be adjusted
       */


      var adjustVerticalDirection = React.useCallback(function () {
        var popover = popoverRef.current;

        if (!popover) {
          return;
        }

        var popoverEle = popover.content;
        if (!popoverEle) return;

        var _a = popoverEle.getBoundingClientRect(),
            top = _a.top,
            bottom = _a.bottom; // 顶部安全距离不够，调整到底部
        // @en The top safety distance is not enough, adjust to the bottom


        if (directionState.indexOf('top') !== -1 && top < getOffset('top') || directionState.indexOf('bottom') !== -1 && bottom + getOffset('bottom') > window.innerHeight) {
          computedChildAndPopoverOffset();
        }
      }, [directionState, popoverRef, computedChildAndPopoverOffset, getOffset]);
      return {
        direction: directionState,
        position: position,
        isCalcPosition: isCalcPosition,
        arrowWidth: arrowWidth,
        transformOrigin: transformOrigin,
        computedChildAndPopoverOffset: computedChildAndPopoverOffset,
        resetPosition: resetPosition,
        onAdjustDirection: onAdjustDirection,
        adjustVerticalDirection: adjustVerticalDirection
      };
    };

    /**
     * 阻止最近一次点击事件计时器
     * @en Block last click event timer
     */

    var preventRecentClickTimer = 0;
    var useEvent = function useEvent(props, wrapperRef, popoverInnerRef, visibleRef, onVisibleChange, adjustVerticalDirection) {
      var _a = props.clickOtherToClose,
          clickOtherToClose = _a === void 0 ? true : _a,
          _b = props.touchOtherToClose,
          touchOtherToClose = _b === void 0 ? props.touchToClose === void 0 ? false : props.touchToClose : _b,
          _c = props.duration,
          duration = _c === void 0 ? 0 : _c,
          _d = props.useAutoDirection,
          useAutoDirection = _d === void 0 ? true : _d,
          _e = props.verticalScrollThrottle,
          verticalScrollThrottle = _e === void 0 ? 100 : _e,
          _f = props.preventBodyClick,
          preventBodyClick = _f === void 0 ? false : _f,
          _g = props.getVerticalScrollContainer,
          getVerticalScrollContainer = _g === void 0 ? function () {
        return document;
      } : _g;
      /**
       * 浮窗消失计时器
       * @en Popup disappearing timer
       */

      var closeTimer = React.useRef(0);
      /** 垂直方向自适应 */

      var autoVerticalDirection = getDefaultValue(isObject$2(useAutoDirection) ? useAutoDirection.vertical : useAutoDirection, defaultAutoDirection);

      var popoverDisappear = function popoverDisappear() {
        onVisibleChange(false);
        window.clearTimeout(closeTimer.current);
        closeTimer.current = 0;
        mayRemoveEventListenerOnBody();
      };

      var throttleHandleVerticalScroll = React.useMemo(function () {
        return lodash_throttle(adjustVerticalDirection, verticalScrollThrottle);
      }, [adjustVerticalDirection, verticalScrollThrottle]);
      React.useEffect(function () {
        var verticalScrollEl = getVerticalScrollContainer();

        if (visibleRef.current && verticalScrollEl && autoVerticalDirection) {
          verticalScrollEl.addEventListener('scroll', throttleHandleVerticalScroll);
        }

        return function () {
          if (verticalScrollEl) {
            verticalScrollEl.removeEventListener('scroll', throttleHandleVerticalScroll);
          }
        };
      }, [throttleHandleVerticalScroll, getVerticalScrollContainer, autoVerticalDirection, visibleRef]);
      var mayRemoveEventListenerOnBody = React.useCallback(function () {
        document.body.removeEventListener('click', handleClickBody, true);
        document.body.removeEventListener('touchstart', handleTouchBody);
        var el = getVerticalScrollContainer();

        if (el) {
          el.removeEventListener('scroll', throttleHandleVerticalScroll);
          el.removeEventListener('scroll', handleScrollBody);
        }
      }, [throttleHandleVerticalScroll]);
      var handleClickBody = React.useCallback(function (e) {
        var _a; // 仅处理子元素和气泡元素外的点击事件
        // @en Only handle click events outside of children elements and bubble elements


        if (!isContains(wrapperRef.current, e.target) && !isContains(((_a = popoverInnerRef.current) === null || _a === void 0 ? void 0 : _a.dom) || null, e.target)) {
          if (preventBodyClick) {
            e.stopPropagation();
            e.preventDefault();
          }

          popoverDisappear();
        }
      }, [preventBodyClick]);
      /**
       * UE要求气泡出现后，点击页面任意元素只隐藏气泡，不响应点击事件
       * @en UE requires that after the bubble appears, clicking any element on the page only hides the bubble and does not respond to the click event
       * 由于touchstart不能取消点击事件
       * @en It can't cancel click event due to touchstart
       * 监听body的最近一次click事件进行取消
       * @en Listen to the body's latest click event to cancel
       * 如果500ms内没有点击事件，用户可能是通过滑动页面触发的touchstart，此时移除click监听
       * @en If there is no click event within 500ms, the user may have triggered the touchstart by sliding the page, and the click listener will be removed at this time.
       */

      var preventRecentClick = function preventRecentClick() {
        clearTimeout(preventRecentClickTimer);

        var handle = function handle(e) {
          e.stopPropagation();
          e.preventDefault();
          document.body.removeEventListener('click', handle, true);
          clearTimeout(preventRecentClickTimer);
        };

        document.body.addEventListener('click', handle, true);
        preventRecentClickTimer = window.setTimeout(function () {
          document.body.removeEventListener('click', handle, true);
        }, 500);
      };

      var handleTouchBody = React.useCallback(function (e) {
        var _a, _b, _c, _d;

        if (!((_a = e.targetTouches[0]) === null || _a === void 0 ? void 0 : _a.target) || !wrapperRef.current || !((_b = popoverInnerRef.current) === null || _b === void 0 ? void 0 : _b.dom) || !visibleRef.current) {
          return;
        } // 判断元素是否非子元素和气泡元素，内部的事件交给组件内部自行处理
        // @en Determine whether the element is not a child element and a bubble element, and the internal events are handed over to the component to handle it by itself


        if (!isContains(wrapperRef.current, (_c = e.targetTouches[0]) === null || _c === void 0 ? void 0 : _c.target) && !isContains(popoverInnerRef.current.dom, (_d = e.targetTouches[0]) === null || _d === void 0 ? void 0 : _d.target)) {
          preventBodyClick && preventRecentClick();
          popoverDisappear();
        }
      }, [preventBodyClick]);
      var handleScrollBody = React.useCallback(function () {
        if (visibleRef.current && touchOtherToClose) {
          popoverDisappear();
        }
      }, [touchOtherToClose]);
      React.useEffect(function () {
        var el = getVerticalScrollContainer();

        if (el && touchOtherToClose && visibleRef.current) {
          el.addEventListener('scroll', handleScrollBody);
        }

        return function () {
          el && el.removeEventListener('scroll', handleScrollBody);
        };
      }, [handleScrollBody, touchOtherToClose]);

      var mayAddEventOnBody = function mayAddEventOnBody() {
        if (touchOtherToClose) {
          document.body.addEventListener('touchstart', handleTouchBody); // FIXME: 解决按住气泡元素后上下滚动页面，气泡未消失的问题
          // @en FIXME: solve the problem that the bubble does not disappear after scrolling the page up and down after pressing the bubble element

          var el = getVerticalScrollContainer();
          el && el.addEventListener('scroll', handleScrollBody);
        } else if (clickOtherToClose) {
          document.body.addEventListener('click', handleClickBody, true);
        }
      };
      /**
       * 气泡自动关闭的场景下，计时关闭气泡
       * @en In the scene where the bubbles are automatically closed, time to close the bubbles
       */


      var startCloseTimer = function startCloseTimer() {
        if (duration !== 0) {
          closeTimer.current = window.setTimeout(function () {
            onVisibleChange(false);
            mayRemoveEventListenerOnBody();
          }, duration);
        }
      };

      return {
        popoverDisappear: popoverDisappear,
        mayRemoveEventListenerOnBody: mayRemoveEventListenerOnBody,
        startCloseTimer: startCloseTimer,
        mayAddEventOnBody: mayAddEventOnBody
      };
    };

    var Popover$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.innerPopoverClassName,
          innerPopoverClassName = _b === void 0 ? '' : _b,
          _c = props.style,
          style = _c === void 0 ? {} : _c,
          _d = props.theme,
          theme = _d === void 0 ? 'black' : _d,
          _e = props.needShadow,
          needShadow = _e === void 0 ? false : _e,
          _f = props.content,
          content = _f === void 0 ? '' : _f,
          _g = props.transitionTimeout,
          transitionTimeout = _g === void 0 ? 300 : _g,
          _h = props.minWidth,
          minWidth = _h === void 0 ? '10px' : _h,
          _j = props.maxWidth,
          maxWidth = _j === void 0 ? '90vw' : _j,
          _k = props.transitionName,
          transitionName = _k === void 0 ? 'fade' : _k,
          _l = props.clickSelfToClose,
          clickSelfToClose = _l === void 0 ? true : _l,
          _m = props.touchSelfToClose,
          touchSelfToClose = _m === void 0 ? props.touchToClose === void 0 ? false : props.touchToClose : _m,
          _o = props.defaultVisible,
          defaultVisible = _o === void 0 ? false : _o,
          visible = props.visible,
          children = props.children,
          _p = props.bordered,
          bordered = _p === void 0 ? props.theme === 'white' : _p,
          _q = props.showCloseIcon,
          showCloseIcon = _q === void 0 ? false : _q,
          _r = props.textSuffix,
          textSuffix = _r === void 0 ? null : _r,
          _s = props.mode,
          mode = _s === void 0 ? 'follow' : _s,
          _t = props.showMask,
          showMask = _t === void 0 ? false : _t,
          _u = props.maskTransitionTimeout,
          maskTransitionTimeout = _u === void 0 ? {
        enter: 450,
        exit: 240
      } : _u,
          renderArrow = props.renderArrow,
          onChange = props.onChange,
          onClickCloseIcon = props.onClickCloseIcon,
          onClickTextSuffix = props.onClickTextSuffix,
          onClickMask = props.onClickMask;
      var prefixCls = React.useContext(GlobalContext).prefixCls;

      var _v = React.useState(false),
          visibleState = _v[0],
          setVisibleState = _v[1];

      var visibleRef = React.useRef(visibleState);
      var wrapperRef = React.useRef(null);
      var childRef = React.useRef(null);
      var popoverRef = React.useRef(null);
      var transitionNodeRef = React.useRef(null);
      var maskRef = React.useRef(null);

      var _w = usePosition(props, popoverRef, childRef, wrapperRef),
          direction = _w.direction,
          position = _w.position,
          isCalcPosition = _w.isCalcPosition,
          transformOrigin = _w.transformOrigin,
          computedChildAndPopoverOffset = _w.computedChildAndPopoverOffset,
          arrowWidth = _w.arrowWidth,
          resetPosition = _w.resetPosition,
          adjustVerticalDirection = _w.adjustVerticalDirection;
      /**
       * 气泡状态切换
       * @en Bubble state toggle
       */


      var onVisibleChange = function onVisibleChange(newVisible) {
        if (newVisible === void 0) {
          newVisible = true;
        } // 为了防止退出中有缩放动画影响气泡位置计算，在退出动画结束前不可切换到展示气泡状态
        // @en In order to prevent the zoom animation in the exit from affecting the calculation of the bubble position, it is not possible to switch to the display bubble state before the exit animation ends.


        if (newVisible && !isCalcPosition) {
          return;
        }

        onChange === null || onChange === void 0 ? void 0 : onChange(newVisible);

        if (visible === void 0) {
          setVisibleState(newVisible);
        }
      };

      var _x = useEvent(props, wrapperRef, popoverRef, visibleRef, onVisibleChange, adjustVerticalDirection),
          popoverDisappear = _x.popoverDisappear,
          mayAddEventOnBody = _x.mayAddEventOnBody,
          startCloseTimer = _x.startCloseTimer,
          mayRemoveEventListenerOnBody = _x.mayRemoveEventListenerOnBody;

      React.useImperativeHandle(ref, function () {
        var _a;

        return {
          dom: wrapperRef.current,
          child: childRef.current,
          innerPopover: popoverRef.current,
          innerPopoverDom: ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.dom) || null,
          updatePosition: updatePosition
        };
      });
      React.useEffect(function () {
        if (defaultVisible || visible) {
          setVisibleState(true);
        }

        return function () {
          mayRemoveEventListenerOnBody();
        };
      }, []);
      React.useEffect(function () {
        if (visible !== void 0) {
          setVisibleState(Boolean(visible));
        }
      }, [visible]);
      React.useEffect(function () {
        // 非 visibleState 变化引起的回调，仅用于更新位置
        // @en Callbacks not caused by visibleState changes, only used to update the position
        if (visibleRef.current) {
          computedChildAndPopoverOffset();
        }
      }, [children, content, direction, mode]);
      React.useEffect(function () {
        visibleState && showPopover();
        visibleRef.current = visibleState;

        if (!visibleState) {
          mayRemoveEventListenerOnBody();
          setTimeout(function () {
            !visibleRef.current && resetPosition();
          }, (typeof transitionTimeout === 'object' ? transitionTimeout.exit : transitionTimeout) || 300);
        }
      }, [visibleState]);

      function showPopover() {
        startCloseTimer();
        setTimeout(mayAddEventOnBody, 0); // 为了防止缩放动画影响气泡位置计算，气泡漏出阶段不重新计算位置
        // @en In order to prevent the zoom animation from affecting the bubble position calculation, the bubble leakage stage does not recalculate the position

        if (!isCalcPosition) {
          return;
        } // 异步计算气泡位置，等待气泡渲染
        // @en Calculate the bubble position asynchronously and wait for the bubble to render


        setTimeout(function () {
          computedChildAndPopoverOffset();
        }, 0);
      }

      function updatePosition() {
        if (!visibleState) return;
        computedChildAndPopoverOffset();
      }

      function onClickWrapper() {
        var visibleRefValue = visibleRef.current;

        if (!visibleRefValue) {
          onVisibleChange(true);
          return;
        }

        if (visibleRefValue && clickSelfToClose && !touchSelfToClose) {
          popoverDisappear();
        }
      }

      function onTouchWrapper() {
        // 仅处理气泡消失，气泡出现交给onClick来处理
        // @en Only the disappearance of the bubble is processed, and the appearance of the bubble is handed over to onClick for processing
        if (touchSelfToClose && visibleRef.current) {
          popoverDisappear();
        }
      }

      var renderInnerPopover = function renderInnerPopover() {
        return /*#__PURE__*/React__default["default"].createElement(PopoverInner, {
          className: cls(theme + "-theme", innerPopoverClassName, {
            bordered: bordered
          }),
          ref: function ref(ele) {
            popoverRef.current = ele;
            transitionNodeRef.current = ele === null || ele === void 0 ? void 0 : ele.dom;
          },
          direction: direction,
          minWidth: minWidth,
          maxWidth: maxWidth,
          position: position,
          arrowWidth: arrowWidth,
          transformOrigin: transformOrigin,
          needShadow: needShadow,
          content: content,
          mode: mode,
          showCloseIcon: showCloseIcon,
          textSuffix: textSuffix,
          renderArrow: renderArrow,
          onClickCloseIcon: onClickCloseIcon,
          onClickTextSuffix: onClickTextSuffix
        });
      };

      var renderPopover = function renderPopover() {
        return /*#__PURE__*/React__default["default"].createElement(Portal, {
          getContainer: function getContainer() {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return mode === 'global' ? document.body : wrapperRef.current;
          }
        }, visibleState && isCalcPosition && renderInnerPopover(), /*#__PURE__*/React__default["default"].createElement(Transition, {
          in: visibleState && !isCalcPosition,
          timeout: transitionTimeout,
          type: transitionName,
          nodeRef: transitionNodeRef,
          mountOnEnter: true,
          unmountOnExit: true
        }, renderInnerPopover()));
      };

      return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, showMask && /*#__PURE__*/React__default["default"].createElement(Portal, null, /*#__PURE__*/React__default["default"].createElement(Transition, {
        in: visibleState && !isCalcPosition,
        timeout: maskTransitionTimeout,
        nodeRef: maskRef,
        type: "fade",
        mountOnEnter: true,
        unmountOnExit: true
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-popover-mask",
        onClick: onClickMask,
        ref: maskRef
      }))), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-popover", className, theme + "-theme", mode + "-mode", {
          bordered: bordered,
          'custom-content': typeof content !== 'string'
        }),
        style: style,
        ref: wrapperRef,
        onClick: onClickWrapper,
        onTouchStart: onTouchWrapper
      }, renderPopover(), /*#__PURE__*/React__default["default"].createElement("div", {
        ref: childRef,
        className: "popover-child-inner"
      }, children)));
    });

    /**
     * 气泡菜单
     * @en Bubble menu
     */

    var Menu = componentGenerator$4(Popover$1);
    /**
     * 气泡卡片，支持六个方向，小箭头在各个方向均基于挂载的子元素居中放置，支持受控和非受控模式。
     * @en Bubble card, supports six directions, small arrows are centered in each direction based on the mounted sub-elements, and supports controlled and uncontrolled modes.
     * @name 气泡卡片
     * @name_en Popover
     * @type 信息展示
     * @type_en Data Display
     */

    var index$b = componentWrapper(Popover$1, {
      Menu: Menu
    });

    function open(Component) {
      return open$5(Component, 'ARCO_POPUP_SWIPER');
    }

    var PopupSwiper = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          visible = props.visible,
          children = props.children,
          maskStyle = props.maskStyle,
          contentStyle = props.contentStyle,
          _b = props.direction,
          direction = _b === void 0 ? 'bottom' : _b,
          _c = props.percentToClose,
          percentToClose = _c === void 0 ? 0.3 : _c,
          _d = props.distanceToClose,
          distanceToClose = _d === void 0 ? 10 : _d,
          _e = props.speedToClose,
          speedToClose = _e === void 0 ? 200 : _e,
          allowSwipeDirections = props.allowSwipeDirections,
          exitDirection = props.exitDirection,
          onTouchMove = props.onTouchMove,
          onTouchStart = props.onTouchStart,
          onTouchEnd = props.onTouchEnd,
          _onOpen = props.onOpen,
          _onClose = props.onClose,
          close = props.close,
          otherProps = __rest$1(props, ["className", "visible", "children", "maskStyle", "contentStyle", "direction", "percentToClose", "distanceToClose", "speedToClose", "allowSwipeDirections", "exitDirection", "onTouchMove", "onTouchStart", "onTouchEnd", "onOpen", "onClose", "close"]);

      var _f = React.useState(visible),
          opened = _f[0],
          setOpened = _f[1];

      var _g = useRefState({
        direction: 'X',
        value: 0
      }),
          distance = _g[0],
          distanceRef = _g[1],
          setDistance = _g[2];

      var _h = React.useState(false),
          hasTrans = _h[0],
          setHasTrans = _h[1];

      var popupRef = React.useRef(null);
      var touchStartXRef = React.useRef(0);
      var touchStartYRef = React.useRef(0);
      var touchStartTimeRef = React.useRef(0);
      var hasTouchStartRef = React.useRef(false);
      var getContentSize = React.useCallback(function (direc) {
        var _a;

        var contentDom = (_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.content;
        var contentWidth = (contentDom === null || contentDom === void 0 ? void 0 : contentDom.offsetWidth) || 0;
        var contentHeight = (contentDom === null || contentDom === void 0 ? void 0 : contentDom.offsetHeight) || 0;
        var contentSize = direc === 'X' ? contentWidth : contentHeight;
        return contentSize;
      }, []);
      var getPercent = React.useCallback(function (dis) {
        var direc = dis.direction,
            value = dis.value;
        var contentSize = getContentSize(direc);
        return contentSize ? Math.max(0, Math.min(1, Math.abs(value) / contentSize)) : 0;
      }, []);
      var percent = React.useMemo(function () {
        return getPercent(distance);
      }, [distance]);
      var allowedDirections = React.useMemo(function () {
        return allowSwipeDirections !== void 0 ? allowSwipeDirections : [direction];
      }, [allowSwipeDirections, direction]);
      var handleTouchStart = React.useCallback(function (e) {
        var _a, _b, _c, _d;

        if (onTouchStart && onTouchStart(e)) {
          return;
        }

        setHasTrans(false);
        hasTouchStartRef.current = true;
        touchStartXRef.current = ((_b = (_a = e.touches) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.clientX) || 0;
        touchStartYRef.current = ((_d = (_c = e.touches) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.clientY) || 0;
        touchStartTimeRef.current = new Date().getTime();
      }, [onTouchStart]);
      var getMovingFromDirection = React.useCallback(function (direc, disX, disY) {
        if (direc === 'X') {
          return disX > 0 ? 'right' : 'left';
        }

        return disY > 0 ? 'bottom' : 'top';
      }, []);
      var handleTouchMove = React.useCallback(function (e, prevented, direc) {
        var _a, _b, _c, _d, _e;

        if (onTouchMove && onTouchMove(e, prevented, direc)) {
          return;
        } // 如果prevented=false说明正在滚动，则专心处理滚动事件而不处理跟手退出


        if (!prevented) {
          hasTouchStartRef.current = false;
        }

        if (!hasTouchStartRef.current || e.target === ((_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.mask)) {
          return;
        }

        var touchMoveX = ((_c = (_b = e.changedTouches) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.clientX) || 0;
        var touchMoveY = ((_e = (_d = e.changedTouches) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.clientY) || 0;
        var disX = touchMoveX < 0 ? 0 : touchMoveX - touchStartXRef.current;
        var disY = touchMoveY - touchStartYRef.current;
        var fromDirec = getMovingFromDirection(direc === 'x' ? 'X' : 'Y', disX, disY);
        var movingFromDirec = allowedDirections.includes(fromDirec) ? fromDirec : '';
        var disDirection = exitDirection || movingFromDirec;
        var direcValue = ['top', 'bottom'].includes(disDirection) ? 'Y' : 'X';
        var direcRatio = ['bottom', 'right'].includes(disDirection) ? 1 : -1;

        switch (movingFromDirec) {
          case 'top':
          case 'bottom':
            setDistance({
              direction: direcValue,
              value: Math.abs(disY) * direcRatio
            });
            break;

          case 'left':
          case 'right':
            setDistance({
              direction: direcValue,
              value: Math.abs(disX) * direcRatio
            });
            break;
        }
      }, [onTouchMove, allowedDirections, exitDirection]);
      var getDescDisFromDirection = React.useCallback(function (direc, dis) {
        var fromDirec = getMovingFromDirection(direc, dis, dis);
        var contentSize = getContentSize(direc);
        var prefix = fromDirec === 'left' || fromDirec === 'top' ? -1 : 1;
        return prefix * contentSize;
      }, []);
      var handleTouchEnd = React.useCallback(function (e) {
        if (onTouchEnd && onTouchEnd(e)) {
          return;
        }

        if (!hasTouchStartRef.current) {
          return;
        }

        hasTouchStartRef.current = false;
        var touchEndTime = new Date().getTime();
        var _a = distanceRef.current,
            direc = _a.direction,
            value = _a.value;
        var per = getPercent(distanceRef.current);
        var speed = value / (touchEndTime - touchStartTimeRef.current) * 1000;

        if (per > 0 && per >= percentToClose && Math.abs(value) > distanceToClose || Math.abs(speed) > speedToClose) {
          setHasTrans(false);
          close(e);
          nextTick(function () {
            setDistance({
              direction: direc,
              value: getDescDisFromDirection(direc, value)
            });
          });
        } else {
          setHasTrans(true);
          setDistance({
            direction: 'X',
            value: 0
          });
        }

        touchStartTimeRef.current = 0;
      }, [onTouchEnd, percentToClose, distanceToClose, speedToClose, close]);
      React.useImperativeHandle(ref, function () {
        return popupRef.current;
      });
      React.useEffect(function () {
        var _a;

        var contentDom = (_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.content;

        if (opened && contentDom) {
          contentDom.addEventListener('touchstart', handleTouchStart);
          contentDom.addEventListener('touchend', handleTouchEnd);
          contentDom.addEventListener('touchcancel', handleTouchEnd);
        }

        return function () {
          var _a;

          var ctDom = (_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.content;

          if (opened && ctDom) {
            ctDom.removeEventListener('touchstart', handleTouchStart);
            ctDom.removeEventListener('touchend', handleTouchEnd);
            ctDom.removeEventListener('touchcancel', handleTouchEnd);
          }
        };
      }, [opened, handleTouchStart, handleTouchEnd]);

      function getContentStyle() {
        var disStyle = getStyleWithVendor({
          transform: distance.value ? "translate" + distance.direction + "(" + distance.value + "px) translateZ(2px)" : void 0
        });
        return __assign$2(__assign$2({}, contentStyle || {}), disStyle);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement(Popup$1, __assign$2({
          ref: popupRef,
          visible: visible,
          close: close,
          className: cls(prefixCls + "-popup-swiper", className, {
            'has-trans': hasTrans
          }),
          direction: direction,
          onTouchMove: handleTouchMove,
          onOpen: function onOpen() {
            setOpened(true);
            _onOpen === null || _onOpen === void 0 ? void 0 : _onOpen();
          },
          onClose: function onClose(scene) {
            setOpened(false);
            setDistance({
              direction: 'X',
              value: 0
            });
            _onClose === null || _onClose === void 0 ? void 0 : _onClose(scene);
          },
          maskStyle: __assign$2(__assign$2({}, maskStyle || {}), {
            opacity: percent ? 1 - percent : void 0
          }),
          contentStyle: getContentStyle()
        }, otherProps), children);
      });
    });
    function methodsGenerator(Comp) {
      return {
        /**
         * 打开弹出层
         * @desc {en} Open the PopupSwiper
         * @param {string | PopupSwiperProps} config Configuration
         * @returns {{ close: () => void; update: (newConfig: PopupSwiperProps) => void; }}
         */
        open: open(Comp)
      };
    }
    var PopupSwiperWithGlobalContext = CompWithGlobalContext(PopupSwiper);
    /**
     * 基于弹出层(Popup)封装的具有手势关闭功能的弹出层组件，拥有 Popup 组件的其他能力。
     * @en The popup with gesture closing function based on the popup encapsulation, has other capabilities of the Popup component.
     * @type 反馈
     * @type_en Feedback
     * @name 可滑动弹出层
     * @name_en PopupSwiper
     */

    var index$a = componentWrapper(PopupSwiper, methodsGenerator(PopupSwiperWithGlobalContext));

    /**
     * 进度条组件，可根据外界传递进来的百分比进行进度展示
     * @en Progress bar, which can display progress according to the percentage passed in from the outside
     * @type 反馈
     * @type_en Feedback
     * @name 进度条
     * @name_en Progress
     */

    var Progress = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.mode,
          mode = _a === void 0 ? 'base' : _a;
      var percentage = Math.min(100, Math.max(props.percentage, 0));
      var top = props.top,
          _b = props.percentPosition,
          percentPosition = _b === void 0 ? 'right' : _b,
          _c = props.className,
          className = _c === void 0 ? '' : _c,
          style = props.style,
          _d = props.showPercent,
          showPercent = _d === void 0 ? mode === 'base' : _d,
          renderPercent = props.renderPercent,
          trackColor = props.trackColor,
          progressColor = props.progressColor,
          _e = props.disabled,
          disabled = _e === void 0 ? false : _e,
          trackStroke = props.trackStroke,
          progressStroke = props.progressStroke,
          _f = props.duration,
          duration = _f === void 0 ? 300 : _f,
          _g = props.step,
          step = _g === void 0 ? 1 : _g,
          _h = props.filleted,
          filleted = _h === void 0 ? true : _h,
          _j = props.mountedTransition,
          mountedTransition = _j === void 0 ? true : _j,
          _k = props.mountedBezier,
          mountedBezier = _k === void 0 ? [0.34, 0.69, 0.1, 1] : _k;
      var domRef = React.useRef(null);

      var _l = useProgress(mountedTransition, percentage, duration, mountedBezier, step),
          currentPercentage = _l[0],
          transitionControl = _l[1];

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      function renderText(position) {
        if (!showPercent) {
          return null;
        }

        if (position === 'follow') {
          return renderPercent !== void 0 ? renderPercent(currentPercentage) : /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls('text-follow', {
              'inner-disabled inner-block-disabled': disabled
            }),
            style: {
              background: progressColor
            }
          }, currentPercentage, "%");
        }

        if (position === percentPosition) {
          return /*#__PURE__*/React__default["default"].createElement("div", {
            style: {
              color: progressColor
            },
            className: cls('text', "text-" + percentPosition, {
              'text-disabled': disabled && (percentPosition === 'left' || percentPosition === 'right')
            })
          }, renderPercent !== void 0 ? renderPercent(currentPercentage) : currentPercentage + "%");
        }

        return null;
      }

      function renderBarProgress(_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "progressbar",
          "aria-valuenow": percentage,
          "aria-valuemax": 100,
          "aria-valuemin": 0,
          className: cls(prefixCls + "-progress", {
            'progress-fixed': mode === 'nav'
          }, {
            'progress-disabled': disabled
          }, className),
          style: __assign$2({
            top: top
          }, style),
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: "progress-wrapper"
        }, renderText('left'), /*#__PURE__*/React__default["default"].createElement("div", {
          style: {
            background: trackColor,
            height: trackStroke
          },
          className: cls('progress-track', "position-" + percentPosition, {
            filleted: filleted
          }, {
            'nav-mode': mode === 'nav'
          })
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          style: getStyleWithVendor({
            background: progressColor,
            width: currentPercentage + "%",
            height: progressStroke,
            transition: transitionControl ? "width linear " + duration / 1000 + "s" : ''
          }),
          className: cls('progress-bar', {
            'bar-disabled': disabled,
            filleted: filleted
          })
        }, percentPosition === 'follow' ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: "wrapper"
        }, renderText('follow')) : null)), renderText('right'), renderText('innerLeft')));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderBarProgress);
    });

    var PullRefreshStatus;

    (function (PullRefreshStatus) {
      PullRefreshStatus[PullRefreshStatus["Static"] = 0] = "Static";
      PullRefreshStatus[PullRefreshStatus["Pulling"] = 1] = "Pulling";
      PullRefreshStatus[PullRefreshStatus["Loosing"] = 2] = "Loosing";
      PullRefreshStatus[PullRefreshStatus["Loading"] = 3] = "Loading";
      PullRefreshStatus[PullRefreshStatus["Finish"] = 4] = "Finish";
    })(PullRefreshStatus || (PullRefreshStatus = {}));

    var useCommonState = function useCommonState(_a) {
      var onRefresh = _a.onRefresh,
          loosingMinHeight = _a.loosingMinHeight;

      var _b = React.useState(PullRefreshStatus.Static),
          status = _b[0],
          setStatus = _b[1];

      var loadingRef = React.useRef(false);
      var labelRef = React.useRef(null);
      var domRef = React.useRef(null);

      var _c = React.useState(false),
          touching = _c[0],
          setTouching = _c[1];

      var tipsHeight = React.useMemo(function () {
        var _a, _b;

        return (_b = (_a = labelRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().height) !== null && _b !== void 0 ? _b : 40;
      }, [status]);
      var loosingHeight = React.useMemo(function () {
        return loosingMinHeight || tipsHeight;
      }, [tipsHeight, loosingMinHeight]);
      var handleRefresh = React.useCallback(function () {
        loadingRef.current = true; // 避免动画过快，最短加载时间
        // @en Minimum load time, avoid animation too fast

        return es6Promise.Promise.all([onRefresh === null || onRefresh === void 0 ? void 0 : onRefresh(), new es6Promise.Promise(function (resolve) {
          // 最少加载一秒
          // @en Load at least one second
          setTimeout(function () {
            resolve();
          }, 500);
        })]);
      }, [onRefresh]);
      return {
        status: status,
        setStatus: setStatus,
        touching: touching,
        setTouching: setTouching,
        loadingRef: loadingRef,
        labelRef: labelRef,
        domRef: domRef,
        loosingHeight: loosingHeight,
        handleRefresh: handleRefresh,
        tipsHeight: tipsHeight
      };
    };
    var useAddScrollEvents = function useAddScrollEvents(_a) {
      var domRef = _a.domRef,
          handleTouchStart = _a.handleTouchStart,
          handleTouchMove = _a.handleTouchMove,
          handleTouchEnd = _a.handleTouchEnd;
      React.useEffect(function () {
        var _a;

        (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchstart', handleTouchStart, {
          passive: false
        });
        return function () {
          var _a;

          (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchstart', handleTouchStart);
        };
      }, [handleTouchMove]);
      React.useEffect(function () {
        var _a;

        (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', handleTouchMove, {
          passive: false
        });
        return function () {
          var _a;

          (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', handleTouchMove);
        };
      }, [handleTouchMove]);
      React.useEffect(function () {
        var _a, _b;

        (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchend', handleTouchEnd);
        (_b = domRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener('touchcancel', handleTouchEnd);
        return function () {
          var _a, _b;

          (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchend', handleTouchEnd);
          (_b = domRef.current) === null || _b === void 0 ? void 0 : _b.removeEventListener('touchcancel', handleTouchEnd);
        };
      }, [handleTouchEnd]);
    };
    var useCheckAsStart = function useCheckAsStart(_a) {
      var allowPullWhenNotTop = _a.allowPullWhenNotTop,
          domRef = _a.domRef;
      var ifShouldHandle = React.useCallback(function () {
        var _a, _b;

        var domRefHeight = (_b = (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0;
        return domRef.current && !(!allowPullWhenNotTop && (domRef.current.scrollTop < 0 || domRef.current.scrollTop > domRef.current.scrollHeight - domRefHeight));
      }, [allowPullWhenNotTop]);
      return {
        ifShouldHandle: ifShouldHandle
      };
    };

    var PullRefresh$2 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var _b = React.useContext(GlobalContext),
          prefixCls = _b.prefixCls,
          _c = _b.locale,
          locale = _c === void 0 ? defaultLocale : _c;

      var animationRef = React.useRef(0);
      var className = props.className,
          style = props.style,
          children = props.children,
          _d = props.loadingText,
          loadingText = _d === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement(Loading, {
        type: "circle",
        radius: 4
      }), /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.loadingText)) : _d,
          _e = props.pullingText,
          pullingText = _e === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.pullingText)) : _e,
          _f = props.finishText,
          finishText = _f === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.finishText)) : _f,
          initialText = props.initialText,
          _g = props.finishDelay,
          finishDelay = _g === void 0 ? 300 : _g,
          _h = props.disabled,
          disabled = _h === void 0 ? false : _h,
          loosingMinHeight = props.loosingMinHeight,
          _j = props.useHideAsNestedScroll,
          useHideAsNestedScroll = _j === void 0 ? true : _j,
          _k = props.allowPullWhenNotTop,
          allowPullWhenNotTop = _k === void 0 ? false : _k,
          onRefresh = props.onRefresh;
      var lastScrollTop = React.useRef(0);
      var statusRef = React.useRef(PullRefreshStatus.Static);

      var _l = React.useState({}),
          labelStyle = _l[0],
          setLabelStyle = _l[1];

      var _m = React.useState(0),
          contentHeight = _m[0],
          setContentHeight = _m[1];

      var _o = useCommonState({
        loosingMinHeight: loosingMinHeight,
        onRefresh: onRefresh
      }),
          loadingRef = _o.loadingRef,
          status = _o.status,
          setStatus = _o.setStatus,
          labelRef = _o.labelRef,
          domRef = _o.domRef,
          touching = _o.touching,
          setTouching = _o.setTouching,
          loosingHeight = _o.loosingHeight,
          tipsHeight = _o.tipsHeight,
          handleRefresh = _o.handleRefresh;

      var ifShouldHandle = useCheckAsStart({
        domRef: domRef,
        allowPullWhenNotTop: allowPullWhenNotTop
      }).ifShouldHandle;
      var currentLabelStyle = React.useMemo(function () {
        var _a, _b;

        return useHideAsNestedScroll && !touching && status === PullRefreshStatus.Pulling && ((_b = (_a = domRef === null || domRef === void 0 ? void 0 : domRef.current) === null || _a === void 0 ? void 0 : _a.scrollTop) !== null && _b !== void 0 ? _b : 0) > 0 || disabled ? __assign$2(__assign$2({}, labelStyle), {
          opacity: 0
        }) : labelStyle;
      }, [labelStyle, useHideAsNestedScroll, touching, disabled]);
      var pullTextConfig = (_a = {}, _a[PullRefreshStatus.Static] = initialText === void 0 ? pullingText : initialText, _a[PullRefreshStatus.Pulling] = pullingText, _a[PullRefreshStatus.Loading] = loadingText, _a[PullRefreshStatus.Finish] = finishText, _a);
      var reset = React.useCallback(function (animationKey, callback) {
        if (callback === void 0) {
          callback = function callback() {};
        }

        if (animationRef.current === animationKey) {
          setLabelStyle({
            position: 'relative',
            height: '0px',
            top: 0,
            transition: 'height .45s'
          });
        }

        setTimeout(function () {
          if (animationRef.current === animationKey) {
            if (domRef.current) domRef.current.style.overflow = 'auto';
            setStatus(PullRefreshStatus.Pulling);
            setLabelStyle({
              position: 'absolute',
              top: "-" + tipsHeight + "px",
              height: tipsHeight + "px",
              transition: 'height 0s'
            });
            statusRef.current = PullRefreshStatus.Static;
            loadingRef.current = false;
            callback();
          }
        }, 450);
      }, [tipsHeight]);
      var handleTouchStart = React.useCallback(function () {
        if (disabled || loadingRef.current || !domRef.current || !ifShouldHandle()) return;
        setTouching(true);

        if (domRef.current && domRef.current.scrollTop === 0) {
          domRef.current.scrollTop = 1;
        }
      }, [disabled, ifShouldHandle]);

      var refresh = function refresh() {
        return new Promise(function (resolve) {
          if (domRef.current) {
            domRef.current.style.overflow = 'hidden';
            var animationKey_1 = new Date().getTime();
            setStatus(PullRefreshStatus.Loading);
            setLabelStyle({
              position: 'relative',
              top: 0,
              height: tipsHeight + "px",
              transition: 'height 0s'
            });
            animationRef.current = animationKey_1;
            handleRefresh().then(function () {
              if (pullTextConfig[PullRefreshStatus.Finish]) {
                setStatus(PullRefreshStatus.Finish);
                setTimeout(function () {
                  reset(animationKey_1, resolve);
                }, finishDelay);
              } else {
                reset(animationKey_1, resolve);
              }
            });
          }
        });
      };

      var handleTouchEnd = React.useCallback(function () {
        if (disabled || loadingRef.current || !domRef.current) return;
        setTouching(false);
        if (statusRef.current === PullRefreshStatus.Loosing) refresh();
      }, [disabled, tipsHeight]);
      var handleTouchMove = React.useCallback(function () {
        if (disabled || loadingRef.current || !domRef.current) return;
        setTimeout(function () {
          var _a, _b, _c, _d;

          var isLoosing = -((_b = (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.scrollTop) !== null && _b !== void 0 ? _b : 0) > loosingHeight;
          if (isLoosing) lastScrollTop.current = (_d = (_c = domRef.current) === null || _c === void 0 ? void 0 : _c.scrollTop) !== null && _d !== void 0 ? _d : 0;
          statusRef.current = isLoosing ? PullRefreshStatus.Loosing : PullRefreshStatus.Pulling;
        });
      }, [disabled, loosingHeight]);
      var updateIOSHeight = React.useCallback(function () {
        if (domRef.current) {
          var height = domRef.current.getBoundingClientRect().height;
          setContentHeight(height);
        }
      }, []);
      useListenResize(updateIOSHeight);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          refresh: refresh,
          updateIOSHeight: updateIOSHeight
        };
      });
      React.useEffect(function () {
        updateIOSHeight();
        reset(animationRef.current);
      }, []);
      useAddScrollEvents({
        domRef: domRef,
        handleTouchStart: handleTouchStart,
        handleTouchMove: handleTouchMove,
        handleTouchEnd: handleTouchEnd
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh all-border-box is-ios", className, {
          'is-disabled': disabled || !touching && useHideAsNestedScroll
        }),
        ref: domRef,
        style: contentHeight > 0 ? __assign$2({
          height: contentHeight
        }, style || {}) : style
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-content-wrapper")
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-wrapper"),
        style: currentLabelStyle
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label"),
        ref: labelRef
      }, pullTextConfig[status])), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-content"),
        style: contentHeight > 0 ? {
          minHeight: contentHeight + 1 + "px"
        } : {}
      }, children)));
    });

    var dampRateCalculate = function dampRateCalculate(val, tipsHeight, dampRate) {
      return val > tipsHeight ? tipsHeight + (val - tipsHeight) / dampRate : val;
    };

    var PullRefresh$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var _b = React.useContext(GlobalContext),
          prefixCls = _b.prefixCls,
          _c = _b.locale,
          locale = _c === void 0 ? defaultLocale : _c;

      var className = props.className,
          style = props.style,
          children = props.children,
          _d = props.loosingText,
          loosingText = _d === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.loosingText)) : _d,
          _e = props.loadingText,
          loadingText = _e === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement(Loading, {
        type: "circle",
        radius: 4
      }), /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.loadingText)) : _e,
          _f = props.pullingText,
          pullingText = _f === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.pullingText)) : _f,
          _g = props.finishText,
          finishText = _g === void 0 ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label-text")
      }, /*#__PURE__*/React__default["default"].createElement("span", null, locale.PullRefresh.finishText)) : _g,
          initialText = props.initialText,
          _h = props.finishDelay,
          finishDelay = _h === void 0 ? 300 : _h,
          loosingMinHeight = props.loosingMinHeight,
          _j = props.dampRate,
          dampRate = _j === void 0 ? 4 : _j,
          _k = props.disabled,
          disabled = _k === void 0 ? false : _k,
          _l = props.useHideAsNestedScroll,
          useHideAsNestedScroll = _l === void 0 ? true : _l,
          onRefresh = props.onRefresh,
          _m = props.allowPullWhenNotTop,
          allowPullWhenNotTop = _m === void 0 ? false : _m;
      var placeRef = React.useRef(null);
      var touchRef = React.useRef(null);
      var currentTranslateYRef = React.useRef(0);
      var onTouching = React.useRef(false);

      var _o = useCommonState({
        loosingMinHeight: loosingMinHeight,
        onRefresh: onRefresh
      }),
          loadingRef = _o.loadingRef,
          status = _o.status,
          setStatus = _o.setStatus,
          labelRef = _o.labelRef,
          domRef = _o.domRef,
          touching = _o.touching,
          setTouching = _o.setTouching,
          loosingHeight = _o.loosingHeight,
          handleRefresh = _o.handleRefresh,
          tipsHeight = _o.tipsHeight;

      var ifShouldHandle = useCheckAsStart({
        domRef: domRef,
        allowPullWhenNotTop: allowPullWhenNotTop
      }).ifShouldHandle;
      var currentLabelStyle = React.useMemo(function () {
        var _a, _b;

        return useHideAsNestedScroll && !touching && status === PullRefreshStatus.Pulling && ((_b = (_a = domRef === null || domRef === void 0 ? void 0 : domRef.current) === null || _a === void 0 ? void 0 : _a.scrollTop) !== null && _b !== void 0 ? _b : 0) > 0 ? {
          opacity: 0
        } : {};
      }, [useHideAsNestedScroll, touching]);
      var pullTextConfig = (_a = {}, _a[PullRefreshStatus.Static] = initialText === void 0 ? pullingText : initialText, _a[PullRefreshStatus.Pulling] = pullingText, _a[PullRefreshStatus.Loosing] = loosingText || pullingText, _a[PullRefreshStatus.Loading] = loadingText, _a[PullRefreshStatus.Finish] = finishText, _a);

      var scroll = function scroll(y, ms, callback) {
        if (y < 5) {
          if (y < 0 || ms === 0) {
            currentTranslateYRef.current = 0;
            return;
          }
        }

        var translateY = dampRateCalculate(y, loosingHeight, dampRate);
        currentTranslateYRef.current = translateY;
        placeRef.current && setStyleWithVendor(placeRef.current, __assign$2({
          transform: translateY ? "translateY(" + translateY + "px) translateZ(0)" : ''
        }, ms ? {
          transition: "all " + ms / 1000 + "s"
        } : {}));
        setTimeout(function () {
          callback === null || callback === void 0 ? void 0 : callback();
        }, ms);
      };

      var reset = function reset(callback) {
        if (callback === void 0) {
          callback = function callback() {};
        }

        scroll(0, 300, function () {
          if (domRef.current && domRef.current.scrollTop < 0) {
            domRef.current.scrollTop = 0;
          }

          loadingRef.current = false;
          setStatus(PullRefreshStatus.Static);
          placeRef.current && setStyleWithVendor(placeRef.current, {
            transition: ''
          });
          callback();
        });
      };

      var handleTouchStart = React.useCallback(function (e) {
        var _a;

        if (disabled || touchRef.current || loadingRef.current || !domRef.current) return;
        if (!ifShouldHandle()) return;
        setTouching(true);

        if (domRef.current.scrollTop === 0) {
          domRef.current.scrollTop = 1;
        }

        var _b = e.touches[0],
            pageX = _b.pageX,
            pageY = _b.pageY;

        if (pageX && pageY) {
          touchRef.current = {
            start: (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.scrollTop,
            x: pageX,
            y: pageY
          };
        }

        setStatus(PullRefreshStatus.Pulling);
      }, [disabled, ifShouldHandle]);

      var refresh = function refresh() {
        return new Promise(function (resolve) {
          setStatus(PullRefreshStatus.Loading);
          nextTick(function () {
            scroll(tipsHeight, 300);
            handleRefresh().then(function () {
              if (pullTextConfig[PullRefreshStatus.Finish]) {
                setStatus(PullRefreshStatus.Finish);
                setTimeout(function () {
                  reset(resolve);
                }, finishDelay);
              } else {
                reset(resolve);
              }
            });
          });
        });
      };

      var handleTouchEnd = React.useCallback(function () {
        if (currentTranslateYRef.current === 0 && !ifShouldHandle()) {
          return;
        }

        onTouching.current = false;
        setTouching(false);
        if (disabled || !touchRef.current || loadingRef.current) return;
        touchRef.current = null;

        if (status === PullRefreshStatus.Loosing) {
          refresh();
        } else {
          reset();
        }
      }, [disabled, status, tipsHeight, ifShouldHandle]);
      var handleTouchMove = React.useCallback(function (e) {
        onTouching.current = true;
        if (disabled || loadingRef.current || !domRef.current) return;
        if (!touchRef.current) return;
        var pageY = e.touches[0].pageY;
        var pullY = pageY - touchRef.current.y - touchRef.current.start;

        if (currentTranslateYRef.current === 0 && domRef.current.scrollTop > 0) {
          return;
        }

        if (currentTranslateYRef.current === 0 && pullY < 0) {
          return;
        }

        setStatus(function () {
          return pullY > loosingHeight ? PullRefreshStatus.Loosing : PullRefreshStatus.Pulling;
        });
        scroll(pullY, 0);
        e.stopPropagation();
        e.cancelable && e.preventDefault();
      }, [disabled, loosingHeight]);
      React.useEffect(function () {
        var _a;

        var onScroll = function onScroll() {
          if (onTouching.current && domRef.current && (domRef.current.scrollTop < 0 || currentTranslateYRef.current)) {
            // 禁止 ios 负 scrollTop 和双层滚动
            domRef.current.scrollTop = 0;
          }
        };

        (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', onScroll);
        return function () {
          var _a;

          (_a = domRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', onScroll);
        };
      }, []);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          refresh: refresh,
          updateIOSHeight: function updateIOSHeight() {
            console.warn('updateIOSHeight 仅在 type="ios" 时可用');
          }
        };
      });
      useAddScrollEvents({
        domRef: domRef,
        handleTouchStart: handleTouchStart,
        handleTouchMove: handleTouchMove,
        handleTouchEnd: handleTouchEnd
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh all-border-box is-android", className, {
          'is-disabled': (disabled || !touching && useHideAsNestedScroll) && status !== PullRefreshStatus.Loading
        }),
        style: style,
        ref: domRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-place"),
        ref: placeRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-label"),
        ref: labelRef,
        style: currentLabelStyle
      }, pullTextConfig[status]), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-pull-refresh-content", {
          'is-loading': [PullRefreshStatus.Loading, PullRefreshStatus.Finish].includes(status)
        })
      }, children)));
    });

    /**
     * 下拉刷新数据组件。
     * @en PullRefresh component that pulls down to refresh data.
     * @name 下拉刷新
     * @name_en PullRefresh
     * @type 其他
     * @type_en Others
     */

    var PullRefresh = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var type = props.type,
          useIosOptimize = props.useIosOptimize,
          children = props.children,
          rest = __rest$1(props, ["type", "useIosOptimize", "children"]);

      var system = useSystem();
      var Container = type === 'ios' || useIosOptimize && (type || system) === 'ios' ? PullRefresh$2 : PullRefresh$1;
      return /*#__PURE__*/React__default["default"].createElement(Container, __assign$2({}, __assign$2(__assign$2({}, rest), {
        ref: ref
      })), children);
    });

    var RadioGroupContext = /*#__PURE__*/React__default["default"].createContext({
      isGroup: false,
      shape: 'circle',
      layout: 'inline',
      disabled: false,
      value: [],
      onChange: function onChange() {}
    });
    function componentGenerator$3(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.style,
            style = _a === void 0 ? {} : _a,
            _b = props.className,
            className = _b === void 0 ? '' : _b,
            defaultValue = props.defaultValue,
            _c = props.disabled,
            disabled = _c === void 0 ? false : _c,
            _d = props.shape,
            shape = _d === void 0 ? 'circle' : _d,
            options = props.options,
            icons = props.icons,
            _e = props.onChange,
            onChange = _e === void 0 ? function () {} : _e,
            value = props.value,
            _f = props.children,
            children = _f === void 0 ? null : _f,
            _g = props.layout,
            layout = _g === void 0 ? 'inline' : _g;

        var _h = React.useState(value || defaultValue),
            groupValue = _h[0],
            setGroupValue = _h[1];

        var domRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });
        React.useEffect(function () {
          value !== void 0 && setGroupValue(value);
        }, [value]);
        /**
         * 切换Radio状态回调
         * @en Callback when toggling radio state
         */

        var handleChange = function handleChange(checked, newValue) {
          if (!checked) return;
          onChange(newValue);

          if (value === void 0) {
            setGroupValue(newValue);
          }
        };

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var prefixCls = _a.prefixCls;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            ref: domRef,
            style: style,
            className: cls(className, prefixCls + "-radio-group")
          }, /*#__PURE__*/React__default["default"].createElement(RadioGroupContext.Provider, {
            value: {
              isGroup: true,
              shape: shape,
              layout: layout,
              disabled: disabled,
              icons: icons,
              value: groupValue === void 0 ? [] : [groupValue],
              onChange: handleChange
            }
          }, children, !children && options && options.map(function (option) {
            return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
              key: option.value
            }, option, {
              isRadio: true
            }));
          })));
        });
      });
    }

    function componentGenerator$2(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var mergedProps = useMergeProps(props, RadioGroupContext);
        var radioRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return radioRef.current;
        });
        return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
          ref: radioRef
        }, mergedProps, {
          isRadio: true
        }));
      });
    }
    var Radio = componentGenerator$2(Checkbox);

    /**
     * 单选项组
     * @en Radio group
     * @displayName RadioGroup
     */

    var Group = componentWrapper(componentGenerator$3(Radio), 'RadioGroup');
    /**
     * 单选框，可用状态下点击切换选择，支持禁用，支持单选项组。
     * @en Radio button, click to switch selection when available, supports disabled state and radio option group.
     * @name 单选框
     * @name_en Radio
     * @type 数据录入
     * @type_en Data Entry
     * @displayName Radio
     */

    var index$9 = componentWrapper(Radio, 'Radio', {
      Group: Group
    });

    var Rate = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          style = props.style,
          _a = props.defaultValue,
          defaultValue = _a === void 0 ? 0 : _a,
          value = props.value,
          _b = props.count,
          count = _b === void 0 ? 5 : _b,
          _c = props.step,
          step = _c === void 0 ? 1 : _c,
          color = props.color,
          normalColor = props.normalColor,
          disabledColor = props.disabledColor,
          _d = props.allowHalf,
          allowHalf = _d === void 0 ? false : _d,
          _e = props.disabled,
          disabled = _e === void 0 ? false : _e,
          size = props.size,
          offset = props.offset,
          icons = props.icons,
          onChange = props.onChange;

      var _f = React.useState(defaultValue),
          innerValue = _f[0],
          setInnerValue = _f[1];

      var starIndex = React.useMemo(function () {
        var actualValue = value !== void 0 ? value : innerValue;
        return actualValue / step || 0;
      }, [value, innerValue, step]);
      var domRef = React.useRef(null);
      var helpArray = React.useMemo(function () {
        return Array(count).fill('');
      }, [count]);
      useUpdateEffect(function () {
        handleStarIndexChange(starIndex);
      }, [step]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      function handleStarIndexChange(newIndex) {
        if (disabled) {
          return;
        }

        var newValue = newIndex * step;
        setInnerValue(newValue);
        onChange && onChange(newValue);
      }

      function renderIconByAttr(defaultNode, index, attr) {
        if (!attr) {
          return defaultNode;
        }

        if (typeof attr === 'function') {
          // 对外的index从0开始
          // @en External index starts from 0
          return attr(index - 1);
        }

        return attr;
      }

      function getIconStatus(index) {
        if (starIndex >= index) {
          return 'active';
        }

        if (starIndex >= index - 0.5 && allowHalf) {
          return 'half-active';
        }

        return 'normal';
      }

      function renderRateIcon(prefix, status, index) {
        if (status === 'active') {
          return renderIconByAttr( /*#__PURE__*/React__default["default"].createElement(IconStarFill, {
            className: cls(prefix + "-icon active", {
              disabled: disabled
            }),
            style: {
              fontSize: size,
              color: disabled ? disabledColor : color
            }
          }), index, icons === null || icons === void 0 ? void 0 : icons.active);
        }

        if (status === 'half-active') {
          var _a = icons || {},
              active = _a.active,
              halfActive = _a.halfActive;

          var customIcon = halfActive || active;
          return renderIconByAttr( /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement(IconStarFill, {
            className: cls(prefix + "-icon normal", {
              disabled: disabled
            }),
            style: {
              fontSize: size,
              color: normalColor
            }
          }), /*#__PURE__*/React__default["default"].createElement(IconStarHalf, {
            className: cls(prefix + "-icon half-active", {
              disabled: disabled
            }),
            style: {
              fontSize: size,
              color: disabled ? disabledColor : color
            }
          })), index, customIcon);
        }

        return renderIconByAttr( /*#__PURE__*/React__default["default"].createElement(IconStarFill, {
          className: cls(prefix + "-icon normal", {
            disabled: disabled
          }),
          style: {
            fontSize: size,
            color: normalColor
          }
        }), index, icons === null || icons === void 0 ? void 0 : icons.normal);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls,
            useRtl = _a.useRtl;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "slider",
          "aria-valuemin": 0,
          "aria-valuemax": count,
          "aria-valuenow": innerValue,
          "aria-disabled": disabled,
          className: cls(prefixCls + "-rate", className, {
            disabled: disabled
          }),
          style: style,
          ref: domRef
        }, helpArray.map(function (_, i) {
          // 对内的index从1开始，方便计算
          // @en The index of the pair starts from 1, which is convenient for calculation
          var index = i + 1;
          var halfIndex = allowHalf ? index - 0.5 : index;
          var status = getIconStatus(index);
          return /*#__PURE__*/React__default["default"].createElement("div", {
            key: index,
            style: {
              padding: offset
            },
            className: prefixCls + "-rate-icon-wrap " + status
          }, renderRateIcon(prefixCls + "-rate", status, index), /*#__PURE__*/React__default["default"].createElement("div", {
            className: prefixCls + "-rate-icon-click-half left",
            onClick: function onClick() {
              return handleStarIndexChange(useRtl ? index : halfIndex);
            }
          }), /*#__PURE__*/React__default["default"].createElement("div", {
            className: prefixCls + "-rate-icon-click-half right",
            onClick: function onClick() {
              return handleStarIndexChange(useRtl ? halfIndex : index);
            }
          }));
        }));
      });
    });
    /**
     * 评分组件，支持受控模式
     * @en Rate component, supports controlled mode
     * @type 数据录入
     * @type_en Data Entry
     * @name 评分
     * @name_en Rate
     * @displayName Rate
     */

    var index$8 = componentWrapper(Rate, 'Rate');

    function createHighlightNode(config, index) {
      var keyword = config.keyword,
          highlightClassName = config.highlightClassName,
          highlightStyle = config.highlightStyle;
      return /*#__PURE__*/React__default["default"].createElement("span", {
        className: highlightClassName,
        style: highlightStyle,
        key: index
      }, keyword);
    }
    /**
     * 高亮搜索候选项中，包含的关键字
     *
     */


    function highlightWithContainMode(config) {
      var _a = config.content,
          content = _a === void 0 ? '' : _a,
          _b = config.keyword,
          keyword = _b === void 0 ? '' : _b; // 具体实现思路就是将keyword作为split的分隔符，切割content得到数组

      var splitContent = content.split(keyword); // 再将高亮后的keyword节点，插空填入数组

      var highlightResult = splitContent.reduce(function (prev, word, index) {
        prev.push(word);

        if (index !== splitContent.length - 1) {
          prev.push(createHighlightNode(config, index));
        }

        return prev;
      }, []);
      return highlightResult;
    }
    /**
     * 高亮搜索候选项和关键字的最长前缀公共字符串
     *
     */

    function highlightWithPrefixMode(config) {
      var _a = config.content,
          content = _a === void 0 ? '' : _a,
          _b = config.keyword,
          keyword = _b === void 0 ? '' : _b,
          otherConfig = __rest$1(config, ["content", "keyword"]);

      var splitIndex = -1;

      for (var i = 0; i < keyword.length; i++) {
        if (i >= content.length || content[i] !== keyword[i]) {
          break;
        }

        splitIndex = i;
      }

      return splitIndex > -1 ? [createHighlightNode(__assign$2(__assign$2({}, otherConfig), {
        keyword: content.substring(0, splitIndex + 1)
      }), 0), content.substring(splitIndex + 1)] : content;
    }

    function SearchBarAssociation(props) {
      var _a;

      var prefixCls = props.prefixCls,
          _b = props.associationItems,
          associationItems = _b === void 0 ? [] : _b,
          highlightClassName = props.highlightClassName,
          _c = props.highlightMode,
          highlightMode = _c === void 0 ? 'none' : _c,
          highlightStyle = props.highlightStyle,
          onAssociationClick = props.onAssociationClick,
          onAssociationItemClick = props.onAssociationItemClick,
          renderAssociation = props.renderAssociation,
          renderAssociationItem = props.renderAssociationItem,
          keyword = props.keyword,
          visible = props.visible;
      var searchBarAssociationPrefixCls = prefixCls + "-association";
      var defaultHighlightClassName = searchBarAssociationPrefixCls + "-item-highlight";

      var renderHighlightNode = function renderHighlightNode(content) {
        if (!content || !keyword || highlightMode === 'none') {
          return content;
        }

        var config = {
          keyword: keyword,
          content: content,
          highlightClassName: highlightClassName || defaultHighlightClassName,
          highlightStyle: highlightStyle
        };

        if (highlightMode === 'contain') {
          return highlightWithContainMode(config);
        }

        if (highlightMode === 'prefix') {
          return highlightWithPrefixMode(config);
        }

        return typeof highlightMode === 'function' ? highlightMode(content, keyword, defaultHighlightClassName) : content;
      };

      var renderItem = function renderItem(item, index) {
        var itemContent = item.content;
        var node = itemContent; // itemContent为string类型，并且开启高亮模式才去走渲染高亮内容的逻辑
        // @en When `itemContent` is a string, and the highlight mode is turned on, the logic of rendering the highlighted content is performed

        if (typeof itemContent === 'string' && highlightMode !== 'none') {
          node = renderHighlightNode(itemContent);
        }

        if (renderAssociationItem) {
          node = renderAssociationItem(item, index, node);
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: index,
          className: searchBarAssociationPrefixCls + "-item",
          onClick: function onClick() {
            return onAssociationItemClick === null || onAssociationItemClick === void 0 ? void 0 : onAssociationItemClick(item, index);
          }
        }, node);
      };

      var renderContent = function renderContent() {
        var associationContent = associationItems.map(renderItem);

        if (renderAssociation) {
          return renderAssociation(associationContent);
        }

        return associationContent;
      };

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(searchBarAssociationPrefixCls, (_a = {}, _a[searchBarAssociationPrefixCls + "-visible"] = visible, _a)),
        onClick: onAssociationClick
      }, renderContent());
    }

    function CancelButton(props) {
      var className = props.className,
          onCancel = props.onCancel,
          focusing = props.focusing,
          currentInputValue = props.currentInputValue,
          text = props.text;

      var _a = React.useState(focusing || Boolean(currentInputValue)),
          visible = _a[0],
          setVisible = _a[1];

      var handleClick = function handleClick() {
        onCancel === null || onCancel === void 0 ? void 0 : onCancel(); // 如果不延迟，在聚焦切输入框有值的情况下，点击取消按钮会造成闪烁
        // @en If there is no delay, when the focus cut input box has a value, clicking the cancel button will cause flickering

        nextTick(function () {
          setVisible(false);
        });
      };

      React.useEffect(function () {
        setVisible(focusing || Boolean(currentInputValue));
      }, [focusing, currentInputValue]);
      return visible ? /*#__PURE__*/React__default["default"].createElement("span", {
        className: className,
        onClick: handleClick
      }, text) : null;
    }

    /**
     * 搜索栏组件
     * @en SearchBar component
     * @type 数据录入
     * @type_en Data Entry
     * @name 搜索栏
     * @name_en SearchBar
     */

    var SearchBar = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = React.useContext(GlobalContext),
          prefixCls = _a.prefixCls,
          locale = _a.locale;

      var searchBarPrefixCls = prefixCls + "-search-bar";

      var inputClass = props.inputClass,
          inputStyle = props.inputStyle,
          _b = props.type,
          type = _b === void 0 ? 'search' : _b,
          nativeProps = props.nativeProps,
          id = props.id,
          name = props.name,
          maxLength = props.maxLength,
          _c = props.placeholder,
          placeholder = _c === void 0 ? locale === null || locale === void 0 ? void 0 : locale.SearchBar.placeholder : _c,
          readOnly = props.readOnly,
          onKeyUp = props.onKeyUp,
          onKeyPress = props.onKeyPress,
          disabled = props.disabled,
          pattern = props.pattern,
          _d = props.prefix,
          prefix = _d === void 0 ? /*#__PURE__*/React__default["default"].createElement(IconSearch, {
        className: searchBarPrefixCls + "-search-icon"
      }) : _d,
          append = props.append,
          _e = props.textAlign,
          textAlign = _e === void 0 ? 'left' : _e,
          actionButton = props.actionButton,
          _f = props.clearable,
          clearable = _f === void 0 ? true : _f,
          _g = props.clearShowType,
          clearShowType = _g === void 0 ? 'value' : _g,
          _h = props.shape,
          shape = _h === void 0 ? 'square' : _h,
          className = props.className,
          _j = props.enableAssociation,
          enableAssociation = _j === void 0 ? false : _j,
          associationVisible = props.associationVisible,
          _k = props.associationShowType,
          associationShowType = _k === void 0 ? 'default' : _k,
          associationItems = props.associationItems,
          highlightClassName = props.highlightClassName,
          highlightMode = props.highlightMode,
          highlightStyle = props.highlightStyle,
          onCancel = props.onCancel,
          onAssociationClick = props.onAssociationClick,
          onAssociationItemClick = props.onAssociationItemClick,
          renderAssociation = props.renderAssociation,
          renderAssociationItem = props.renderAssociationItem,
          inputProps = __rest$1(props, ["inputClass", "inputStyle", "type", "nativeProps", "id", "name", "maxLength", "placeholder", "readOnly", "onKeyUp", "onKeyPress", "disabled", "pattern", "prefix", "append", "textAlign", "actionButton", "clearable", "clearShowType", "shape", "className", "enableAssociation", "associationVisible", "associationShowType", "associationItems", "highlightClassName", "highlightMode", "highlightStyle", "onCancel", "onAssociationClick", "onAssociationItemClick", "renderAssociation", "renderAssociationItem"]);

      var inputRef = React.useRef(null);
      /**
       * 格式化搜索输入框尾部要插入的内容
       * @en Format the content to be inserted at the end of the search input box
       */

      var formatAppendProp = function formatAppendProp(focusing, currentInputValue) {
        var appendNode = null;

        if (typeof append === 'function') {
          appendNode = append(focusing, currentInputValue);
        } else {
          appendNode = append;
        } // 默认情况下，在激活时或有内容时插入一个cancelBtn
        // @en By default inserts a cancelBtn on activation or when there is content


        var formatActionButton = typeof actionButton === 'undefined' ? /*#__PURE__*/React__default["default"].createElement(CancelButton, {
          focusing: focusing,
          currentInputValue: currentInputValue,
          className: searchBarPrefixCls + "-cancel-btn",
          onCancel: onCancel,
          text: locale === null || locale === void 0 ? void 0 : locale.SearchBar.cancelBtn
        }) : actionButton;
        return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, appendNode, formatActionButton, enableAssociation ? /*#__PURE__*/React__default["default"].createElement(SearchBarAssociation, {
          prefixCls: searchBarPrefixCls,
          keyword: currentInputValue,
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          visible: actualVisible,
          associationItems: associationItems,
          highlightClassName: highlightClassName,
          highlightMode: highlightMode,
          highlightStyle: highlightStyle,
          onAssociationClick: onAssociationClick,
          onAssociationItemClick: onAssociationItemClick,
          renderAssociation: renderAssociation,
          renderAssociationItem: renderAssociationItem
        }) : null);
      };

      var _l = useInputLogic(__assign$2({
        className: cls(className, searchBarPrefixCls + "-" + shape),
        prefix: prefix,
        clearable: clearable,
        append: formatAppendProp,
        clearShowType: clearShowType
      }, inputProps), inputRef),
          inputValue = _l.inputValue,
          handleChange = _l.handleChange,
          handleInput = _l.handleInput,
          handleKeyDown = _l.handleKeyDown,
          handleFocus = _l.handleFocus,
          handleBlur = _l.handleBlur,
          handleClick = _l.handleClick,
          renderWrapper = _l.renderWrapper,
          wrapRef = _l.wrapRef;

      var _m = React.useState(associationShowType === 'always' || (associationShowType === 'value' || associationShowType === 'default') && Boolean(inputValue)),
          visible = _m[0],
          setVisible = _m[1]; // 真实的控制搜索联想框显隐，受控模式优先生效
      // @en Control the display and hide of the search association box, and the controlled mode takes effect first


      var actualVisible = associationVisible !== null && associationVisible !== void 0 ? associationVisible : visible;
      React.useImperativeHandle(ref, function () {
        return {
          dom: wrapRef.current,
          input: inputRef.current,
          toggleAssociation: function toggleAssociation(newVisible) {
            setVisible(newVisible !== null && newVisible !== void 0 ? newVisible : !visible);
          }
        };
      });
      /**
       * 处理非受控逻辑下，搜索联想框的显隐状态
       * @en Handle the display state of the search association box under uncontrolled logic
       *
       * @param {boolean} newVisible 新的visible
       * @param {string} newValue 新的输入框值
       */

      var formatSetAssociationVisible = function formatSetAssociationVisible(newVisible, newValue) {
        if (associationShowType === 'always') {
          setVisible(true); // 聚焦模式下，直接把visible和newVisible对齐即可
          // @en In focus mode, just align visible and newVisible directly
        } else if (associationShowType === 'focus') {
          setVisible(newVisible); // 聚焦 + 有值模式下，需要newVisible为true和newValue.length > 0同时满足
          // @en In focus + valued mode, newVisible is required to be true and newValue.length > 0 to be satisfied at the same time
        } else if (associationShowType === 'default') {
          setVisible(newVisible && Boolean(newValue)); // 仅有值模式下，visible需要newValue.length > 0
          // @en In value-only mode, visible requires newValue.length > 0
        } else if (associationShowType === 'value') {
          setVisible(Boolean(newValue));
        }
      };

      var handleInputFocus = function handleInputFocus(e) {
        formatSetAssociationVisible(true, e.target.value);
        handleFocus(e);
      };

      var handleInputBlur = function handleInputBlur(e) {
        formatSetAssociationVisible(false, e.target.value);
        handleBlur(e);
      };

      var handleInputChange = function handleInputChange(e) {
        var newValue = e.target.value;
        formatSetAssociationVisible(Boolean(newValue), newValue);
        handleChange(e);
      };

      var renderSearchBar = function renderSearchBar() {
        return renderWrapper(searchBarPrefixCls, type, /*#__PURE__*/React__default["default"].createElement("input", __assign$2({}, nativeProps, {
          id: id,
          name: name,
          maxLength: maxLength,
          placeholder: placeholder,
          readOnly: readOnly,
          onFocus: handleInputFocus,
          onBlur: handleInputBlur,
          onKeyUp: onKeyUp,
          onKeyPress: onKeyPress,
          ref: inputRef,
          className: cls(searchBarPrefixCls + "-input", inputClass, searchBarPrefixCls + "-input-" + textAlign),
          style: inputStyle,
          value: inputValue,
          type: type,
          disabled: disabled,
          pattern: pattern,
          onChange: handleInputChange,
          onInput: handleInput,
          onKeyDown: handleKeyDown,
          onClick: handleClick
        })));
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderSearchBar);
    });

    var LISTEN_FLAG = 'data-show-listened';
    /**
     * 父 dom 节点集合
     * @en Parent dom node collection
     */

    var wrapperNodeList = [];
    /**
     * 同一父节点下监听队列
     * @en Listening queue under the same parent node
     */

    var listeners = {};
    var onOnceEmittedListeners = {};
    /**
     * Intersection Observer 同一 root 节点下的监听队列
     * @en Intersection Observer Listening queue under the same root node
     */

    var ioListeners = [];
    /**
     * Intersection Observer 监听 visible 状态队列
     * @en Intersection Observer listens to the visible status queue
     */

    var ioVisibleList = [];
    var throttlingVisibleChange;
    /**
     * 通过滚动事件监测 children 是否进入视口或离开视口。
     * @en Use scroll events to monitor whether children enter or leave the viewport.
     * @type 其他
     * @type_en Others
     * @name 滚动视口监听
     * @name_en ShowMonitor
     */

    var ShowMonitor = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          style = props.style,
          getScrollContainer = props.getScrollContainer,
          _a = props.throttle,
          throttle = _a === void 0 ? 300 : _a,
          _b = props.listenResize,
          listenResize = _b === void 0 ? true : _b,
          _c = props.listenScroll,
          listenScroll = _c === void 0 ? true : _c,
          _d = props.overflow,
          overflow = _d === void 0 ? false : _d,
          _e = props.offset,
          offset = _e === void 0 ? 0 : _e,
          _f = props.threshold,
          threshold = _f === void 0 ? 0 : _f,
          _g = props.once,
          once = _g === void 0 ? false : _g,
          _h = props.children,
          children = _h === void 0 ? null : _h,
          _j = props.disabled,
          disabled = _j === void 0 ? false : _j,
          onVisibleChange = props.onVisibleChange,
          onClick = props.onClick;
      var domRef = React.useRef(null);
      /**
       * 滚动容器父级元素
       * @en Scroll container parent element
       */

      var scrollPort = React.useRef(null);
      /**
       * 局部滚动元素父节点
       * @en Parent node of the local scroll element
       */

      var domRefParent = React.useRef(null);
      /**
       * 保存当前节点信息，类似于 class component 中 this
       * @en Save current node information, similar to this in class component
       */

      var listener = React.useRef(null);
      /**
       * Intersection Observer 实例化对象
       * @en Instantiated object of Intersection Observer
       */

      var io = React.useRef(null);
      /**
       * 父容器唯一 key（wrapperNodeList index）
       * @en The unique key of the parent container (wrapperNodeList index)
       */

      var wrapperKey = React.useRef(-1);
      var isChildrenExist = React.useRef(Boolean(children));
      var isSupportNativeApi = React.useMemo(function () {
        return typeof IntersectionObserver === 'function';
      }, []); // 是否支持 Intersection Observer

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,

          /**
           * 提供检查元素是否可见的api
           * @en Provides an api to check whether the element is visible
           */
          checkVisible: function checkVisible() {
            return _checkVisible({
              node: domRef.current,
              overflow: overflow,
              onVisibleChange: onVisibleChange,
              offset: offset,
              threshold: threshold
            }, true);
          },

          /**
           * 重置元素初始可见态为false，并重新对元素可见度发起检测，优先级低于disabled（通常用在对ShowMonitor内部元素变化时发起的重新监听）
           * @en Reset the initial visible state of the element to false, and re-detect the visibility of the element, the priority is lower than 'disabled'(Usually used to re-listen when elements inside ShowMonitor change)
           */
          flushVisibleStatus: function flushVisibleStatus() {
            if (isSupportNativeApi) {
              disabled ? ioUnobserve() : ioObserve();
            } else if (listener.current) {
              var key = wrapperKey.current;

              if (once && (onOnceEmittedListeners === null || onOnceEmittedListeners === void 0 ? void 0 : onOnceEmittedListeners[key])) {
                onOnceEmittedListeners[key] = onOnceEmittedListeners[key].filter(function (emitListener) {
                  return emitListener !== listener.current;
                });
              }

              if (!disabled && !listeners[key].find(function (_listener) {
                return _listener === listener.current;
              })) {
                listeners[key].push(listener.current);
              }

              !disabled && _checkVisible(listener.current);
            }
          }
        };
      });

      function _checkVisible(component, ignoreCheckPreVisibleStatus) {
        if (ignoreCheckPreVisibleStatus === void 0) {
          ignoreCheckPreVisibleStatus = false;
        }

        var node = component.node,
            compOverflow = component.overflow,
            compOnce = component.once,
            onCompVisibleChange = component.onVisibleChange,
            preVisible = component.isVisible;

        if (!(node instanceof HTMLElement)) {
          return;
        }

        var parent = scrollParent(node);
        /**
         * 当前元素为非 document 元素，即为局部滚动
         * @en If the current element is a non-document element, it's local scrolling
         */

        var isOverflow = compOverflow && [node.ownerDocument, document, document.documentElement].indexOf(parent) === -1;
        /**
         * 检查元素是否可见
         * @en Check if element is visible
         */

        var curVisible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component);
        /**
         * 忽略前后可见状态判断
         * @en Ignore the visible state judgment before and after
         */

        if (ignoreCheckPreVisibleStatus) {
          return curVisible;
        }
        /**
         * 当前元素 visible 对比之前发生改变，触发回调函数
         * @en The current element visible is changed before the comparison, and the callback function is triggered
         */


        curVisible !== preVisible && handleCheckChildrenExist() && onCompVisibleChange(curVisible, node);
        var key = wrapperKey.current;
        /**
         * 监听一次后加入 pendingList 队列，随后被 listeners 过滤掉
         * @en After listening once, it is added to the pendingList queue, and then filtered out by listeners
         */

        if (!onOnceEmittedListeners[key]) {
          onOnceEmittedListeners[key] = [];
        }
        /**
         * 当前元素不可见 -> 可见，且 once, 触发回调函数
         * @en The current element is invisible -> visible, and once, triggers the callback function
         */


        curVisible && !preVisible && compOnce && onOnceEmittedListeners[key].push(component);
      }

      var checkVisibleHandler = React.useCallback(function () {
        var key = wrapperKey.current;
        var curListeners = listeners[key] || [];
        curListeners.forEach(function (listen) {
          return _checkVisible(listen);
        });
        listeners[key] = curListeners.filter(function (item) {
          return onOnceEmittedListeners[key].indexOf(item) === -1;
        });
        onOnceEmittedListeners[key] = [];
      }, []);

      function handleCheckChildrenExist(target) {
        var dom = target || domRef.current;
        return isChildrenExist.current && (dom === null || dom === void 0 ? void 0 : dom.children.length);
      }

      function handleObserverStatusChange(entries) {
        entries.forEach(function (entry) {
          var isIntersecting = entry.isIntersecting,
              target = entry.target;
          var visibleItem = ioVisibleList.find(function (item) {
            return item.node === target;
          });

          if (visibleItem) {
            var curVisible = visibleItem.isVisible,
                onCompVisibleChange = visibleItem.onVisibleChange,
                onceEmit = visibleItem.once;
            /**
             * 当前元素 visible 对比之前发生改变，触发回调函数
             * @en Callback when the visible status of current element changes before the comparison
             */

            isIntersecting !== curVisible && handleCheckChildrenExist(target) && onCompVisibleChange(isIntersecting, target);
            /**
             * 当前元素状态由不可见变为可见，且只触发一次
             * @en The current element is invisible -> visible, and once, triggers the callback
             */

            isIntersecting && !curVisible && onceEmit && target && ioUnobserve(target);
            visibleItem.isVisible = isIntersecting;
          }
        });
      }
      /**
       * 获取 io 单例
       * @en Get the io singleton
       */


      function getIOSingleton(ioOptions) {
        var root = ioOptions.root,
            rootMargin = ioOptions.rootMargin,
            ioThreshold = ioOptions.threshold;
        var ioKey = JSON.stringify({
          rootMargin: rootMargin,
          threshold: ioThreshold
        });

        var _ioListener = ioListeners.find(function (ioListener) {
          return ioListener.root === root && ioListener.key === ioKey;
        });

        if (!_ioListener) {
          ioListeners.push({
            root: root,
            key: ioKey,
            listener: io.current = new IntersectionObserver(handleObserverStatusChange, ioOptions)
          });
        } else {
          io.current = _ioListener.listener;
        }
      }

      function ioObserve() {
        if (domRef.current && io.current) {
          var curIdx = ioVisibleList.findIndex(function (ioVisibleItem) {
            return ioVisibleItem.node === domRef.current;
          });

          if (curIdx !== -1) {
            ioVisibleList[curIdx].isVisible = false;
          } else {
            ioVisibleList.push({
              node: domRef.current,
              isVisible: false,
              once: once,
              onVisibleChange: onVisibleChange
            });
          }

          io.current.observe(domRef.current);
        }
      }

      function ioUnobserve(target) {
        var targetNode = target || domRef.current;

        if (io.current && targetNode) {
          var curIdx = ioVisibleList.findIndex(function (ioVisibleItem) {
            return ioVisibleItem.node === targetNode;
          });

          if (curIdx !== -1) {
            ioVisibleList.splice(curIdx, 1);
          }

          io.current.unobserve(targetNode);
        }
      }
      /**
       * 非首次下disabled变化时，重新监听元素
       * @en Re-listen to the element when it is not the first time that the disabled status changes,
       */


      React.useEffect(function () {
        if (isSupportNativeApi) {
          // 非首次 render 下
          // @en Not for the first time
          disabled ? ioUnobserve() : ioObserve();
        } else {
          // 非首次 render 下
          // @en Not for the first time
          if (wrapperKey.current !== -1 && listener.current && listeners[wrapperKey.current]) {
            // 禁用监听，找到对应listener并删除
            // @en Disable listening, find the corresponding listener and delete it
            if (disabled) {
              var isExist = listeners[wrapperKey.current].findIndex(function (item) {
                return item.node === domRef.current;
              });

              if (isExist !== -1) {
                listeners[wrapperKey.current].splice(0, 1);
              }
            } else {
              // 开启监听
              // @en Start to listen
              listeners[wrapperKey.current].push(listener.current);
            }
          }
        }
      }, [disabled]);
      React.useEffect(function () {
        isChildrenExist.current = Boolean(children);
      }, [children]);
      React.useEffect(function () {
        scrollPort.current = getScrollContainer ? getScrollContainer() : window;
        if (!scrollPort.current) return;
        var wrapperNodeIndex = wrapperNodeList.indexOf(scrollPort.current);

        if (wrapperNodeIndex === -1) {
          // 当前滚动视口元素不在 wrapperNodeList 中, 入队列
          // @en The current scroll viewport element is not in the wrapperNodeList, push it into the list
          wrapperNodeList.push(scrollPort.current);
          wrapperKey.current = wrapperNodeList.length - 1;
        } else {
          // 取当前 index 作为 key
          // @en Take the current index as the key
          wrapperKey.current = wrapperNodeIndex;
        }

        var curWrapperKey = wrapperKey.current;

        if (isSupportNativeApi) {
          if (domRef.current) {
            domRefParent.current = scrollParent(domRef.current);
            var parent_1 = domRefParent.current;
            var isHTMLElement = [domRef.current.ownerDocument, document, document.documentElement].indexOf(parent_1) === -1;
            var overflowRoot = isHTMLElement ? parent_1 : null;
            var root = overflow ? overflowRoot : scrollPort.current === window ? null : scrollPort.current;
            var rootMargin_1 = '';

            if (Array.isArray(offset)) {
              if (offset.length === 2) {
                rootMargin_1 = offset[0] + "px 0px " + offset[1] + "px";
              } else {
                offset.forEach(function (val, index) {
                  var space = index === 0 ? '' : ' ';
                  rootMargin_1 += "" + space + val + "px";
                });
              }
            } else {
              rootMargin_1 = offset + "px";
            }

            getIOSingleton({
              root: root,
              rootMargin: rootMargin_1,
              threshold: threshold
            });
            !disabled && ioObserve();
          }
        } else {
          // 节流后回调函数
          // @en Callback after throttling
          throttlingVisibleChange = checkVisibleHandler;
          throttle && (throttlingVisibleChange = lodash_throttle(throttlingVisibleChange, throttle));

          if (overflow) {
            if (domRef.current) {
              domRefParent.current = scrollParent(domRef.current);
              var parent_2 = domRefParent.current;

              if (parent_2 && parent_2 instanceof HTMLElement && typeof parent_2.getAttribute === 'function') {
                var listenerCount = 1 + Number(parent_2.getAttribute(LISTEN_FLAG));

                if (!listeners[curWrapperKey]) {
                  listeners[curWrapperKey] = [];
                }

                if (listenerCount === 1) {
                  // listener 数量为1时监听事件（列表中插入 ShowMonitor 时做判断）
                  // @en Listen when the number of listeners is 1 (judging when ShowMonitor is inserted into the list)
                  parent_2.addEventListener('scroll', throttlingVisibleChange);
                }

                parent_2.setAttribute(LISTEN_FLAG, String(listenerCount));
              }
            }
          } else if (!listeners[curWrapperKey] || listeners[curWrapperKey].length === 0 || // 相同curWrapperKey内全部为overflow场景，需要单独注册scroll事件
          // @en It need to register the scroll event separately when all values in the same curWrapperKey are overflow
          listeners[curWrapperKey] && listeners[curWrapperKey].every(function (it) {
            return it.overflow;
          })) {
            if (!listeners[curWrapperKey]) {
              listeners[curWrapperKey] = [];
            }

            listenScroll && scrollPort.current.addEventListener('scroll', throttlingVisibleChange);
            listenResize && scrollPort.current.addEventListener('resize', throttlingVisibleChange);
          }

          listener.current = {
            node: domRef.current,
            isVisible: false,
            overflow: overflow,
            once: once,
            offset: offset,
            threshold: threshold,
            onVisibleChange: onVisibleChange
          }; // 将当前 listener 存入 listeners

          !disabled && listeners[curWrapperKey].push(listener.current);
          nextTick(function () {
            !disabled && _checkVisible(listener.current);
          });
        }
      }, []);
      React.useEffect(function () {
        return function () {
          if (isSupportNativeApi) {
            ioUnobserve();
          } else {
            if (overflow) {
              var parent_3 = domRefParent.current;

              if (parent_3 && parent_3 instanceof HTMLElement && typeof parent_3.getAttribute === 'function') {
                var listenerCount = Number(parent_3.getAttribute(LISTEN_FLAG) || 0) - 1;

                if (listenerCount === 0) {
                  // 如果监听队列中无节点，解绑事件
                  // @en If there is no node in the listening queue, unbind the event
                  parent_3.removeEventListener('scroll', throttlingVisibleChange);
                } else {
                  // 如果监听队列中有元素节点，将 dataset 减1
                  // @en If there are element nodes in the listening queue, decrement dataset by 1
                  parent_3.setAttribute(LISTEN_FLAG, String(listenerCount));
                }
              }
            }

            var key = wrapperKey.current;
            var curListeners = listeners[key];

            if (curListeners) {
              // 不在监听队列中，移除
              // @en Not in the listening queue, remove it
              var index = curListeners.indexOf(listener.current);
              index !== -1 && curListeners.splice(index, 1); // 监听队列为空，解绑 scroll、resize 事件
              // @en When the listening queue is empty, unbind scroll and resize events

              if (curListeners.length === 0) {
                delete listeners[key];

                if (scrollPort.current) {
                  scrollPort.current.removeEventListener('scroll', throttlingVisibleChange);
                  scrollPort.current.removeEventListener('resize', throttlingVisibleChange);
                }
              }
            }
          }
        };
      }, []);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-show-monitor", className),
          style: style,
          ref: domRef,
          onClick: onClick
        }, children);
      });
    });

    var SkeletonContext = /*#__PURE__*/React__default["default"].createContext({
      showAnimation: true,
      animation: 'gradient'
    });

    var calcOffset = function calcOffset(dom, useRtl) {
      if (!dom) {
        return 0;
      }

      if (useRtl) {
        return dom.offsetLeft - dom.offsetTop;
      }

      return dom.offsetLeft + dom.offsetTop;
    };

    function useOffset(dom, useRtl) {
      var _a = React.useState(),
          offset = _a[0],
          setOffset = _a[1];

      var calcLayout = function calcLayout() {
        var _a;

        var isList = Array.isArray(dom);

        if (!(isList ? dom.length > 0 : (_a = dom) === null || _a === void 0 ? void 0 : _a.current)) {
          return;
        }

        setOffset(isList ? dom.map(function (item) {
          return calcOffset(item, useRtl);
        }) : calcOffset(dom.current, useRtl));
      };

      React.useEffect(function () {
        nextTick(function () {
          calcLayout();
        });
      }, [dom, useRtl]);
      useListenResize(calcLayout);
      return offset;
    }

    var SkeletonNode = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          children = props.children;

      var _b = React.useContext(GlobalContext),
          useRtl = _b.useRtl,
          prefixCls = _b.prefixCls;

      var _c = React.useContext(SkeletonContext),
          backgroundColor = _c.backgroundColor,
          showAnimation = _c.showAnimation,
          animation = _c.animation;

      var domRef = React.useRef(null);
      var isGradientAnimation = showAnimation && animation === 'gradient';
      var offset = useOffset(isGradientAnimation ? domRef : undefined, useRtl);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-node", showAnimation && prefixCls + "-skeleton-animation-" + animation, className),
        style: __assign$2({
          backgroundColor: backgroundColor
        }, style),
        ref: domRef
      }, children, isGradientAnimation && offset !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-skeleton-animation-item",
        style: {
          left: 0 - offset
        }
      }));
    });
    var SkeletonTitle = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.width,
          width = _b === void 0 ? '40%' : _b;

      var _c = React.useContext(GlobalContext),
          useRtl = _c.useRtl,
          prefixCls = _c.prefixCls;

      var _d = React.useContext(SkeletonContext),
          backgroundColor = _d.backgroundColor,
          showAnimation = _d.showAnimation,
          animation = _d.animation;

      var domRef = React.useRef(null);
      var isGradientAnimation = showAnimation && animation === 'gradient';
      var offset = useOffset(isGradientAnimation ? domRef : undefined, useRtl);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-title", showAnimation && prefixCls + "-skeleton-animation-" + animation, className),
        style: __assign$2({
          width: width,
          backgroundColor: backgroundColor
        }, style),
        ref: domRef
      }, isGradientAnimation && offset !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-skeleton-animation-item",
        style: {
          left: 0 - offset
        }
      }));
    });
    var SkeletonParagraph = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.rows,
          rows = _b === void 0 ? 3 : _b,
          _c = props.width,
          width = _c === void 0 ? '60%' : _c;

      var _d = React.useContext(GlobalContext),
          useRtl = _d.useRtl,
          prefixCls = _d.prefixCls;

      var _e = React.useContext(SkeletonContext),
          backgroundColor = _e.backgroundColor,
          showAnimation = _e.showAnimation,
          animation = _e.animation;

      var domRef = React.useRef(null);
      var lineDomRefs = React.useRef([]);
      var isGradientAnimation = showAnimation && animation === 'gradient';
      var offsets = useOffset(isGradientAnimation ? lineDomRefs.current : undefined, useRtl);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var getWidth = function getWidth(idx) {
        if (isArray(width)) {
          return width[idx];
        }

        if (rows - 1 === idx) {
          return width;
        }

        return undefined;
      };

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton-paragraph", className),
        style: style,
        ref: domRef
      }, Array.from(new Array(rows)).map(function (_, idx) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: idx,
          className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-paragraph-line", showAnimation && prefixCls + "-skeleton-animation-" + animation),
          style: {
            width: getWidth(idx),
            backgroundColor: backgroundColor
          },
          ref: function ref(el) {
            return el && (lineDomRefs.current[idx] = el);
          }
        }, isGradientAnimation && offsets !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-skeleton-animation-item",
          style: {
            left: 0 - (offsets[idx] || 0)
          }
        }));
      }));
    });
    var SkeletonAvatar = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style;

      var _b = React.useContext(GlobalContext),
          useRtl = _b.useRtl,
          prefixCls = _b.prefixCls;

      var _c = React.useContext(SkeletonContext),
          backgroundColor = _c.backgroundColor,
          showAnimation = _c.showAnimation,
          animation = _c.animation;

      var domRef = React.useRef(null);
      var isGradientAnimation = showAnimation && animation === 'gradient';
      var offset = useOffset(isGradientAnimation ? domRef : undefined, useRtl);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-avatar", showAnimation && prefixCls + "-skeleton-animation-" + animation, className),
        style: __assign$2({
          backgroundColor: backgroundColor
        }, style),
        ref: domRef
      }, isGradientAnimation && offset !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-skeleton-animation-item",
        style: {
          left: 0 - offset
        }
      }));
    });
    var SkeletonGrid = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          _b = props.columns,
          columns = _b === void 0 ? 4 : _b;

      var _c = React.useContext(GlobalContext),
          useRtl = _c.useRtl,
          prefixCls = _c.prefixCls;

      var _d = React.useContext(SkeletonContext),
          backgroundColor = _d.backgroundColor,
          showAnimation = _d.showAnimation,
          animation = _d.animation;

      var domRef = React.useRef(null);
      var iconDomRefs = React.useRef([]);
      var textDomRefs = React.useRef([]);
      var isGradientAnimation = showAnimation && animation === 'gradient';
      var iconOffsets = useOffset(isGradientAnimation ? iconDomRefs.current : undefined, useRtl);
      var textOffsets = useOffset(isGradientAnimation ? textDomRefs.current : undefined, useRtl);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton-grid", className),
        style: style,
        ref: domRef
      }, Array.from(new Array(columns)).map(function (_, idx) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: idx,
          className: cls(prefixCls + "-skeleton-grid-item")
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-grid-icon", showAnimation && prefixCls + "-skeleton-animation-" + animation),
          style: {
            backgroundColor: backgroundColor
          },
          ref: function ref(el) {
            return el && (iconDomRefs.current[idx] = el);
          }
        }, isGradientAnimation && iconOffsets !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-skeleton-animation-item",
          style: {
            left: 0 - ((iconOffsets === null || iconOffsets === void 0 ? void 0 : iconOffsets[idx]) || 0)
          }
        })), /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-skeleton-item", prefixCls + "-skeleton-grid-text", showAnimation && prefixCls + "-skeleton-animation-" + animation),
          style: {
            backgroundColor: backgroundColor
          },
          ref: function ref(el) {
            return el && (textDomRefs.current[idx] = el);
          }
        }, isGradientAnimation && textOffsets !== undefined && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-skeleton-animation-item",
          style: {
            left: 0 - ((textOffsets === null || textOffsets === void 0 ? void 0 : textOffsets[idx]) || 0)
          }
        })));
      }));
    });

    function getComponentProps(prop) {
      if (prop && typeof prop === 'object') {
        return prop;
      }

      return {};
    }

    var Skeleton = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a;

      var _b = props.className,
          className = _b === void 0 ? '' : _b,
          style = props.style,
          children = props.children,
          _c = props.title,
          title = _c === void 0 ? true : _c,
          _d = props.paragraph,
          paragraph = _d === void 0 ? true : _d,
          _e = props.avatar,
          avatar = _e === void 0 ? false : _e,
          grid = props.grid,
          _f = props.showAnimation,
          showAnimation = _f === void 0 ? true : _f,
          _g = props.animation,
          animation = _g === void 0 ? 'gradient' : _g,
          animationGradientColor = props.animationGradientColor,
          backgroundColor = props.backgroundColor;
      var domRef = React.useRef(null);
      var prefixCls = React.useContext(GlobalContext).prefixCls;
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      var isGrid = !!grid;
      var hasTitle = !!title;
      var hasParagraph = !!paragraph;
      var hasAvatar = !!avatar;
      var content = isGrid ? /*#__PURE__*/React__default["default"].createElement(SkeletonGrid, __assign$2({}, getComponentProps(grid))) : /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, hasAvatar && /*#__PURE__*/React__default["default"].createElement(SkeletonAvatar, __assign$2({}, getComponentProps(avatar))), (hasTitle || hasParagraph) && /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-skeleton-content"
      }, hasTitle && /*#__PURE__*/React__default["default"].createElement(SkeletonTitle, __assign$2({}, getComponentProps(title))), hasParagraph && /*#__PURE__*/React__default["default"].createElement(SkeletonParagraph, __assign$2({}, getComponentProps(paragraph)))));
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-skeleton", (_a = {}, _a[prefixCls + "-skeleton-with-avatar"] = hasAvatar, _a), className),
        style: __assign$2({
          color: animationGradientColor
        }, style),
        ref: domRef
      }, /*#__PURE__*/React__default["default"].createElement(SkeletonContext.Provider, {
        value: {
          showAnimation: showAnimation,
          animation: animation,
          backgroundColor: backgroundColor
        }
      }, content, children));
    });
    /**
     * 在内容加载过程中展示一组占位图形。
     * @en Display a set of placeholder graphics during content loading
     * @type 信息展示
     * @type_en Data Display
     * @name 骨架屏
     * @name_en Skeleton
     */

    var index$7 = componentWrapper(Skeleton, {
      Node: SkeletonNode,
      Title: SkeletonTitle,
      Paragraph: SkeletonParagraph,
      Avatar: SkeletonAvatar,
      Grid: SkeletonGrid
    });

    var useSliderIcon = function useSliderIcon(_a) {
      var valueGroup = _a.valueGroup;
      var _b = React.useContext(GlobalContext).prefixCls,
          prefixCls = _b === void 0 ? '' : _b;

      var _c = React.useContext(SliderContext),
          max = _c.max,
          suffixLabel = _c.suffixLabel,
          min = _c.min,
          prefixLabel = _c.prefixLabel;

      var renderPrefixLabel = React.useMemo(function () {
        if (!prefixLabel) return null;
        var inner;

        if (typeof prefixLabel === 'boolean' && prefixLabel) {
          inner = min;
        } else if (typeof prefixLabel === 'function') {
          inner = prefixLabel(valueGroup);
        } else {
          inner = prefixLabel;
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-slider-label is-prefix"
        }, inner);
      }, [min, prefixLabel, valueGroup]);
      var renderSuffixLabel = React.useMemo(function () {
        if (!suffixLabel) return null;
        var inner;

        if (typeof suffixLabel === 'boolean' && suffixLabel) {
          inner = max;
        } else if (typeof suffixLabel === 'function') {
          inner = suffixLabel(valueGroup);
        } else {
          inner = suffixLabel;
        }

        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-slider-label is-suffix"
        }, inner);
      }, [max, suffixLabel, valueGroup]);
      return {
        renderPrefixLabel: renderPrefixLabel,
        renderSuffixLabel: renderSuffixLabel
      };
    };

    var useSliderInit = function useSliderInit(_a) {
      var _b, _c;

      var commonIsTouching = _a.commonIsTouching;
      var ctx = React.useContext(SliderContext);
      var value = ctx.value,
          min = ctx.min,
          max = ctx.max,
          onAfterChange = ctx.onAfterChange,
          onChange = ctx.onChange,
          useMarkOnly = ctx.useMarkOnly,
          marks = ctx.marks,
          useRange = ctx.useRange;
      var baseValue = (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.value) !== null && _b !== void 0 ? _b : ctx === null || ctx === void 0 ? void 0 : ctx.defaultValue) !== null && _c !== void 0 ? _c : min;

      var _d = React.useState(baseValue),
          valueGroup = _d[0],
          setValueGroup = _d[1];

      var _e = React.useState(false),
          firstRender = _e[0],
          setFirstRender = _e[1];

      var _f = React.useState(false),
          firstTouch = _f[0],
          setFirstTouch = _f[1]; // 基础标签数组
      // @en Base mark list


      var baseConfig = React.useMemo(function () {
        if (marks === void 0) return [];
        var res = [];

        if (typeof marks === 'number') {
          res = Array((max - min) / marks + 1).fill('').map(function (_, idx) {
            return idx * marks;
          });
        } else if (Array.isArray(marks)) {
          res = marks;
        } else {
          res = Object.keys(marks).map(function (e) {
            return parseInt(e);
          });
        }

        return __spreadArrays$1(res).filter(function (e) {
          return e <= max && e >= min;
        }).sort(function (a, b) {
          return a > b ? 1 : -1;
        });
      }, [marks, max, min]);
      var validate = React.useCallback(function (newValue) {
        if (typeof valueGroup === 'number') return newValue <= valueGroup;

        var _a = __spreadArrays$1(valueGroup).sort(function (a, b) {
          return a > b ? 1 : -1;
        }),
            small = _a[0],
            large = _a[1];

        return newValue >= small && newValue <= large;
      }, [valueGroup]); // 实际 mark 标签
      // @en Actual mark tags

      var runTimeConfig = React.useMemo(function () {
        return baseConfig.map(function (e) {
          var label = marks && !Array.isArray(marks) && marks[String(e)] && typeof marks !== 'number' ? marks[String(e)] : /*#__PURE__*/React__default["default"].createElement("p", null, e);
          return {
            activated: validate(e),
            value: e,
            label: label
          };
        });
      }, [baseConfig, valueGroup, validate, marks]); // 当前值最近的标签值
      // @en The mark value closest to the current value

      var formatMarksValue = React.useCallback(function (newValue) {
        if (!useMarkOnly || marks === void 0) return newValue;

        var format = function format(v) {
          var idx;
          baseConfig.forEach(function (e, i) {
            if (v >= e) {
              idx = i;
            }
          });

          if (idx !== void 0) {
            var largerIdx = idx + 1;

            if (largerIdx < baseConfig.length && Math.abs(baseConfig[largerIdx] - v) < Math.abs(baseConfig[idx] - v)) {
              return baseConfig[largerIdx];
            }

            return baseConfig[idx];
          }

          return baseConfig[0];
        };

        if (typeof newValue === 'number') return format(newValue);
        return newValue.map(function (v) {
          return format(v);
        });
      }, [useMarkOnly, marks, baseConfig]);
      /**
       * 标记第一次渲染，方便获取位置
       * @en Mark the first render for easy location
       */

      React.useEffect(function () {
        if (commonIsTouching) setFirstTouch(true);
      }, [commonIsTouching]);
      /**
       * 是否为 range，多个游标
       * @en Whether it is range, multiple cursors
       */

      var isMultiThumb = React.useMemo(function () {
        return useRange || Array.isArray(baseValue);
      }, [useRange, typeof baseValue === 'number']);
      /**
       * 为 range 组件初始化数据
       * @en Initialize data for the range component
       */

      React.useEffect(function () {
        setFirstRender(true);
        /**
         * 初始化数据
         * @en Initialize data
         */

        var newValue = isMultiThumb && typeof valueGroup === 'number' ? formatMarksValue([valueGroup, valueGroup]) : formatMarksValue(valueGroup);
        setValueGroup(newValue);
      }, [isMultiThumb]);
      /**
       * 监听数据 value 变化
       * @en Monitor data value changes
       */

      React.useEffect(function () {
        if (value === void 0 || !firstRender || commonIsTouching !== -1) return;
        var newValue = isMultiThumb && typeof value === 'number' ? formatMarksValue([value, value]) : formatMarksValue(value);
        setValueGroup(newValue); // 如果受控需要还原
        // @en If controlled, it needs to restore
      }, [firstRender && value, commonIsTouching]);
      /**
       * 上报排序后的值
       * @en report sorted value
       */

      var formatValueGroup = React.useMemo(function () {
        return typeof valueGroup === 'number' ? valueGroup : __spreadArrays$1(valueGroup).sort(function (a, b) {
          return a > b ? 1 : -1;
        });
      }, [valueGroup]);
      React.useEffect(function () {
        if (!firstTouch) return;
        if (commonIsTouching > -1) onChange(formatValueGroup);
      }, [valueGroup]);
      React.useEffect(function () {
        if (!firstTouch) return;

        if (commonIsTouching === -1) {
          onAfterChange(formatMarksValue(formatValueGroup));

          if (value === void 0) {
            var newValue = formatMarksValue(valueGroup);
            setValueGroup(newValue);
          }
        }
      }, [commonIsTouching, formatMarksValue]);
      return {
        valueGroup: valueGroup,
        setValueGroup: setValueGroup,
        firstRender: firstRender,
        runTimeConfig: runTimeConfig,
        isMultiThumb: isMultiThumb
      };
    };

    var useSliderStyle = function useSliderStyle(_a) {
      var getLinePosition = _a.getLinePosition,
          commonIsTouching = _a.commonIsTouching,
          valueGroup = _a.valueGroup;
      var useRtl = React.useContext(GlobalContext).useRtl;

      var _b = React.useContext(SliderContext),
          size = _b.size,
          useAnimation = _b.useAnimation,
          min = _b.min,
          max = _b.max,
          type = _b.type;

      var isHorizontal = /^horizontal/g.test(type);
      var heightStyle = React.useMemo(function () {
        var _a;

        if (size === void 0) return {};
        var sizeCount = typeof size === 'string' ? parseInt(size) : size;
        return _a = {}, _a[isHorizontal ? 'height' : 'width'] = sizeCount + "px", _a;
      }, [size, isHorizontal]);
      var transitionClass = React.useMemo(function () {
        return useAnimation && commonIsTouching === -1 ? 'is-transferable' : '';
      }, [commonIsTouching, useAnimation]);
      var activeLineStyle = React.useMemo(function () {
        var _a;

        var length = getLinePosition().length;
        var start = 0;

        if (typeof valueGroup === 'number') {
          length *= (valueGroup - min) / (max - min);
        } else {
          var _b = __spreadArrays$1(valueGroup).sort(function (a, b) {
            return a > b ? 1 : -1;
          }),
              smaller = _b[0],
              larger = _b[1];

          start = (smaller - min) / (max - min) * length;
          length = (larger - min) / (max - min) * length - start;
        }

        var leftStyle = useRtl ? 'right' : 'left';
        return _a = {}, _a[isHorizontal ? leftStyle : 'bottom'] = start + "px", _a[isHorizontal ? 'width' : 'height'] = Math.abs(length) + "px", _a;
      }, [valueGroup, getLinePosition, min, max, isHorizontal]);
      return {
        heightStyle: heightStyle,
        transitionClass: transitionClass,
        activeLineStyle: activeLineStyle
      };
    };

    var IsTouchingStatus;

    (function (IsTouchingStatus) {
      IsTouchingStatus[IsTouchingStatus["Idle"] = 0] = "Idle";
      IsTouchingStatus[IsTouchingStatus["Start"] = 1] = "Start";
      IsTouchingStatus[IsTouchingStatus["Moving"] = 2] = "Moving";
    })(IsTouchingStatus || (IsTouchingStatus = {}));

    var useSliderEvents = function useSliderEvents(_a) {
      var getLinePosition = _a.getLinePosition,
          lineRef = _a.lineRef,
          valueGroup = _a.valueGroup,
          setValueGroup = _a.setValueGroup,
          setCommonIsTouching = _a.setCommonIsTouching;
      var useRtl = React.useContext(GlobalContext).useRtl;

      var _b = React.useContext(SliderContext),
          disabled = _b.disabled,
          step = _b.step,
          min = _b.min,
          max = _b.max,
          type = _b.type,
          draggableTrackOnly = _b.draggableTrackOnly;

      var _c = React.useState(IsTouchingStatus.Idle),
          isTouching = _c[0],
          setIsTouching = _c[1];

      var _d = React.useState(0),
          touchStartPosition = _d[0],
          setTouchStartPosition = _d[1];

      var linePositionRef = React.useRef({
        length: 0,
        start: 0
      });
      var isHorizontal = /^horizontal/g.test(type);
      var validateValue = React.useCallback(function (value) {
        if (value >= min && value <= max) return value;
        return value <= (min + max) / 2 ? min : max;
      }, [min, max]); // 通过位置获取值
      // @en Get value by position

      var getValueFromPosition = React.useCallback(function (touchPosition) {
        var _a = linePositionRef.current,
            length = _a.length,
            start = _a.start;
        if (length === 0) return 0;
        var rtlRatio = useRtl ? -1 : 1;
        var newWidth = isHorizontal ? (touchPosition - start) * rtlRatio : length - touchPosition + start;

        if (newWidth < 0) {
          newWidth = 0;
        } else if (newWidth > length) {
          newWidth = length;
        }

        var newRealTimeValue = validateValue(Math.round(newWidth / length * (max - min) / step) * step + min);
        return newRealTimeValue;
      }, [isHorizontal, max, min, step]); // 设置不同的值，因为可以点击 line ，需要提前计算具体修改的是哪个值。
      // @en Set different values. Because line can  be clicked, it needs to calculate which value to modify in advance.

      var setCommonValue = React.useMemo(function () {
        var start = getValueFromPosition(touchStartPosition);

        if (!Array.isArray(valueGroup)) {
          if (isTouching) {
            setValueGroup(start);
            setCommonIsTouching(0);
            setIsTouching(IsTouchingStatus.Moving);
          }

          return function (realTimeValue) {
            setValueGroup(realTimeValue);
          };
        }

        var index = Math.abs(valueGroup[0] - start) < Math.abs(valueGroup[1] - start) ? 0 : 1;

        var handleValue = function handleValue(realTimeValue) {
          setValueGroup(function (passValueGroup) {
            if (typeof passValueGroup === 'number') {
              return [passValueGroup, realTimeValue];
            }

            var newValueGroup = __spreadArrays$1(passValueGroup);

            newValueGroup[index] = realTimeValue;
            return newValueGroup;
          });
        };

        if (isTouching) {
          setCommonIsTouching(index);
          handleValue(start);
          setIsTouching(IsTouchingStatus.Moving);
        }

        return handleValue;
      }, [touchStartPosition, getValueFromPosition]);
      React.useEffect(function () {
        var _a;

        if (disabled) return;

        var handleTouchStart = function handleTouchStart(e) {
          if (draggableTrackOnly && e.target === lineRef.current) return;
          linePositionRef.current = getLinePosition();
          var _a = e.touches[0],
              clientX = _a.clientX,
              clientY = _a.clientY;
          var touchPosition = isHorizontal ? clientX : clientY;
          setIsTouching(IsTouchingStatus.Start);
          setTouchStartPosition(touchPosition);
          e.stopPropagation();
          e.preventDefault();
        };

        (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchstart', handleTouchStart);
        return function () {
          var _a;

          !disabled && ((_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchstart', handleTouchStart));
        };
      }, [disabled, isHorizontal, draggableTrackOnly]);
      React.useEffect(function () {
        var _a;

        if (disabled) return;

        var handleTouchMove = function handleTouchMove(e) {
          if (isTouching === IsTouchingStatus.Moving) {
            var _a = e.touches[0],
                clientX = _a.clientX,
                clientY = _a.clientY;
            var touchPosition = isHorizontal ? clientX : clientY;
            setCommonValue(getValueFromPosition(touchPosition));
          }

          e.stopPropagation();
          e.cancelable && e.preventDefault();
        };

        (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', handleTouchMove);
        return function () {
          var _a;

          !disabled && ((_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', handleTouchMove));
        };
      }, [disabled, isHorizontal, isTouching]);
      React.useEffect(function () {
        var _a, _b;

        if (disabled) return;

        var handleTouchEnd = function handleTouchEnd(e) {
          setIsTouching(IsTouchingStatus.Idle);
          setCommonIsTouching(-1);
          e.stopPropagation();
          e.preventDefault();
        };

        (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('touchend', handleTouchEnd);
        (_b = lineRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener('touchcancel', handleTouchEnd);
        return function () {
          var _a, _b;

          !disabled && ((_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchend', handleTouchEnd));
          !disabled && ((_b = lineRef.current) === null || _b === void 0 ? void 0 : _b.removeEventListener('touchcancel', handleTouchEnd));
        };
      }, [disabled]);
      return {
        isTouching: isTouching
      };
    };

    var baseRenderThumb = function baseRenderThumb(prefixCls) {
      return function () {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-slider-thumb"
        });
      };
    }; // 因为子组件和 hooks 较多, 为了代码整洁和可读性，做了拆分。
    // 参数通过 context 共享
    // @en Parameters are shared through context

    var SliderContext = /*#__PURE__*/React.createContext({
      className: '',
      style: {},
      disabled: false,
      useRange: false,
      useAnimation: true,
      size: 2,
      min: 0,
      max: 100,
      step: 1,
      type: 'horizontal',
      showTooltip: 'auto',
      useMarkOnly: false,
      showMarks: false,
      prefixLabel: false,
      suffixLabel: false,
      draggableTrackOnly: false,
      formatTooltip: function formatTooltip(value) {
        return String(value);
      },
      onChange: function onChange() {},
      onAfterChange: function onAfterChange() {},
      renderThumb: baseRenderThumb('')
    });

    function Popover(_a) {
      var visible = _a.visible,
          content = _a.content,
          children = _a.children;
      var _b = React.useContext(GlobalContext).prefixCls,
          prefixCls = _b === void 0 ? '' : _b;
      var domRef = React.useRef(null);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-popover-wrapper"
      }, /*#__PURE__*/React__default["default"].createElement(Transition, {
        in: visible,
        timeout: 300,
        type: "fade",
        mountOnEnter: true,
        unmountOnExit: true,
        nodeRef: domRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-popover" + (content ? '' : ' no-content'),
        ref: domRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-popover-content"
      }, content), /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-popover-arrow"
      }))), children);
    }

    var Thumb = function Thumb(_a) {
      var className = _a.className,
          value = _a.value,
          style = _a.style,
          isTouching = _a.isTouching;
      var _b = React.useContext(GlobalContext).prefixCls,
          prefixCls = _b === void 0 ? '' : _b;

      var _c = React.useContext(SliderContext),
          showTooltip = _c.showTooltip,
          renderThumb = _c.renderThumb,
          formatTooltip = _c.formatTooltip;

      var isHidden = showTooltip === 'never';
      var renderValue = React.useMemo(function () {
        return formatTooltip(value);
      }, [formatTooltip, value]);
      var isTooltipVisible = React.useMemo(function () {
        if (isHidden) return false;
        if (showTooltip === 'always') return true;
        return isTouching;
      }, [showTooltip, isTouching]);

      var renderWrapper = function renderWrapper(el) {
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-slider-thumb-wrapper " + className,
          style: __assign$2({}, style)
        }, el);
      };

      var thumbEl = typeof renderThumb === 'function' ? renderThumb(value) : renderThumb;
      if (isHidden) return renderWrapper(thumbEl);
      return renderWrapper( /*#__PURE__*/React__default["default"].createElement(Popover, {
        visible: isTooltipVisible,
        content: renderValue
      }, thumbEl));
    };

    function Marks(_a) {
      var runTimeConfig = _a.runTimeConfig,
          _b = _a.className,
          className = _b === void 0 ? '' : _b,
          _c = _a.style,
          style = _c === void 0 ? {} : _c;

      var _d = React.useContext(GlobalContext),
          _e = _d.prefixCls,
          prefixCls = _e === void 0 ? '' : _e,
          useRtl = _d.useRtl;

      var _f = React.useContext(SliderContext),
          type = _f.type,
          showMarks = _f.showMarks,
          max = _f.max,
          min = _f.min;

      var isHorizontal = /^horizontal/g.test(type);
      var genMarkStyle = React.useCallback(function (value) {
        var _a;

        var leftStyle = useRtl ? 'right' : 'left';
        return _a = {}, _a[isHorizontal ? leftStyle : 'bottom'] = (value - min) / (max - min) * 100 + "%", _a;
      }, [isHorizontal, min, max]);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-marks"
      }, runTimeConfig.map(function (_a) {
        var value = _a.value,
            label = _a.label,
            activated = _a.activated;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          key: value,
          className: cls(prefixCls + "-slider-marks-item", {
            'is-activated': activated
          }, className),
          style: __assign$2(__assign$2({}, genMarkStyle(value)), style)
        }, showMarks && /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-slider-marks-item-label"
        }, label));
      }));
    }

    var Slider = /*#__PURE__*/React.forwardRef(function (_, ref) {
      var _a = React.useContext(GlobalContext),
          _b = _a.prefixCls,
          prefixCls = _b === void 0 ? '' : _b,
          useRtl = _a.useRtl;

      var _c = React.useContext(SliderContext),
          className = _c.className,
          style = _c.style,
          disabled = _c.disabled,
          min = _c.min,
          max = _c.max,
          type = _c.type,
          showTooltip = _c.showTooltip,
          showMarks = _c.showMarks;

      var domRef = React.useRef(null);
      var lineRef = React.useRef(null); // 拖动滑块的 index 为当前的 isTouching
      // @en The index of the slider is the current isTouching

      var _d = React.useState(-1),
          commonIsTouching = _d[0],
          setCommonIsTouching = _d[1];

      var isHorizontal = /^horizontal/g.test(type);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var _e = useSliderInit({
        commonIsTouching: commonIsTouching
      }),
          firstRender = _e.firstRender,
          valueGroup = _e.valueGroup,
          setValueGroup = _e.setValueGroup,
          runTimeConfig = _e.runTimeConfig,
          isMultiThumb = _e.isMultiThumb; // 最长线 div 位置


      var getLinePosition = React.useCallback(function () {
        var _a, _b;

        var _c = (_b = (_a = lineRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) !== null && _b !== void 0 ? _b : {
          width: 0,
          left: 0,
          top: 0,
          height: 0
        },
            width = _c.width,
            left = _c.left,
            top = _c.top,
            height = _c.height;

        var leftValue = useRtl ? left + width : left;
        return {
          length: isHorizontal ? width : height,
          start: isHorizontal ? leftValue : top
        };
      }, [isHorizontal, firstRender]);

      var _f = useSliderStyle({
        getLinePosition: getLinePosition,
        commonIsTouching: commonIsTouching,
        valueGroup: valueGroup
      }),
          heightStyle = _f.heightStyle,
          transitionClass = _f.transitionClass,
          activeLineStyle = _f.activeLineStyle;

      useSliderEvents({
        lineRef: lineRef,
        valueGroup: valueGroup,
        setValueGroup: setValueGroup,
        getLinePosition: getLinePosition,
        setCommonIsTouching: setCommonIsTouching
      });

      var _g = useSliderIcon({
        valueGroup: valueGroup
      }),
          renderPrefixLabel = _g.renderPrefixLabel,
          renderSuffixLabel = _g.renderSuffixLabel;
      /**
       * 为了减少 dom 元素计算，只改变激活 line 的样式，让对应的 thumb 附着在两边，所以需要实时调整 className
       * @en In order to reduce the calculation of dom elements, only the style of the active line is changed, so that the corresponding thumb is attached to both sides, so the className needs to be adjusted in real time
       */


      var thumbConfig = React.useMemo(function () {
        if (isMultiThumb) {
          var classNames_1 = ['is-end', 'is-start'];
          return Array(2).fill('').map(function (_, index) {
            var childClassName = classNames_1[index];

            if (valueGroup[index] > valueGroup[1 - index]) {
              childClassName = classNames_1[0];
            } else if (valueGroup[index] < valueGroup[1 - index]) {
              childClassName = classNames_1[1];
            }

            return {
              className: childClassName
            };
          });
        }

        return [{
          className: 'is-end'
        }];
        /**
         * 只有 range 状态才监听 valueGroup
         * @en Only listen to valueGroup in the range state
         */
      }, [isMultiThumb && valueGroup]);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-slider " + className, "is-" + type, {
          'is-disabled': disabled,
          'show-tooltip': showTooltip !== 'never' && !disabled,
          'show-marks': showMarks
        }),
        style: style,
        ref: domRef,
        role: "slider",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": Array.isArray(valueGroup) ? valueGroup[0] : valueGroup,
        "aria-disabled": disabled
      }, isHorizontal ? renderPrefixLabel : renderSuffixLabel, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-wrapper"
      }, /*#__PURE__*/React__default["default"].createElement(Marks, {
        runTimeConfig: runTimeConfig,
        className: transitionClass
      }), /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-line",
        style: heightStyle,
        ref: lineRef
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-slider-line is-activated " + transitionClass,
        style: __assign$2(__assign$2({}, heightStyle), activeLineStyle)
      }, thumbConfig.map(function (cfg, idx) {
        return /*#__PURE__*/React__default["default"].createElement(Thumb, __assign$2({
          key: idx
        }, __assign$2({
          value: Array.isArray(valueGroup) ? valueGroup[idx] : valueGroup,
          min: min,
          max: max,
          isTouching: commonIsTouching === idx
        }, cfg)));
      })))), isHorizontal ? renderSuffixLabel : renderPrefixLabel);
    });
    var SliderWrapper = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = React.useContext(GlobalContext).prefixCls,
          prefixCls = _a === void 0 ? '' : _a;
      var defaultProps = React.useContext(SliderContext);

      var newProps = __assign$2(__assign$2(__assign$2({}, defaultProps), {
        renderThumb: baseRenderThumb(prefixCls)
      }), props);

      return /*#__PURE__*/React__default["default"].createElement(SliderContext.Provider, {
        value: newProps
      }, /*#__PURE__*/React__default["default"].createElement(Slider, {
        ref: ref
      }));
    });
    /**
     * 滑动型输入器，展示当前值和可选范围。
     * @en Slide input component, displays the current value and optional range.
     * @name 滑动输入条
     * @name_en Slider
     * @type 数据录入
     * @type_en Data Entry
     * @displayName Slider
     */

    var index$6 = componentWrapper(SliderWrapper, 'Slider');

    function correctCalculation(leftNumber, rightNumber, operator) {
      var magnification = 1e17;
      var left = leftNumber * magnification;
      var right = rightNumber * magnification;
      return operator === '-' ? (left - right) / magnification : (left + right) / magnification;
    }

    function useButtonClick(params) {
      var actualInputValue = params.actualInputValue,
          min = params.min,
          max = params.max,
          step = params.step,
          disabled = params.disabled,
          equalLimitDisabled = params.equalLimitDisabled,
          updateValue = params.updateValue,
          onAddButtonClick = params.onAddButtonClick,
          onMinusButtonClick = params.onMinusButtonClick;
      var minusDisable = actualInputValue <= min || disabled;

      var _a = React.useState(minusDisable),
          minusButtonDisable = _a[0],
          setMinusButtonDisable = _a[1];

      var addDisable = actualInputValue >= max || disabled;

      var _b = React.useState(addDisable),
          addButtonDisable = _b[0],
          setAddButtonDisable = _b[1];

      var handleMinusButtonClick = function handleMinusButtonClick(e) {
        if (minusButtonDisable) {
          return;
        }

        updateValue(function (oldValue) {
          var result = correctCalculation(oldValue, step, '-');
          return result < min ? equalLimitDisabled ? oldValue : min : result;
        });
        onMinusButtonClick && onMinusButtonClick(e);
      };

      var handleAddButtonClick = function handleAddButtonClick(e) {
        if (addButtonDisable) {
          return;
        }

        updateValue(function (oldValue) {
          var result = correctCalculation(Number(oldValue), step, '+');
          return result > max ? equalLimitDisabled ? oldValue : max : result;
        });
        onAddButtonClick && onAddButtonClick(e);
      }; // 当前值改变时，更新按钮状态
      // Changes button status when value changed


      React.useEffect(function () {
        setMinusButtonDisable(minusDisable);
        setAddButtonDisable(addDisable);
      }, [minusDisable, addDisable]);
      return {
        minusButtonDisable: minusButtonDisable,
        addButtonDisable: addButtonDisable,
        handleMinusButtonClick: handleMinusButtonClick,
        handleAddButtonClick: handleAddButtonClick
      };
    }

    function useInputEvent(params) {
      var defaultValue = params.defaultValue,
          min = params.min,
          max = params.max,
          digits = params.digits,
          actualInputValue = params.actualInputValue,
          allowEmpty = params.allowEmpty,
          updateValue = params.updateValue,
          onBlur = params.onBlur,
          onChange = params.onChange,
          onInput = params.onInput;

      var handleInput = function handleInput(e) {
        var targetValue = e.target.value;
        var numberValue = Number(targetValue);
        var pointIndex = targetValue.indexOf('.');

        if (digits > 0 && pointIndex !== -1) {
          var decimalLength = targetValue.slice(pointIndex + 1).length;
          updateValue(decimalLength > digits ? actualInputValue : numberValue);
        } else if (allowEmpty && targetValue === '') {
          updateValue(Number.MIN_VALUE);
        } else {
          updateValue(numberValue);
        }

        onInput && onInput(e);
      };

      var handleBlur = function handleBlur(e) {
        var targetValue = e.target.value;
        var numberValue = Number(targetValue);

        if (allowEmpty && targetValue === '') {
          updateValue(Number.MIN_VALUE);
        } else if (!allowEmpty && targetValue === '') {
          updateValue(defaultValue);
        } else {
          updateValue(Math.max(min, Math.min(max, numberValue)));
        }

        onBlur && onBlur(e);
      };

      useUpdateEffect(function () {
        onChange && onChange(actualInputValue);
      }, [actualInputValue]);
      return {
        handleInput: handleInput,
        handleBlur: handleBlur
      };
    }

    function useValue(params) {
      var defaultValue = params.defaultValue,
          formatter = params.formatter,
          max = params.max,
          min = params.min,
          value = params.value,
          digits = params.digits;

      var _a = React.useState(defaultValue),
          innerValue = _a[0],
          setInnerValue = _a[1];

      var updateValue = function updateValue(updater) {
        var tempValue = typeof updater === 'function' ? updater(innerValue) : updater;

        if (formatter) {
          new Promise(function (resolve) {
            resolve(formatter(Number(tempValue)));
          }).then(function (result) {
            var res = Math.max(min, Math.min(max, result));
            setInnerValue(res);
          });
        } else {
          setInnerValue(tempValue);
        }
      };

      var actualInputValue = value !== undefined ? value : innerValue; // 将actualInputValue等于Number.MIN_VALUE的情况视为空值
      // @en If actualInputValue equal Number.MIN_VALUE, actualInputValue equal ''

      var showValue = actualInputValue === Number.MIN_VALUE ? '' : digits > 0 ? parseFloat(String(actualInputValue)).toFixed(digits) : actualInputValue;
      return {
        updateValue: updateValue,
        actualInputValue: actualInputValue,
        showValue: showValue
      };
    }

    var Stepper = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          inputStyle = props.inputStyle,
          _b = props.inputClass,
          inputClass = _b === void 0 ? '' : _b,
          value = props.value,
          _c = props.defaultValue,
          defaultValue = _c === void 0 ? 1 : _c,
          _d = props.allowEmpty,
          allowEmpty = _d === void 0 ? false : _d,
          _e = props.digits,
          digits = _e === void 0 ? 0 : _e,
          _f = props.disabled,
          disabled = _f === void 0 ? false : _f,
          _g = props.inputReadonly,
          inputReadonly = _g === void 0 ? false : _g,
          _h = props.max,
          max = _h === void 0 ? Infinity : _h,
          _j = props.min,
          min = _j === void 0 ? 1 : _j,
          _k = props.equalLimitDisabled,
          equalLimitDisabled = _k === void 0 ? false : _k,
          _l = props.step,
          step = _l === void 0 ? 1 : _l,
          _m = props.theme,
          theme = _m === void 0 ? 'default' : _m,
          formatter = props.formatter,
          addButton = props.addButton,
          minusButton = props.minusButton,
          renderContent = props.renderContent,
          onBlur = props.onBlur,
          onChange = props.onChange,
          onFocus = props.onFocus,
          onAddButtonClick = props.onAddButtonClick,
          onMinusButtonClick = props.onMinusButtonClick,
          onClick = props.onClick,
          onInput = props.onInput; // 值的相关逻辑
      // @en The logic is that handle value

      var _o = useValue({
        defaultValue: defaultValue,
        formatter: formatter,
        min: min,
        max: max,
        value: value,
        digits: digits
      }),
          updateValue = _o.updateValue,
          actualInputValue = _o.actualInputValue,
          showValue = _o.showValue; // 按钮点击的相关逻辑
      // @en The logic is that handle button click


      var _p = useButtonClick({
        actualInputValue: actualInputValue,
        min: min,
        max: max,
        step: step,
        disabled: disabled,
        digits: digits,
        equalLimitDisabled: equalLimitDisabled,
        updateValue: updateValue,
        onAddButtonClick: onAddButtonClick,
        onMinusButtonClick: onMinusButtonClick
      }),
          minusButtonDisable = _p.minusButtonDisable,
          addButtonDisable = _p.addButtonDisable,
          handleAddButtonClick = _p.handleAddButtonClick,
          handleMinusButtonClick = _p.handleMinusButtonClick; // 输入框操作的相关逻辑
      // @en The logic is that handle input operation


      var _q = useInputEvent({
        defaultValue: defaultValue,
        min: min,
        max: max,
        digits: digits,
        actualInputValue: actualInputValue,
        allowEmpty: allowEmpty,
        updateValue: updateValue,
        onBlur: onBlur,
        onChange: onChange,
        onInput: onInput
      }),
          handleInput = _q.handleInput,
          handleBlur = _q.handleBlur;

      var domRef = React.useRef(null);
      var inputRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          input: inputRef.current,
          changeValue: function changeValue(newValue) {
            var tempValue = newValue != null ? newValue : defaultValue;
            tempValue = Math.min(max, Math.max(tempValue, min));
            updateValue(tempValue);
          }
        };
      });
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-stepper", prefixCls + "-" + theme, className),
          style: style,
          ref: domRef,
          onClick: onClick
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          "aria-label": "decrease",
          onClick: handleMinusButtonClick
        }, minusButton || /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-stepper-minus-button")
        }, /*#__PURE__*/React__default["default"].createElement(IconMinus, {
          className: cls(prefixCls + "-stepper-minus-button-icon", {
            disabled: minusButtonDisable
          })
        }))), renderContent ? renderContent(actualInputValue) : /*#__PURE__*/React__default["default"].createElement("input", {
          style: inputStyle,
          className: cls(prefixCls + "-stepper-input", inputClass),
          onFocus: onFocus,
          onInput: handleInput,
          onBlur: handleBlur,
          disabled: disabled,
          value: showValue,
          readOnly: inputReadonly,
          ref: inputRef,
          type: "number",
          role: "spinbutton",
          "aria-valuenow": Number(showValue),
          "aria-valuemax": max,
          "aria-valuemin": min
        }), /*#__PURE__*/React__default["default"].createElement("div", {
          "aria-label": "increase",
          onClick: handleAddButtonClick
        }, addButton || /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-stepper-add-button")
        }, /*#__PURE__*/React__default["default"].createElement(IconAdd, {
          className: cls(prefixCls + "-stepper-add-button-icon", {
            disabled: addButtonDisable
          })
        }))));
      });
    });
    /**
     * 步进器组件，支持受控模式
     * @en Stepper component, provide controlled mode
     * @type 数据录入
     * @type_en Data Entry
     * @name 步进器
     * @name_en Stepper
     * @displayName Stepper
     */

    var index$5 = componentWrapper(Stepper, 'Stepper');

    var Step = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var title = props.title,
          description = props.description,
          icon = props.icon;

      var _a = React.useContext(StepsContext),
          iconType = _a.iconType,
          current = _a.current,
          direction = _a.direction,
          _b = _a.index,
          index = _b === void 0 ? 0 : _b,
          contextStatus = _a.status,
          contextAlign = _a.align,
          changeIndex = _a.changeIndex;

      var status = props.status || contextStatus;
      var align = props.align || contextAlign;
      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      var currentStatus = React.useMemo(function () {
        if (status) return status;

        if (current < index) {
          return 'wait';
        }

        if (current === index) {
          return 'process';
        }

        return 'finish';
      }, [status, index, current]);

      function renderNumIcon(prefixCls) {
        var content;

        if (currentStatus === 'finish') {
          content = /*#__PURE__*/React__default["default"].createElement(IconCheckBold, null);
        } else if (currentStatus === 'error') {
          content = /*#__PURE__*/React__default["default"].createElement(IconCloseBold, null);
        }

        return content || /*#__PURE__*/React__default["default"].createElement("span", {
          className: cls(prefixCls + "-steps-item-icon-num")
        }, index + 1);
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          ref: domRef,
          className: cls(prefixCls + "-steps-item", prefixCls + "-steps-item-align-" + align, currentStatus, direction, iconType),
          onClick: function onClick() {
            return changeIndex(index);
          }
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-tail", prefixCls + "-steps-item-tail-status-" + currentStatus, prefixCls + "-steps-item-tail-align-" + align, currentStatus + "-tail-color-with-config")
        }), icon ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-custom-icon", currentStatus + "-custom-icon-bg-color-with-config")
        }, icon) : /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-icon", currentStatus + "-bg-color-with-config")
        }, iconType === 'number' ? renderNumIcon(prefixCls) : /*#__PURE__*/React__default["default"].createElement("span", {
          className: cls(prefixCls + "-steps-item-icon-dot")
        })), title || description ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-content", prefixCls + "-steps-item-content-align-" + align)
        }, title ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-title", currentStatus + "-title-color-with-config")
        }, title) : null, description ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-steps-item-description")
        }, description) : null) : null);
      });
    });

    var StepsContext = /*#__PURE__*/React.createContext({
      changeIndex: function changeIndex() {}
    });
    var Steps = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          children = props.children,
          _b = props.direction,
          direction = _b === void 0 ? 'horizontal' : _b,
          userSetAlign = props.align,
          _c = props.iconType,
          iconType = _c === void 0 ? 'number' : _c,
          current = props.current,
          _d = props.defaultIndex,
          defaultIndex = _d === void 0 ? 0 : _d,
          _e = props.status,
          status = _e === void 0 ? 'process' : _e,
          items = props.items,
          onClick = props.onClick,
          onChange = props.onChange;
      var defaultAlign = direction === 'vertical' ? 'start' : 'center';
      var align = userSetAlign !== void 0 ? userSetAlign : defaultAlign;

      var _f = React.useState(Number(defaultIndex)),
          innerIndex = _f[0],
          setInnerIndex = _f[1];

      var _g = useRefState(current === void 0 ? innerIndex : current),
          activeIndex = _g[0],
          activeRefIndex = _g[1],
          setActiveIndex = _g[2];

      var domRef = React.useRef(null);
      var system = useSystem();

      function changeIndex(newIndex) {
        onClick === null || onClick === void 0 ? void 0 : onClick(newIndex);
        setInnerIndex(newIndex);
        newIndex !== activeRefIndex.current && (onChange === null || onChange === void 0 ? void 0 : onChange(newIndex));
      }

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      React.useEffect(function () {
        setActiveIndex(current === void 0 ? innerIndex : current);
      }, [current, innerIndex]);
      var renderStep = React.useCallback(function (child, index) {
        return /*#__PURE__*/React__default["default"].createElement(StepsContext.Provider, {
          value: {
            iconType: iconType,
            current: activeIndex,
            direction: direction,
            index: index,
            status: activeIndex === index ? status : void 0,
            align: align,
            changeIndex: changeIndex
          },
          key: index
        }, child);
      }, [iconType, activeIndex, direction, align]);
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-steps all-border-box " + className + " " + direction + " " + system,
          style: style,
          ref: domRef
        }, items ? items.map(function (item, index) {
          return renderStep( /*#__PURE__*/React__default["default"].createElement(Step, __assign$2({}, item, {
            key: index
          })), index);
        }) : React.Children.toArray(children).map(function (child, index) {
          return renderStep(child, index);
        }));
      });
    });
    /**
     * 显示一个任务的进度; 或者引导用户完成某个复杂任务。
     * @en Display the progress of a task, or guide users to complete a complex task.
     * @name 步骤条
     * @name_en Steps
     * @type 信息展示
     * @type_en Data Display
     */

    var index$4 = componentWrapper(Steps, {
      Step: Step
    });

    function renderAction(_a) {
      var action = _a.action,
          prefixCls = _a.prefixCls,
          index = _a.index,
          type = _a.type,
          close = _a.close;
      var text = action.text,
          actionStyle = action.style,
          className = action.className,
          onClick = action.onClick,
          icon = action.icon,
          children = action.children;

      function click() {
        var result = (onClick === null || onClick === void 0 ? void 0 : onClick()) || null;

        if (!result || typeof result === 'boolean') {
          !result && close();
        } else if (result && result.then) {
          result.then(function (res) {
            return !res && close();
          });
        }
      }

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-" + type + " " + prefixCls + "-info-container", className),
        style: __assign$2({
          zIndex: index
        }, actionStyle),
        onClick: click
      }, children || /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-info"
      }, icon ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-info-icon"
      }, icon) : null, text ? /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-info-text"
      }, text) : null));
    }

    /**
     * 滑动操作组件，左右滑动拉出菜单栏
     * @en SwipeAction component, slide left and right to pull out the menu bar
     * @type 反馈
     * @type_en FeedBack
     * @name 滑动操作
     * @name_en SwipeAction
     */

    var SwipeAction = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          style = props.style,
          children = props.children,
          leftActions = props.leftActions,
          rightActions = props.rightActions,
          _b = props.disabled,
          disabled = _b === void 0 ? false : _b,
          _c = props.threshold,
          threshold = _c === void 0 ? 0.15 : _c,
          closeOnTouchOutside = props.closeOnTouchOutside,
          _d = props.transitionDuration,
          transitionDuration = _d === void 0 ? 300 : _d,
          _e = props.dampRate,
          dampRate = _e === void 0 ? 15 : _e,
          _f = props.openStyleType,
          openStyleType = _f === void 0 ? 'layer' : _f,
          onClose = props.onClose,
          onOpen = props.onOpen;
      var domRef = React.useRef(null);
      var leftRef = React.useRef(null);
      var rightRef = React.useRef(null);
      var isOpen = React.useRef(false);
      var leftMenuWidthRef = React.useRef(0);

      var _g = React.useState([]),
          leftMenuWidthArr = _g[0],
          setLeftMenuWidthArr = _g[1];

      var rightMenuWidthRef = React.useRef(0);

      var _h = React.useState([]),
          rightMenuWidthArr = _h[0],
          setRightMenuWidthArr = _h[1];

      var dampRateRef = useLatestRef(dampRate);
      var forbidClick = React.useRef(false);
      var scrollingRef = React.useRef(null);

      var _j = useRefState(false),
          moving = _j[0],
          movingRef = _j[1],
          setMoving = _j[2];

      var _k = useRefState(0),
          offset = _k[0],
          offsetRef = _k[1],
          setOffset = _k[2];

      var prefixCls = React.useContext(GlobalContext).prefixCls;
      var startRef = React.useRef(0);
      var startX = React.useRef(0);
      var startY = React.useRef(0);
      var slideX = React.useRef(0);
      var isLayer = openStyleType === 'layer';
      var transitionStyle = React.useMemo(function () {
        return getStyleWithVendor({
          transitionDuration: moving ? '0ms' : transitionDuration + "ms"
        });
      }, [moving, transitionDuration]);

      function resetMoveData() {
        startX.current = 0;
        startY.current = 0;
        slideX.current = 0;
      }

      function getMenuCurrentWidth(a, min, max) {
        var buffer = Math.abs(a) / dampRateRef.current;
        return Math.min(Math.max(a, min - buffer), max + buffer);
      }

      function touchstart(e) {
        startRef.current = offsetRef.current;
        resetMoveData();
        scrollingRef.current = null;
        startX.current = e.touches[0].pageX;
        startY.current = e.touches[0].pageY;
      }

      function touchmove(e) {
        var x = e.changedTouches[0].pageX - startX.current;
        var y = e.changedTouches[0].pageY - startY.current;

        if (scrollingRef.current === null) {
          scrollingRef.current = Math.abs(x) < Math.abs(y);
        }

        if (scrollingRef.current) {
          setMoving(false);
          setOffset(0);
          return;
        }

        e.cancelable && e.preventDefault();
        slideX.current = x;
        forbidClick.current = true;
        setMoving(true);
        setOffset(getMenuCurrentWidth(slideX.current + startRef.current, -rightMenuWidthRef.current, leftMenuWidthRef.current));
      }

      function touchend() {
        if (movingRef.current && !scrollingRef.current) {
          var currentMenu = offsetRef.current > 0 ? 'left' : 'right';
          changeMenu(currentMenu);
          setMoving(false);
          nextTick(function () {
            forbidClick.current = false;
          });
        }
      }

      function changeMenu(dir) {
        var cookedThreshold = isOpen.current ? 1 - threshold : threshold;
        var width = dir === 'left' ? leftMenuWidthRef.current : rightMenuWidthRef.current;

        if (width && Math.abs(offsetRef.current) > width * cookedThreshold) {
          open(dir);
        } else {
          close(dir);
        }
      }

      function getWidthByRef(widthRef) {
        if (!widthRef.current) {
          return {
            totalWidth: 0,
            widthArr: []
          };
        }

        var totalWidth = 0;
        var widthArr = [];
        var allEle = widthRef.current.getElementsByClassName(prefixCls + "-swipe-action-menu-action-info-container");
        Array.prototype.forEach.call(allEle, function (ele) {
          var _a;

          var w = (_a = ele.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
          totalWidth += w;
          widthArr.push(w);
        });
        return {
          totalWidth: totalWidth,
          widthArr: widthArr
        };
      }

      React.useEffect(function () {
        var container = domRef.current;

        if (!disabled && container) {
          container.addEventListener('touchstart', touchstart);
          container.addEventListener('touchmove', touchmove);
          container.addEventListener('touchend', touchend);
        }

        return function () {
          if (!disabled && container) {
            container.removeEventListener('touchstart', touchstart);
            container.removeEventListener('touchmove', touchmove);
            container.removeEventListener('touchend', touchend);
          }
        };
      }, [disabled]); // 获取左右菜单的宽度
      // @en Get the width of the left and right menu

      React.useEffect(function () {
        var _a = getWidthByRef(leftRef),
            leftTotalWidth = _a.totalWidth,
            leftWidthArr = _a.widthArr;

        leftMenuWidthRef.current = leftTotalWidth;
        setLeftMenuWidthArr(leftWidthArr);

        var _b = getWidthByRef(rightRef),
            rightTotalWidth = _b.totalWidth,
            rightWidthArr = _b.widthArr;

        rightMenuWidthRef.current = rightTotalWidth;
        setRightMenuWidthArr(rightWidthArr);
      }, [leftActions, rightActions]); // 点击外部区域事件
      // @en Event when clicking outside of the element

      React.useEffect(function () {
        var handle = function handle(e) {
          var _a;

          if (!((_a = domRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) && isOpen.current) {
            close();
          }
        };

        closeOnTouchOutside && document.addEventListener('touchstart', handle);
        return function () {
          closeOnTouchOutside && document.removeEventListener('touchstart', handle);
        };
      }, [closeOnTouchOutside]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current,
          close: close,
          open: open
        };
      });

      function close(dir) {
        setOffset(0);

        if (isOpen.current) {
          isOpen.current = false;

          if (!dir && offsetRef.current !== 0) {
            var noDir = offsetRef.current > 0 ? 'left' : 'right';
            handleClose(noDir);
            return;
          }

          handleClose(dir);
        }
      }

      function open(dir) {
        if (dir === void 0) {
          dir = 'right';
        }

        if (!isOpen.current) {
          isOpen.current = true;
          handleOpen(dir);
        }

        setOffset(dir === 'left' ? leftMenuWidthRef.current : -rightMenuWidthRef.current);
      }

      function handleOpen(dir) {
        setTimeout(function () {
          onOpen === null || onOpen === void 0 ? void 0 : onOpen(dir);
        }, transitionDuration);
      }

      function handleClose(dir) {
        setTimeout(function () {
          onClose === null || onClose === void 0 ? void 0 : onClose(dir);
        }, transitionDuration);
      }

      function actionClick(e) {
        var _a, _b;

        if (isOpen.current && !forbidClick.current && !((_a = leftRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) && !((_b = rightRef.current) === null || _b === void 0 ? void 0 : _b.contains(e.target))) {
          close();
        }
      }

      function getActionRightByIndex(index) {
        var preWidth = leftMenuWidthArr.slice(index + 1).reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
        return (preWidth / leftMenuWidthRef.current || 0) * 100 + "%";
      }

      function getActionLeftByIndex(index) {
        var preWidth = rightMenuWidthArr.slice(0, index).reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
        return (preWidth / rightMenuWidthRef.current || 0) * 100 + "%";
      }

      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-swipe-action", className, offset === 0 ? 'action-close' : 'action-open'),
        style: getStyleWithVendor(__assign$2(__assign$2(__assign$2({}, style || {}), transitionStyle), {
          transform: "translateX(" + offset + "px)"
        })),
        ref: domRef,
        onClick: actionClick
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-swipe-action-menu-left", prefixCls + "-swipe-action-menu", offset > 0 ? 'action-open' : 'action-close'),
        ref: leftRef,
        style: isLayer && offset >= 0 ? __assign$2({
          width: offset
        }, transitionStyle) : {}
      }, leftActions === null || leftActions === void 0 ? void 0 : leftActions.map(function (action, index) {
        return /*#__PURE__*/React__default["default"].createElement(renderAction, {
          action: __assign$2(__assign$2({}, action || {}), {
            style: __assign$2(__assign$2({}, isLayer ? {
              right: getActionRightByIndex(index)
            } : {}), action.style || {}),
            className: cls(action.className, "open-style-" + openStyleType)
          }),
          prefixCls: prefixCls + "-swipe-action-menu-action",
          index: leftActions.length - index,
          type: "left",
          close: close,
          key: index
        });
      })), /*#__PURE__*/React__default["default"].createElement("div", {
        className: prefixCls + "-swipe-action-content"
      }, children), /*#__PURE__*/React__default["default"].createElement("div", {
        className: cls(prefixCls + "-swipe-action-menu-right", prefixCls + "-swipe-action-menu", offset < 0 ? 'action-open' : 'action-close'),
        ref: rightRef,
        style: isLayer && offset <= 0 ? __assign$2({
          width: -1 * offset
        }, transitionStyle) : {}
      }, rightActions === null || rightActions === void 0 ? void 0 : rightActions.map(function (action, index) {
        return /*#__PURE__*/React__default["default"].createElement(renderAction, {
          action: __assign$2(__assign$2({}, action || {}), {
            style: __assign$2(__assign$2({}, isLayer ? {
              left: getActionLeftByIndex(index)
            } : {}), action.style || {}),
            className: cls(action.className, "open-style-" + openStyleType)
          }),
          prefixCls: prefixCls + "-swipe-action-menu-action",
          index: index + 1,
          type: "right",
          close: close,
          key: index
        });
      })));
    });

    /**
     * 向左滑动到达屏幕边缘后，超过一定距离时触发加载，常用于横划展示少量的元素，滑动到底后跳转至另外界面的场景
     * @en After swiping to the left to reach the edge of the screen, the loading is triggered when the distance exceeds a certain distance. It is often used to display a small number of elements horizontally, and then jump to another interface after swiping to the end.
     * @type 反馈
     * @type_en FeedBack
     * @name 左滑加载
     * @name_en SwipeLoad
     */

    var SwipeLoad = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = props.className,
          className = _a === void 0 ? '' : _a,
          _b = props.maxElementOffset,
          maxElementOffset = _b === void 0 ? 56 : _b,
          _c = props.maxLabelOffset,
          maxLabelOffset = _c === void 0 ? 40 : _c,
          onConfirm = props.onConfirm,
          _d = props.disabled,
          disabled = _d === void 0 ? false : _d,
          _e = props.circleSize,
          circleSize = _e === void 0 ? 80 : _e,
          _f = props.minConfirmOffset,
          minConfirmOffset = _f === void 0 ? 30 : _f,
          _g = props.labelAnimationFunction,
          labelAnimationFunction = _g === void 0 ? 'cubic-bezier(0.14, 1, 0.34, 1)' : _g,
          _h = props.labelAnimationDuration,
          labelAnimationDuration = _h === void 0 ? 250 : _h,
          children = props.children,
          _j = props.normalText,
          normalText = _j === void 0 ? '' : _j,
          _k = props.activeText,
          activeText = _k === void 0 ? '' : _k,
          _l = props.initPos,
          initPos = _l === void 0 ? 0 : _l,
          _m = props.bounceWhenBumpBoundary,
          bounceWhenBumpBoundary = _m === void 0 ? false : _m,
          _o = props.bounceDampRate,
          bounceDampRate = _o === void 0 ? 3 : _o,
          _p = props.bounceAnimateDuration,
          bounceAnimateDuration = _p === void 0 ? 300 : _p,
          damping = props.damping,
          bounceDistanceProcessor = props.bounceDistanceProcessor,
          getScrollContainer = props.getScrollContainer,
          getBounceContainer = props.getBounceContainer,
          onTouchStart = props.onTouchStart,
          onTouchEnd = props.onTouchEnd,
          onTouchCancel = props.onTouchCancel,
          onTouchMove = props.onTouchMove,
          renderLabel = props.renderLabel;
      var _q = React.useContext(GlobalContext).locale,
          locale = _q === void 0 ? defaultLocale : _q;

      var _r = React.useState(disabled),
          disableState = _r[0],
          setDisableState = _r[1];

      var _s = React.useState(0),
          labelOffsetState = _s[0],
          setLabelOffsetState = _s[1];

      var containerRef = React.useRef(null);
      var loadingRef = React.useRef(null);
      var loadingLabelRef = React.useRef(null);
      var showLoadMoreRef = React.useRef(false);
      var ifToRightRef = React.useRef(false);
      var bouncingRef = React.useRef(false);
      var offsetRef = React.useRef(0);
      var domRef = React.useRef(null);
      var wrapperEl = domRef.current;
      useAddListener(wrapperEl, 'touchstart', onTouchStart);
      useAddListener(wrapperEl, 'touchend', onTouchEnd);
      useAddListener(wrapperEl, 'touchcancel', onTouchCancel);
      useAddListener(wrapperEl, 'touchmove', onTouchMove);
      React.useEffect(function () {
        var _a;

        if (disabled || !containerRef.current || disableState) {
          return;
        }

        var scrollContainer; // 对children类型进行判断
        // @en Judging the type of children

        if (containerRef.current.childNodes.length === 0) {
          // 未传入子元素 不启用组件
          // @en If no child element is passed in,  component will be disabled
          setDisableState(true);
        } else if (containerRef.current.childNodes.length === 1) {
          // 传入一个子元素 滑动单个元素
          // @en Pass in a child element swipe the single element
          scrollContainer = (_a = getScrollContainer === null || getScrollContainer === void 0 ? void 0 : getScrollContainer()) !== null && _a !== void 0 ? _a : containerRef.current.firstChild;
        } else {
          // 传入多个子元素(列表元素为例) 组件控制自行滑动 不推荐
          // @en Pass in multiple sub-elements (list elements as an example) Component control slides by itself which is not recommended
          scrollContainer = containerRef.current;
          scrollContainer.style.width = '100%';
          scrollContainer.style.overflowX = 'scroll';
          scrollContainer.style.display = 'inline-flex';
          scrollContainer.style.webkitOverflowScrolling = 'touch';
        }

        if (!scrollContainer) {
          return;
        }

        var loadingCurrent = loadingRef.current;
        var loadingLabelCurrent = loadingLabelRef.current;

        if (!loadingCurrent) {
          return;
        }

        var bounceScrollContainer = (getBounceContainer === null || getBounceContainer === void 0 ? void 0 : getBounceContainer()) || scrollContainer; // 初始不显示标签
        // @en Initially no labels are displayed

        loadingCurrent.style.display = 'none';
        var startX = 0;
        var endX = 0;
        var bounceDistance = 0; // 触摸页面确定X起始坐标
        // @en Determine the X starting coordinate on touchstart

        var touchstart = function touchstart(e) {
          var evt = e.touches[0];
          startX = evt.clientX || 0;
        }; // 页面滑动确定X终止坐标，更新手指的X坐标，改变loading中的文字和大小
        // @en Determine the X end coordinate, update the X coordinate of the finger, change the text and size in the loading on touchmove


        var touchmove = function touchmove(e) {
          // 判断元素是否属于滚动元素 先置为1 之后变成0表示非滚动容器
          // @en Determine whether the element belongs to a scrolling element. Set it to 1 and then change to 0 to indicate a non-scrolling container
          if (!scrollContainer.scrollLeft) {
            scrollContainer.scrollLeft = 1;
          }

          endX = e.touches[0].clientX || 0;
          var diff = endX - startX;
          offsetRef.current = diff;
          var labelDiff = fingerDisToLabelDis(Math.abs(diff), damping); // 滑动到最左侧，处理回弹效果
          // @en Swipe to the far left to handle the rebound effect

          if (diff > 0 && scrollContainer.scrollLeft <= 1 && bounceWhenBumpBoundary) {
            e.stopPropagation();
            e.cancelBubble && e.preventDefault();
            bouncingRef.current = true;

            var processor = bounceDistanceProcessor || function (dis) {
              return Math.min(dis, bounceScrollContainer.offsetWidth) / bounceDampRate;
            };

            bounceDistance = processor(diff);
            setStyleWithVendor(bounceScrollContainer, {
              transition: 'none',
              transform: "translateX(" + bounceDistance + "px) translateZ(0)"
            });
          } // 向左滑动到尽头 '更多'标签加载 根据scrollLeft判断 滚动容器到达边缘触发 非滚动容器不判断
          // @en Swipe left to the end and the 'more' label is loaded. Judging by scrollLeft, the scroll container reaches the edge and the non-scroll container does not judge


          if (diff < 0 && (scrollContainer.scrollLeft + scrollContainer.clientWidth >= scrollContainer.scrollWidth - 1 || !scrollContainer.scrollLeft) && !ifToRightRef.current) {
            showLoadMoreRef.current = true;
            loadingCurrent.style.display = 'flex';
          } // 继续滑动露出标签
          // @en Continue swiping to reveal labels


          if (showLoadMoreRef.current && diff < 0) {
            // 此时禁止list原生滚动
            // @en Disable list native scrolling at this time
            e.stopPropagation();
            e.cancelable && e.preventDefault(); // list元素平移最大 maxElementOffset
            // @en Maximum list element translation, maxElementOffset

            var listRightMargin = labelDiff > maxElementOffset ? maxElementOffset : labelDiff; // 标签的平移最大为40px(半圆)
            // @en The translation of the label is up to 40px (semi-circle)

            var labelRightMargin = labelDiff > maxLabelOffset ? maxLabelOffset : labelDiff;
            setLabelOffsetState(labelRightMargin); // 标签全部展示 字样改变
            // @en All labels are displayed and the text style is changed

            if (loadingLabelCurrent) {
              loadingLabelCurrent.innerHTML = labelDiff >= minConfirmOffset ? activeText || locale.SwipeLoad.activeText : normalText || locale.SwipeLoad.normalText;
            }

            setStyleWithVendor(loadingCurrent, {
              transition: 'none',
              transform: "translateX(-" + labelRightMargin + "px) translateZ(0)"
            });
            setStyleWithVendor(scrollContainer, {
              transition: 'none',
              transform: "translateX(-" + listRightMargin + "px) translateZ(0)"
            });
          }

          if (diff > 0 && scrollContainer.scrollLeft + scrollContainer.clientWidth <= scrollContainer.scrollWidth - 1) {
            showLoadMoreRef.current = false;
            loadingCurrent.style.display = 'none';
          } // 针对ios惯性滚动处理
          // @en Handling inertial scrolling for ios


          if (diff < 0 && scrollContainer.scrollLeft + scrollContainer.clientWidth <= scrollContainer.scrollWidth - 1) {
            ifToRightRef.current = false;
          } else {
            ifToRightRef.current = true;
          }
        }; // 露出标签 反方向滑动隐藏'更多'标签
        // @en Reveal the label,  swipe in opposite direction to hide 'more' tab


        var touchend = function touchend() {
          var diff = endX - startX;
          offsetRef.current = diff;
          var labelDiff = fingerDisToLabelDis(Math.abs(diff));

          var resumeAnimation = function resumeAnimation() {
            if (showLoadMoreRef.current) {
              showLoadMoreRef.current = false;
              var scrollTransitionCssStyle = "all " + labelAnimationDuration + "ms " + labelAnimationFunction;
              var scrollTransformCssStyle = 'translateX(0px) translateZ(0)';
              setStyleWithVendor(scrollContainer, {
                transition: scrollTransitionCssStyle,
                transform: scrollTransformCssStyle
              });
              setStyleWithVendor(loadingCurrent, {
                transition: scrollTransitionCssStyle,
                transform: scrollTransformCssStyle
              });
            }

            if (bouncingRef.current) {
              bouncingRef.current = false;
              setStyleWithVendor(bounceScrollContainer, {
                transition: "all " + bounceAnimateDuration + "ms",
                transform: 'translateX(0px) translateZ(0)'
              });
            }

            ifToRightRef.current = false;
            setTimeout(function () {
              loadingCurrent.style.display = 'none';
            }, labelAnimationDuration);
          }; // 向左滑动 标签已经全部展示
          // @em Swipe left,  labels are all displayed


          if (labelDiff >= minConfirmOffset && (scrollContainer.scrollLeft + scrollContainer.clientWidth >= scrollContainer.scrollWidth - 1 || !scrollContainer.scrollLeft) && showLoadMoreRef.current) {
            onConfirm(); // 安卓机型返回动画优化
            // @en Return animation optimization on Android

            setTimeout(function () {
              resumeAnimation();
            }, 250);
            return;
          }

          resumeAnimation();
        };

        scrollContainer.addEventListener('touchstart', touchstart);
        scrollContainer.addEventListener('touchmove', touchmove);
        scrollContainer.addEventListener('touchend', touchend);
        return function () {
          scrollContainer.removeEventListener('touchstart', touchstart);
          scrollContainer.removeEventListener('touchmove', touchmove);
          scrollContainer.removeEventListener('touchend', touchend);
        };
      }, [disabled, getScrollContainer, getBounceContainer, bounceWhenBumpBoundary, bounceDampRate, bounceAnimateDuration]);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-swipe-load " + className,
          ref: domRef
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-list-area"),
          ref: containerRef
        }, children), renderLabel ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-custom-loading-area"),
          ref: loadingRef,
          style: {
            position: 'absolute',
            right: initPos + "px"
          }
        }, renderLabel.length ? renderLabel(labelOffsetState) : renderLabel()) : /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-loading-area"),
          ref: loadingRef,
          style: {
            width: circleSize + "px",
            height: circleSize + "px",
            position: 'absolute',
            right: "-" + circleSize + "px"
          }
        }, /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-loading-label"),
          ref: loadingLabelRef
        })));
      });
    });

    var Switch = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var useRtl = React.useContext(GlobalContext).useRtl;
      var system = useSystem();
      var className = props.className,
          style = props.style,
          _a = props.platform,
          platform = _a === void 0 ? system : _a,
          checked = props.checked,
          _b = props.disabled,
          disabled = _b === void 0 ? false : _b,
          _c = props.defaultChecked,
          defaultChecked = _c === void 0 ? false : _c,
          text = props.text,
          _d = props.shape,
          shape = _d === void 0 ? 'fully' : _d,
          innerArea = props.innerArea,
          onChange = props.onChange,
          onTouchStart = props.onTouchStart,
          onTouchEnd = props.onTouchEnd,
          onClick = props.onClick;

      var _e = React.useState(0),
          touchStartX = _e[0],
          setTouchStartX = _e[1];

      var initChecked = false;

      if ('checked' in props) {
        initChecked = Boolean(checked);
      } else {
        initChecked = defaultChecked;
      }

      var _f = React.useState(initChecked),
          switchChecked = _f[0],
          setSwitchChecked = _f[1];

      var domRef = React.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });
      React.useEffect(function () {
        if ('checked' in props) {
          setSwitchChecked(Boolean(checked));
        }
      }, [checked]);

      function handleTouchStart(e) {
        onTouchStart && onTouchStart(e);

        if (disabled) {
          return;
        }

        var startX = e.touches && e.touches[0] ? e.touches[0].clientX : 0;
        setTouchStartX(startX);
      }

      function handleTouchEnd(e) {
        onTouchEnd && onTouchEnd(e);

        if (disabled) {
          return;
        }

        var touchEndX = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : 0;
        var distance = touchEndX - touchStartX;
        var swipeRight = useRtl ? distance < 0 : distance > 0;
        var swipeLeft = useRtl ? distance > 0 : distance < 0;
        var newChecked = false; // 右滑打开
        // @en Swipe right to open

        if (swipeRight) {
          newChecked = true; // 左滑关闭
          // @en Swipe left to close
        } else if (swipeLeft) {
          newChecked = false; // 点击时取反
          // @en Invert on clicking
        } else {
          newChecked = !switchChecked;
        }

        if (!('checked' in props)) {
          setSwitchChecked(newChecked);
        }

        if (onChange) {
          onChange(newChecked);
        }
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          role: "switch",
          "aria-checked": switchChecked,
          "aria-disabled": disabled,
          tabIndex: 0,
          ref: domRef,
          className: cls(prefixCls + "-switch all-border-box", className, "type-" + platform, "system-" + system, shape, {
            checked: switchChecked,
            disabled: disabled
          }),
          style: style,
          onTouchStart: handleTouchStart,
          onTouchEnd: handleTouchEnd,
          onClick: onClick
        }, text ? /*#__PURE__*/React__default["default"].createElement("span", {
          className: prefixCls + "-switch-text"
        }, switchChecked ? text.off || '' : text.on || '') : null, /*#__PURE__*/React__default["default"].createElement("div", {
          className: prefixCls + "-switch-inner"
        }, innerArea || null));
      });
    });
    /**
     * 开关组件，支持点击和滑动触发开关动作。
     * @en A switch component that supports click and slide trigger switch actions.
     * @type 数据录入
     * @type_en Data Entry
     * @name 开关
     * @name_en Switch
     * @displayName Switch
     */

    var index$3 = componentWrapper(Switch, 'Switch');

    var TabBarContext = /*#__PURE__*/React.createContext({
      changeIndex: function changeIndex() {},
      active: false,
      index: 0,
      activeCustomStyle: {}
    });
    function componentGenerator$1(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var _a = props.defaultActiveIndex,
            defaultActiveIndex = _a === void 0 ? 0 : _a,
            activeIndexProps = props.activeIndex,
            className = props.className,
            _b = props.fixed,
            fixed = _b === void 0 ? true : _b,
            style = props.style,
            dataSource = props.dataSource,
            children = props.children,
            onChange = props.onChange,
            activeCustomStyle = props.activeCustomStyle;

        var _c = React.useState(defaultActiveIndex),
            innerIndex = _c[0],
            setInnerIndex = _c[1];

        var _d = useRefState(activeIndexProps === void 0 ? innerIndex : activeIndexProps),
            activeIndex = _d[0],
            activeRefIndex = _d[1],
            setActiveIndex = _d[2];

        React.useEffect(function () {
          setActiveIndex(activeIndexProps === void 0 ? innerIndex : activeIndexProps);
        }, [activeIndexProps, innerIndex]);
        var domRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current,
            changeIndex: changeIndex
          };
        });
        var renderItem = React.useCallback(function (child, index) {
          return /*#__PURE__*/React__default["default"].createElement(TabBarContext.Provider, {
            value: {
              active: index === activeIndex,
              changeIndex: changeIndex,
              index: index,
              activeCustomStyle: activeCustomStyle
            },
            key: index
          }, child);
        }, [activeIndex]);

        function changeIndex(index) {
          setInnerIndex(index);
          index !== activeRefIndex.current && (onChange === null || onChange === void 0 ? void 0 : onChange(index));
        }

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var _b;

          var prefixCls = _a.prefixCls;
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefixCls + "-tab-bar", className, (_b = {}, _b[prefixCls + "-tab-bar-fixed"] = fixed, _b)),
            style: style,
            ref: domRef
          }, dataSource ? dataSource.map(function (data, index) {
            return renderItem( /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
              key: index
            }, data)), index);
          }) : React.Children.toArray(children).map(function (child, index) {
            return renderItem(child, index);
          }));
        });
      });
    }

    var Item = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _a = React.useContext(TabBarContext),
          active = _a.active,
          changeIndex = _a.changeIndex,
          index = _a.index,
          activeCustomStyle = _a.activeCustomStyle;

      var onClick = props.onClick,
          className = props.className,
          style = props.style;
      var domRef = React.useRef(null);

      function renderContent(prefixCls) {
        var _a;

        var iconElm = props.icon ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-tab-bar-item-icon")
        }, typeof props.icon === 'function' ? props.icon(active) : props.icon) : null;
        var titleElm = props.title ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-tab-bar-item-title", (_a = {}, _a[prefixCls + "-tab-bar-item-only-title"] = !iconElm, _a))
        }, typeof props.title === 'function' ? props.title(active) : props.title) : null;
        var extraElm = props.extra && typeof props.extra === 'function' ? props.extra(active) : props.extra;
        var childElm = props.child && /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-tab-bar-item-children")
        }, typeof props.child === 'function' ? props.child(active) : props.child);
        var extraWrap = iconElm || extraElm ? /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-extra-wrap")
        }, iconElm, extraElm) : null;
        return childElm || /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, extraWrap, titleElm);
      }

      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      var handleClick = function handleClick(e) {
        onClick === null || onClick === void 0 ? void 0 : onClick(e);
        changeIndex(index);
      };

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var _b;

        var prefixCls = _a.prefixCls;
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefixCls + "-tab-bar-item", (_b = {}, _b[prefixCls + "-tab-bar-item-active"] = active, _b), className),
          style: __assign$2(__assign$2({}, style), active ? activeCustomStyle : {}),
          ref: domRef,
          onClick: function onClick(e) {
            return handleClick(e);
          }
        }, renderContent(prefixCls));
      });
    });

    var TabBar = componentGenerator$1(Item);
    /**
     * 标签栏组件，Tabs 的简化版，仅支持标签切换
     * @en TabBar component, a simplified version of Tabs, only supports tab switching.
     * @type 导航
     * @type_en Navigation
     * @name 标签栏
     * @name_en TabBar
     */

    var index$2 = componentWrapper(TabBar, {
      Item: Item
    });

    var Tag = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var className = props.className,
          style = props.style,
          _a = props.type,
          type = _a === void 0 ? 'primary' : _a,
          icon = props.icon,
          children = props.children,
          _b = props.size,
          size = _b === void 0 ? 'medium' : _b,
          color = props.color,
          bgColor = props.bgColor,
          borderColor = props.borderColor,
          _c = props.borderStyle,
          borderStyle = _c === void 0 ? 'solid' : _c,
          _d = props.halfBorder,
          halfBorder = _d === void 0 ? true : _d,
          closeable = props.closeable,
          closeIcon = props.closeIcon,
          closeColor = props.closeColor,
          filleted = props.filleted,
          onClose = props.onClose,
          onClick = props.onClick;
      var domRef = React.useRef(null);
      var system = useSystem();
      React.useImperativeHandle(ref, function () {
        return {
          dom: domRef.current
        };
      });

      function getTagStyle() {
        return __assign$2({
          color: color,
          background: bgColor,
          borderColor: borderColor,
          borderStyle: borderStyle
        }, style || {});
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-tag";
        return /*#__PURE__*/React__default["default"].createElement("div", {
          className: cls(prefix, 'all-border-box', className, prefix + "-" + type, {
            'half-border': halfBorder
          }, system, "size-" + size, {
            filleted: filleted
          }),
          style: getTagStyle(),
          ref: domRef,
          onClick: onClick
        }, icon, /*#__PURE__*/React__default["default"].createElement("span", {
          className: "tag-text"
        }, children), closeable ? /*#__PURE__*/React__default["default"].createElement("div", {
          onClick: function onClick(e) {
            e.stopPropagation();
            onClose && onClose(e);
          },
          className: "tag-close-wrap"
        }, closeIcon || /*#__PURE__*/React__default["default"].createElement(IconClose, {
          className: "tag-close-icon",
          color: closeColor
        })) : null);
      });
    });

    function componentGenerator(Comp) {
      return /*#__PURE__*/React.forwardRef(function (props, ref) {
        var className = props.className,
            style = props.style,
            list = props.list,
            type = props.type,
            _a = props.showAddButton,
            showAddButton = _a === void 0 ? true : _a,
            addArea = props.addArea,
            horizontalPadding = props.horizontalPadding,
            verticalPadding = props.verticalPadding,
            onAdd = props.onAdd,
            _onClose = props.onClose;
        var domRef = React.useRef(null);
        React.useImperativeHandle(ref, function () {
          return {
            dom: domRef.current
          };
        });

        function getTagStyle(tag, index) {
          var baseStyle = tag.style || {};
          var paddingStyle = index === list.length - 1 && !showAddButton ? {} : {
            marginRight: horizontalPadding
          };
          return __assign$2(__assign$2(__assign$2({}, baseStyle), paddingStyle), {
            marginBottom: verticalPadding
          });
        }

        function getListStyle() {
          var marginStyle = {};

          if (verticalPadding && typeof verticalPadding === 'string') {
            marginStyle = {
              marginBottom: "-" + verticalPadding
            };
          } else if (verticalPadding && typeof verticalPadding === 'number') {
            marginStyle = {
              marginBottom: -1 * verticalPadding
            };
          }

          return __assign$2(__assign$2({}, style || {}), marginStyle);
        }

        return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, function (_a) {
          var prefixCls = _a.prefixCls,
              locale = _a.locale;
          var prefix = prefixCls + "-tag-list";
          return /*#__PURE__*/React__default["default"].createElement("div", {
            className: cls(prefix, className),
            style: getListStyle(),
            ref: domRef
          }, list.map(function (tag, index) {
            return /*#__PURE__*/React__default["default"].createElement(Comp, __assign$2({
              key: index
            }, tag, {
              style: getTagStyle(tag, index),
              type: type,
              onClose: function onClose(e) {
                tag.onClose && tag.onClose(e);
                _onClose && _onClose(index, e);
              }
            }));
          }), showAddButton ? /*#__PURE__*/React__default["default"].createElement("div", {
            className: "tag-list-add-wrap",
            onClick: onAdd
          }, addArea !== void 0 ? addArea : /*#__PURE__*/React__default["default"].createElement(Tag, {
            type: type,
            className: "tag-list-add",
            borderStyle: "dashed",
            icon: /*#__PURE__*/React__default["default"].createElement(IconAdd, null),
            style: {
              marginBottom: verticalPadding
            }
          }, locale === null || locale === void 0 ? void 0 : locale.Tag.addTag)) : null);
        });
      });
    }

    /**
     * 标签列表，支持动态编辑标签
     * @en Tag list, support dynamic editing of tags
     */

    var List = componentGenerator(Tag);
    /**
     * 标签组件，支持标签和标签组。
     * @en Tag component, supports tags and tag groups.
     * @type 信息展示
     * @type_en Data Display
     * @name 标签
     * @name_en Tag
     */

    var index$1 = componentWrapper(Tag, {
      List: List
    });

    var Textarea = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var id = props.id,
          name = props.name,
          rows = props.rows,
          placeholder = props.placeholder,
          readOnly = props.readOnly,
          onKeyUp = props.onKeyUp,
          onKeyPress = props.onKeyPress,
          disabled = props.disabled,
          autosize = props.autosize,
          cloneNodeWhenAutosize = props.cloneNodeWhenAutosize,
          _a = props.showStatistics,
          showStatistics = _a === void 0 ? true : _a,
          statisticsMaxlength = props.statisticsMaxlength,
          statisticsLengthCaculator = props.statisticsLengthCaculator,
          onErrStatusChange = props.onErrStatusChange,
          onErrValueChange = props.onErrValueChange,
          renderStatistics = props.renderStatistics,
          maxLength = props.maxLength,
          textareaClass = props.textareaClass,
          textareaStyle = props.textareaStyle,
          _b = props.nativeProps,
          nativeProps = _b === void 0 ? {} : _b;
      var textareaRef = React.useRef(null);
      var cloneNodeRef = React.useRef(null);

      var _c = useInputLogic(props, textareaRef),
          inputValue = _c.inputValue,
          handleClick = _c.handleClick,
          handleChange = _c.handleChange,
          handleInput = _c.handleInput,
          handleKeyDown = _c.handleKeyDown,
          handleFocus = _c.handleFocus,
          handleBlur = _c.handleBlur,
          renderWrapper = _c.renderWrapper,
          wrapRef = _c.wrapRef;

      var maxValueLength = statisticsMaxlength || maxLength;
      var currentValueLength = React.useMemo(function () {
        if (statisticsLengthCaculator) {
          return statisticsLengthCaculator(inputValue);
        } // 默认为过滤换行后的字符长度
        // @en The default is the character length after filtering newlines


        var validValue = (inputValue || '').replace(/\n/g, '');
        return validValue ? String(validValue).length : 0;
      }, [inputValue, statisticsLengthCaculator]);
      var exceed = maxValueLength ? currentValueLength > maxValueLength : false;
      React.useImperativeHandle(ref, function () {
        return {
          dom: wrapRef.current,
          textarea: textareaRef.current,
          resize: resizeTextarea
        };
      }, [resizeTextarea]);
      React.useEffect(function () {
        return function () {
          cloneNodeRef.current && document.body.removeChild(cloneNodeRef.current);
        };
      }, []);
      React.useEffect(function () {
        resizeTextarea();
      }, [inputValue, placeholder]);
      React.useEffect(function () {
        onErrStatusChange && onErrStatusChange(exceed);
      }, [exceed]);
      React.useEffect(function () {
        onErrValueChange && onErrValueChange(exceed, currentValueLength, maxValueLength);
      }, [maxValueLength, currentValueLength]);

      function resizeTextarea() {
        if (!autosize || !textareaRef.current) {
          return;
        }

        var currentRef = textareaRef.current;

        if (cloneNodeWhenAutosize) {
          var cloneNode_1 = textareaRef.current.cloneNode(true);

          if (cloneNodeRef.current) {
            document.body.replaceChild(cloneNode_1, cloneNodeRef.current);
          } else {
            document.body.appendChild(cloneNode_1);
          }

          var computedStyle_1 = window.getComputedStyle(textareaRef.current); // 影响布局的css属性复制
          // @en Copy css properties which affect layout

          ['width', 'fontSize', 'lineHeight', 'letterSpacing', 'wordSpacing'].forEach(function (styleKey) {
            cloneNode_1.style[styleKey] = computedStyle_1[styleKey];
          });
          cloneNode_1.classList.add('fake-textarea');
          cloneNodeRef.current = cloneNode_1;
          currentRef = cloneNode_1;
        }

        currentRef.style.height = 'auto';
        var maxHeight = Math.max(currentRef.clientHeight, currentRef.scrollHeight);
        textareaRef.current.style.height = maxHeight + "px";
      }

      function renderTextarea(_a) {
        var prefixCls = _a.prefixCls;
        var prefix = prefixCls + "-input";
        return renderWrapper(prefix, "textarea " + (showStatistics ? 'has-stat' : ''), /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("textarea", __assign$2({}, nativeProps, {
          id: id,
          name: name,
          rows: rows,
          placeholder: placeholder,
          readOnly: readOnly,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyUp: onKeyUp,
          onKeyPress: onKeyPress,
          ref: textareaRef,
          className: cls(prefixCls + "-textarea", textareaClass),
          style: textareaStyle,
          value: inputValue,
          maxLength: maxLength,
          disabled: disabled,
          onChange: handleChange,
          onInput: handleInput,
          onKeyDown: handleKeyDown,
          onClick: handleClick
        })), showStatistics && maxValueLength ? /*#__PURE__*/React__default["default"].createElement("span", {
          className: cls('statistic-text', {
            exceed: exceed
          })
        }, renderStatistics ? renderStatistics(currentValueLength, maxValueLength) : currentValueLength + "/" + maxValueLength) : null));
      }

      return /*#__PURE__*/React__default["default"].createElement(ContextLayout, null, renderTextarea);
    });
    /**
     * 多行文本输入框组件，支持自适应内容高度。
     * @en A multi-line textarea, supports adaptive content height.
     * @type 数据录入
     * @type_en Data Entry
     * @name 多行文本框
     * @name_en Textarea
     * @displayName Textarea
     */

    var index = componentWrapper(Textarea, 'Textarea');

    exports.ActionSheet = index$o;
    exports.Avatar = index$n;
    exports.Badge = Badge;
    exports.Button = Button;
    exports.Carousel = Carousel;
    exports.Cell = index$m;
    exports.Checkbox = Checkbox;
    exports.CircleProgress = CircleProgress;
    exports.Collapse = index$l;
    exports.ContextProvider = ContextProvider;
    exports.CountDown = CountDown;
    exports.DatePicker = index$k;
    exports.Dialog = index$j;
    exports.Divider = Divider;
    exports.Dropdown = Dropdown$1;
    exports.DropdownMenu = DropdownMenu;
    exports.Ellipsis = Ellipsis;
    exports.Form = index$h;
    exports.Grid = Grid;
    exports.Image = BaseImage;
    exports.ImagePicker = index$g;
    exports.ImagePreview = index$f;
    exports.IndexBar = index$e;
    exports.Input = index$d;
    exports.Keyboard = Keyboard;
    exports.LoadMore = LoadMore;
    exports.Loading = Loading;
    exports.Masking = Masking$1;
    exports.NavBar = NavBar;
    exports.NoticeBar = NoticeBar;
    exports.Notify = index$c;
    exports.Pagination = Pagination;
    exports.Picker = Picker$1;
    exports.PickerView = PickerView$1;
    exports.Popover = index$b;
    exports.Popup = Popup$1;
    exports.PopupSwiper = index$a;
    exports.Portal = Portal;
    exports.Progress = Progress;
    exports.PullRefresh = PullRefresh;
    exports.Radio = index$9;
    exports.Rate = index$8;
    exports.SearchBar = SearchBar;
    exports.ShowMonitor = ShowMonitor;
    exports.Skeleton = index$7;
    exports.Slider = index$6;
    exports.Stepper = index$5;
    exports.Steps = index$4;
    exports.Sticky = Sticky;
    exports.SwipeAction = SwipeAction;
    exports.SwipeLoad = SwipeLoad;
    exports.Switch = index$3;
    exports.TabBar = index$2;
    exports.Tabs = Tabs;
    exports.Tag = index$1;
    exports.Textarea = index;
    exports.Toast = index$p;
    exports.Transition = Transition;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
