{"version":3,"file":"ReactQuery.js","mappings":"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","sources":["webpack://ReactQuery/webpack/universalModuleDefinition","webpack://ReactQuery/./packages/react-query/src/HydrationBoundary.tsx","webpack://ReactQuery/./packages/react-query/src/QueryClientProvider.tsx","webpack://ReactQuery/./packages/react-query/src/QueryErrorResetBoundary.tsx","webpack://ReactQuery/./packages/react-query/src/errorBoundaryUtils.ts","webpack://ReactQuery/./packages/react-query/src/infiniteQueryOptions.ts","webpack://ReactQuery/./packages/react-query/src/isRestoring.ts","webpack://ReactQuery/./packages/react-query/src/queryOptions.ts","webpack://ReactQuery/./packages/react-query/src/suspense.ts","webpack://ReactQuery/./packages/react-query/src/useBaseQuery.ts","webpack://ReactQuery/./packages/react-query/src/useInfiniteQuery.ts","webpack://ReactQuery/./packages/react-query/src/useIsFetching.ts","webpack://ReactQuery/./packages/react-query/src/useMutation.ts","webpack://ReactQuery/./packages/react-query/src/useMutationState.ts","webpack://ReactQuery/./packages/react-query/src/useQueries.ts","webpack://ReactQuery/./packages/react-query/src/useQuery.ts","webpack://ReactQuery/./packages/react-query/src/useSuspenseInfiniteQuery.ts","webpack://ReactQuery/./packages/react-query/src/useSuspenseQueries.ts","webpack://ReactQuery/./packages/react-query/src/useSuspenseQuery.ts","webpack://ReactQuery/./packages/react-query/src/utils.ts","webpack://ReactQuery/external umd \"React\"","webpack://ReactQuery/external umd \"ReactQueryCore\"","webpack://ReactQuery/webpack/bootstrap","webpack://ReactQuery/webpack/runtime/compat get default export","webpack://ReactQuery/webpack/runtime/define property getters","webpack://ReactQuery/webpack/runtime/hasOwnProperty shorthand","webpack://ReactQuery/webpack/runtime/make namespace object","webpack://ReactQuery/./packages/react-query/src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"ReactQueryCore\"), require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"ReactQueryCore\", \"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactQuery\"] = factory(require(\"ReactQueryCore\"), require(\"React\"));\n\telse\n\t\troot[\"ReactQuery\"] = factory(root[\"ReactQueryCore\"], root[\"React\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__296__, __WEBPACK_EXTERNAL_MODULE__24__) => {\nreturn ","'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: Omit<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: Omit<HydrateOptions['defaultOptions'], 'mutations'>\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n  const [hydrationQueue, setHydrationQueue] = React.useState<\n    DehydratedState['queries'] | undefined\n  >()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it _must_\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== 'object') {\n        return\n      }\n\n      const queryCache = client.getQueryCache()\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const queries = (state as DehydratedState).queries || []\n\n      const newQueries: DehydratedState['queries'] = []\n      const existingQueries: DehydratedState['queries'] = []\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery)\n        } else {\n          const hydrationIsNewer =\n            dehydratedQuery.state.dataUpdatedAt >\n            existingQuery.state.dataUpdatedAt\n          const queryAlreadyQueued = hydrationQueue?.find(\n            (query) => query.queryHash === dehydratedQuery.queryHash,\n          )\n\n          if (\n            hydrationIsNewer &&\n            (!queryAlreadyQueued ||\n              dehydratedQuery.state.dataUpdatedAt >\n                queryAlreadyQueued.state.dataUpdatedAt)\n          ) {\n            existingQueries.push(dehydratedQuery)\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        // It's actually fine to call this with queries/state that already exists\n        // in the cache, or is older. hydrate() is idempotent for queries.\n        hydrate(client, { queries: newQueries }, optionsRef.current)\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue((prev) =>\n          prev ? [...prev, ...existingQueries] : existingQueries,\n        )\n      }\n    }\n  }, [client, hydrationQueue, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n      setHydrationQueue(undefined)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.throwOnError) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    shouldThrowError(throwOnError, [result.error, query])\n  )\n}\n","import type { DataTag } from '@tanstack/query-core'\nimport type { InfiniteData } from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './types'\nimport type { DefaultError, QueryKey } from '@tanstack/query-core'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?: undefined\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import type { DataTag, DefaultError, QueryKey } from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?: undefined\n}\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n","import type { DefaultError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => typeof query.state.data === 'undefined'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { UseBaseQueryOptions } from './types'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    // Do the same thing as the effect right above because the effect won't run\n    // when we suspend but also, the component won't re-mount so our observer would\n    // be out of date.\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseInfiniteQueryResult,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): DefinedUseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery(\n  options: UseInfiniteQueryOptions,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(\n    options,\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { MutationObserver, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>,\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>,\n            )\n          : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>()\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n","'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'suspense'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, any>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesOptions<\n            [...Tail],\n            [...Result, GetOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesResults<\n            [...Tail],\n            [...Result, GetResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseQueryResult>\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(opts)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<TData, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n","'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type {\n  InfiniteQueryObserverSuccessResult,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n} from './types'\n\nexport function useSuspenseInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseSuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseSuspenseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as InfiniteQueryObserverSuccessResult<TData, TError>\n}\n","'use client'\nimport { useQueries } from './useQueries'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueryClient,\n  QueryFunction,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetSuspenseOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryOptions<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryOptions<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryOptions<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryOptions<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryOptions<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryOptions<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseSuspenseQueryOptions\n\ntype GetSuspenseResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseSuspenseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, any>\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetSuspenseOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? SuspenseQueriesOptions<\n            [...Tail],\n            [...Result, GetSuspenseOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseSuspenseQueryOptions<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n              >\n            : // Fallback\n              Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetSuspenseResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? SuspenseQueriesResults<\n            [...Tail],\n            [...Result, GetSuspenseResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseSuspenseQueryOptions<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseSuspenseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseSuspenseQueryResult>\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries: readonly [...SuspenseQueriesOptions<T>]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query) => ({\n        ...query,\n        suspense: true,\n        throwOnError: defaultThrowOnError,\n        enabled: true,\n      })),\n    } as any,\n    queryClient,\n  )\n}\n","'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseSuspenseQueryResult<TData, TError> {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    QueryObserver,\n    queryClient,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n","export function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwError function to override throwing behavior on a per-error basis\n  if (typeof throwError === 'function') {\n    return throwError(...params)\n  }\n\n  return !!throwError\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__24__;","module.exports = __WEBPACK_EXTERNAL_MODULE__296__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* istanbul ignore file */\n\n// Re-export core\nexport * from '@tanstack/query-core'\n\n// React Query\nexport * from './types'\nexport { useQueries } from './useQueries'\nexport type { QueriesResults, QueriesOptions } from './useQueries'\nexport { useQuery } from './useQuery'\nexport { useSuspenseQuery } from './useSuspenseQuery'\nexport { useSuspenseInfiniteQuery } from './useSuspenseInfiniteQuery'\nexport { useSuspenseQueries } from './useSuspenseQueries'\nexport type {\n  SuspenseQueriesResults,\n  SuspenseQueriesOptions,\n} from './useSuspenseQueries'\nexport { queryOptions } from './queryOptions'\nexport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\nexport { infiniteQueryOptions } from './infiniteQueryOptions'\nexport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\nexport {\n  QueryClientContext,\n  QueryClientProvider,\n  useQueryClient,\n} from './QueryClientProvider'\nexport type { QueryClientProviderProps } from './QueryClientProvider'\nexport type { QueryErrorResetBoundaryProps } from './QueryErrorResetBoundary'\nexport { HydrationBoundary } from './HydrationBoundary'\nexport type { HydrationBoundaryProps } from './HydrationBoundary'\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary,\n} from './QueryErrorResetBoundary'\nexport { useIsFetching } from './useIsFetching'\nexport { useIsMutating, useMutationState } from './useMutationState'\nexport { useMutation } from './useMutation'\nexport { useInfiniteQuery } from './useInfiniteQuery'\nexport { useIsRestoring, IsRestoringProvider } from './isRestoring'\n"],"names":[],"sourceRoot":""}