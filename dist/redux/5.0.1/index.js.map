{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;UCVA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA,MAAMA,YAAY,GAAG,eAAgB,CAAC,MACnC,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,UAAU,IAAK,cAAc,EAAC,CAAE;AAE1E,wDAAeF,YAAY;;ACT3B;;;;;;AAOA,MAAMG,YAAY,GAAGA,CAAA,KACnBC,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;AAE7D,MAAMC,uBAAW,GAAG;EAClBC,IAAI,EAAE,eAAe,eAAgBR,YAAY,EAAE,EAAE;EACrDS,OAAO,EAAE,kBAAkB,eAAgBT,YAAY,EAAE,EAAE;EAC3DU,oBAAoB,EAAEA,CAAA,KAAM,+BAA+BV,YAAY,EAAE;CAC1E;AAED,kDAAeO,uBAAW;;AChB1B;;;;AAIc,SAAUI,2BAAaA,CAACC,GAAQ;EAC5C,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE,OAAO,KAAK;EAEzD,IAAIC,KAAK,GAAGD,GAAG;EACf,OAAOE,MAAM,CAACC,cAAc,CAACF,KAAK,CAAC,KAAK,IAAI,EAAE;IAC5CA,KAAK,GAAGC,MAAM,CAACC,cAAc,CAACF,KAAK,CAAC;EACtC;EAEA,OACEC,MAAM,CAACC,cAAc,CAACH,GAAG,CAAC,KAAKC,KAAK,IAAIC,MAAM,CAACC,cAAc,CAACH,GAAG,CAAC,KAAK,IAAI;AAE/E;;ACfA;AACM,SAAUI,UAAUA,CAACC,GAAQ;EACjC,IAAIA,GAAG,KAAK,KAAK,CAAC,EAAE,OAAO,WAAW;EACtC,IAAIA,GAAG,KAAK,IAAI,EAAE,OAAO,MAAM;EAE/B,MAAMC,IAAI,GAAG,OAAOD,GAAG;EACvB,QAAQC,IAAI;IACV,KAAK,SAAS;IACd,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,UAAU;MAAE;QACf,OAAOA,IAAI;MACb;EACF;EAEA,IAAIC,KAAK,CAACC,OAAO,CAACH,GAAG,CAAC,EAAE,OAAO,OAAO;EACtC,IAAII,MAAM,CAACJ,GAAG,CAAC,EAAE,OAAO,MAAM;EAC9B,IAAIK,OAAO,CAACL,GAAG,CAAC,EAAE,OAAO,OAAO;EAEhC,MAAMM,eAAe,GAAGC,QAAQ,CAACP,GAAG,CAAC;EACrC,QAAQM,eAAe;IACrB,KAAK,QAAQ;IACb,KAAK,SAAS;IACd,KAAK,SAAS;IACd,KAAK,SAAS;IACd,KAAK,KAAK;IACV,KAAK,KAAK;MACR,OAAOA,eAAe;EAC1B;EAEA;EACA,OAAOT,MAAM,CAACW,SAAS,CAACtB,QAAQ,CAC7BuB,IAAI,CAACT,GAAG,CAAC,CACTU,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CACZC,WAAW,EAAE,CACbC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;AACvB;AAEA,SAASL,QAAQA,CAACP,GAAQ;EACxB,OAAO,OAAOA,GAAG,CAACa,WAAW,KAAK,UAAU,GAAGb,GAAG,CAACa,WAAW,CAACC,IAAI,GAAG,IAAI;AAC5E;AAEA,SAAST,OAAOA,CAACL,GAAQ;EACvB,OACEA,GAAG,YAAYe,KAAK,IACnB,OAAOf,GAAG,CAACgB,OAAO,KAAK,QAAQ,IAC9BhB,GAAG,CAACa,WAAW,IACf,OAAOb,GAAG,CAACa,WAAW,CAACI,eAAe,KAAK,QAAS;AAE1D;AAEA,SAASb,MAAMA,CAACJ,GAAQ;EACtB,IAAIA,GAAG,YAAYkB,IAAI,EAAE,OAAO,IAAI;EACpC,OACE,OAAOlB,GAAG,CAACmB,YAAY,KAAK,UAAU,IACtC,OAAOnB,GAAG,CAACoB,OAAO,KAAK,UAAU,IACjC,OAAOpB,GAAG,CAACqB,OAAO,KAAK,UAAU;AAErC;AAEM,SAAUC,aAAMA,CAACtB,GAAQ;EAC7B,IAAIuB,SAAS,GAAW,OAAOvB,GAAG;EAElC,IAAIwB,KAAqC,EAAE,EAE1C;EAED,OAAOD,SAAS;AAClB;;ACrEoD;AAYP;AACI;AACV;AAwEjC,SAAUI,WAAWA,CAOzBC,OAAsC,EACtCC,cAA0E,EAC1EC,QAAuC;EAEvC,IAAI,OAAOF,OAAO,KAAK,UAAU,EAAE;IACjC,MAAM,IAAIb,KAAK,CACb,mEAAmEO,aAAM,CACvEM,OAAO,CACR,GAAG,CACL;EACH;EAEA,IACG,OAAOC,cAAc,KAAK,UAAU,IAAI,OAAOC,QAAQ,KAAK,UAAU,IACtE,OAAOA,QAAQ,KAAK,UAAU,IAAI,OAAOC,SAAS,CAAC,CAAC,CAAC,KAAK,UAAW,EACtE;IACA,MAAM,IAAIhB,KAAK,CACb,2DAA2D,GACzD,8DAA8D,GAC9D,6IAA6I,CAChJ;EACH;EAEA,IAAI,OAAOc,cAAc,KAAK,UAAU,IAAI,OAAOC,QAAQ,KAAK,WAAW,EAAE;IAC3EA,QAAQ,GAAGD,cAA8C;IACzDA,cAAc,GAAGG,SAAS;EAC5B;EAEA,IAAI,OAAOF,QAAQ,KAAK,WAAW,EAAE;IACnC,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAIf,KAAK,CACb,+DAA+DO,aAAM,CACnEQ,QAAQ,CACT,GAAG,CACL;IACH;IAEA,OAAOA,QAAQ,CAACH,WAAW,CAAC,CAC1BC,OAAO,EACPC,cAA4C,CAC7C;EACH;EAEA,IAAII,cAAc,GAAGL,OAAO;EAC5B,IAAIM,YAAY,GAAmCL,cAEtC;EACb,IAAIM,gBAAgB,GAAyC,IAAIC,GAAG,EAAE;EACtE,IAAIC,aAAa,GAAGF,gBAAgB;EACpC,IAAIG,iBAAiB,GAAG,CAAC;EACzB,IAAIC,aAAa,GAAG,KAAK;EAEzB;;;;;;;EAOA,SAASC,4BAA4BA,CAAA;IACnC,IAAIH,aAAa,KAAKF,gBAAgB,EAAE;MACtCE,aAAa,GAAG,IAAID,GAAG,EAAE;MACzBD,gBAAgB,CAACM,OAAO,CAAC,CAACC,QAAQ,EAAEC,GAAG,KAAI;QACzCN,aAAa,CAACO,GAAG,CAACD,GAAG,EAAED,QAAQ,CAAC;MAClC,CAAC,CAAC;IACJ;EACF;EAEA;;;;;EAKA,SAASG,QAAQA,CAAA;IACf,IAAIN,aAAa,EAAE;MACjB,MAAM,IAAIxB,KAAK,CACb,oEAAoE,GAClE,6DAA6D,GAC7D,yEAAyE,CAC5E;IACH;IAEA,OAAOmB,YAAiB;EAC1B;EAEA;;;;;;;;;;;;;;;;;;;;;;;EAuBA,SAASY,SAASA,CAACJ,QAAoB;IACrC,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAI3B,KAAK,CACb,+DAA+DO,aAAM,CACnEoB,QAAQ,CACT,GAAG,CACL;IACH;IAEA,IAAIH,aAAa,EAAE;MACjB,MAAM,IAAIxB,KAAK,CACb,qEAAqE,GACnE,sFAAsF,GACtF,oFAAoF,GACpF,wEAAwE,CAC3E;IACH;IAEA,IAAIgC,YAAY,GAAG,IAAI;IAEvBP,4BAA4B,EAAE;IAC9B,MAAMQ,UAAU,GAAGV,iBAAiB,EAAE;IACtCD,aAAa,CAACO,GAAG,CAACI,UAAU,EAAEN,QAAQ,CAAC;IAEvC,OAAO,SAASO,WAAWA,CAAA;MACzB,IAAI,CAACF,YAAY,EAAE;QACjB;MACF;MAEA,IAAIR,aAAa,EAAE;QACjB,MAAM,IAAIxB,KAAK,CACb,gFAAgF,GAC9E,wEAAwE,CAC3E;MACH;MAEAgC,YAAY,GAAG,KAAK;MAEpBP,4BAA4B,EAAE;MAC9BH,aAAa,CAACa,MAAM,CAACF,UAAU,CAAC;MAChCb,gBAAgB,GAAG,IAAI;IACzB,CAAC;EACH;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;EAyBA,SAASgB,QAAQA,CAACC,MAAS;IACzB,IAAI,CAAC1D,2BAAa,CAAC0D,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIrC,KAAK,CACb,iEAAiEO,aAAM,CACrE8B,MAAM,CACP,4UAA4U,CAC9U;IACH;IAEA,IAAI,OAAOA,MAAM,CAACnD,IAAI,KAAK,WAAW,EAAE;MACtC,MAAM,IAAIc,KAAK,CACb,4GAA4G,CAC7G;IACH;IAEA,IAAI,OAAOqC,MAAM,CAACnD,IAAI,KAAK,QAAQ,EAAE;MACnC,MAAM,IAAIc,KAAK,CACb,2EAA2EO,aAAM,CAC/E8B,MAAM,CAACnD,IAAI,CACZ,kBAAkBmD,MAAM,CAACnD,IAAI,iBAAiB,CAChD;IACH;IAEA,IAAIsC,aAAa,EAAE;MACjB,MAAM,IAAIxB,KAAK,CAAC,oCAAoC,CAAC;IACvD;IAEA,IAAI;MACFwB,aAAa,GAAG,IAAI;MACpBL,YAAY,GAAGD,cAAc,CAACC,YAAY,EAAEkB,MAAM,CAAC;IACrD,CAAC,SAAS;MACRb,aAAa,GAAG,KAAK;IACvB;IAEA,MAAMc,SAAS,GAAIlB,gBAAgB,GAAGE,aAAc;IACpDgB,SAAS,CAACZ,OAAO,CAACC,QAAQ,IAAG;MAC3BA,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,OAAOU,MAAM;EACf;EAEA;;;;;;;;;EASA,SAASE,cAAcA,CAACC,WAA0B;IAChD,IAAI,OAAOA,WAAW,KAAK,UAAU,EAAE;MACrC,MAAM,IAAIxC,KAAK,CACb,kEAAkEO,aAAM,CACtEiC,WAAW,CACZ,EAAE,CACJ;IACH;IAEAtB,cAAc,GAAGsB,WAAuD;IAExE;IACA;IACA;IACA;IACAJ,QAAQ,CAAC;MAAElD,IAAI,EAAEX,WAAW,CAACE;IAAO,CAAO,CAAC;EAC9C;EAEA;;;;;;EAMA,SAASV,UAAUA,CAAA;IACjB,MAAM0E,cAAc,GAAGV,SAAS;IAChC,OAAO;MACL;;;;;;;;MAQAA,SAASA,CAACW,QAAiB;QACzB,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,IAAI,EAAE;UACrD,MAAM,IAAIC,SAAS,CACjB,8DAA8DpC,aAAM,CAClEmC,QAAQ,CACT,GAAG,CACL;QACH;QAEA,SAASE,YAAYA,CAAA;UACnB,MAAMC,kBAAkB,GAAGH,QAAuB;UAClD,IAAIG,kBAAkB,CAACC,IAAI,EAAE;YAC3BD,kBAAkB,CAACC,IAAI,CAAChB,QAAQ,EAAE,CAAC;UACrC;QACF;QAEAc,YAAY,EAAE;QACd,MAAMV,WAAW,GAAGO,cAAc,CAACG,YAAY,CAAC;QAChD,OAAO;UAAEV;QAAW,CAAE;MACxB,CAAC;MAED,CAACrE,iBAAY,IAAC;QACZ,OAAO,IAAI;MACb;KACD;EACH;EAEA;EACA;EACA;EACAuE,QAAQ,CAAC;IAAElD,IAAI,EAAEX,WAAW,CAACC;EAAI,CAAO,CAAC;EAEzC,MAAMuE,KAAK,GAAG;IACZX,QAAQ,EAAEA,QAAuB;IACjCL,SAAS;IACTD,QAAQ;IACRS,cAAc;IACd,CAAC1E,iBAAY,GAAGE;GACyB;EAC3C,OAAOgF,KAAK;AACd;AAkFM,SAAUC,kBAAkBA,CAOhCnC,OAAsB,EACtBC,cAA0E,EAC1EC,QAAuC;EAEvC,OAAOH,WAAW,CAACC,OAAO,EAAEC,cAAqB,EAAEC,QAAQ,CAAC;AAC9D;;ACje6C;AACI;AACZ;AACE;AAEvC,SAASmC,qCAAqCA,CAC5CC,UAAkB,EAClBC,QAAmD,EACnDf,MAAc,EACdgB,kBAA2C;EAE3C,MAAMC,WAAW,GAAGxE,MAAM,CAACyE,IAAI,CAACH,QAAQ,CAAC;EACzC,MAAMI,YAAY,GAChBnB,MAAM,IAAIA,MAAM,CAACnD,IAAI,KAAKX,WAAW,CAACC,IAAI,GACtC,+CAA+C,GAC/C,wCAAwC;EAE9C,IAAI8E,WAAW,CAACG,MAAM,KAAK,CAAC,EAAE;IAC5B,OACE,qEAAqE,GACrE,4DAA4D;EAEhE;EAEA,IAAI,CAAC9E,aAAa,CAACwE,UAAU,CAAC,EAAE;IAC9B,OACE,OAAOK,YAAY,4BAA4BjD,MAAM,CACnD4C,UAAU,CACX,0DAA0D,GAC3D,UAAUG,WAAW,CAAChF,IAAI,CAAC,MAAM,CAAC,GAAG;EAEzC;EAEA,MAAMoF,cAAc,GAAG5E,MAAM,CAACyE,IAAI,CAACJ,UAAU,CAAC,CAACQ,MAAM,CACnD/B,GAAG,IAAI,CAACwB,QAAQ,CAACQ,cAAc,CAAChC,GAAG,CAAC,IAAI,CAACyB,kBAAkB,CAACzB,GAAG,CAAC,CACjE;EAED8B,cAAc,CAAChC,OAAO,CAACE,GAAG,IAAG;IAC3ByB,kBAAkB,CAACzB,GAAG,CAAC,GAAG,IAAI;EAChC,CAAC,CAAC;EAEF,IAAIS,MAAM,IAAIA,MAAM,CAACnD,IAAI,KAAKX,WAAW,CAACE,OAAO,EAAE;EAEnD,IAAIiF,cAAc,CAACD,MAAM,GAAG,CAAC,EAAE;IAC7B,OACE,cAAcC,cAAc,CAACD,MAAM,GAAG,CAAC,GAAG,MAAM,GAAG,KAAK,GAAG,GAC3D,IAAIC,cAAc,CAACpF,IAAI,CAAC,MAAM,CAAC,cAAckF,YAAY,IAAI,GAC7D,0DAA0D,GAC1D,IAAIF,WAAW,CAAChF,IAAI,CAAC,MAAM,CAAC,qCAAqC;EAErE;AACF;AAEA,SAASuF,kBAAkBA,CAACT,QAE3B;EACCtE,MAAM,CAACyE,IAAI,CAACH,QAAQ,CAAC,CAAC1B,OAAO,CAACE,GAAG,IAAG;IAClC,MAAMf,OAAO,GAAGuC,QAAQ,CAACxB,GAAG,CAAC;IAC7B,MAAMkC,YAAY,GAAGjD,OAAO,CAACI,SAAS,EAAE;MAAE/B,IAAI,EAAEX,WAAW,CAACC;IAAI,CAAE,CAAC;IAEnE,IAAI,OAAOsF,YAAY,KAAK,WAAW,EAAE;MACvC,MAAM,IAAI9D,KAAK,CACb,8BAA8B4B,GAAG,8CAA8C,GAC7E,4DAA4D,GAC5D,6DAA6D,GAC7D,uEAAuE,GACvE,wCAAwC,CAC3C;IACH;IAEA,IACE,OAAOf,OAAO,CAACI,SAAS,EAAE;MACxB/B,IAAI,EAAEX,WAAW,CAACG,oBAAoB;KACvC,CAAC,KAAK,WAAW,EAClB;MACA,MAAM,IAAIsB,KAAK,CACb,8BAA8B4B,GAAG,uDAAuD,GACtF,wBAAwBrD,WAAW,CAACC,IAAI,kCAAkC,GAC1E,uEAAuE,GACvE,iEAAiE,GACjE,qEAAqE,GACrE,uEAAuE,CAC1E;IACH;EACF,CAAC,CAAC;AACJ;AA6Bc,SAAUuF,eAAeA,CAACX,QAEvC;EACC,MAAME,WAAW,GAAGxE,MAAM,CAACyE,IAAI,CAACH,QAAQ,CAAC;EACzC,MAAMY,aAAa,GAA8C,EAAE;EACnE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,WAAW,CAACG,MAAM,EAAEQ,CAAC,EAAE,EAAE;IAC3C,MAAMrC,GAAG,GAAG0B,WAAW,CAACW,CAAC,CAAC;IAE1B,IAAIxD,KAAqC,EAAE,EAI1C;IAED,IAAI,OAAO2C,QAAQ,CAACxB,GAAG,CAAC,KAAK,UAAU,EAAE;MACvCoC,aAAa,CAACpC,GAAG,CAAC,GAAGwB,QAAQ,CAACxB,GAAG,CAAC;IACpC;EACF;EACA,MAAMsC,gBAAgB,GAAGpF,MAAM,CAACyE,IAAI,CAACS,aAAa,CAAC;EAEnD;EACA;EACA,IAAIX,kBAA2C;EAC/C,IAAI5C,KAAqC,EAAE,EAE1C;EAED,IAAI0D,mBAA4B;EAChC,IAAI;IACFN,kBAAkB,CAACG,aAAa,CAAC;EACnC,CAAC,CAAC,OAAOI,CAAC,EAAE;IACVD,mBAAmB,GAAGC,CAAC;EACzB;EAEA,OAAO,SAASC,WAAWA,CACzBC,KAAA,GAAqD,EAAE,EACvDjC,MAAc;IAEd,IAAI8B,mBAAmB,EAAE;MACvB,MAAMA,mBAAmB;IAC3B;IAEA,IAAI1D,KAAqC,EAAE,EAU1C;IAED,IAAI+D,UAAU,GAAG,KAAK;IACtB,MAAMC,SAAS,GAAgD,EAAE;IACjE,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,gBAAgB,CAACT,MAAM,EAAEQ,CAAC,EAAE,EAAE;MAChD,MAAMrC,GAAG,GAAGsC,gBAAgB,CAACD,CAAC,CAAC;MAC/B,MAAMpD,OAAO,GAAGmD,aAAa,CAACpC,GAAG,CAAC;MAClC,MAAM8C,mBAAmB,GAAGJ,KAAK,CAAC1C,GAAG,CAAC;MACtC,MAAM+C,eAAe,GAAG9D,OAAO,CAAC6D,mBAAmB,EAAErC,MAAM,CAAC;MAC5D,IAAI,OAAOsC,eAAe,KAAK,WAAW,EAAE;QAC1C,MAAMC,UAAU,GAAGvC,MAAM,IAAIA,MAAM,CAACnD,IAAI;QACxC,MAAM,IAAIc,KAAK,CACb,sCACE4E,UAAU,GAAG,IAAIC,MAAM,CAACD,UAAU,CAAC,GAAG,GAAG,gBAC3C,gCAAgChD,GAAG,wBAAwB,GACzD,sEAAsE,GACtE,sFAAsF,CACzF;MACH;MACA6C,SAAS,CAAC7C,GAAG,CAAC,GAAG+C,eAAe;MAChCH,UAAU,GAAGA,UAAU,IAAIG,eAAe,KAAKD,mBAAmB;IACpE;IACAF,UAAU,GACRA,UAAU,IAAIN,gBAAgB,CAACT,MAAM,KAAK3E,MAAM,CAACyE,IAAI,CAACe,KAAK,CAAC,CAACb,MAAM;IACrE,OAAOe,UAAU,GAAGC,SAAS,GAAGH,KAAK;EACvC,CAAC;AACH;;ACtMuC;AAEvC,SAASQ,iBAAiBA,CACxBC,aAA+B,EAC/B3C,QAAqB;EAErB,OAAO,UAAqB,GAAG4C,IAAW;IACxC,OAAO5C,QAAQ,CAAC2C,aAAa,CAACE,KAAK,CAAC,IAAI,EAAED,IAAI,CAAC,CAAC;EAClD,CAAC;AACH;AA0Cc,SAAUE,kBAAkBA,CACxCC,cAA4D,EAC5D/C,QAAkB;EAElB,IAAI,OAAO+C,cAAc,KAAK,UAAU,EAAE;IACxC,OAAOL,iBAAiB,CAACK,cAAc,EAAE/C,QAAQ,CAAC;EACpD;EAEA,IAAI,OAAO+C,cAAc,KAAK,QAAQ,IAAIA,cAAc,KAAK,IAAI,EAAE;IACjE,MAAM,IAAInF,KAAK,CACb,+EAA+EO,aAAM,CACnF4E,cAAc,CACf,KAAK,GACJ,0FAA0F,CAC7F;EACH;EAEA,MAAMC,mBAAmB,GAA4B,EAAE;EACvD,KAAK,MAAMxD,GAAG,IAAIuD,cAAc,EAAE;IAChC,MAAMJ,aAAa,GAAGI,cAAc,CAACvD,GAAG,CAAC;IACzC,IAAI,OAAOmD,aAAa,KAAK,UAAU,EAAE;MACvCK,mBAAmB,CAACxD,GAAG,CAAC,GAAGkD,iBAAiB,CAACC,aAAa,EAAE3C,QAAQ,CAAC;IACvE;EACF;EACA,OAAOgD,mBAAmB;AAC5B;;ACjCc,SAAUC,OAAOA,CAAC,GAAGC,KAAiB;EAClD,IAAIA,KAAK,CAAC7B,MAAM,KAAK,CAAC,EAAE;IACtB;IACA,OAAW8B,GAAM,IAAKA,GAAG;EAC3B;EAEA,IAAID,KAAK,CAAC7B,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO6B,KAAK,CAAC,CAAC,CAAC;EACjB;EAEA,OAAOA,KAAK,CAACE,MAAM,CACjB,CAACC,CAAC,EAAEC,CAAC,KACH,CAAC,GAAGV,IAAS,KACXS,CAAC,CAACC,CAAC,CAAC,GAAGV,IAAI,CAAC,CAAC,CAClB;AACH;;AC5D+B;AAoDjB,SAAUW,eAAeA,CACrC,GAAGC,WAAyB;EAE5B,OAAOhF,WAAW,IAAI,CAACC,OAAO,EAAEC,cAAc,KAAI;IAChD,MAAMiC,KAAK,GAAGnC,WAAW,CAACC,OAAO,EAAEC,cAAc,CAAC;IAClD,IAAIsB,QAAQ,GAAaA,CAAA,KAAK;MAC5B,MAAM,IAAIpC,KAAK,CACb,iEAAiE,GAC/D,yDAAyD,CAC5D;IACH,CAAC;IAED,MAAM6F,aAAa,GAAkB;MACnC/D,QAAQ,EAAEiB,KAAK,CAACjB,QAAQ;MACxBM,QAAQ,EAAEA,CAACC,MAAM,EAAE,GAAG2C,IAAI,KAAK5C,QAAQ,CAACC,MAAM,EAAE,GAAG2C,IAAI;KACxD;IACD,MAAMc,KAAK,GAAGF,WAAW,CAACG,GAAG,CAACC,UAAU,IAAIA,UAAU,CAACH,aAAa,CAAC,CAAC;IACtEzD,QAAQ,GAAGiD,OAAO,CAAkB,GAAGS,KAAK,CAAC,CAAC/C,KAAK,CAACX,QAAQ,CAAC;IAE7D,OAAO;MACL,GAAGW,KAAK;MACRX;KACD;EACH,CAAC;AACH;;AC3E2C;AAE7B,SAAU6D,QAAQA,CAAC5D,MAAe;EAC9C,OACE1D,2BAAa,CAAC0D,MAAM,CAAC,IACrB,MAAM,IAAIA,MAAM,IAChB,OAAQA,MAAkC,CAACnD,IAAI,KAAK,QAAQ;AAEhE;;;;;;;;;;AKTA;AAC+D;AAChB;AACM;AACN;AAChB;AACQ;AACU;AACU;AAE3D;AACA;AAUsB;AACtB;AASyB;AACzB;AACwE;AACxE;AAC8D;AAC9D;AACkE","sources":["webpack://Redux/webpack/universalModuleDefinition","webpack://Redux/webpack/bootstrap","webpack://Redux/webpack/runtime/define property getters","webpack://Redux/webpack/runtime/hasOwnProperty shorthand","webpack://Redux/webpack/runtime/make namespace object","webpack://Redux/./src/utils/symbol-observable.ts","webpack://Redux/./src/utils/actionTypes.ts","webpack://Redux/./src/utils/isPlainObject.ts","webpack://Redux/./src/utils/kindOf.ts","webpack://Redux/./src/createStore.ts","webpack://Redux/./src/combineReducers.ts","webpack://Redux/./src/bindActionCreators.ts","webpack://Redux/./src/compose.ts","webpack://Redux/./src/applyMiddleware.ts","webpack://Redux/./src/utils/isAction.ts","webpack://Redux/./src/types/store.ts","webpack://Redux/./src/types/reducers.ts","webpack://Redux/./src/types/actions.ts","webpack://Redux/./src/types/middleware.ts","webpack://Redux/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Redux\"] = factory();\n\telse\n\t\troot[\"Redux\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","declare global {\n  interface SymbolConstructor {\n    readonly observable: symbol\n  }\n}\n\nconst $$observable = /* #__PURE__ */ (() =>\n  (typeof Symbol === 'function' && Symbol.observable) || '@@observable')()\n\nexport default $$observable\n","/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nconst randomString = () =>\n  Math.random().toString(36).substring(7).split('').join('.')\n\nconst ActionTypes = {\n  INIT: `@@redux/INIT${/* #__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* #__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n}\n\nexport default ActionTypes\n","/**\n * @param obj The object to inspect.\n * @returns True if the argument appears to be a plain object.\n */\nexport default function isPlainObject(obj: any): obj is object {\n  if (typeof obj !== 'object' || obj === null) return false\n\n  let proto = obj\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto)\n  }\n\n  return (\n    Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null\n  )\n}\n","// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nexport function miniKindOf(val: any): string {\n  if (val === void 0) return 'undefined'\n  if (val === null) return 'null'\n\n  const type = typeof val\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function': {\n      return type\n    }\n  }\n\n  if (Array.isArray(val)) return 'array'\n  if (isDate(val)) return 'date'\n  if (isError(val)) return 'error'\n\n  const constructorName = ctorName(val)\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName\n  }\n\n  // other\n  return Object.prototype.toString\n    .call(val)\n    .slice(8, -1)\n    .toLowerCase()\n    .replace(/\\s/g, '')\n}\n\nfunction ctorName(val: any): string | null {\n  return typeof val.constructor === 'function' ? val.constructor.name : null\n}\n\nfunction isError(val: any) {\n  return (\n    val instanceof Error ||\n    (typeof val.message === 'string' &&\n      val.constructor &&\n      typeof val.constructor.stackTraceLimit === 'number')\n  )\n}\n\nfunction isDate(val: any) {\n  if (val instanceof Date) return true\n  return (\n    typeof val.toDateString === 'function' &&\n    typeof val.getDate === 'function' &&\n    typeof val.setDate === 'function'\n  )\n}\n\nexport function kindOf(val: any) {\n  let typeOfVal: string = typeof val\n\n  if (process.env.NODE_ENV !== 'production') {\n    typeOfVal = miniKindOf(val)\n  }\n\n  return typeOfVal\n}\n","import $$observable from './utils/symbol-observable'\n\nimport {\n  Store,\n  StoreEnhancer,\n  Dispatch,\n  Observer,\n  ListenerCallback,\n  UnknownIfNonSpecific\n} from './types/store'\nimport { Action } from './types/actions'\nimport { Reducer } from './types/reducers'\nimport ActionTypes from './utils/actionTypes'\nimport isPlainObject from './utils/isPlainObject'\nimport { kindOf } from './utils/kindOf'\n\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\nexport function createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {}\n>(\n  reducer: Reducer<S, A>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\nexport function createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {},\n  PreloadedState = S\n>(\n  reducer: Reducer<S, A, PreloadedState>,\n  preloadedState?: PreloadedState | undefined,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\nexport function createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {},\n  PreloadedState = S\n>(\n  reducer: Reducer<S, A, PreloadedState>,\n  preloadedState?: PreloadedState | StoreEnhancer<Ext, StateExt> | undefined,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext {\n  if (typeof reducer !== 'function') {\n    throw new Error(\n      `Expected the root reducer to be a function. Instead, received: '${kindOf(\n        reducer\n      )}'`\n    )\n  }\n\n  if (\n    (typeof preloadedState === 'function' && typeof enhancer === 'function') ||\n    (typeof enhancer === 'function' && typeof arguments[3] === 'function')\n  ) {\n    throw new Error(\n      'It looks like you are passing several store enhancers to ' +\n        'createStore(). This is not supported. Instead, compose them ' +\n        'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.'\n    )\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState as StoreEnhancer<Ext, StateExt>\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error(\n        `Expected the enhancer to be a function. Instead, received: '${kindOf(\n          enhancer\n        )}'`\n      )\n    }\n\n    return enhancer(createStore)(\n      reducer,\n      preloadedState as PreloadedState | undefined\n    )\n  }\n\n  let currentReducer = reducer\n  let currentState: S | PreloadedState | undefined = preloadedState as\n    | PreloadedState\n    | undefined\n  let currentListeners: Map<number, ListenerCallback> | null = new Map()\n  let nextListeners = currentListeners\n  let listenerIdCounter = 0\n  let isDispatching = false\n\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = new Map()\n      currentListeners.forEach((listener, key) => {\n        nextListeners.set(key, listener)\n      })\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns The current state tree of your application.\n   */\n  function getState(): S {\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.'\n      )\n    }\n\n    return currentState as S\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param listener A callback to be invoked on every dispatch.\n   * @returns A function to remove this change listener.\n   */\n  function subscribe(listener: () => void) {\n    if (typeof listener !== 'function') {\n      throw new Error(\n        `Expected the listener to be a function. Instead, received: '${kindOf(\n          listener\n        )}'`\n      )\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api/store#subscribelistener for more details.'\n      )\n    }\n\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    const listenerId = listenerIdCounter++\n    nextListeners.set(listenerId, listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api/store#subscribelistener for more details.'\n        )\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      nextListeners.delete(listenerId)\n      currentListeners = null\n    }\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action: A) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        `Actions must be plain objects. Instead, the actual type was: '${kindOf(\n          action\n        )}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`\n      )\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.'\n      )\n    }\n\n    if (typeof action.type !== 'string') {\n      throw new Error(\n        `Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(\n          action.type\n        )}'. Value was: '${action.type}' (stringified)`\n      )\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = (currentListeners = nextListeners)\n    listeners.forEach(listener => {\n      listener()\n    })\n    return action\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param nextReducer The reducer for the store to use instead.\n   */\n  function replaceReducer(nextReducer: Reducer<S, A>): void {\n    if (typeof nextReducer !== 'function') {\n      throw new Error(\n        `Expected the nextReducer to be a function. Instead, received: '${kindOf(\n          nextReducer\n        )}`\n      )\n    }\n\n    currentReducer = nextReducer as unknown as Reducer<S, A, PreloadedState>\n\n    // This action has a similar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n    dispatch({ type: ActionTypes.REPLACE } as A)\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer: unknown) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError(\n            `Expected the observer to be an object. Instead, received: '${kindOf(\n              observer\n            )}'`\n          )\n        }\n\n        function observeState() {\n          const observerAsObserver = observer as Observer<S>\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState())\n          }\n        }\n\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT } as A)\n\n  const store = {\n    dispatch: dispatch as Dispatch<A>,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  } as unknown as Store<S, A, StateExt> & Ext\n  return store\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nexport function legacy_createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {}\n>(\n  reducer: Reducer<S, A>,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nexport function legacy_createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {},\n  PreloadedState = S\n>(\n  reducer: Reducer<S, A, PreloadedState>,\n  preloadedState?: PreloadedState | undefined,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\nexport function legacy_createStore<\n  S,\n  A extends Action,\n  Ext extends {} = {},\n  StateExt extends {} = {},\n  PreloadedState = S\n>(\n  reducer: Reducer<S, A>,\n  preloadedState?: PreloadedState | StoreEnhancer<Ext, StateExt> | undefined,\n  enhancer?: StoreEnhancer<Ext, StateExt>\n): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext {\n  return createStore(reducer, preloadedState as any, enhancer)\n}\n","import { Action } from './types/actions'\nimport {\n  ActionFromReducersMapObject,\n  PreloadedStateShapeFromReducersMapObject,\n  Reducer,\n  StateFromReducersMapObject\n} from './types/reducers'\n\nimport ActionTypes from './utils/actionTypes'\nimport isPlainObject from './utils/isPlainObject'\nimport warning from './utils/warning'\nimport { kindOf } from './utils/kindOf'\n\nfunction getUnexpectedStateShapeWarningMessage(\n  inputState: object,\n  reducers: { [key: string]: Reducer<any, any, any> },\n  action: Action,\n  unexpectedKeyCache: { [key: string]: true }\n) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName =\n    action && action.type === ActionTypes.INIT\n      ? 'preloadedState argument passed to createStore'\n      : 'previous state received by the reducer'\n\n  if (reducerKeys.length === 0) {\n    return (\n      'Store does not have a valid reducer. Make sure the argument passed ' +\n      'to combineReducers is an object whose values are reducers.'\n    )\n  }\n\n  if (!isPlainObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"${kindOf(\n        inputState\n      )}\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(\n    key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (action && action.type === ActionTypes.REPLACE) return\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +\n      `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` +\n      `Expected to find one of the known reducer keys instead: ` +\n      `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers: {\n  [key: string]: Reducer<any, any, any>\n}) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ActionTypes.INIT })\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don't want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      )\n    }\n\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === 'undefined'\n    ) {\n      throw new Error(\n        `The slice reducer for key \"${key}\" returned undefined when probed with a random type. ` +\n          `Don't try to handle '${ActionTypes.INIT}' or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      )\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @template S Combined state object type.\n *\n * @param reducers An object whose values correspond to different reducer\n *   functions that need to be combined into one. One handy way to obtain it\n *   is to use `import * as reducers` syntax. The reducers may never\n *   return undefined for any action. Instead, they should return their\n *   initial state if the state passed to them was undefined, and the current\n *   state for any unrecognized action.\n *\n * @returns A reducer function that invokes every reducer inside the passed\n *   object, and builds a state object with the same shape.\n */\nexport default function combineReducers<M>(\n  reducers: M\n): M[keyof M] extends Reducer<any, any, any> | undefined\n  ? Reducer<\n      StateFromReducersMapObject<M>,\n      ActionFromReducersMapObject<M>,\n      Partial<PreloadedStateShapeFromReducersMapObject<M>>\n    >\n  : never\nexport default function combineReducers(reducers: {\n  [key: string]: Reducer<any, any, any>\n}) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers: { [key: string]: Reducer<any, any, any> } = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`)\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  // This is used to make sure we don't warn about the same\n  // keys multiple times.\n  let unexpectedKeyCache: { [key: string]: true }\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError: unknown\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(\n    state: StateFromReducersMapObject<typeof reducers> = {},\n    action: Action\n  ) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache\n      )\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState: StateFromReducersMapObject<typeof reducers> = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === 'undefined') {\n        const actionType = action && action.type\n        throw new Error(\n          `When called with an action of type ${\n            actionType ? `\"${String(actionType)}\"` : '(unknown type)'\n          }, the slice reducer for key \"${key}\" returned undefined. ` +\n            `To ignore an action, you must explicitly return the previous state. ` +\n            `If you want this reducer to hold no value, you can return null instead of undefined.`\n        )\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n    return hasChanged ? nextState : state\n  }\n}\n","import { Dispatch } from './types/store'\nimport { ActionCreator, ActionCreatorsMapObject, Action } from './types/actions'\nimport { kindOf } from './utils/kindOf'\n\nfunction bindActionCreator<A extends Action>(\n  actionCreator: ActionCreator<A>,\n  dispatch: Dispatch<A>\n) {\n  return function (this: any, ...args: any[]) {\n    return dispatch(actionCreator.apply(this, args))\n  }\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use `import * as`\n * syntax. You may also pass a single function.\n *\n * @param dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nexport default function bindActionCreators<A, C extends ActionCreator<A>>(\n  actionCreator: C,\n  dispatch: Dispatch\n): C\n\nexport default function bindActionCreators<\n  A extends ActionCreator<any>,\n  B extends ActionCreator<any>\n>(actionCreator: A, dispatch: Dispatch): B\n\nexport default function bindActionCreators<\n  A,\n  M extends ActionCreatorsMapObject<A>\n>(actionCreators: M, dispatch: Dispatch): M\nexport default function bindActionCreators<\n  M extends ActionCreatorsMapObject,\n  N extends ActionCreatorsMapObject\n>(actionCreators: M, dispatch: Dispatch): N\n\nexport default function bindActionCreators(\n  actionCreators: ActionCreator<any> | ActionCreatorsMapObject,\n  dispatch: Dispatch\n) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, but instead received: '${kindOf(\n        actionCreators\n      )}'. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    )\n  }\n\n  const boundActionCreators: ActionCreatorsMapObject = {}\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\n","type Func<T extends any[], R> = (...a: T) => R\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for the\n * resulting composite function.\n *\n * @param funcs The functions to compose.\n * @returns A function obtained by composing the argument functions from right\n *   to left. For example, `compose(f, g, h)` is identical to doing\n *   `(...args) => f(g(h(...args)))`.\n */\nexport default function compose(): <R>(a: R) => R\n\nexport default function compose<F extends Function>(f: F): F\n\n/* two functions */\nexport default function compose<A, T extends any[], R>(\n  f1: (a: A) => R,\n  f2: Func<T, A>\n): Func<T, R>\n\n/* three functions */\nexport default function compose<A, B, T extends any[], R>(\n  f1: (b: B) => R,\n  f2: (a: A) => B,\n  f3: Func<T, A>\n): Func<T, R>\n\n/* four functions */\nexport default function compose<A, B, C, T extends any[], R>(\n  f1: (c: C) => R,\n  f2: (b: B) => C,\n  f3: (a: A) => B,\n  f4: Func<T, A>\n): Func<T, R>\n\n/* rest */\nexport default function compose<R>(\n  f1: (a: any) => R,\n  ...funcs: Function[]\n): (...args: any[]) => R\n\nexport default function compose<R>(...funcs: Function[]): (...args: any[]) => R\n\nexport default function compose(...funcs: Function[]) {\n  if (funcs.length === 0) {\n    // infer the argument type so it is usable in inference down the line\n    return <T>(arg: T) => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce(\n    (a, b) =>\n      (...args: any) =>\n        a(b(...args))\n  )\n}\n","import compose from './compose'\nimport { Middleware, MiddlewareAPI } from './types/middleware'\nimport { StoreEnhancer, Dispatch } from './types/store'\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param middlewares The middleware chain to be applied.\n * @returns A store enhancer applying the middleware.\n *\n * @template Ext Dispatch signature added by a middleware.\n * @template S The type of the state supported by a middleware.\n */\nexport default function applyMiddleware(): StoreEnhancer\nexport default function applyMiddleware<Ext1, S>(\n  middleware1: Middleware<Ext1, S, any>\n): StoreEnhancer<{ dispatch: Ext1 }>\nexport default function applyMiddleware<Ext1, Ext2, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>,\n  middleware4: Middleware<Ext4, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 }>\nexport default function applyMiddleware<Ext1, Ext2, Ext3, Ext4, Ext5, S>(\n  middleware1: Middleware<Ext1, S, any>,\n  middleware2: Middleware<Ext2, S, any>,\n  middleware3: Middleware<Ext3, S, any>,\n  middleware4: Middleware<Ext4, S, any>,\n  middleware5: Middleware<Ext5, S, any>\n): StoreEnhancer<{ dispatch: Ext1 & Ext2 & Ext3 & Ext4 & Ext5 }>\nexport default function applyMiddleware<Ext, S = any>(\n  ...middlewares: Middleware<any, S, any>[]\n): StoreEnhancer<{ dispatch: Ext }>\nexport default function applyMiddleware(\n  ...middlewares: Middleware[]\n): StoreEnhancer<any> {\n  return createStore => (reducer, preloadedState) => {\n    const store = createStore(reducer, preloadedState)\n    let dispatch: Dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI: MiddlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    }\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose<typeof dispatch>(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n","import { Action } from '../types/actions'\nimport isPlainObject from './isPlainObject'\n\nexport default function isAction(action: unknown): action is Action<string> {\n  return (\n    isPlainObject(action) &&\n    'type' in action &&\n    typeof (action as Record<'type', unknown>).type === 'string'\n  )\n}\n","import { Action, UnknownAction } from './actions'\nimport { Reducer } from './reducers'\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport _$$observable from '../utils/symbol-observable'\n\n/**\n * A *dispatching function* (or simply *dispatch function*) is a function that\n * accepts an action or an async action; it then may or may not dispatch one\n * or more actions to the store.\n *\n * We must distinguish between dispatching functions in general and the base\n * `dispatch` function provided by the store instance without any middleware.\n *\n * The base dispatch function *always* synchronously sends an action to the\n * store's reducer, along with the previous state returned by the store, to\n * calculate a new state. It expects actions to be plain objects ready to be\n * consumed by the reducer.\n *\n * Middleware wraps the base dispatch function. It allows the dispatch\n * function to handle async actions in addition to actions. Middleware may\n * transform, delay, ignore, or otherwise interpret actions or async actions\n * before passing them to the next middleware.\n *\n * @template A The type of things (actions or otherwise) which may be\n *   dispatched.\n */\nexport interface Dispatch<A extends Action = UnknownAction> {\n  <T extends A>(action: T, ...extraArgs: any[]): T\n}\n\n/**\n * Function to remove listener added by `Store.subscribe()`.\n */\nexport interface Unsubscribe {\n  (): void\n}\n\nexport type ListenerCallback = () => void\n\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol\n  }\n}\n\n/**\n * A minimal observable of state changes.\n * For more information, see the observable proposal:\n * https://github.com/tc39/proposal-observable\n */\nexport type Observable<T> = {\n  /**\n   * The minimal observable subscription method.\n   * @param {Object} observer Any object that can be used as an observer.\n   * The observer object should have a `next` method.\n   * @returns {subscription} An object with an `unsubscribe` method that can\n   * be used to unsubscribe the observable from the store, and prevent further\n   * emission of values from the observable.\n   */\n  subscribe: (observer: Observer<T>) => { unsubscribe: Unsubscribe }\n  [Symbol.observable](): Observable<T>\n}\n\n/**\n * An Observer is used to receive data from an Observable, and is supplied as\n * an argument to subscribe.\n */\nexport type Observer<T> = {\n  next?(value: T): void\n}\n\n/**\n * A store is an object that holds the application's state tree.\n * There should only be a single store in a Redux app, as the composition\n * happens on the reducer level.\n *\n * @template S The type of state held by this store.\n * @template A the type of actions which may be dispatched by this store.\n * @template StateExt any extension to state from store enhancers\n */\nexport interface Store<\n  S = any,\n  A extends Action = UnknownAction,\n  StateExt extends unknown = unknown\n> {\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will be\n   * considered the **next** state of the tree, and the change listeners will\n   * be notified.\n   *\n   * The base implementation only supports plain object actions. If you want\n   * to dispatch a Promise, an Observable, a thunk, or something else, you\n   * need to wrap your store creating function into the corresponding\n   * middleware. For example, see the documentation for the `redux-thunk`\n   * package. Even the middleware will eventually dispatch plain object\n   * actions using this method.\n   *\n   * @param action A plain object representing “what changed”. It is a good\n   *   idea to keep actions serializable so you can record and replay user\n   *   sessions, or use the time travelling `redux-devtools`. An action must\n   *   have a `type` property which may not be `undefined`. It is a good idea\n   *   to use string constants for action types.\n   *\n   * @returns For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  dispatch: Dispatch<A>\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns The current state tree of your application.\n   */\n  getState(): S & StateExt\n\n  /**\n   * Adds a change listener. It will be called any time an action is\n   * dispatched, and some part of the state tree may potentially have changed.\n   * You may then call `getState()` to read the current state tree inside the\n   * callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked,\n   * this will not have any effect on the `dispatch()` that is currently in\n   * progress. However, the next `dispatch()` call, whether nested or not,\n   * will use a more recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all states changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param listener A callback to be invoked on every dispatch.\n   * @returns A function to remove this change listener.\n   */\n  subscribe(listener: ListenerCallback): Unsubscribe\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param nextReducer The reducer for the store to use instead.\n   */\n  replaceReducer(nextReducer: Reducer<S, A>): void\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  [Symbol.observable](): Observable<S & StateExt>\n}\n\nexport type UnknownIfNonSpecific<T> = {} extends T ? unknown : T\n\n/**\n * A store creator is a function that creates a Redux store. Like with\n * dispatching function, we must distinguish the base store creator,\n * `createStore(reducer, preloadedState)` exported from the Redux package, from\n * store creators that are returned from the store enhancers.\n *\n * @template S The type of state to be held by the store.\n * @template A The type of actions which may be dispatched.\n * @template PreloadedState The initial state that is passed into the reducer.\n * @template Ext Store extension that is mixed in to the Store type.\n * @template StateExt State extension that is mixed into the state type.\n */\nexport interface StoreCreator {\n  <S, A extends Action, Ext extends {} = {}, StateExt extends {} = {}>(\n    reducer: Reducer<S, A>,\n    enhancer?: StoreEnhancer<Ext, StateExt>\n  ): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\n  <\n    S,\n    A extends Action,\n    Ext extends {} = {},\n    StateExt extends {} = {},\n    PreloadedState = S\n  >(\n    reducer: Reducer<S, A, PreloadedState>,\n    preloadedState?: PreloadedState | undefined,\n    enhancer?: StoreEnhancer<Ext>\n  ): Store<S, A, UnknownIfNonSpecific<StateExt>> & Ext\n}\n\n/**\n * A store enhancer is a higher-order function that composes a store creator\n * to return a new, enhanced store creator. This is similar to middleware in\n * that it allows you to alter the store interface in a composable way.\n *\n * Store enhancers are much the same concept as higher-order components in\n * React, which are also occasionally called “component enhancers”.\n *\n * Because a store is not an instance, but rather a plain-object collection of\n * functions, copies can be easily created and modified without mutating the\n * original store. There is an example in `compose` documentation\n * demonstrating that.\n *\n * Most likely you'll never write a store enhancer, but you may use the one\n * provided by the developer tools. It is what makes time travel possible\n * without the app being aware it is happening. Amusingly, the Redux\n * middleware implementation is itself a store enhancer.\n *\n * @template Ext Store extension that is mixed into the Store type.\n * @template StateExt State extension that is mixed into the state type.\n */\nexport type StoreEnhancer<Ext extends {} = {}, StateExt extends {} = {}> = <\n  NextExt extends {},\n  NextStateExt extends {}\n>(\n  next: StoreEnhancerStoreCreator<NextExt, NextStateExt>\n) => StoreEnhancerStoreCreator<NextExt & Ext, NextStateExt & StateExt>\nexport type StoreEnhancerStoreCreator<\n  Ext extends {} = {},\n  StateExt extends {} = {}\n> = <S, A extends Action, PreloadedState>(\n  reducer: Reducer<S, A, PreloadedState>,\n  preloadedState?: PreloadedState | undefined\n) => Store<S, A, StateExt> & Ext\n","import { Action, UnknownAction } from './actions'\n\n/* reducers */\n\n/**\n * A *reducer* is a function that accepts\n * an accumulation and a value and returns a new accumulation. They are used\n * to reduce a collection of values down to a single value\n *\n * Reducers are not unique to Redux—they are a fundamental concept in\n * functional programming.  Even most non-functional languages, like\n * JavaScript, have a built-in API for reducing. In JavaScript, it's\n * `Array.prototype.reduce()`.\n *\n * In Redux, the accumulated value is the state object, and the values being\n * accumulated are actions. Reducers calculate a new state given the previous\n * state and an action. They must be *pure functions*—functions that return\n * the exact same output for given inputs. They should also be free of\n * side-effects. This is what enables exciting features like hot reloading and\n * time travel.\n *\n * Reducers are the most important concept in Redux.\n *\n * *Do not put API calls into reducers.*\n *\n * @template S The type of state consumed and produced by this reducer.\n * @template A The type of actions the reducer can potentially respond to.\n * @template PreloadedState The type of state consumed by this reducer the first time it's called.\n */\nexport type Reducer<\n  S = any,\n  A extends Action = UnknownAction,\n  PreloadedState = S\n> = (state: S | PreloadedState | undefined, action: A) => S\n\n/**\n * Object whose values correspond to different reducer functions.\n *\n * @template S The combined state of the reducers.\n * @template A The type of actions the reducers can potentially respond to.\n * @template PreloadedState The combined preloaded state of the reducers.\n */\nexport type ReducersMapObject<\n  S = any,\n  A extends Action = UnknownAction,\n  PreloadedState = S\n> = keyof PreloadedState extends keyof S\n  ? {\n      [K in keyof S]: Reducer<\n        S[K],\n        A,\n        K extends keyof PreloadedState ? PreloadedState[K] : never\n      >\n    }\n  : never\n\n/**\n * Infer a combined state shape from a `ReducersMapObject`.\n *\n * @template M Object map of reducers as provided to `combineReducers(map: M)`.\n */\nexport type StateFromReducersMapObject<M> = M[keyof M] extends\n  | Reducer<any, any, any>\n  | undefined\n  ? {\n      [P in keyof M]: M[P] extends Reducer<infer S, any, any> ? S : never\n    }\n  : never\n\n/**\n * Infer reducer union type from a `ReducersMapObject`.\n *\n * @template M Object map of reducers as provided to `combineReducers(map: M)`.\n */\nexport type ReducerFromReducersMapObject<M> = M[keyof M] extends\n  | Reducer<any, any, any>\n  | undefined\n  ? M[keyof M]\n  : never\n\n/**\n * Infer action type from a reducer function.\n *\n * @template R Type of reducer.\n */\nexport type ActionFromReducer<R> = R extends Reducer<any, infer A, any>\n  ? A\n  : never\n\n/**\n * Infer action union type from a `ReducersMapObject`.\n *\n * @template M Object map of reducers as provided to `combineReducers(map: M)`.\n */\nexport type ActionFromReducersMapObject<M> = ActionFromReducer<\n  ReducerFromReducersMapObject<M>\n>\n\n/**\n * Infer a combined preloaded state shape from a `ReducersMapObject`.\n *\n * @template M Object map of reducers as provided to `combineReducers(map: M)`.\n */\nexport type PreloadedStateShapeFromReducersMapObject<M> = M[keyof M] extends\n  | Reducer<any, any, any>\n  | undefined\n  ? {\n      [P in keyof M]: M[P] extends (\n        inputState: infer InputState,\n        action: UnknownAction\n      ) => any\n        ? InputState\n        : never\n    }\n  : never\n","/**\n * An *action* is a plain object that represents an intention to change the\n * state. Actions are the only way to get data into the store. Any data,\n * whether from UI events, network callbacks, or other sources such as\n * WebSockets needs to eventually be dispatched as actions.\n *\n * Actions must have a `type` field that indicates the type of action being\n * performed. Types can be defined as constants and imported from another\n * module. These must be strings, as strings are serializable.\n *\n * Other than `type`, the structure of an action object is really up to you.\n * If you're interested, check out Flux Standard Action for recommendations on\n * how actions should be constructed.\n *\n * @template T the type of the action's `type` tag.\n */\n// this needs to be a type, not an interface\n// https://github.com/microsoft/TypeScript/issues/15300\nexport type Action<T extends string = string> = {\n  type: T\n}\n\n/**\n * An Action type which accepts any other properties.\n * This is mainly for the use of the `Reducer` type.\n * This is not part of `Action` itself to prevent types that extend `Action` from\n * having an index signature.\n */\nexport interface UnknownAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: unknown\n}\n\n/**\n * An Action type which accepts any other properties.\n * This is mainly for the use of the `Reducer` type.\n * This is not part of `Action` itself to prevent types that extend `Action` from\n * having an index signature.\n * @deprecated use Action or UnknownAction instead\n */\nexport interface AnyAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: any\n}\n\n/* action creators */\n\n/**\n * An *action creator* is, quite simply, a function that creates an action. Do\n * not confuse the two terms—again, an action is a payload of information, and\n * an action creator is a factory that creates an action.\n *\n * Calling an action creator only produces an action, but does not dispatch\n * it. You need to call the store's `dispatch` function to actually cause the\n * mutation. Sometimes we say *bound action creators* to mean functions that\n * call an action creator and immediately dispatch its result to a specific\n * store instance.\n *\n * If an action creator needs to read the current state, perform an API call,\n * or cause a side effect, like a routing transition, it should return an\n * async action instead of an action.\n *\n * @template A Returned action type.\n */\nexport interface ActionCreator<A, P extends any[] = any[]> {\n  (...args: P): A\n}\n\n/**\n * Object whose values are action creator functions.\n */\nexport interface ActionCreatorsMapObject<A = any, P extends any[] = any[]> {\n  [key: string]: ActionCreator<A, P>\n}\n","import { Dispatch } from './store'\n\nexport interface MiddlewareAPI<D extends Dispatch = Dispatch, S = any> {\n  dispatch: D\n  getState(): S\n}\n\n/**\n * A middleware is a higher-order function that composes a dispatch function\n * to return a new dispatch function. It often turns async actions into\n * actions.\n *\n * Middleware is composable using function composition. It is useful for\n * logging actions, performing side effects like routing, or turning an\n * asynchronous API call into a series of synchronous actions.\n *\n * @template DispatchExt Extra Dispatch signature added by this middleware.\n * @template S The type of the state supported by this middleware.\n * @template D The type of Dispatch of the store where this middleware is\n *   installed.\n */\nexport interface Middleware<\n  _DispatchExt = {}, // TODO: see if this can be used in type definition somehow (can't be removed, as is used to get final dispatch type)\n  S = any,\n  D extends Dispatch = Dispatch\n> {\n  (api: MiddlewareAPI<D, S>): (\n    next: (action: unknown) => unknown\n  ) => (action: unknown) => unknown\n}\n","// functions\nimport { createStore, legacy_createStore } from './createStore'\nimport combineReducers from './combineReducers'\nimport bindActionCreators from './bindActionCreators'\nimport applyMiddleware from './applyMiddleware'\nimport compose from './compose'\nimport isAction from './utils/isAction'\nimport isPlainObject from './utils/isPlainObject'\nimport __DO_NOT_USE__ActionTypes from './utils/actionTypes'\n\n// types\n// store\nexport {\n  Dispatch,\n  Unsubscribe,\n  Observable,\n  Observer,\n  Store,\n  StoreCreator,\n  StoreEnhancer,\n  StoreEnhancerStoreCreator\n} from './types/store'\n// reducers\nexport {\n  Reducer,\n  ReducersMapObject,\n  StateFromReducersMapObject,\n  ReducerFromReducersMapObject,\n  ActionFromReducer,\n  ActionFromReducersMapObject,\n  PreloadedStateShapeFromReducersMapObject\n} from './types/reducers'\n// action creators\nexport { ActionCreator, ActionCreatorsMapObject } from './types/actions'\n// middleware\nexport { MiddlewareAPI, Middleware } from './types/middleware'\n// actions\nexport { Action, UnknownAction, AnyAction } from './types/actions'\n\nexport {\n  createStore,\n  legacy_createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose,\n  isAction,\n  isPlainObject,\n  __DO_NOT_USE__ActionTypes\n}\n"],"names":["$$observable","Symbol","observable","randomString","Math","random","toString","substring","split","join","ActionTypes","INIT","REPLACE","PROBE_UNKNOWN_ACTION","isPlainObject","obj","proto","Object","getPrototypeOf","miniKindOf","val","type","Array","isArray","isDate","isError","constructorName","ctorName","prototype","call","slice","toLowerCase","replace","constructor","name","Error","message","stackTraceLimit","Date","toDateString","getDate","setDate","kindOf","typeOfVal","process","env","NODE_ENV","createStore","reducer","preloadedState","enhancer","arguments","undefined","currentReducer","currentState","currentListeners","Map","nextListeners","listenerIdCounter","isDispatching","ensureCanMutateNextListeners","forEach","listener","key","set","getState","subscribe","isSubscribed","listenerId","unsubscribe","delete","dispatch","action","listeners","replaceReducer","nextReducer","outerSubscribe","observer","TypeError","observeState","observerAsObserver","next","store","legacy_createStore","warning","getUnexpectedStateShapeWarningMessage","inputState","reducers","unexpectedKeyCache","reducerKeys","keys","argumentName","length","unexpectedKeys","filter","hasOwnProperty","assertReducerShape","initialState","combineReducers","finalReducers","i","finalReducerKeys","shapeAssertionError","e","combination","state","warningMessage","hasChanged","nextState","previousStateForKey","nextStateForKey","actionType","String","bindActionCreator","actionCreator","args","apply","bindActionCreators","actionCreators","boundActionCreators","compose","funcs","arg","reduce","a","b","applyMiddleware","middlewares","middlewareAPI","chain","map","middleware","isAction","__DO_NOT_USE__ActionTypes","Dispatch","Unsubscribe","Observable","Observer","Store","StoreCreator","StoreEnhancer","StoreEnhancerStoreCreator","Reducer","ReducersMapObject","StateFromReducersMapObject","ReducerFromReducersMapObject","ActionFromReducer","ActionFromReducersMapObject","PreloadedStateShapeFromReducersMapObject","ActionCreator","ActionCreatorsMapObject","MiddlewareAPI","Middleware","Action","UnknownAction","AnyAction"],"sourceRoot":""}