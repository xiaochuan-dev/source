{"version":3,"file":"pinia.iife.prod.js","sources":["../src/rootStore.ts","../src/types.ts","../src/env.ts","../src/subscriptions.ts","../src/store.ts","../src/mapHelpers.ts","../src/vue2-plugin.ts","../src/hmr.ts","../src/createPinia.ts","../src/storeToRefs.ts"],"sourcesContent":["import {\n  App,\n  EffectScope,\n  inject,\n  hasInjectionContext,\n  InjectionKey,\n  Ref,\n} from 'vue-demi'\nimport {\n  StateTree,\n  PiniaCustomProperties,\n  _Method,\n  Store,\n  _GettersTree,\n  _ActionsTree,\n  PiniaCustomStateProperties,\n  DefineStoreOptionsInPlugin,\n  StoreGeneric,\n} from './types'\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nexport let activePinia: Pinia | undefined\n\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nexport const setActivePinia: _SetActivePinia = (pinia) => (activePinia = pinia)\n\ninterface _SetActivePinia {\n  (pinia: Pinia): Pinia\n  (pinia: undefined): undefined\n  (pinia: Pinia | undefined): Pinia | undefined\n}\n\n/**\n * Get the currently active pinia if there is any.\n */\nexport const getActivePinia = () =>\n  (hasInjectionContext() && inject(piniaSymbol)) || activePinia\n\n/**\n * Every application must own its own pinia to be able to create stores\n */\nexport interface Pinia {\n  install: (app: App) => void\n\n  /**\n   * root state\n   */\n  state: Ref<Record<string, StateTree>>\n\n  /**\n   * Adds a store plugin to extend every store\n   *\n   * @param plugin - store plugin to add\n   */\n  use(plugin: PiniaPlugin): Pinia\n\n  /**\n   * Installed store plugins\n   *\n   * @internal\n   */\n  _p: PiniaPlugin[]\n\n  /**\n   * App linked to this Pinia instance\n   *\n   * @internal\n   */\n  _a: App\n\n  /**\n   * Effect scope the pinia is attached to\n   *\n   * @internal\n   */\n  _e: EffectScope\n\n  /**\n   * Registry of stores used by this pinia.\n   *\n   * @internal\n   */\n  _s: Map<string, StoreGeneric>\n\n  /**\n   * Added by `createTestingPinia()` to bypass `useStore(pinia)`.\n   *\n   * @internal\n   */\n  _testing?: boolean\n}\n\nexport const piniaSymbol = (\n  __DEV__ ? Symbol('pinia') : /* istanbul ignore next */ Symbol()\n) as InjectionKey<Pinia>\n\n/**\n * Context argument passed to Pinia plugins.\n */\nexport interface PiniaPluginContext<\n  Id extends string = string,\n  S extends StateTree = StateTree,\n  G /* extends _GettersTree<S> */ = _GettersTree<S>,\n  A /* extends _ActionsTree */ = _ActionsTree\n> {\n  /**\n   * pinia instance.\n   */\n  pinia: Pinia\n\n  /**\n   * Current app created with `Vue.createApp()`.\n   */\n  app: App\n\n  /**\n   * Current store being extended.\n   */\n  store: Store<Id, S, G, A>\n\n  /**\n   * Initial options defining the store when calling `defineStore()`.\n   */\n  options: DefineStoreOptionsInPlugin<Id, S, G, A>\n}\n\n/**\n * Plugin to extend every store.\n */\nexport interface PiniaPlugin {\n  /**\n   * Plugin to extend every store. Returns an object to extend the store or\n   * nothing.\n   *\n   * @param context - Context\n   */\n  (context: PiniaPluginContext): Partial<\n    PiniaCustomProperties & PiniaCustomStateProperties\n  > | void\n}\n\n/**\n * Plugin to extend every store.\n * @deprecated use PiniaPlugin instead\n */\nexport type PiniaStorePlugin = PiniaPlugin\n","import type {\n  ComputedRef,\n  DebuggerEvent,\n  Ref,\n  UnwrapRef,\n  WatchOptions,\n} from 'vue-demi'\nimport { Pinia } from './rootStore'\n\n/**\n * Generic state of a Store\n */\nexport type StateTree = Record<string | number | symbol, any>\n\nexport function isPlainObject<S extends StateTree>(\n  value: S | unknown\n): value is S\nexport function isPlainObject(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  o: any\n): o is StateTree {\n  return (\n    o &&\n    typeof o === 'object' &&\n    Object.prototype.toString.call(o) === '[object Object]' &&\n    typeof o.toJSON !== 'function'\n  )\n}\n\n/**\n * Recursive `Partial<T>`. Used by {@link Store['$patch']}.\n *\n * For internal use **only**\n */\nexport type _DeepPartial<T> = { [K in keyof T]?: _DeepPartial<T[K]> }\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nexport enum MutationType {\n  /**\n   * Direct mutation of the state:\n   *\n   * - `store.name = 'new name'`\n   * - `store.$state.name = 'new name'`\n   * - `store.list.push('new item')`\n   */\n  direct = 'direct',\n\n  /**\n   * Mutated the state with `$patch` and an object\n   *\n   * - `store.$patch({ name: 'newName' })`\n   */\n  patchObject = 'patch object',\n\n  /**\n   * Mutated the state with `$patch` and a function\n   *\n   * - `store.$patch(state => state.name = 'newName')`\n   */\n  patchFunction = 'patch function',\n\n  // maybe reset? for $state = {} and $reset\n}\n\n/**\n * Base type for the context passed to a subscription callback. Internal type.\n */\nexport interface _SubscriptionCallbackMutationBase {\n  /**\n   * Type of the mutation.\n   */\n  type: MutationType\n\n  /**\n   * `id` of the store doing the mutation.\n   */\n  storeId: string\n\n  /**\n   * 🔴 DEV ONLY, DO NOT use for production code. Different mutation calls. Comes from\n   * https://vuejs.org/guide/extras/reactivity-in-depth.html#reactivity-debugging and allows to track mutations in\n   * devtools and plugins **during development only**.\n   */\n  events?: DebuggerEvent[] | DebuggerEvent\n}\n\n/**\n * Context passed to a subscription callback when directly mutating the state of\n * a store with `store.someState = newValue` or `store.$state.someState =\n * newValue`.\n */\nexport interface SubscriptionCallbackMutationDirect\n  extends _SubscriptionCallbackMutationBase {\n  type: MutationType.direct\n\n  events: DebuggerEvent\n}\n\n/**\n * Context passed to a subscription callback when `store.$patch()` is called\n * with an object.\n */\nexport interface SubscriptionCallbackMutationPatchObject<S>\n  extends _SubscriptionCallbackMutationBase {\n  type: MutationType.patchObject\n\n  events: DebuggerEvent[]\n\n  /**\n   * Object passed to `store.$patch()`.\n   */\n  payload: _DeepPartial<S>\n}\n\n/**\n * Context passed to a subscription callback when `store.$patch()` is called\n * with a function.\n */\nexport interface SubscriptionCallbackMutationPatchFunction\n  extends _SubscriptionCallbackMutationBase {\n  type: MutationType.patchFunction\n\n  events: DebuggerEvent[]\n\n  /**\n   * Object passed to `store.$patch()`.\n   */\n  // payload: DeepPartial<UnwrapRef<S>>\n}\n\n/**\n * Context object passed to a subscription callback.\n */\nexport type SubscriptionCallbackMutation<S> =\n  | SubscriptionCallbackMutationDirect\n  | SubscriptionCallbackMutationPatchObject<S>\n  | SubscriptionCallbackMutationPatchFunction\n\n/**\n * Callback of a subscription\n */\nexport type SubscriptionCallback<S> = (\n  /**\n   * Object with information relative to the store mutation that triggered the\n   * subscription.\n   */\n  mutation: SubscriptionCallbackMutation<S>,\n\n  /**\n   * State of the store when the subscription is triggered. Same as\n   * `store.$state`.\n   */\n  state: UnwrapRef<S>\n) => void\n\n// to support TS 4.4\n// TODO: remove in 2.1.0, use Awaited, and up the peer dep to TS 4.5\nexport type _Awaited<T> = T extends null | undefined\n  ? T // special case for `null | undefined` when not in `--strictNullChecks` mode\n  : T extends object & { then(onfulfilled: infer F): any } // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped\n  ? F extends (value: infer V, ...args: any) => any // if the argument to `then` is callable, extracts the first argument\n    ? _Awaited<V> // recursively unwrap the value\n    : never // the argument to `then` was not callable\n  : T // non-object or non-thenable\n\n/**\n * Actual type for {@link StoreOnActionListenerContext}. Exists for refactoring\n * purposes. For internal use only.\n * For internal use **only**\n */\nexport interface _StoreOnActionListenerContext<\n  Store,\n  ActionName extends string,\n  A\n> {\n  /**\n   * Name of the action\n   */\n  name: ActionName\n\n  /**\n   * Store that is invoking the action\n   */\n  store: Store\n\n  /**\n   * Parameters passed to the action\n   */\n  args: A extends Record<ActionName, _Method>\n    ? Parameters<A[ActionName]>\n    : unknown[]\n\n  /**\n   * Sets up a hook once the action is finished. It receives the return value\n   * of the action, if it's a Promise, it will be unwrapped.\n   */\n  after: (\n    callback: A extends Record<ActionName, _Method>\n      ? (resolvedReturn: _Awaited<ReturnType<A[ActionName]>>) => void\n      : () => void\n  ) => void\n\n  /**\n   * Sets up a hook if the action fails. Return `false` to catch the error and\n   * stop it from propagating.\n   */\n  onError: (callback: (error: unknown) => void) => void\n}\n\n/**\n * Context object passed to callbacks of `store.$onAction(context => {})`\n * TODO: should have only the Id, the Store and Actions to generate the proper object\n */\nexport type StoreOnActionListenerContext<\n  Id extends string,\n  S extends StateTree,\n  G /* extends GettersTree<S> */,\n  A /* extends ActionsTree */\n> = _ActionsTree extends A\n  ? _StoreOnActionListenerContext<StoreGeneric, string, _ActionsTree>\n  : {\n      [Name in keyof A]: Name extends string\n        ? _StoreOnActionListenerContext<Store<Id, S, G, A>, Name, A>\n        : never\n    }[keyof A]\n\n/**\n * Argument of `store.$onAction()`\n */\nexport type StoreOnActionListener<\n  Id extends string,\n  S extends StateTree,\n  G /* extends GettersTree<S> */,\n  A /* extends ActionsTree */\n> = (\n  context: StoreOnActionListenerContext<\n    Id,\n    S,\n    G,\n    // {} creates a type of never due to how StoreOnActionListenerContext is defined\n    {} extends A ? _ActionsTree : A\n  >\n) => void\n\n/**\n * Properties of a store.\n */\nexport interface StoreProperties<Id extends string> {\n  /**\n   * Unique identifier of the store\n   */\n  $id: Id\n\n  /**\n   * Private property defining the pinia the store is attached to.\n   *\n   * @internal\n   */\n  _p: Pinia\n\n  /**\n   * Used by devtools plugin to retrieve getters. Removed in production.\n   *\n   * @internal\n   */\n  _getters?: string[]\n\n  /**\n   * Used (and added) by devtools plugin to detect Setup vs Options API usage.\n   *\n   * @internal\n   */\n  _isOptionsAPI?: boolean\n\n  /**\n   * Used by devtools plugin to retrieve properties added with plugins. Removed\n   * in production. Can be used by the user to add property keys of the store\n   * that should be displayed in devtools.\n   */\n  _customProperties: Set<string>\n\n  /**\n   * Handles a HMR replacement of this store. Dev Only.\n   *\n   * @internal\n   */\n  _hotUpdate(useStore: StoreGeneric): void\n\n  /**\n   * Allows pausing some of the watching mechanisms while the store is being\n   * patched with a newer version.\n   *\n   * @internal\n   */\n  _hotUpdating: boolean\n\n  /**\n   * Payload of the hmr update. Dev only.\n   *\n   * @internal\n   */\n  _hmrPayload: {\n    state: string[]\n    hotState: Ref<StateTree>\n    actions: _ActionsTree\n    getters: _ActionsTree\n  }\n}\n\n/**\n * Base store with state and functions. Should not be used directly.\n */\nexport interface _StoreWithState<\n  Id extends string,\n  S extends StateTree,\n  G /* extends GettersTree<StateTree> */,\n  A /* extends ActionsTree */\n> extends StoreProperties<Id> {\n  /**\n   * State of the Store. Setting it will internally call `$patch()` to update the state.\n   */\n  $state: UnwrapRef<S> & PiniaCustomStateProperties<S>\n\n  /**\n   * Applies a state patch to current state. Allows passing nested values\n   *\n   * @param partialState - patch to apply to the state\n   */\n  $patch(partialState: _DeepPartial<UnwrapRef<S>>): void\n\n  /**\n   * Group multiple changes into one function. Useful when mutating objects like\n   * Sets or arrays and applying an object patch isn't practical, e.g. appending\n   * to an array. The function passed to `$patch()` **must be synchronous**.\n   *\n   * @param stateMutator - function that mutates `state`, cannot be asynchronous\n   */\n  $patch<F extends (state: UnwrapRef<S>) => any>(\n    // this prevents the user from using `async` which isn't allowed\n    stateMutator: ReturnType<F> extends Promise<any> ? never : F\n  ): void\n\n  /**\n   * Resets the store to its initial state by building a new state object.\n   * TODO: make this options only\n   */\n  $reset(): void\n\n  /**\n   * Setups a callback to be called whenever the state changes. It also returns a function to remove the callback. Note\n   * that when calling `store.$subscribe()` inside of a component, it will be automatically cleaned up when the\n   * component gets unmounted unless `detached` is set to true.\n   *\n   * @param callback - callback passed to the watcher\n   * @param options - `watch` options + `detached` to detach the subscription from the context (usually a component)\n   * this is called from. Note that the `flush` option does not affect calls to `store.$patch()`.\n   * @returns function that removes the watcher\n   */\n  $subscribe(\n    callback: SubscriptionCallback<S>,\n    options?: { detached?: boolean } & WatchOptions\n  ): () => void\n\n  /**\n   * Setups a callback to be called every time an action is about to get\n   * invoked. The callback receives an object with all the relevant information\n   * of the invoked action:\n   * - `store`: the store it is invoked on\n   * - `name`: The name of the action\n   * - `args`: The parameters passed to the action\n   *\n   * On top of these, it receives two functions that allow setting up a callback\n   * once the action finishes or when it fails.\n   *\n   * It also returns a function to remove the callback. Note than when calling\n   * `store.$onAction()` inside of a component, it will be automatically cleaned\n   * up when the component gets unmounted unless `detached` is set to true.\n   *\n   * @example\n   *\n   *```js\n   *store.$onAction(({ after, onError }) => {\n   *  // Here you could share variables between all of the hooks as well as\n   *  // setting up watchers and clean them up\n   *  after((resolvedValue) => {\n   *    // can be used to cleanup side effects\n   * .  // `resolvedValue` is the value returned by the action, if it's a\n   * .  // Promise, it will be the resolved value instead of the Promise\n   *  })\n   *  onError((error) => {\n   *    // can be used to pass up errors\n   *  })\n   *})\n   *```\n   *\n   * @param callback - callback called before every action\n   * @param detached - detach the subscription from the context this is called from\n   * @returns function that removes the watcher\n   */\n  $onAction(\n    callback: StoreOnActionListener<Id, S, G, A>,\n    detached?: boolean\n  ): () => void\n\n  /**\n   * Stops the associated effect scope of the store and remove it from the store\n   * registry. Plugins can override this method to cleanup any added effects.\n   * e.g. devtools plugin stops displaying disposed stores from devtools.\n   * Note this doesn't delete the state of the store, you have to do it manually with\n   * `delete pinia.state.value[store.$id]` if you want to. If you don't and the\n   * store is used again, it will reuse the previous state.\n   */\n  $dispose(): void\n\n  /**\n   * Vue 2 only. Is the store ready. Used for store cross usage. Getters automatically compute when they are added to\n   * the store, before the store is actually ready, this allows to avoid calling the computed function yet.\n   *\n   * @internal\n   */\n  _r?: boolean\n}\n\n/**\n * Generic type for a function that can infer arguments and return type\n *\n * For internal use **only**\n */\nexport type _Method = (...args: any[]) => any\n\n// export type StoreAction<P extends any[], R> = (...args: P) => R\n// export interface StoreAction<P, R> {\n//   (...args: P[]): R\n// }\n\n// in this type we forget about this because otherwise the type is recursive\n/**\n * Store augmented for actions. For internal usage only.\n * For internal use **only**\n */\nexport type _StoreWithActions<A> = {\n  [k in keyof A]: A[k] extends (...args: infer P) => infer R\n    ? (...args: P) => R\n    : never\n}\n\n/**\n * Store augmented with getters. For internal usage only.\n * For internal use **only**\n */\nexport type _StoreWithGetters<G> = {\n  readonly [k in keyof G]: G[k] extends (...args: any[]) => infer R\n    ? R\n    : UnwrapRef<G[k]>\n}\n\n/**\n * Store type to build a store.\n */\nexport type Store<\n  Id extends string = string,\n  S extends StateTree = {},\n  G /* extends GettersTree<S>*/ = {},\n  // has the actions without the context (this) for typings\n  A /* extends ActionsTree */ = {}\n> = _StoreWithState<Id, S, G, A> &\n  UnwrapRef<S> &\n  _StoreWithGetters<G> &\n  // StoreWithActions<A> &\n  (_ActionsTree extends A ? {} : A) &\n  PiniaCustomProperties<Id, S, G, A> &\n  PiniaCustomStateProperties<S>\n\n/**\n * Generic and type-unsafe version of Store. Doesn't fail on access with\n * strings, making it much easier to write generic functions that do not care\n * about the kind of store that is passed.\n */\nexport type StoreGeneric = Store<\n  string,\n  StateTree,\n  _GettersTree<StateTree>,\n  _ActionsTree\n>\n\n/**\n * Return type of `defineStore()`. Function that allows instantiating a store.\n */\nexport interface StoreDefinition<\n  Id extends string = string,\n  S extends StateTree = StateTree,\n  G /* extends GettersTree<S>*/ = _GettersTree<S>,\n  A /* extends ActionsTree */ = _ActionsTree\n> {\n  /**\n   * Returns a store, creates it if necessary.\n   *\n   * @param pinia - Pinia instance to retrieve the store\n   * @param hot - dev only hot module replacement\n   */\n  (pinia?: Pinia | null | undefined, hot?: StoreGeneric): Store<Id, S, G, A>\n\n  /**\n   * Id of the store. Used by map helpers.\n   */\n  $id: Id\n\n  /**\n   * Dev only pinia for HMR.\n   *\n   * @internal\n   */\n  _pinia?: Pinia\n}\n\n/**\n * Interface to be extended by the user when they add properties through plugins.\n */\nexport interface PiniaCustomProperties<\n  Id extends string = string,\n  S extends StateTree = StateTree,\n  G /* extends GettersTree<S> */ = _GettersTree<S>,\n  A /* extends ActionsTree */ = _ActionsTree\n> {}\n\n/**\n * Properties that are added to every `store.$state` by `pinia.use()`.\n */\nexport interface PiniaCustomStateProperties<S extends StateTree = StateTree> {}\n\n/**\n * Type of an object of Getters that infers the argument. For internal usage only.\n * For internal use **only**\n */\nexport type _GettersTree<S extends StateTree> = Record<\n  string,\n  | ((state: UnwrapRef<S> & UnwrapRef<PiniaCustomStateProperties<S>>) => any)\n  | (() => any)\n>\n\n/**\n * Type of an object of Actions. For internal usage only.\n * For internal use **only**\n */\nexport type _ActionsTree = Record<string, _Method>\n\n/**\n * Type that enables refactoring through IDE.\n * For internal use **only**\n */\nexport type _ExtractStateFromSetupStore_Keys<SS> = keyof {\n  [K in keyof SS as SS[K] extends _Method | ComputedRef ? never : K]: any\n}\n\n/**\n * Type that enables refactoring through IDE.\n * For internal use **only**\n */\nexport type _ExtractActionsFromSetupStore_Keys<SS> = keyof {\n  [K in keyof SS as SS[K] extends _Method ? K : never]: any\n}\n\n/**\n * Type that enables refactoring through IDE.\n * For internal use **only**\n */\nexport type _ExtractGettersFromSetupStore_Keys<SS> = keyof {\n  [K in keyof SS as SS[K] extends ComputedRef ? K : never]: any\n}\n\n/**\n * Type that enables refactoring through IDE.\n * For internal use **only**\n */\nexport type _UnwrapAll<SS> = { [K in keyof SS]: UnwrapRef<SS[K]> }\n\n/**\n * For internal use **only**\n */\nexport type _ExtractStateFromSetupStore<SS> = SS extends undefined | void\n  ? {}\n  : _ExtractStateFromSetupStore_Keys<SS> extends keyof SS\n  ? _UnwrapAll<Pick<SS, _ExtractStateFromSetupStore_Keys<SS>>>\n  : never\n\n/**\n * For internal use **only**\n */\nexport type _ExtractActionsFromSetupStore<SS> = SS extends undefined | void\n  ? {}\n  : _ExtractActionsFromSetupStore_Keys<SS> extends keyof SS\n  ? Pick<SS, _ExtractActionsFromSetupStore_Keys<SS>>\n  : never\n\n/**\n * For internal use **only**\n */\nexport type _ExtractGettersFromSetupStore<SS> = SS extends undefined | void\n  ? {}\n  : _ExtractGettersFromSetupStore_Keys<SS> extends keyof SS\n  ? Pick<SS, _ExtractGettersFromSetupStore_Keys<SS>>\n  : never\n\n/**\n * Options passed to `defineStore()` that are common between option and setup\n * stores. Extend this interface if you want to add custom options to both kinds\n * of stores.\n */\nexport interface DefineStoreOptionsBase<S extends StateTree, Store> {}\n\n/**\n * Options parameter of `defineStore()` for option stores. Can be extended to\n * augment stores with the plugin API. @see {@link DefineStoreOptionsBase}.\n */\nexport interface DefineStoreOptions<\n  Id extends string,\n  S extends StateTree,\n  G /* extends GettersTree<S> */,\n  A /* extends Record<string, StoreAction> */\n> extends DefineStoreOptionsBase<S, Store<Id, S, G, A>> {\n  /**\n   * Unique string key to identify the store across the application.\n   */\n  id: Id\n\n  /**\n   * Function to create a fresh state. **Must be an arrow function** to ensure\n   * correct typings!\n   */\n  state?: () => S\n\n  /**\n   * Optional object of getters.\n   */\n  getters?: G &\n    ThisType<UnwrapRef<S> & _StoreWithGetters<G> & PiniaCustomProperties> &\n    _GettersTree<S>\n\n  /**\n   * Optional object of actions.\n   */\n  actions?: A &\n    ThisType<\n      A &\n        UnwrapRef<S> &\n        _StoreWithState<Id, S, G, A> &\n        _StoreWithGetters<G> &\n        PiniaCustomProperties\n    >\n\n  /**\n   * Allows hydrating the store during SSR when complex state (like client side only refs) are used in the store\n   * definition and copying the value from `pinia.state` isn't enough.\n   *\n   * @example\n   * If in your `state`, you use any `customRef`s, any `computed`s, or any `ref`s that have a different value on\n   * Server and Client, you need to manually hydrate them. e.g., a custom ref that is stored in the local\n   * storage:\n   *\n   * ```ts\n   * const useStore = defineStore('main', {\n   *   state: () => ({\n   *     n: useLocalStorage('key', 0)\n   *   }),\n   *   hydrate(storeState, initialState) {\n   *     // @ts-expect-error: https://github.com/microsoft/TypeScript/issues/43826\n   *     storeState.n = useLocalStorage('key', 0)\n   *   }\n   * })\n   * ```\n   *\n   * @param storeState - the current state in the store\n   * @param initialState - initialState\n   */\n  hydrate?(storeState: UnwrapRef<S>, initialState: UnwrapRef<S>): void\n}\n\n/**\n * Options parameter of `defineStore()` for setup stores. Can be extended to\n * augment stores with the plugin API. @see {@link DefineStoreOptionsBase}.\n */\nexport interface DefineSetupStoreOptions<\n  Id extends string,\n  // NOTE: Passing SS seems to make TS crash\n  S extends StateTree,\n  G,\n  A /* extends ActionsTree */\n> extends DefineStoreOptionsBase<S, Store<Id, S, G, A>> {\n  /**\n   * Extracted actions. Added by useStore(). SHOULD NOT be added by the user when\n   * creating the store. Can be used in plugins to get the list of actions in a\n   * store defined with a setup function. Note this is always defined\n   */\n  actions?: A\n}\n\n/**\n * Available `options` when creating a pinia plugin.\n */\nexport interface DefineStoreOptionsInPlugin<\n  Id extends string,\n  S extends StateTree,\n  G,\n  A\n> extends Omit<DefineStoreOptions<Id, S, G, A>, 'id' | 'actions'> {\n  /**\n   * Extracted object of actions. Added by useStore() when the store is built\n   * using the setup API, otherwise uses the one passed to `defineStore()`.\n   * Defaults to an empty object if no actions are defined.\n   */\n  actions: A\n}\n","export const IS_CLIENT = typeof window !== 'undefined'\n\n/**\n * Should we add the devtools plugins.\n * - only if dev mode or forced through the prod devtools flag\n * - not in test\n * - only if window exists (could change in the future)\n */\nexport const USE_DEVTOOLS =\n  (__DEV__ || __FEATURE_PROD_DEVTOOLS__) && !__TEST__ && IS_CLIENT\n","import { getCurrentScope, onScopeDispose } from 'vue-demi'\nimport { _Method } from './types'\n\nexport const noop = () => {}\n\nexport function addSubscription<T extends _Method>(\n  subscriptions: T[],\n  callback: T,\n  detached?: boolean,\n  onCleanup: () => void = noop\n) {\n  subscriptions.push(callback)\n\n  const removeSubscription = () => {\n    const idx = subscriptions.indexOf(callback)\n    if (idx > -1) {\n      subscriptions.splice(idx, 1)\n      onCleanup()\n    }\n  }\n\n  if (!detached && getCurrentScope()) {\n    onScopeDispose(removeSubscription)\n  }\n\n  return removeSubscription\n}\n\nexport function triggerSubscriptions<T extends _Method>(\n  subscriptions: T[],\n  ...args: Parameters<T>\n) {\n  subscriptions.slice().forEach((callback) => {\n    callback(...args)\n  })\n}\n","import {\n  watch,\n  computed,\n  inject,\n  hasInjectionContext,\n  getCurrentInstance,\n  reactive,\n  DebuggerEvent,\n  WatchOptions,\n  UnwrapRef,\n  markRaw,\n  isRef,\n  isReactive,\n  effectScope,\n  EffectScope,\n  ComputedRef,\n  toRaw,\n  toRef,\n  toRefs,\n  Ref,\n  ref,\n  set,\n  del,\n  nextTick,\n  isVue2,\n} from 'vue-demi'\nimport {\n  StateTree,\n  SubscriptionCallback,\n  _DeepPartial,\n  isPlainObject,\n  Store,\n  _Method,\n  DefineStoreOptions,\n  StoreDefinition,\n  _GettersTree,\n  MutationType,\n  StoreOnActionListener,\n  _ActionsTree,\n  SubscriptionCallbackMutation,\n  DefineSetupStoreOptions,\n  DefineStoreOptionsInPlugin,\n  StoreGeneric,\n  _StoreWithGetters,\n  _ExtractActionsFromSetupStore,\n  _ExtractGettersFromSetupStore,\n  _ExtractStateFromSetupStore,\n  _StoreWithState,\n} from './types'\nimport { setActivePinia, piniaSymbol, Pinia, activePinia } from './rootStore'\nimport { IS_CLIENT, USE_DEVTOOLS } from './env'\nimport { patchObject } from './hmr'\nimport { addSubscription, triggerSubscriptions, noop } from './subscriptions'\n\nconst fallbackRunWithContext = (fn: () => unknown) => fn()\n\ntype _ArrayType<AT> = AT extends Array<infer T> ? T : never\n\nfunction mergeReactiveObjects<\n  T extends Record<any, unknown> | Map<unknown, unknown> | Set<unknown>\n>(target: T, patchToApply: _DeepPartial<T>): T {\n  // Handle Map instances\n  if (target instanceof Map && patchToApply instanceof Map) {\n    patchToApply.forEach((value, key) => target.set(key, value))\n  }\n  // Handle Set instances\n  if (target instanceof Set && patchToApply instanceof Set) {\n    patchToApply.forEach(target.add, target)\n  }\n\n  // no need to go through symbols because they cannot be serialized anyway\n  for (const key in patchToApply) {\n    if (!patchToApply.hasOwnProperty(key)) continue\n    const subPatch = patchToApply[key]\n    const targetValue = target[key]\n    if (\n      isPlainObject(targetValue) &&\n      isPlainObject(subPatch) &&\n      target.hasOwnProperty(key) &&\n      !isRef(subPatch) &&\n      !isReactive(subPatch)\n    ) {\n      // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n      // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n      // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n      target[key] = mergeReactiveObjects(targetValue, subPatch)\n    } else {\n      // @ts-expect-error: subPatch is a valid value\n      target[key] = subPatch\n    }\n  }\n\n  return target\n}\n\nconst skipHydrateSymbol = __DEV__\n  ? Symbol('pinia:skipHydration')\n  : /* istanbul ignore next */ Symbol()\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap<any, any>()\n\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nexport function skipHydrate<T = any>(obj: T): T {\n  return isVue2\n    ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n      /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\n    : Object.defineProperty(obj, skipHydrateSymbol, {})\n}\n\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj: any) {\n  return isVue2\n    ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\n    : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol)\n}\n\nconst { assign } = Object\n\nfunction isComputed<T>(value: ComputedRef<T> | unknown): value is ComputedRef<T>\nfunction isComputed(o: any): o is ComputedRef {\n  return !!(isRef(o) && (o as any).effect)\n}\n\nfunction createOptionsStore<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A extends _ActionsTree\n>(\n  id: Id,\n  options: DefineStoreOptions<Id, S, G, A>,\n  pinia: Pinia,\n  hot?: boolean\n): Store<Id, S, G, A> {\n  const { state, actions, getters } = options\n\n  const initialState: StateTree | undefined = pinia.state.value[id]\n\n  let store: Store<Id, S, G, A>\n\n  function setup() {\n    if (!initialState && (!__DEV__ || !hot)) {\n      /* istanbul ignore if */\n      if (isVue2) {\n        set(pinia.state.value, id, state ? state() : {})\n      } else {\n        pinia.state.value[id] = state ? state() : {}\n      }\n    }\n\n    // avoid creating a state in pinia.state.value\n    const localState =\n      __DEV__ && hot\n        ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n          toRefs(ref(state ? state() : {}).value)\n        : toRefs(pinia.state.value[id])\n\n    return assign(\n      localState,\n      actions,\n      Object.keys(getters || {}).reduce((computedGetters, name) => {\n        if (__DEV__ && name in localState) {\n          console.warn(\n            `[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`\n          )\n        }\n\n        computedGetters[name] = markRaw(\n          computed(() => {\n            setActivePinia(pinia)\n            // it was created just before\n            const store = pinia._s.get(id)!\n\n            // allow cross using stores\n            /* istanbul ignore next */\n            if (isVue2 && !store._r) return\n\n            // @ts-expect-error\n            // return getters![name].call(context, context)\n            // TODO: avoid reading the getter while assigning with a global variable\n            return getters![name].call(store, store)\n          })\n        )\n        return computedGetters\n      }, {} as Record<string, ComputedRef>)\n    )\n  }\n\n  store = createSetupStore(id, setup, options, pinia, hot, true)\n\n  return store as any\n}\n\nfunction createSetupStore<\n  Id extends string,\n  SS extends Record<any, unknown>,\n  S extends StateTree,\n  G extends Record<string, _Method>,\n  A extends _ActionsTree\n>(\n  $id: Id,\n  setup: () => SS,\n  options:\n    | DefineSetupStoreOptions<Id, S, G, A>\n    | DefineStoreOptions<Id, S, G, A> = {},\n  pinia: Pinia,\n  hot?: boolean,\n  isOptionsStore?: boolean\n): Store<Id, S, G, A> {\n  let scope!: EffectScope\n\n  const optionsForPlugin: DefineStoreOptionsInPlugin<Id, S, G, A> = assign(\n    { actions: {} as A },\n    options\n  )\n\n  /* istanbul ignore if */\n  if (__DEV__ && !pinia._e.active) {\n    throw new Error('Pinia destroyed')\n  }\n\n  // watcher options for $subscribe\n  const $subscribeOptions: WatchOptions = {\n    deep: true,\n    // flush: 'post',\n  }\n  /* istanbul ignore else */\n  if (__DEV__ && !isVue2) {\n    $subscribeOptions.onTrigger = (event) => {\n      /* istanbul ignore else */\n      if (isListening) {\n        debuggerEvents = event\n        // avoid triggering this while the store is being built and the state is being set in pinia\n      } else if (isListening == false && !store._hotUpdating) {\n        // let patch send all the events together later\n        /* istanbul ignore else */\n        if (Array.isArray(debuggerEvents)) {\n          debuggerEvents.push(event)\n        } else {\n          console.error(\n            '🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.'\n          )\n        }\n      }\n    }\n  }\n\n  // internal state\n  let isListening: boolean // set to true at the end\n  let isSyncListening: boolean // set to true at the end\n  let subscriptions: SubscriptionCallback<S>[] = []\n  let actionSubscriptions: StoreOnActionListener<Id, S, G, A>[] = []\n  let debuggerEvents: DebuggerEvent[] | DebuggerEvent\n  const initialState = pinia.state.value[$id] as UnwrapRef<S> | undefined\n\n  // avoid setting the state for option stores if it is set\n  // by the setup\n  if (!isOptionsStore && !initialState && (!__DEV__ || !hot)) {\n    /* istanbul ignore if */\n    if (isVue2) {\n      set(pinia.state.value, $id, {})\n    } else {\n      pinia.state.value[$id] = {}\n    }\n  }\n\n  const hotState = ref({} as S)\n\n  // avoid triggering too many listeners\n  // https://github.com/vuejs/pinia/issues/1129\n  let activeListener: Symbol | undefined\n  function $patch(stateMutation: (state: UnwrapRef<S>) => void): void\n  function $patch(partialState: _DeepPartial<UnwrapRef<S>>): void\n  function $patch(\n    partialStateOrMutator:\n      | _DeepPartial<UnwrapRef<S>>\n      | ((state: UnwrapRef<S>) => void)\n  ): void {\n    let subscriptionMutation: SubscriptionCallbackMutation<S>\n    isListening = isSyncListening = false\n    // reset the debugger events since patches are sync\n    /* istanbul ignore else */\n    if (__DEV__) {\n      debuggerEvents = []\n    }\n    if (typeof partialStateOrMutator === 'function') {\n      partialStateOrMutator(pinia.state.value[$id] as UnwrapRef<S>)\n      subscriptionMutation = {\n        type: MutationType.patchFunction,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    } else {\n      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)\n      subscriptionMutation = {\n        type: MutationType.patchObject,\n        payload: partialStateOrMutator,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    }\n    const myListenerId = (activeListener = Symbol())\n    nextTick().then(() => {\n      if (activeListener === myListenerId) {\n        isListening = true\n      }\n    })\n    isSyncListening = true\n    // because we paused the watcher, we need to manually call the subscriptions\n    triggerSubscriptions(\n      subscriptions,\n      subscriptionMutation,\n      pinia.state.value[$id] as UnwrapRef<S>\n    )\n  }\n\n  const $reset = isOptionsStore\n    ? function $reset(this: _StoreWithState<Id, S, G, A>) {\n        const { state } = options as DefineStoreOptions<Id, S, G, A>\n        const newState = state ? state() : {}\n        // we use a patch to group all changes into one single subscription\n        this.$patch(($state) => {\n          assign($state, newState)\n        })\n      }\n    : /* istanbul ignore next */\n    __DEV__\n    ? () => {\n        throw new Error(\n          `🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`\n        )\n      }\n    : noop\n\n  function $dispose() {\n    scope.stop()\n    subscriptions = []\n    actionSubscriptions = []\n    pinia._s.delete($id)\n  }\n\n  /**\n   * Wraps an action to handle subscriptions.\n   *\n   * @param name - name of the action\n   * @param action - action to wrap\n   * @returns a wrapped action to handle subscriptions\n   */\n  function wrapAction(name: string, action: _Method) {\n    return function (this: any) {\n      setActivePinia(pinia)\n      const args = Array.from(arguments)\n\n      const afterCallbackList: Array<(resolvedReturn: any) => any> = []\n      const onErrorCallbackList: Array<(error: unknown) => unknown> = []\n      function after(callback: _ArrayType<typeof afterCallbackList>) {\n        afterCallbackList.push(callback)\n      }\n      function onError(callback: _ArrayType<typeof onErrorCallbackList>) {\n        onErrorCallbackList.push(callback)\n      }\n\n      // @ts-expect-error\n      triggerSubscriptions(actionSubscriptions, {\n        args,\n        name,\n        store,\n        after,\n        onError,\n      })\n\n      let ret: any\n      try {\n        ret = action.apply(this && this.$id === $id ? this : store, args)\n        // handle sync errors\n      } catch (error) {\n        triggerSubscriptions(onErrorCallbackList, error)\n        throw error\n      }\n\n      if (ret instanceof Promise) {\n        return ret\n          .then((value) => {\n            triggerSubscriptions(afterCallbackList, value)\n            return value\n          })\n          .catch((error) => {\n            triggerSubscriptions(onErrorCallbackList, error)\n            return Promise.reject(error)\n          })\n      }\n\n      // trigger after callbacks\n      triggerSubscriptions(afterCallbackList, ret)\n      return ret\n    }\n  }\n\n  const _hmrPayload = /*#__PURE__*/ markRaw({\n    actions: {} as Record<string, any>,\n    getters: {} as Record<string, Ref>,\n    state: [] as string[],\n    hotState,\n  })\n\n  const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n    $subscribe(callback, options = {}) {\n      const removeSubscription = addSubscription(\n        subscriptions,\n        callback,\n        options.detached,\n        () => stopWatcher()\n      )\n      const stopWatcher = scope.run(() =>\n        watch(\n          () => pinia.state.value[$id] as UnwrapRef<S>,\n          (state) => {\n            if (options.flush === 'sync' ? isSyncListening : isListening) {\n              callback(\n                {\n                  storeId: $id,\n                  type: MutationType.direct,\n                  events: debuggerEvents as DebuggerEvent,\n                },\n                state\n              )\n            }\n          },\n          assign({}, $subscribeOptions, options)\n        )\n      )!\n\n      return removeSubscription\n    },\n    $dispose,\n  } as _StoreWithState<Id, S, G, A>\n\n  /* istanbul ignore if */\n  if (isVue2) {\n    // start as non ready\n    partialStore._r = false\n  }\n\n  const store: Store<Id, S, G, A> = reactive(\n    __DEV__ || USE_DEVTOOLS\n      ? assign(\n          {\n            _hmrPayload,\n            _customProperties: markRaw(new Set<string>()), // devtools custom properties\n          },\n          partialStore\n          // must be added later\n          // setupStore\n        )\n      : partialStore\n  ) as unknown as Store<Id, S, G, A>\n\n  // store the partial store now so the setup of stores can instantiate each other before they are finished without\n  // creating infinite loops.\n  pinia._s.set($id, store)\n\n  const runWithContext =\n    (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext\n\n  // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n  const setupStore = runWithContext(() =>\n    pinia._e.run(() => (scope = effectScope()).run(setup)!)\n  )!\n\n  // overwrite existing actions to support $onAction\n  for (const key in setupStore) {\n    const prop = setupStore[key]\n\n    if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n      // mark it as a piece of state to be serialized\n      if (__DEV__ && hot) {\n        set(hotState.value, key, toRef(setupStore as any, key))\n        // createOptionStore directly sets the state in pinia.state.value so we\n        // can just skip that\n      } else if (!isOptionsStore) {\n        // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n        if (initialState && shouldHydrate(prop)) {\n          if (isRef(prop)) {\n            prop.value = initialState[key]\n          } else {\n            // probably a reactive object, lets recursively assign\n            // @ts-expect-error: prop is unknown\n            mergeReactiveObjects(prop, initialState[key])\n          }\n        }\n        // transfer the ref to the pinia state to keep everything in sync\n        /* istanbul ignore if */\n        if (isVue2) {\n          set(pinia.state.value[$id], key, prop)\n        } else {\n          pinia.state.value[$id][key] = prop\n        }\n      }\n\n      /* istanbul ignore else */\n      if (__DEV__) {\n        _hmrPayload.state.push(key)\n      }\n      // action\n    } else if (typeof prop === 'function') {\n      // @ts-expect-error: we are overriding the function we avoid wrapping if\n      const actionValue = __DEV__ && hot ? prop : wrapAction(key, prop)\n      // this a hot module replacement store because the hotUpdate method needs\n      // to do it with the right context\n      /* istanbul ignore if */\n      if (isVue2) {\n        set(setupStore, key, actionValue)\n      } else {\n        // @ts-expect-error\n        setupStore[key] = actionValue\n      }\n\n      /* istanbul ignore else */\n      if (__DEV__) {\n        _hmrPayload.actions[key] = prop\n      }\n\n      // list actions so they can be used in plugins\n      // @ts-expect-error\n      optionsForPlugin.actions[key] = prop\n    } else if (__DEV__) {\n      // add getters for devtools\n      if (isComputed(prop)) {\n        _hmrPayload.getters[key] = isOptionsStore\n          ? // @ts-expect-error\n            options.getters[key]\n          : prop\n        if (IS_CLIENT) {\n          const getters: string[] =\n            (setupStore._getters as string[]) ||\n            // @ts-expect-error: same\n            ((setupStore._getters = markRaw([])) as string[])\n          getters.push(key)\n        }\n      }\n    }\n  }\n\n  // add the state, getters, and action properties\n  /* istanbul ignore if */\n  if (isVue2) {\n    Object.keys(setupStore).forEach((key) => {\n      set(store, key, setupStore[key])\n    })\n  } else {\n    assign(store, setupStore)\n    // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n    // Make `storeToRefs()` work with `reactive()` #799\n    assign(toRaw(store), setupStore)\n  }\n\n  // use this instead of a computed with setter to be able to create it anywhere\n  // without linking the computed lifespan to wherever the store is first\n  // created.\n  Object.defineProperty(store, '$state', {\n    get: () => (__DEV__ && hot ? hotState.value : pinia.state.value[$id]),\n    set: (state) => {\n      /* istanbul ignore if */\n      if (__DEV__ && hot) {\n        throw new Error('cannot set hotState')\n      }\n      $patch(($state) => {\n        assign($state, state)\n      })\n    },\n  })\n\n  // add the hotUpdate before plugins to allow them to override it\n  /* istanbul ignore else */\n  if (__DEV__) {\n    store._hotUpdate = markRaw((newStore) => {\n      store._hotUpdating = true\n      newStore._hmrPayload.state.forEach((stateKey) => {\n        if (stateKey in store.$state) {\n          const newStateTarget = newStore.$state[stateKey]\n          const oldStateSource = store.$state[stateKey]\n          if (\n            typeof newStateTarget === 'object' &&\n            isPlainObject(newStateTarget) &&\n            isPlainObject(oldStateSource)\n          ) {\n            patchObject(newStateTarget, oldStateSource)\n          } else {\n            // transfer the ref\n            newStore.$state[stateKey] = oldStateSource\n          }\n        }\n        // patch direct access properties to allow store.stateProperty to work as\n        // store.$state.stateProperty\n        set(store, stateKey, toRef(newStore.$state, stateKey))\n      })\n\n      // remove deleted state properties\n      Object.keys(store.$state).forEach((stateKey) => {\n        if (!(stateKey in newStore.$state)) {\n          del(store, stateKey)\n        }\n      })\n\n      // avoid devtools logging this as a mutation\n      isListening = false\n      isSyncListening = false\n      pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState')\n      isSyncListening = true\n      nextTick().then(() => {\n        isListening = true\n      })\n\n      for (const actionName in newStore._hmrPayload.actions) {\n        const action: _Method = newStore[actionName]\n\n        set(store, actionName, wrapAction(actionName, action))\n      }\n\n      // TODO: does this work in both setup and option store?\n      for (const getterName in newStore._hmrPayload.getters) {\n        const getter: _Method = newStore._hmrPayload.getters[getterName]\n        const getterValue = isOptionsStore\n          ? // special handling of options api\n            computed(() => {\n              setActivePinia(pinia)\n              return getter.call(store, store)\n            })\n          : getter\n\n        set(store, getterName, getterValue)\n      }\n\n      // remove deleted getters\n      Object.keys(store._hmrPayload.getters).forEach((key) => {\n        if (!(key in newStore._hmrPayload.getters)) {\n          del(store, key)\n        }\n      })\n\n      // remove old actions\n      Object.keys(store._hmrPayload.actions).forEach((key) => {\n        if (!(key in newStore._hmrPayload.actions)) {\n          del(store, key)\n        }\n      })\n\n      // update the values used in devtools and to allow deleting new properties later on\n      store._hmrPayload = newStore._hmrPayload\n      store._getters = newStore._getters\n      store._hotUpdating = false\n    })\n  }\n\n  if (USE_DEVTOOLS) {\n    const nonEnumerable = {\n      writable: true,\n      configurable: true,\n      // avoid warning on devtools trying to display this property\n      enumerable: false,\n    }\n\n    // avoid listing internal properties in devtools\n    ;(['_p', '_hmrPayload', '_getters', '_customProperties'] as const).forEach(\n      (p) => {\n        Object.defineProperty(\n          store,\n          p,\n          assign({ value: store[p] }, nonEnumerable)\n        )\n      }\n    )\n  }\n\n  /* istanbul ignore if */\n  if (isVue2) {\n    // mark the store as ready before plugins\n    store._r = true\n  }\n\n  // apply all plugins\n  pinia._p.forEach((extender) => {\n    /* istanbul ignore else */\n    if (USE_DEVTOOLS) {\n      const extensions = scope.run(() =>\n        extender({\n          store,\n          app: pinia._a,\n          pinia,\n          options: optionsForPlugin,\n        })\n      )!\n      Object.keys(extensions || {}).forEach((key) =>\n        store._customProperties.add(key)\n      )\n      assign(store, extensions)\n    } else {\n      assign(\n        store,\n        scope.run(() =>\n          extender({\n            store,\n            app: pinia._a,\n            pinia,\n            options: optionsForPlugin,\n          })\n        )!\n      )\n    }\n  })\n\n  if (\n    __DEV__ &&\n    store.$state &&\n    typeof store.$state === 'object' &&\n    typeof store.$state.constructor === 'function' &&\n    !store.$state.constructor.toString().includes('[native code]')\n  ) {\n    console.warn(\n      `[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\n        `\\tstate: () => new MyClass()\\n` +\n        `Found in store \"${store.$id}\".`\n    )\n  }\n\n  // only apply hydrate to option stores with an initial state in pinia\n  if (\n    initialState &&\n    isOptionsStore &&\n    (options as DefineStoreOptions<Id, S, G, A>).hydrate\n  ) {\n    ;(options as DefineStoreOptions<Id, S, G, A>).hydrate!(\n      store.$state,\n      initialState\n    )\n  }\n\n  isListening = true\n  isSyncListening = true\n  return store\n}\n\n/**\n * Extract the actions of a store type. Works with both a Setup Store or an\n * Options Store.\n */\nexport type StoreActions<SS> = SS extends Store<\n  string,\n  StateTree,\n  _GettersTree<StateTree>,\n  infer A\n>\n  ? A\n  : _ExtractActionsFromSetupStore<SS>\n\n/**\n * Extract the getters of a store type. Works with both a Setup Store or an\n * Options Store.\n */\nexport type StoreGetters<SS> = SS extends Store<\n  string,\n  StateTree,\n  infer G,\n  _ActionsTree\n>\n  ? _StoreWithGetters<G>\n  : _ExtractGettersFromSetupStore<SS>\n\n/**\n * Extract the state of a store type. Works with both a Setup Store or an\n * Options Store. Note this unwraps refs.\n */\nexport type StoreState<SS> = SS extends Store<\n  string,\n  infer S,\n  _GettersTree<StateTree>,\n  _ActionsTree\n>\n  ? UnwrapRef<S>\n  : _ExtractStateFromSetupStore<SS>\n\n// type a1 = _ExtractStateFromSetupStore<{ a: Ref<number>; action: () => void }>\n// type a2 = _ExtractActionsFromSetupStore<{ a: Ref<number>; action: () => void }>\n// type a3 = _ExtractGettersFromSetupStore<{\n//   a: Ref<number>\n//   b: ComputedRef<string>\n//   action: () => void\n// }>\n\n/**\n * Creates a `useStore` function that retrieves the store instance\n *\n * @param id - id of the store (must be unique)\n * @param options - options to define the store\n */\nexport function defineStore<\n  Id extends string,\n  S extends StateTree = {},\n  G extends _GettersTree<S> = {},\n  // cannot extends ActionsTree because we loose the typings\n  A /* extends ActionsTree */ = {}\n>(\n  id: Id,\n  options: Omit<DefineStoreOptions<Id, S, G, A>, 'id'>\n): StoreDefinition<Id, S, G, A>\n\n/**\n * Creates a `useStore` function that retrieves the store instance\n *\n * @param options - options to define the store\n */\nexport function defineStore<\n  Id extends string,\n  S extends StateTree = {},\n  G extends _GettersTree<S> = {},\n  // cannot extends ActionsTree because we loose the typings\n  A /* extends ActionsTree */ = {}\n>(options: DefineStoreOptions<Id, S, G, A>): StoreDefinition<Id, S, G, A>\n\n/**\n * Creates a `useStore` function that retrieves the store instance\n *\n * @param id - id of the store (must be unique)\n * @param storeSetup - function that defines the store\n * @param options - extra options\n */\nexport function defineStore<Id extends string, SS>(\n  id: Id,\n  storeSetup: () => SS,\n  options?: DefineSetupStoreOptions<\n    Id,\n    _ExtractStateFromSetupStore<SS>,\n    _ExtractGettersFromSetupStore<SS>,\n    _ExtractActionsFromSetupStore<SS>\n  >\n): StoreDefinition<\n  Id,\n  _ExtractStateFromSetupStore<SS>,\n  _ExtractGettersFromSetupStore<SS>,\n  _ExtractActionsFromSetupStore<SS>\n>\nexport function defineStore(\n  // TODO: add proper types from above\n  idOrOptions: any,\n  setup?: any,\n  setupOptions?: any\n): StoreDefinition {\n  let id: string\n  let options:\n    | DefineStoreOptions<\n        string,\n        StateTree,\n        _GettersTree<StateTree>,\n        _ActionsTree\n      >\n    | DefineSetupStoreOptions<\n        string,\n        StateTree,\n        _GettersTree<StateTree>,\n        _ActionsTree\n      >\n\n  const isSetupStore = typeof setup === 'function'\n  if (typeof idOrOptions === 'string') {\n    id = idOrOptions\n    // the option store setup will contain the actual options in this case\n    options = isSetupStore ? setupOptions : setup\n  } else {\n    options = idOrOptions\n    id = idOrOptions.id\n\n    if (__DEV__ && typeof id !== 'string') {\n      throw new Error(\n        `[🍍]: \"defineStore()\" must be passed a store id as its first argument.`\n      )\n    }\n  }\n\n  function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric {\n    const hasContext = hasInjectionContext()\n    pinia =\n      // in test mode, ignore the argument provided as we can always retrieve a\n      // pinia instance with getActivePinia()\n      (__TEST__ && activePinia && activePinia._testing ? null : pinia) ||\n      (hasContext ? inject(piniaSymbol, null) : null)\n    if (pinia) setActivePinia(pinia)\n\n    if (__DEV__ && !activePinia) {\n      throw new Error(\n        `[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n          `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n          `This will fail in production.`\n      )\n    }\n\n    pinia = activePinia!\n\n    if (!pinia._s.has(id)) {\n      // creating the store registers it in `pinia._s`\n      if (isSetupStore) {\n        createSetupStore(id, setup, options, pinia)\n      } else {\n        createOptionsStore(id, options as any, pinia)\n      }\n\n      /* istanbul ignore else */\n      if (__DEV__) {\n        // @ts-expect-error: not the right inferred type\n        useStore._pinia = pinia\n      }\n    }\n\n    const store: StoreGeneric = pinia._s.get(id)!\n\n    if (__DEV__ && hot) {\n      const hotId = '__hot:' + id\n      const newStore = isSetupStore\n        ? createSetupStore(hotId, setup, options, pinia, true)\n        : createOptionsStore(hotId, assign({}, options) as any, pinia, true)\n\n      hot._hotUpdate(newStore)\n\n      // cleanup the state properties and the store from the cache\n      delete pinia.state.value[hotId]\n      pinia._s.delete(hotId)\n    }\n\n    if (__DEV__ && IS_CLIENT) {\n      const currentInstance = getCurrentInstance()\n      // save stores in instances to access them devtools\n      if (\n        currentInstance &&\n        currentInstance.proxy &&\n        // avoid adding stores that are just built for hot module replacement\n        !hot\n      ) {\n        const vm = currentInstance.proxy\n        const cache = '_pStores' in vm ? vm._pStores! : (vm._pStores = {})\n        cache[id] = store\n      }\n    }\n\n    // StoreGeneric cannot be casted towards Store\n    return store as any\n  }\n\n  useStore.$id = id\n\n  return useStore\n}\n\n/**\n * Return type of `defineStore()` with a setup function.\n * - `Id` is a string literal of the store's name\n * - `SS` is the return type of the setup function\n * @see {@link StoreDefinition}\n */\nexport interface SetupStoreDefinition<Id extends string, SS>\n  extends StoreDefinition<\n    Id,\n    _ExtractStateFromSetupStore<SS>,\n    _ExtractGettersFromSetupStore<SS>,\n    _ExtractActionsFromSetupStore<SS>\n  > {}\n","import type { ComponentPublicInstance } from 'vue-demi'\nimport type {\n  _GettersTree,\n  _Method,\n  StateTree,\n  Store,\n  StoreDefinition,\n} from './types'\n\n/**\n * Interface to allow customizing map helpers. Extend this interface with the\n * following properties:\n *\n * - `suffix`: string. Affects the suffix of `mapStores()`, defaults to `Store`.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MapStoresCustomization {\n  // cannot be added or it wouldn't be able to be extended\n  // suffix?: string\n}\n\n/**\n * For internal use **only**.\n */\nexport type _StoreObject<S> = S extends StoreDefinition<\n  infer Ids,\n  infer State,\n  infer Getters,\n  infer Actions\n>\n  ? {\n      [Id in `${Ids}${MapStoresCustomization extends Record<\n        'suffix',\n        infer Suffix\n      >\n        ? Suffix\n        : 'Store'}`]: () => Store<\n        Id extends `${infer RealId}${MapStoresCustomization extends Record<\n          'suffix',\n          infer Suffix\n        >\n          ? Suffix\n          : 'Store'}`\n          ? RealId\n          : string,\n        State,\n        Getters,\n        Actions\n      >\n    }\n  : {}\n\n/**\n * For internal use **only**.\n */\nexport type _Spread<A extends readonly any[]> = A extends [infer L, ...infer R]\n  ? _StoreObject<L> & _Spread<R>\n  : unknown\n\nexport let mapStoreSuffix = 'Store'\n\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nexport function setMapStoreSuffix(\n  suffix: MapStoresCustomization extends Record<'suffix', infer Suffix>\n    ? Suffix\n    : string // could be 'Store' but that would be annoying for JS\n): void {\n  mapStoreSuffix = suffix\n}\n\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nexport function mapStores<Stores extends any[]>(\n  ...stores: [...Stores]\n): _Spread<Stores> {\n  if (__DEV__ && Array.isArray(stores[0])) {\n    console.warn(\n      `[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n        `Replace\\n` +\n        `\\tmapStores([useAuthStore, useCartStore])\\n` +\n        `with\\n` +\n        `\\tmapStores(useAuthStore, useCartStore)\\n` +\n        `This will fail in production if not fixed.`\n    )\n    stores = stores[0]\n  }\n\n  return stores.reduce((reduced, useStore) => {\n    // @ts-expect-error: $id is added by defineStore\n    reduced[useStore.$id + mapStoreSuffix] = function (\n      this: ComponentPublicInstance\n    ) {\n      return useStore(this.$pinia)\n    }\n    return reduced\n  }, {} as _Spread<Stores>)\n}\n\n/**\n * For internal use **only**\n */\nexport type _MapStateReturn<\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  Keys extends keyof S | keyof G = keyof S | keyof G\n> = {\n  // [key in keyof S | keyof G]: () => key extends keyof S\n  //   ? S[key]\n  //   : key extends keyof G\n  //   ? G[key]\n  //   : never\n  [key in Keys]: () => Store<string, S, G, {}>[key]\n}\n\n/**\n * For internal use **only**\n */\nexport type _MapStateObjectReturn<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  T extends Record<\n    string,\n    keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)\n  > = {}\n> = {\n  [key in keyof T]: () => T[key] extends (store: any) => infer R\n    ? R\n    : T[key] extends keyof Store<Id, S, G, A>\n    ? Store<Id, S, G, A>[T[key]]\n    : never\n}\n\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component. The values of the object are the state properties/getters\n * while the keys are the names of the resulting computed properties.\n * Optionally, you can also pass a custom function that will receive the store\n * as its first argument. Note that while it has access to the component\n * instance via `this`, it won't be typed.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     // useCounterStore has a state property named `count` and a getter `double`\n *     ...mapState(useCounterStore, {\n *       n: 'count',\n *       triple: store => store.n * 3,\n *       // note we can't use an arrow function if we want to use `this`\n *       custom(store) {\n *         return this.someComponentValue + store.n\n *       },\n *       doubleN: 'double'\n *     })\n *   },\n *\n *   created() {\n *     this.n // 2\n *     this.doubleN // 4\n *   }\n * }\n * ```\n *\n * @param useStore - store to map from\n * @param keyMapper - object of state properties or getters\n */\nexport function mapState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  KeyMapper extends Record<\n    string,\n    keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)\n  >\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keyMapper: KeyMapper\n): _MapStateObjectReturn<Id, S, G, A, KeyMapper>\n\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapState(useCounterStore, ['count', 'double'])\n *   },\n *\n *   created() {\n *     this.count // 2\n *     this.double // 4\n *   }\n * }\n * ```\n *\n * @param useStore - store to map from\n * @param keys - array of state properties or getters\n */\nexport function mapState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  Keys extends keyof S | keyof G\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keys: readonly Keys[]\n): _MapStateReturn<S, G, Keys>\n\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nexport function mapState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keysOrMapper: any\n): _MapStateReturn<S, G> | _MapStateObjectReturn<Id, S, G, A> {\n  return Array.isArray(keysOrMapper)\n    ? keysOrMapper.reduce((reduced, key) => {\n        reduced[key] = function (this: ComponentPublicInstance) {\n          return useStore(this.$pinia)[key]\n        } as () => any\n        return reduced\n      }, {} as _MapStateReturn<S, G>)\n    : Object.keys(keysOrMapper).reduce((reduced, key: string) => {\n        // @ts-expect-error\n        reduced[key] = function (this: ComponentPublicInstance) {\n          const store = useStore(this.$pinia)\n          const storeKey = keysOrMapper[key]\n          // for some reason TS is unable to infer the type of storeKey to be a\n          // function\n          return typeof storeKey === 'function'\n            ? (storeKey as (store: Store<Id, S, G, A>) => any).call(this, store)\n            : store[storeKey]\n        }\n        return reduced\n      }, {} as _MapStateObjectReturn<Id, S, G, A>)\n}\n\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nexport const mapGetters = mapState\n\n/**\n * For internal use **only**\n */\nexport type _MapActionsReturn<A> = {\n  [key in keyof A]: A[key]\n}\n\n/**\n * For internal use **only**\n */\nexport type _MapActionsObjectReturn<A, T extends Record<string, keyof A>> = {\n  [key in keyof T]: A[T[key]]\n}\n\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component. The values of the object are the actions while the keys are\n * the names of the resulting methods.\n *\n * @example\n * ```js\n * export default {\n *   methods: {\n *     // other methods properties\n *     // useCounterStore has two actions named `increment` and `setCount`\n *     ...mapActions(useCounterStore, { moar: 'increment', setIt: 'setCount' })\n *   },\n *\n *   created() {\n *     this.moar()\n *     this.setIt(2)\n *   }\n * }\n * ```\n *\n * @param useStore - store to map from\n * @param keyMapper - object to define new names for the actions\n */\nexport function mapActions<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  KeyMapper extends Record<string, keyof A>\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keyMapper: KeyMapper\n): _MapActionsObjectReturn<A, KeyMapper>\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @example\n * ```js\n * export default {\n *   methods: {\n *     // other methods properties\n *     ...mapActions(useCounterStore, ['increment', 'setCount'])\n *   },\n *\n *   created() {\n *     this.increment()\n *     this.setCount(2) // pass arguments as usual\n *   }\n * }\n * ```\n *\n * @param useStore - store to map from\n * @param keys - array of action names to map\n */\nexport function mapActions<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keys: Array<keyof A>\n): _MapActionsReturn<A>\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nexport function mapActions<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  KeyMapper extends Record<string, keyof A>\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keysOrMapper: Array<keyof A> | KeyMapper\n): _MapActionsReturn<A> | _MapActionsObjectReturn<A, KeyMapper> {\n  return Array.isArray(keysOrMapper)\n    ? keysOrMapper.reduce((reduced, key) => {\n        // @ts-expect-error\n        reduced[key] = function (\n          this: ComponentPublicInstance,\n          ...args: any[]\n        ) {\n          return useStore(this.$pinia)[key](...args)\n        }\n        return reduced\n      }, {} as _MapActionsReturn<A>)\n    : Object.keys(keysOrMapper).reduce((reduced, key: keyof KeyMapper) => {\n        // @ts-expect-error\n        reduced[key] = function (\n          this: ComponentPublicInstance,\n          ...args: any[]\n        ) {\n          return useStore(this.$pinia)[keysOrMapper[key]](...args)\n        }\n        return reduced\n      }, {} as _MapActionsObjectReturn<A, KeyMapper>)\n}\n\n/**\n * For internal use **only**\n */\nexport type _MapWritableStateReturn<S extends StateTree> = {\n  [key in keyof S]: {\n    get: () => S[key]\n    set: (value: S[key]) => any\n  }\n}\n\n/**\n * For internal use **only**\n */\nexport type _MapWritableStateObjectReturn<\n  S extends StateTree,\n  T extends Record<string, keyof S>\n> = {\n  [key in keyof T]: {\n    get: () => S[T[key]]\n    set: (value: S[T[key]]) => any\n  }\n}\n\n/**\n * Same as `mapState()` but creates computed setters as well so the state can be\n * modified. Differently from `mapState()`, only `state` properties can be\n * added.\n *\n * @param useStore - store to map from\n * @param keyMapper - object of state properties\n */\nexport function mapWritableState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  KeyMapper extends Record<string, keyof S>\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keyMapper: KeyMapper\n): _MapWritableStateObjectReturn<S, KeyMapper>\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keys - array of state properties\n */\nexport function mapWritableState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  Keys extends keyof S\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keys: readonly Keys[]\n): {\n  [K in Keys]: {\n    get: () => S[K]\n    set: (value: S[K]) => any\n  }\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nexport function mapWritableState<\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree<S>,\n  A,\n  KeyMapper extends Record<string, keyof S>\n>(\n  useStore: StoreDefinition<Id, S, G, A>,\n  keysOrMapper: Array<keyof S> | KeyMapper\n): _MapWritableStateReturn<S> | _MapWritableStateObjectReturn<S, KeyMapper> {\n  return Array.isArray(keysOrMapper)\n    ? keysOrMapper.reduce((reduced, key) => {\n        // @ts-ignore\n        reduced[key] = {\n          get(this: ComponentPublicInstance) {\n            return useStore(this.$pinia)[key]\n          },\n          set(this: ComponentPublicInstance, value) {\n            // it's easier to type it here as any\n            return (useStore(this.$pinia)[key] = value as any)\n          },\n        }\n        return reduced\n      }, {} as _MapWritableStateReturn<S>)\n    : Object.keys(keysOrMapper).reduce((reduced, key: keyof KeyMapper) => {\n        // @ts-ignore\n        reduced[key] = {\n          get(this: ComponentPublicInstance) {\n            return useStore(this.$pinia)[keysOrMapper[key]]\n          },\n          set(this: ComponentPublicInstance, value) {\n            // it's easier to type it here as any\n            return (useStore(this.$pinia)[keysOrMapper[key]] = value as any)\n          },\n        }\n        return reduced\n      }, {} as _MapWritableStateObjectReturn<S, KeyMapper>)\n}\n","import type { Plugin } from 'vue-demi'\nimport { registerPiniaDevtools } from './devtools'\nimport { IS_CLIENT, USE_DEVTOOLS } from './env'\nimport { Pinia, piniaSymbol, setActivePinia } from './rootStore'\n\n/**\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\n * https://pinia.vuejs.org/ssr/nuxt.html.\n *\n * @example\n * ```js\n * import Vue from 'vue'\n * import { PiniaVuePlugin, createPinia } from 'pinia'\n *\n * Vue.use(PiniaVuePlugin)\n * const pinia = createPinia()\n *\n * new Vue({\n *   el: '#app',\n *   // ...\n *   pinia,\n * })\n * ```\n *\n * @param _Vue - `Vue` imported from 'vue'.\n */\nexport const PiniaVuePlugin: Plugin = function (_Vue) {\n  // Equivalent of\n  // app.config.globalProperties.$pinia = pinia\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options\n      if (options.pinia) {\n        const pinia = options.pinia as Pinia\n        // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\n        /* istanbul ignore else */\n        if (!(this as any)._provided) {\n          const provideCache = {}\n          Object.defineProperty(this, '_provided', {\n            get: () => provideCache,\n            set: (v) => Object.assign(provideCache, v),\n          })\n        }\n        ;(this as any)._provided[piniaSymbol as any] = pinia\n\n        // propagate the pinia instance in an SSR friendly way\n        // avoid adding it to nuxt twice\n        /* istanbul ignore else */\n        if (!this.$pinia) {\n          this.$pinia = pinia\n        }\n\n        pinia._a = this as any\n        if (IS_CLIENT) {\n          // this allows calling useStore() outside of a component setup after\n          // installing pinia's plugin\n          setActivePinia(pinia)\n        }\n        if (USE_DEVTOOLS) {\n          registerPiniaDevtools(pinia._a, pinia)\n        }\n      } else if (!this.$pinia && options.parent && options.parent.$pinia) {\n        this.$pinia = options.parent.$pinia\n      }\n    },\n    destroyed() {\n      delete this._pStores\n    },\n  })\n}\n","import { isRef, isReactive, isVue2, set } from 'vue-demi'\nimport { Pinia } from './rootStore'\nimport {\n  isPlainObject,\n  StateTree,\n  StoreDefinition,\n  StoreGeneric,\n  _GettersTree,\n  _Method,\n  _ActionsTree,\n} from './types'\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nexport const isUseStore = (fn: any): fn is StoreDefinition => {\n  return typeof fn === 'function' && typeof fn.$id === 'string'\n}\n\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nexport function patchObject(\n  newState: Record<string, any>,\n  oldState: Record<string, any>\n): Record<string, any> {\n  // no need to go through symbols because they cannot be serialized anyway\n  for (const key in oldState) {\n    const subPatch = oldState[key]\n\n    // skip the whole sub tree\n    if (!(key in newState)) {\n      continue\n    }\n\n    const targetValue = newState[key]\n    if (\n      isPlainObject(targetValue) &&\n      isPlainObject(subPatch) &&\n      !isRef(subPatch) &&\n      !isReactive(subPatch)\n    ) {\n      newState[key] = patchObject(targetValue, subPatch)\n    } else {\n      // objects are either a bit more complex (e.g. refs) or primitives, so we\n      // just set the whole thing\n      if (isVue2) {\n        set(newState, key, subPatch)\n      } else {\n        newState[key] = subPatch\n      }\n    }\n  }\n\n  return newState\n}\n\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nexport function acceptHMRUpdate<\n  Id extends string = string,\n  S extends StateTree = StateTree,\n  G extends _GettersTree<S> = _GettersTree<S>,\n  A = _ActionsTree\n>(initialUseStore: StoreDefinition<Id, S, G, A>, hot: any) {\n  // strip as much as possible from iife.prod\n  if (!__DEV__) {\n    return () => {}\n  }\n  return (newModule: any) => {\n    const pinia: Pinia | undefined = hot.data.pinia || initialUseStore._pinia\n\n    if (!pinia) {\n      // this store is still not used\n      return\n    }\n\n    // preserve the pinia instance across loads\n    hot.data.pinia = pinia\n\n    // console.log('got data', newStore)\n    for (const exportName in newModule) {\n      const useStore = newModule[exportName]\n      // console.log('checking for', exportName)\n      if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n        // console.log('Accepting update for', useStore.$id)\n        const id = useStore.$id\n\n        if (id !== initialUseStore.$id) {\n          console.warn(\n            `The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`\n          )\n          // return import.meta.hot.invalidate()\n          return hot.invalidate()\n        }\n\n        const existingStore: StoreGeneric = pinia._s.get(id)!\n        if (!existingStore) {\n          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`)\n          return\n        }\n        useStore(pinia, existingStore)\n      }\n    }\n  }\n}\n","import { Pinia, PiniaPlugin, setActivePinia, piniaSymbol } from './rootStore'\nimport { ref, App, markRaw, effectScope, isVue2, Ref } from 'vue-demi'\nimport { registerPiniaDevtools, devtoolsPlugin } from './devtools'\nimport { USE_DEVTOOLS } from './env'\nimport { StateTree, StoreGeneric } from './types'\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nexport function createPinia(): Pinia {\n  const scope = effectScope(true)\n  // NOTE: here we could check the window object for a state and directly set it\n  // if there is anything like it with Vue 3 SSR\n  const state = scope.run<Ref<Record<string, StateTree>>>(() =>\n    ref<Record<string, StateTree>>({})\n  )!\n\n  let _p: Pinia['_p'] = []\n  // plugins added before calling app.use(pinia)\n  let toBeInstalled: PiniaPlugin[] = []\n\n  const pinia: Pinia = markRaw({\n    install(app: App) {\n      // this allows calling useStore() outside of a component setup after\n      // installing pinia's plugin\n      setActivePinia(pinia)\n      if (!isVue2) {\n        pinia._a = app\n        app.provide(piniaSymbol, pinia)\n        app.config.globalProperties.$pinia = pinia\n        /* istanbul ignore else */\n        if (USE_DEVTOOLS) {\n          registerPiniaDevtools(app, pinia)\n        }\n        toBeInstalled.forEach((plugin) => _p.push(plugin))\n        toBeInstalled = []\n      }\n    },\n\n    use(plugin) {\n      if (!this._a && !isVue2) {\n        toBeInstalled.push(plugin)\n      } else {\n        _p.push(plugin)\n      }\n      return this\n    },\n\n    _p,\n    // it's actually undefined here\n    // @ts-expect-error\n    _a: null,\n    _e: scope,\n    _s: new Map<string, StoreGeneric>(),\n    state,\n  })\n\n  // pinia devtools rely on dev only features so they cannot be forced unless\n  // the dev build of Vue is used. Avoid old browsers like IE11.\n  if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\n    pinia.use(devtoolsPlugin)\n  }\n\n  return pinia\n}\n","import {\n  ComputedRef,\n  isReactive,\n  isRef,\n  isVue2,\n  Ref,\n  toRaw,\n  ToRef,\n  toRef,\n  ToRefs,\n  toRefs,\n} from 'vue-demi'\nimport { StoreGetters, StoreState } from './store'\nimport type { PiniaCustomStateProperties, StoreGeneric } from './types'\n\ntype ToComputedRefs<T> = {\n  [K in keyof T]: ToRef<T[K]> extends Ref<infer U>\n    ? ComputedRef<U>\n    : ToRef<T[K]>\n}\n\n/**\n * Extracts the return type for `storeToRefs`.\n * Will convert any `getters` into `ComputedRef`.\n */\nexport type StoreToRefs<SS extends StoreGeneric> = ToRefs<\n  StoreState<SS> & PiniaCustomStateProperties<StoreState<SS>>\n> &\n  ToComputedRefs<StoreGetters<SS>>\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nexport function storeToRefs<SS extends StoreGeneric>(\n  store: SS\n): StoreToRefs<SS> {\n  // See https://github.com/vuejs/pinia/issues/852\n  // It's easier to just use toRefs() even if it includes more stuff\n  if (isVue2) {\n    // @ts-expect-error: toRefs include methods and others\n    return toRefs(store)\n  } else {\n    store = toRaw(store)\n\n    const refs = {} as StoreToRefs<SS>\n    for (const key in store) {\n      const value = store[key]\n      if (isRef(value) || isReactive(value)) {\n        // @ts-expect-error: the key is state or getter\n        refs[key] =\n          // ---\n          toRef(store, key)\n      }\n    }\n\n    return refs\n  }\n}\n"],"names":["activePinia","setActivePinia","pinia","piniaSymbol","Symbol","isPlainObject","o","Object","prototype","toString","call","toJSON","MutationType","exports","IS_CLIENT","window","noop","addSubscription","subscriptions","callback","detached","onCleanup","push","removeSubscription","idx","indexOf","splice","getCurrentScope","onScopeDispose","triggerSubscriptions","args","slice","forEach","fallbackRunWithContext","fn","mergeReactiveObjects","target","patchToApply","Map","value","key","set","Set","add","hasOwnProperty","subPatch","targetValue","isRef","isReactive","skipHydrateSymbol","assign","createSetupStore","$id","setup","options","hot","isOptionsStore","scope","optionsForPlugin","actions","$subscribeOptions","deep","isListening","isSyncListening","debuggerEvents","actionSubscriptions","initialState","state","activeListener","$patch","partialStateOrMutator","subscriptionMutation","type","patchFunction","storeId","events","patchObject","payload","myListenerId","nextTick","then","ref","$reset","newState","this","$state","wrapAction","name","action","Array","from","arguments","afterCallbackList","onErrorCallbackList","ret","store","after","onError","apply","error","Promise","catch","reject","partialStore","_p","$onAction","bind","$subscribe","stopWatcher","run","watch","flush","direct","$dispose","stop","_s","delete","reactive","setupStore","_a","runWithContext","_e","effectScope","prop","effect","obj","actionValue","toRaw","defineProperty","get","extender","app","hydrate","mapStoreSuffix","mapState","useStore","keysOrMapper","isArray","reduce","reduced","$pinia","keys","storeKey","mapGetters","_Vue","mixin","beforeCreate","$options","_provided","provideCache","v","parent","destroyed","_pStores","initialUseStore","toBeInstalled","markRaw","install","provide","config","globalProperties","plugin","use","idOrOptions","setupOptions","id","isSetupStore","hasContext","hasInjectionContext","inject","has","getters","localState","toRefs","computedGetters","computed","createOptionsStore","stores","suffix","refs","toRef"],"mappings":"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"}