var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames253() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      __name(classNames253, "classNames");
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames253.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      __name(parseValue, "parseValue");
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      __name(appendClass, "appendClass");
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames253.default = classNames253;
        module2.exports = classNames253;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames253;
        });
      } else {
        window.classNames = classNames253;
      }
    })();
  }
});

// node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type5) {
          if (typeof type5 === "string" || typeof type5 === "function") {
            return true;
          }
          if (type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type5 === "object" && type5 !== null) {
            if (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        __name(isValidElementType, "isValidElementType");
        function typeOf(object4) {
          if (typeof object4 === "object" && object4 !== null) {
            var $$typeof = object4.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type5 = object4.type;
                switch (type5) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type5;
                  default:
                    var $$typeofType = type5 && type5.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        __name(typeOf, "typeOf");
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment47 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal3 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object4) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        __name(isAsyncMode, "isAsyncMode");
        function isConcurrentMode(object4) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        __name(isConcurrentMode, "isConcurrentMode");
        function isContextConsumer(object4) {
          return typeOf(object4) === REACT_CONTEXT_TYPE;
        }
        __name(isContextConsumer, "isContextConsumer");
        function isContextProvider(object4) {
          return typeOf(object4) === REACT_PROVIDER_TYPE;
        }
        __name(isContextProvider, "isContextProvider");
        function isElement(object4) {
          return typeof object4 === "object" && object4 !== null && object4.$$typeof === REACT_ELEMENT_TYPE;
        }
        __name(isElement, "isElement");
        function isForwardRef(object4) {
          return typeOf(object4) === REACT_FORWARD_REF_TYPE;
        }
        __name(isForwardRef, "isForwardRef");
        function isFragment4(object4) {
          return typeOf(object4) === REACT_FRAGMENT_TYPE;
        }
        __name(isFragment4, "isFragment");
        function isLazy(object4) {
          return typeOf(object4) === REACT_LAZY_TYPE;
        }
        __name(isLazy, "isLazy");
        function isMemo2(object4) {
          return typeOf(object4) === REACT_MEMO_TYPE;
        }
        __name(isMemo2, "isMemo");
        function isPortal(object4) {
          return typeOf(object4) === REACT_PORTAL_TYPE;
        }
        __name(isPortal, "isPortal");
        function isProfiler(object4) {
          return typeOf(object4) === REACT_PROFILER_TYPE;
        }
        __name(isProfiler, "isProfiler");
        function isStrictMode(object4) {
          return typeOf(object4) === REACT_STRICT_MODE_TYPE;
        }
        __name(isStrictMode, "isStrictMode");
        function isSuspense(object4) {
          return typeOf(object4) === REACT_SUSPENSE_TYPE;
        }
        __name(isSuspense, "isSuspense");
        function isSuspenseList(object4) {
          return typeOf(object4) === REACT_SUSPENSE_LIST_TYPE;
        }
        __name(isSuspenseList, "isSuspenseList");
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef2;
        exports.Fragment = Fragment47;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal3;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment4;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo2;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// packages/util/src/warning.ts
var warning_exports = {};
__export(warning_exports, {
  call: () => call,
  default: () => warning_default,
  note: () => note,
  noteOnce: () => noteOnce,
  preMessage: () => preMessage,
  resetWarned: () => resetWarned,
  warning: () => warning,
  warningOnce: () => warningOnce
});
function warning(valid, message2) {
  if (!valid && console !== void 0) {
    const finalMessage = preWarningFns.reduce(
      (msg, preMessageFn) => preMessageFn(msg ?? "", "warning"),
      message2
    );
    if (finalMessage) {
      console.error(`Warning: ${finalMessage}`);
    }
  }
}
function note(valid, message2) {
  if (!valid && console !== void 0) {
    const finalMessage = preWarningFns.reduce(
      (msg, preMessageFn) => preMessageFn(msg ?? "", "note"),
      message2
    );
    if (finalMessage) {
      console.warn(`Note: ${finalMessage}`);
    }
  }
}
function resetWarned() {
  warned = {};
}
function call(method4, valid, message2) {
  if (!valid && !warned[message2]) {
    method4(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid, message2) {
  call(warning, valid, message2);
}
function noteOnce(valid, message2) {
  call(note, valid, message2);
}
var warned, preWarningFns, preMessage, warning_default;
var init_warning = __esm({
  "packages/util/src/warning.ts"() {
    warned = {};
    preWarningFns = [];
    preMessage = /* @__PURE__ */ __name((fn) => {
      preWarningFns.push(fn);
    }, "preMessage");
    __name(warning, "warning");
    __name(note, "note");
    __name(resetWarned, "resetWarned");
    __name(call, "call");
    __name(warningOnce, "warningOnce");
    __name(noteOnce, "noteOnce");
    warningOnce.preMessage = preMessage;
    warningOnce.resetWarned = resetWarned;
    warningOnce.noteOnce = noteOnce;
    warning_default = warningOnce;
  }
});

// packages/util/src/Dom/canUseDom.ts
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var init_canUseDom = __esm({
  "packages/util/src/Dom/canUseDom.ts"() {
    __name(canUseDom, "canUseDom");
  }
});

// packages/util/src/Dom/contains.ts
function contains(root, n2) {
  if (!root) {
    return false;
  }
  if (root.contains) {
    return root.contains(n2);
  }
  let node2 = n2;
  while (node2) {
    if (node2 === root) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var init_contains = __esm({
  "packages/util/src/Dom/contains.ts"() {
    __name(contains, "contains");
  }
});

// packages/util/src/Dom/dynamicCSS.ts
var dynamicCSS_exports = {};
__export(dynamicCSS_exports, {
  clearContainerCache: () => clearContainerCache,
  injectCSS: () => injectCSS,
  removeCSS: () => removeCSS,
  updateCSS: () => updateCSS
});
function getMark({ mark } = {}) {
  if (mark) {
    return mark.startsWith("data-") ? mark : `data-${mark}`;
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  const head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from(
    (containerCache.get(container) || container).children
  ).filter((node2) => node2.tagName === "STYLE");
}
function injectCSS(css, option = {}) {
  if (!canUseDom()) {
    return null;
  }
  const { csp, prepend, priority = 0 } = option;
  const mergedOrder = getOrder(prepend);
  const isPrependQueue = mergedOrder === "prependQueue";
  const styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, mergedOrder);
  if (isPrependQueue && priority) {
    styleNode.setAttribute(APPEND_PRIORITY, `${priority}`);
  }
  if (csp?.nonce) {
    styleNode.nonce = csp?.nonce;
  }
  styleNode.innerHTML = css;
  const container = getContainer(option);
  const { firstChild } = container;
  if (prepend) {
    if (isPrependQueue) {
      const existStyle = (option.styles || findStyles(container)).filter(
        (node2) => {
          if (!["prepend", "prependQueue"].includes(
            node2.getAttribute(APPEND_ORDER)
          )) {
            return false;
          }
          const nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
          return priority >= nodePriority;
        }
      );
      if (existStyle.length) {
        container.insertBefore(
          styleNode,
          existStyle[existStyle.length - 1].nextSibling
        );
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key, option = {}) {
  const container = getContainer(option);
  return (option.styles || findStyles(container)).find(
    (node2) => node2.getAttribute(getMark(option)) === key
  );
}
function removeCSS(key, option = {}) {
  const existNode = findExistNode(key, option);
  if (existNode) {
    const container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  const cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    const placeholderStyle = injectCSS("", option);
    const { parentNode } = placeholderStyle;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function clearContainerCache() {
  containerCache.clear();
}
function updateCSS(css, key, originOption = {}) {
  const container = getContainer(originOption);
  const styles = findStyles(container);
  const option = { ...originOption, styles };
  syncRealContainer(container, option);
  const existNode = findExistNode(key, option);
  if (existNode) {
    if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce) {
      existNode.nonce = option.csp?.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  const newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}
var APPEND_ORDER, APPEND_PRIORITY, MARK_KEY, containerCache;
var init_dynamicCSS = __esm({
  "packages/util/src/Dom/dynamicCSS.ts"() {
    init_canUseDom();
    init_contains();
    APPEND_ORDER = "data-rc-order";
    APPEND_PRIORITY = "data-rc-priority";
    MARK_KEY = `rc-util-key`;
    containerCache = /* @__PURE__ */ new Map();
    __name(getMark, "getMark");
    __name(getContainer, "getContainer");
    __name(getOrder, "getOrder");
    __name(findStyles, "findStyles");
    __name(injectCSS, "injectCSS");
    __name(findExistNode, "findExistNode");
    __name(removeCSS, "removeCSS");
    __name(syncRealContainer, "syncRealContainer");
    __name(clearContainerCache, "clearContainerCache");
    __name(updateCSS, "updateCSS");
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/Context.js
var require_Context = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/Context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = __require("react");
    var IconContext2 = /* @__PURE__ */ (0, _react.createContext)({});
    var _default = IconContext2;
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}
var init_util = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/util.js"() {
    __name(bound01, "bound01");
    __name(clamp01, "clamp01");
    __name(isOnePointZero, "isOnePointZero");
    __name(isPercentage, "isPercentage");
    __name(boundAlpha, "boundAlpha");
    __name(convertToPercentage, "convertToPercentage");
    __name(pad2, "pad2");
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r2, g, b) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r2, g, b);
  var min = Math.min(r2, g, b);
  var h = 0;
  var s = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s = 0;
    h = 0;
  } else {
    var d = max - min;
    s = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, l: l2 };
}
function hue2rgb(p, q, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p + (q - p) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q;
  }
  if (t2 < 2 / 3) {
    return p + (q - p) * (2 / 3 - t2) * 6;
  }
  return p;
}
function hslToRgb(h, s, l2) {
  var r2;
  var g;
  var b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l2 = bound01(l2, 100);
  if (s === 0) {
    g = l2;
    b = l2;
    r2 = l2;
  } else {
    var q = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    var p = 2 * l2 - q;
    r2 = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r2 * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r2, g, b) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r2, g, b);
  var min = Math.min(r2, g, b);
  var h = 0;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;
  if (max === min) {
    h = 0;
  } else {
    switch (max) {
      case r2:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r2) / d + 2;
        break;
      case b:
        h = (r2 - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t2 = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r2 = [v, q, p, p, t2, v][mod];
  var g = [t2, v, v, q, p, p][mod];
  var b = [p, p, t2, v, v, q][mod];
  return { r: r2 * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r2, g, b, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g, b, a, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var init_conversion = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/conversion.js"() {
    init_util();
    __name(rgbToRgb, "rgbToRgb");
    __name(rgbToHsl, "rgbToHsl");
    __name(hue2rgb, "hue2rgb");
    __name(hslToRgb, "hslToRgb");
    __name(rgbToHsv, "rgbToHsv");
    __name(hsvToRgb, "hsvToRgb");
    __name(rgbToHex, "rgbToHex");
    __name(rgbaToHex, "rgbaToHex");
    __name(convertDecimalToHex, "convertDecimalToHex");
    __name(convertHexToDecimal, "convertHexToDecimal");
    __name(parseIntFromHex, "parseIntFromHex");
    __name(numberInputToObject, "numberInputToObject");
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names;
var init_css_color_names = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/css-color-names.js"() {
    names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l2);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var CSS_INTEGER, CSS_NUMBER, CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, matchers;
var init_format_input = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/format-input.js"() {
    init_conversion();
    init_css_color_names();
    init_util();
    __name(inputToRGB, "inputToRGB");
    CSS_INTEGER = "[-\\+]?\\d+%?";
    CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    __name(stringInputToObject, "stringInputToObject");
    __name(isValidCSSUnit, "isValidCSSUnit");
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor;
var init_module = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/index.js"() {
    init_conversion();
    init_css_color_names();
    init_format_input();
    init_util();
    TinyColor = /** @class */
    function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      __name(TinyColor2, "TinyColor");
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R;
        var G;
        var B;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.isMonochrome = function() {
        var s = this.toHsl().s;
        return s === 0;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h = Math.round(hsv.h * 360);
        var s = Math.round(hsv.s * 100);
        var v = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h = Math.round(hsl.h * 360);
        var s = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toHexShortString = function(allowShortChar) {
        if (allowShortChar === void 0) {
          allowShortChar = false;
        }
        return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r2 = Math.round(this.r);
        var g = Math.round(this.g);
        var b = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r2, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = /* @__PURE__ */ __name(function(x) {
          return "".concat(Math.round(bound01(x, 255) * 100), "%");
        }, "fmt");
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = /* @__PURE__ */ __name(function(x) {
          return Math.round(bound01(x, 255) * 100);
        }, "rnd");
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
          var _b = _a[_i], key = _b[0], value = _b[1];
          if (hex2 === value) {
            return key;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h = hsv.h;
        var s = hsv.s;
        var v = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h, s, v }));
          v = (v + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        var alpha = fg.a + bg.a * (1 - fg.a);
        return new TinyColor2({
          r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
          g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
          b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
          a: alpha
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n2) {
        var hsl = this.toHsl();
        var h = hsl.h;
        var result = [this];
        var increment = 360 / n2;
        for (var i = 1; i < n2; i++) {
          result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }();
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/readability.js
var init_readability = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/readability.js"() {
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/to-ms-filter.js
var init_to_ms_filter = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/to-ms-filter.js"() {
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/from-ratio.js
var init_from_ratio = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/from-ratio.js"() {
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/random.js
var init_random = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/random.js"() {
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/interfaces.js
var init_interfaces = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/interfaces.js"() {
  }
});

// node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/public_api.js
var init_public_api = __esm({
  "node_modules/.pnpm/@ctrl+tinycolor@3.6.1/node_modules/@ctrl/tinycolor/dist/module/public_api.js"() {
    init_module();
    init_css_color_names();
    init_readability();
    init_to_ms_filter();
    init_from_ratio();
    init_format_input();
    init_random();
    init_interfaces();
    init_conversion();
  }
});

// packages/ant-design-colors/src/generate.ts
function toHsv({ r: r2, g, b }) {
  const hsv = rgbToHsv(r2, g, b);
  return { h: hsv.h * 360, s: hsv.s, v: hsv.v };
}
function toHex({ r: r2, g, b }) {
  return `#${rgbToHex(r2, g, b, false)}`;
}
function mix(rgb1, rgb2, amount) {
  const p = amount / 100;
  const rgb = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i, light) {
  let hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  let saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i, light) {
  let value;
  if (light) {
    value = hsv.v + brightnessStep1 * i;
  } else {
    value = hsv.v - brightnessStep2 * i;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate(color, opts = {}) {
  const patterns = [];
  const pColor = inputToRGB(color);
  for (let i = lightColorCount; i > 0; i -= 1) {
    const hsv = toHsv(pColor);
    const colorString = toHex(
      inputToRGB({
        h: getHue(hsv, i, true),
        s: getSaturation(hsv, i, true),
        v: getValue(hsv, i, true)
      })
    );
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (let i = 1; i <= darkColorCount; i += 1) {
    const hsv = toHsv(pColor);
    const colorString = toHex(
      inputToRGB({
        h: getHue(hsv, i),
        s: getSaturation(hsv, i),
        v: getValue(hsv, i)
      })
    );
    patterns.push(colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(({ index: index3, opacity }) => {
      const darkColorString = toHex(
        mix(
          inputToRGB(opts.backgroundColor || "#141414"),
          inputToRGB(patterns[index3]),
          opacity * 100
        )
      );
      return darkColorString;
    });
  }
  return patterns;
}
var hueStep, saturationStep, saturationStep2, brightnessStep1, brightnessStep2, lightColorCount, darkColorCount, darkColorMap;
var init_generate = __esm({
  "packages/ant-design-colors/src/generate.ts"() {
    "use strict";
    init_public_api();
    hueStep = 2;
    saturationStep = 0.16;
    saturationStep2 = 0.05;
    brightnessStep1 = 0.05;
    brightnessStep2 = 0.15;
    lightColorCount = 5;
    darkColorCount = 4;
    darkColorMap = [
      { index: 7, opacity: 0.15 },
      { index: 6, opacity: 0.25 },
      { index: 5, opacity: 0.3 },
      { index: 5, opacity: 0.45 },
      { index: 5, opacity: 0.65 },
      { index: 5, opacity: 0.85 },
      { index: 4, opacity: 0.9 },
      { index: 3, opacity: 0.95 },
      { index: 2, opacity: 0.97 },
      { index: 1, opacity: 0.98 }
    ];
    __name(toHsv, "toHsv");
    __name(toHex, "toHex");
    __name(mix, "mix");
    __name(getHue, "getHue");
    __name(getSaturation, "getSaturation");
    __name(getValue, "getValue");
    __name(generate, "generate");
  }
});

// packages/ant-design-colors/src/index.ts
var src_exports = {};
__export(src_exports, {
  blue: () => blue,
  cyan: () => cyan,
  geekblue: () => geekblue,
  generate: () => generate,
  gold: () => gold,
  gray: () => gray,
  green: () => green,
  grey: () => grey,
  lime: () => lime,
  magenta: () => magenta,
  orange: () => orange,
  presetDarkPalettes: () => presetDarkPalettes,
  presetPalettes: () => presetPalettes,
  presetPrimaryColors: () => presetPrimaryColors,
  purple: () => purple,
  red: () => red,
  volcano: () => volcano,
  yellow: () => yellow
});
var presetPrimaryColors, presetPalettes, presetDarkPalettes, red, volcano, gold, orange, yellow, lime, green, cyan, blue, geekblue, purple, magenta, grey, gray;
var init_src = __esm({
  "packages/ant-design-colors/src/index.ts"() {
    "use strict";
    init_generate();
    presetPrimaryColors = {
      red: "#F5222D",
      volcano: "#FA541C",
      orange: "#FA8C16",
      gold: "#FAAD14",
      yellow: "#FADB14",
      lime: "#A0D911",
      green: "#52C41A",
      cyan: "#13C2C2",
      blue: "#1677FF",
      geekblue: "#2F54EB",
      purple: "#722ED1",
      magenta: "#EB2F96",
      grey: "#666666"
    };
    presetPalettes = {};
    presetDarkPalettes = {};
    Object.keys(presetPrimaryColors).forEach((key) => {
      presetPalettes[key] = generate(presetPrimaryColors[key]);
      presetPalettes[key].primary = presetPalettes[key][5];
      presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
        theme: "dark",
        backgroundColor: "#141414"
      });
      presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
    });
    red = presetPalettes.red;
    volcano = presetPalettes.volcano;
    gold = presetPalettes.gold;
    orange = presetPalettes.orange;
    yellow = presetPalettes.yellow;
    lime = presetPalettes.lime;
    green = presetPalettes.green;
    cyan = presetPalettes.cyan;
    blue = presetPalettes.blue;
    geekblue = presetPalettes.geekblue;
    purple = presetPalettes.purple;
    magenta = presetPalettes.magenta;
    grey = presetPalettes.grey;
    gray = presetPalettes.grey;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CheckCircleFilled.js
var require_CheckCircleFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CheckCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CheckCircleFilled8 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
    exports.default = CheckCircleFilled8;
  }
});

// packages/util/src/Dom/shadow.ts
var shadow_exports = {};
__export(shadow_exports, {
  getShadowRoot: () => getShadowRoot,
  inShadow: () => inShadow
});
function getRoot(ele) {
  return ele?.getRootNode?.();
}
function inShadow(ele) {
  return getRoot(ele) instanceof ShadowRoot;
}
function getShadowRoot(ele) {
  return inShadow(ele) ? getRoot(ele) : null;
}
var init_shadow = __esm({
  "packages/util/src/Dom/shadow.ts"() {
    __name(getRoot, "getRoot");
    __name(inShadow, "inShadow");
    __name(getShadowRoot, "getShadowRoot");
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    __name(_export, "_export");
    _export(exports, {
      generate: function() {
        return generate2;
      },
      getSecondaryColor: function() {
        return getSecondaryColor;
      },
      iconStyles: function() {
        return iconStyles;
      },
      isIconDefinition: function() {
        return isIconDefinition;
      },
      normalizeAttrs: function() {
        return normalizeAttrs;
      },
      normalizeTwoToneColors: function() {
        return normalizeTwoToneColors;
      },
      svgBaseProps: function() {
        return svgBaseProps;
      },
      useInsertStyles: function() {
        return useInsertStyles;
      },
      warning: function() {
        return warning5;
      }
    });
    var _colors = (init_src(), __toCommonJS(src_exports));
    var _dynamicCSS = (init_dynamicCSS(), __toCommonJS(dynamicCSS_exports));
    var _shadow = (init_shadow(), __toCommonJS(shadow_exports));
    var _warning = /* @__PURE__ */ _interop_require_default((init_warning(), __toCommonJS(warning_exports)));
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _Context = /* @__PURE__ */ _interop_require_default(require_Context());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function camelCase(input) {
      return input.replace(/-(.)/g, function(match2, g) {
        return g.toUpperCase();
      });
    }
    __name(camelCase, "camelCase");
    function warning5(valid, message2) {
      (0, _warning.default)(valid, "[@ant-design/icons] ".concat(message2));
    }
    __name(warning5, "warning");
    function isIconDefinition(target) {
      return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
    }
    __name(isIconDefinition, "isIconDefinition");
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            delete acc[key];
            acc[camelCase(key)] = val;
        }
        return acc;
      }, {});
    }
    __name(normalizeAttrs, "normalizeAttrs");
    function generate2(node2, key, rootProps) {
      if (!rootProps) {
        return _react.default.createElement(node2.tag, _object_spread({
          key
        }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index3) {
          return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index3));
        }));
      }
      return _react.default.createElement(node2.tag, _object_spread({
        key
      }, normalizeAttrs(node2.attrs), rootProps), (node2.children || []).map(function(child, index3) {
        return generate2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index3));
      }));
    }
    __name(generate2, "generate");
    function getSecondaryColor(primaryColor) {
      return (0, _colors.generate)(primaryColor)[0];
    }
    __name(getSecondaryColor, "getSecondaryColor");
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [
        twoToneColor
      ];
    }
    __name(normalizeTwoToneColors, "normalizeTwoToneColors");
    var svgBaseProps = {
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true",
      focusable: "false"
    };
    var iconStyles = "\n.anticon {\n  display: inline-flex;\n  alignItems: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = /* @__PURE__ */ __name(function(eleRef) {
      var _useContext = (0, _react.useContext)(_Context.default), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
      var mergedStyleStr = iconStyles;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      (0, _react.useEffect)(function() {
        var ele = eleRef.current;
        var shadowRoot = (0, _shadow.getShadowRoot)(ele);
        (0, _dynamicCSS.updateCSS)(mergedStyleStr, "@ant-design-icons", {
          prepend: true,
          csp,
          attachTo: shadowRoot
        });
      }, []);
    }, "useInsertStyles");
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/IconBase.js
var require_IconBase = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/IconBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _utils = require_utils();
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    function _object_without_properties(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    __name(_object_without_properties, "_object_without_properties");
    function _object_without_properties_loose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    __name(_object_without_properties_loose, "_object_without_properties_loose");
    var twoToneColorPalette = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors(param) {
      var primaryColor = param.primaryColor, secondaryColor = param.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || (0, _utils.getSecondaryColor)(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    __name(setTwoToneColors, "setTwoToneColors");
    function getTwoToneColors() {
      return _object_spread({}, twoToneColorPalette);
    }
    __name(getTwoToneColors, "getTwoToneColors");
    var IconBase = /* @__PURE__ */ __name(function(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _object_without_properties(props, [
        "icon",
        "className",
        "onClick",
        "style",
        "primaryColor",
        "secondaryColor"
      ]);
      var svgRef = _react.useRef();
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || (0, _utils.getSecondaryColor)(primaryColor)
        };
      }
      (0, _utils.useInsertStyles)(svgRef);
      (0, _utils.warning)((0, _utils.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!(0, _utils.isIconDefinition)(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _object_spread_props(_object_spread({}, target), {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return (0, _utils.generate)(target.icon, "svg-".concat(target.name), _object_spread_props(_object_spread({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps), {
        ref: svgRef
      }));
    }, "IconBase");
    IconBase.displayName = "IconReact";
    IconBase.getTwoToneColors = getTwoToneColors;
    IconBase.setTwoToneColors = setTwoToneColors;
    var _default = IconBase;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/twoTonePrimaryColor.js
var require_twoTonePrimaryColor = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/twoTonePrimaryColor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    __name(_export, "_export");
    _export(exports, {
      getTwoToneColor: function() {
        return getTwoToneColor;
      },
      setTwoToneColor: function() {
        return setTwoToneColor;
      }
    });
    var _IconBase = /* @__PURE__ */ _interop_require_default(require_IconBase());
    var _utils = require_utils();
    function _array_like_to_array(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    __name(_array_like_to_array, "_array_like_to_array");
    function _array_with_holes(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    __name(_array_with_holes, "_array_with_holes");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _iterable_to_array_limit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    __name(_iterable_to_array_limit, "_iterable_to_array_limit");
    function _non_iterable_rest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_non_iterable_rest, "_non_iterable_rest");
    function _sliced_to_array(arr, i) {
      return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
    }
    __name(_sliced_to_array, "_sliced_to_array");
    function _unsupported_iterable_to_array(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _array_like_to_array(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _array_like_to_array(o3, minLen);
    }
    __name(_unsupported_iterable_to_array, "_unsupported_iterable_to_array");
    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColors = _sliced_to_array((0, _utils.normalizeTwoToneColors)(twoToneColor), 2), primaryColor = _normalizeTwoToneColors[0], secondaryColor = _normalizeTwoToneColors[1];
      return _IconBase.default.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    __name(setTwoToneColor, "setTwoToneColor");
    function getTwoToneColor() {
      var colors = _IconBase.default.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [
        colors.primaryColor,
        colors.secondaryColor
      ];
    }
    __name(getTwoToneColor, "getTwoToneColor");
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/AntdIcon.js
var require_AntdIcon = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/components/AntdIcon.js"(exports) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _classnames = /* @__PURE__ */ _interop_require_default(require_classnames());
    var _colors = (init_src(), __toCommonJS(src_exports));
    var _Context = /* @__PURE__ */ _interop_require_default(require_Context());
    var _IconBase = /* @__PURE__ */ _interop_require_default(require_IconBase());
    var _twoTonePrimaryColor = require_twoTonePrimaryColor();
    var _utils = require_utils();
    function _array_like_to_array(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    __name(_array_like_to_array, "_array_like_to_array");
    function _array_with_holes(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    __name(_array_with_holes, "_array_with_holes");
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _iterable_to_array_limit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    __name(_iterable_to_array_limit, "_iterable_to_array_limit");
    function _non_iterable_rest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_non_iterable_rest, "_non_iterable_rest");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    function _object_without_properties(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    __name(_object_without_properties, "_object_without_properties");
    function _object_without_properties_loose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    __name(_object_without_properties_loose, "_object_without_properties_loose");
    function _sliced_to_array(arr, i) {
      return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
    }
    __name(_sliced_to_array, "_sliced_to_array");
    function _unsupported_iterable_to_array(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _array_like_to_array(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(n2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _array_like_to_array(o3, minLen);
    }
    __name(_unsupported_iterable_to_array, "_unsupported_iterable_to_array");
    (0, _twoTonePrimaryColor.setTwoToneColor)(_colors.blue.primary);
    var Icon4 = /* @__PURE__ */ _react.forwardRef(function(props, ref) {
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _object_without_properties(props, [
        "className",
        "icon",
        "spin",
        "rotate",
        "tabIndex",
        "onClick",
        "twoToneColor"
      ]);
      var _React_useContext = _react.useContext(_Context.default), _React_useContext_prefixCls = _React_useContext.prefixCls, prefixCls = _React_useContext_prefixCls === void 0 ? "anticon" : _React_useContext_prefixCls, rootClassName = _React_useContext.rootClassName;
      var _obj;
      var classString = (0, _classnames.default)(rootClassName, prefixCls, (_obj = {}, _define_property(_obj, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _define_property(_obj, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _obj), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColors = _sliced_to_array((0, _utils.normalizeTwoToneColors)(twoToneColor), 2), primaryColor = _normalizeTwoToneColors[0], secondaryColor = _normalizeTwoToneColors[1];
      return /* @__PURE__ */ _react.createElement("span", _object_spread_props(_object_spread({
        role: "img",
        "aria-label": icon.name
      }, restProps), {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ _react.createElement(_IconBase.default, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon4.displayName = "AntdIcon";
    Icon4.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
    Icon4.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
    var _default = Icon4;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CheckCircleFilled.js
var require_CheckCircleFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CheckCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CheckCircleFilled = /* @__PURE__ */ _interop_require_default(require_CheckCircleFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CheckCircleFilled8 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CheckCircleFilled.default
      }));
    }, "CheckCircleFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CheckCircleFilled8);
    if (true) {
      RefIcon.displayName = "CheckCircleFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CheckCircleFilled.js
var require_CheckCircleFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CheckCircleFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CheckCircleFilled = _interopRequireDefault(require_CheckCircleFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CheckCircleFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CloseCircleFilled.js
var require_CloseCircleFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CloseCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CloseCircleFilled10 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
    exports.default = CloseCircleFilled10;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CloseCircleFilled.js
var require_CloseCircleFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CloseCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CloseCircleFilled = /* @__PURE__ */ _interop_require_default(require_CloseCircleFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CloseCircleFilled10 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CloseCircleFilled.default
      }));
    }, "CloseCircleFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CloseCircleFilled10);
    if (true) {
      RefIcon.displayName = "CloseCircleFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CloseCircleFilled.js
var require_CloseCircleFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CloseCircleFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CloseCircleFilled = _interopRequireDefault(require_CloseCircleFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CloseCircleFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CloseOutlined.js
var require_CloseOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CloseOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CloseOutlined14 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
    exports.default = CloseOutlined14;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CloseOutlined.js
var require_CloseOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CloseOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CloseOutlined = /* @__PURE__ */ _interop_require_default(require_CloseOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CloseOutlined14 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CloseOutlined.default
      }));
    }, "CloseOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CloseOutlined14);
    if (true) {
      RefIcon.displayName = "CloseOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CloseOutlined.js
var require_CloseOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CloseOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CloseOutlined = _interopRequireDefault(require_CloseOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CloseOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ExclamationCircleFilled.js
var require_ExclamationCircleFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ExclamationCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExclamationCircleFilled9 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
    exports.default = ExclamationCircleFilled9;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ExclamationCircleFilled.js
var require_ExclamationCircleFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ExclamationCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _ExclamationCircleFilled = /* @__PURE__ */ _interop_require_default(require_ExclamationCircleFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var ExclamationCircleFilled9 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _ExclamationCircleFilled.default
      }));
    }, "ExclamationCircleFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(ExclamationCircleFilled9);
    if (true) {
      RefIcon.displayName = "ExclamationCircleFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ExclamationCircleFilled.js
var require_ExclamationCircleFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ExclamationCircleFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ExclamationCircleFilled = _interopRequireDefault(require_ExclamationCircleFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _ExclamationCircleFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/InfoCircleFilled.js
var require_InfoCircleFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/InfoCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InfoCircleFilled5 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
    exports.default = InfoCircleFilled5;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/InfoCircleFilled.js
var require_InfoCircleFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/InfoCircleFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _InfoCircleFilled = /* @__PURE__ */ _interop_require_default(require_InfoCircleFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var InfoCircleFilled5 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _InfoCircleFilled.default
      }));
    }, "InfoCircleFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(InfoCircleFilled5);
    if (true) {
      RefIcon.displayName = "InfoCircleFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/InfoCircleFilled.js
var require_InfoCircleFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/InfoCircleFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _InfoCircleFilled = _interopRequireDefault(require_InfoCircleFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _InfoCircleFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/LoadingOutlined.js
var require_LoadingOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/LoadingOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LoadingOutlined11 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
    exports.default = LoadingOutlined11;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/LoadingOutlined.js
var require_LoadingOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/LoadingOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _LoadingOutlined = /* @__PURE__ */ _interop_require_default(require_LoadingOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var LoadingOutlined11 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _LoadingOutlined.default
      }));
    }, "LoadingOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(LoadingOutlined11);
    if (true) {
      RefIcon.displayName = "LoadingOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/LoadingOutlined.js
var require_LoadingOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/LoadingOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _LoadingOutlined = _interopRequireDefault(require_LoadingOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _LoadingOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CheckOutlined.js
var require_CheckOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CheckOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CheckOutlined5 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
    exports.default = CheckOutlined5;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CheckOutlined.js
var require_CheckOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CheckOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CheckOutlined = /* @__PURE__ */ _interop_require_default(require_CheckOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CheckOutlined5 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CheckOutlined.default
      }));
    }, "CheckOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CheckOutlined5);
    if (true) {
      RefIcon.displayName = "CheckOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CheckOutlined.js
var require_CheckOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CheckOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CheckOutlined = _interopRequireDefault(require_CheckOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CheckOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DownOutlined.js
var require_DownOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DownOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownOutlined6 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
    exports.default = DownOutlined6;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DownOutlined.js
var require_DownOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DownOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DownOutlined = /* @__PURE__ */ _interop_require_default(require_DownOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DownOutlined6 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DownOutlined.default
      }));
    }, "DownOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DownOutlined6);
    if (true) {
      RefIcon.displayName = "DownOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DownOutlined.js
var require_DownOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DownOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DownOutlined = _interopRequireDefault(require_DownOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DownOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SearchOutlined.js
var require_SearchOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SearchOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchOutlined5 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
    exports.default = SearchOutlined5;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SearchOutlined.js
var require_SearchOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SearchOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _SearchOutlined = /* @__PURE__ */ _interop_require_default(require_SearchOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var SearchOutlined5 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _SearchOutlined.default
      }));
    }, "SearchOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(SearchOutlined5);
    if (true) {
      RefIcon.displayName = "SearchOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SearchOutlined.js
var require_SearchOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SearchOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _SearchOutlined = _interopRequireDefault(require_SearchOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _SearchOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/VerticalAlignTopOutlined.js
var require_VerticalAlignTopOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/VerticalAlignTopOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VerticalAlignTopOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
    exports.default = VerticalAlignTopOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/VerticalAlignTopOutlined.js
var require_VerticalAlignTopOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/VerticalAlignTopOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _VerticalAlignTopOutlined = /* @__PURE__ */ _interop_require_default(require_VerticalAlignTopOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var VerticalAlignTopOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _VerticalAlignTopOutlined.default
      }));
    }, "VerticalAlignTopOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(VerticalAlignTopOutlined3);
    if (true) {
      RefIcon.displayName = "VerticalAlignTopOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/VerticalAlignTopOutlined.js
var require_VerticalAlignTopOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/VerticalAlignTopOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _VerticalAlignTopOutlined = _interopRequireDefault(require_VerticalAlignTopOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _VerticalAlignTopOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RightOutlined.js
var require_RightOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RightOutlined8 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
    exports.default = RightOutlined8;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RightOutlined.js
var require_RightOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _RightOutlined = /* @__PURE__ */ _interop_require_default(require_RightOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var RightOutlined8 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _RightOutlined.default
      }));
    }, "RightOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(RightOutlined8);
    if (true) {
      RefIcon.displayName = "RightOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RightOutlined.js
var require_RightOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RightOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _RightOutlined = _interopRequireDefault(require_RightOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _RightOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/BarsOutlined.js
var require_BarsOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/BarsOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BarsOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
    exports.default = BarsOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/BarsOutlined.js
var require_BarsOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/BarsOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _BarsOutlined = /* @__PURE__ */ _interop_require_default(require_BarsOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var BarsOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _BarsOutlined.default
      }));
    }, "BarsOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(BarsOutlined2);
    if (true) {
      RefIcon.displayName = "BarsOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/BarsOutlined.js
var require_BarsOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/BarsOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _BarsOutlined = _interopRequireDefault(require_BarsOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _BarsOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/LeftOutlined.js
var require_LeftOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/LeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LeftOutlined6 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
    exports.default = LeftOutlined6;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/LeftOutlined.js
var require_LeftOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/LeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _LeftOutlined = /* @__PURE__ */ _interop_require_default(require_LeftOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var LeftOutlined6 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _LeftOutlined.default
      }));
    }, "LeftOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(LeftOutlined6);
    if (true) {
      RefIcon.displayName = "LeftOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/LeftOutlined.js
var require_LeftOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/LeftOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _LeftOutlined = _interopRequireDefault(require_LeftOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _LeftOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EllipsisOutlined.js
var require_EllipsisOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EllipsisOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EllipsisOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
    exports.default = EllipsisOutlined4;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EllipsisOutlined.js
var require_EllipsisOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EllipsisOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _EllipsisOutlined = /* @__PURE__ */ _interop_require_default(require_EllipsisOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var EllipsisOutlined4 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _EllipsisOutlined.default
      }));
    }, "EllipsisOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(EllipsisOutlined4);
    if (true) {
      RefIcon.displayName = "EllipsisOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EllipsisOutlined.js
var require_EllipsisOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EllipsisOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _EllipsisOutlined = _interopRequireDefault(require_EllipsisOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _EllipsisOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t2, e3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e3();
    }(exports, function() {
      "use strict";
      var t2 = 1e3, e3 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o3 = "week", c = "month", f = "quarter", h = "year", d = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e4 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
      } }, m = /* @__PURE__ */ __name(function(t3, e4, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e4 ? t3 : "" + Array(e4 + 1 - r3.length).join(n3) + t3;
      }, "m"), v = { s: m, z: function(t3) {
        var e4 = -t3.utcOffset(), n3 = Math.abs(e4), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
        return (e4 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
      }, m: /* @__PURE__ */ __name(function t3(e4, n3) {
        if (e4.date() < n3.date())
          return -t3(n3, e4);
        var r3 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i2 = e4.clone().add(r3, c), s2 = n3 - i2 < 0, u2 = e4.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n3 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, "t"), a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c, y: h, w: o3, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = /* @__PURE__ */ __name(function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p]);
      }, "S"), w = /* @__PURE__ */ __name(function t3(e4, n3, r3) {
        var i2;
        if (!e4)
          return g;
        if ("string" == typeof e4) {
          var s2 = e4.toLowerCase();
          D[s2] && (i2 = s2), n3 && (D[s2] = n3, i2 = s2);
          var u2 = e4.split("-");
          if (!i2 && u2.length > 1)
            return t3(u2[0]);
        } else {
          var a2 = e4.name;
          D[a2] = e4, i2 = a2;
        }
        return !r3 && i2 && (g = i2), i2 || !r3 && g;
      }, "t"), O = /* @__PURE__ */ __name(function(t3, e4) {
        if (S(t3))
          return t3.clone();
        var n3 = "object" == typeof e4 ? e4 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, "O"), b = v;
      b.l = w, b.i = S, b.w = function(t3, e4) {
        return O(t3, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
      };
      var _ = function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
        }
        __name(M2, "M");
        var m2 = M2.prototype;
        return m2.parse = function(t3) {
          this.$d = function(t4) {
            var e4 = t4.date, n3 = t4.utc;
            if (null === e4)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e4))
              return /* @__PURE__ */ new Date();
            if (e4 instanceof Date)
              return new Date(e4);
            if ("string" == typeof e4 && !/Z$/i.test(e4)) {
              var r3 = e4.match($);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e4);
          }(t3), this.init();
        }, m2.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m2.isSame = function(t3, e4) {
          var n3 = O(t3);
          return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
        }, m2.isAfter = function(t3, e4) {
          return O(t3) < this.startOf(e4);
        }, m2.isBefore = function(t3, e4) {
          return this.endOf(e4) < O(t3);
        }, m2.$g = function(t3, e4, n3) {
          return b.u(t3) ? this[e4] : this.set(n3, t3);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t3, e4) {
          var n3 = this, r3 = !!b.u(e4) || e4, f2 = b.p(t3), l3 = /* @__PURE__ */ __name(function(t4, e5) {
            var i2 = b.w(n3.$u ? Date.UTC(n3.$y, e5, t4) : new Date(n3.$y, e5, t4), n3);
            return r3 ? i2 : i2.endOf(a);
          }, "l"), $2 = /* @__PURE__ */ __name(function(t4, e5) {
            return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
          }, "$"), y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o3:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l3(r3 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m2.$set = function(t3, e4) {
          var n3, o4 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o4], $2 = o4 === a ? this.$D + (e4 - this.$W) : e4;
          if (o4 === c || o4 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l3]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m2.set = function(t3, e4) {
          return this.clone().$set(t3, e4);
        }, m2.get = function(t3) {
          return this[b.p(t3)]();
        }, m2.add = function(r3, f2) {
          var d2, l3 = this;
          r3 = Number(r3);
          var $2 = b.p(f2), y2 = /* @__PURE__ */ __name(function(t3) {
            var e4 = O(l3);
            return b.w(e4.date(e4.date() + Math.round(t3 * r3)), l3);
          }, "y");
          if ($2 === c)
            return this.set(c, this.$M + r3);
          if ($2 === h)
            return this.set(h, this.$y + r3);
          if ($2 === a)
            return y2(1);
          if ($2 === o3)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e3, d2[u] = n2, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r3 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t3, e4) {
          return this.add(-1 * t3, e4);
        }, m2.format = function(t3) {
          var e4 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o4 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h2 = /* @__PURE__ */ __name(function(t4, n4, i3, s3) {
            return t4 && (t4[n4] || t4(e4, r3)) || i3[n4].slice(0, s3);
          }, "h"), d2 = /* @__PURE__ */ __name(function(t4) {
            return b.s(s2 % 12 || 12, t4, "0");
          }, "d"), $2 = f2 || function(t4, e5, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e4.$y).slice(-2);
                case "YYYY":
                  return b.s(e4.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n3.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e4.$D;
                case "DD":
                  return b.s(e4.$D, 2, "0");
                case "d":
                  return String(e4.$W);
                case "dd":
                  return h2(n3.weekdaysMin, e4.$W, o4, 2);
                case "ddd":
                  return h2(n3.weekdaysShort, e4.$W, o4, 3);
                case "dddd":
                  return o4[e4.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e4.$s);
                case "ss":
                  return b.s(e4.$s, 2, "0");
                case "SSS":
                  return b.s(e4.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t4) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d2, l3) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e3, g2 = this - m3, D2 = /* @__PURE__ */ __name(function() {
            return b.m(y2, m3);
          }, "D");
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o3:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n2;
              break;
            case s:
              $2 = g2 / e3;
              break;
            case i:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l3 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t3, e4) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = w(t3, e4, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t3) {
        k[t3[1]] = function(e4) {
          return this.$g(e4, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e4) {
        return t3.$i || (t3(e4, _, O), t3.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekday.js
var require_weekday = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekday.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekday = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekday = function(e4) {
          var t3 = this.$locale().weekStart || 0, i = this.$W, n2 = (i < t3 ? i + 7 : i) - t3;
          return this.$utils().u(e4) ? n2 : this.subtract(n2, "day").add(e4, "day");
        };
      };
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/localeData.js"(exports, module2) {
    !function(n2, e3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (n2 = "undefined" != typeof globalThis ? globalThis : n2 || self).dayjs_plugin_localeData = e3();
    }(exports, function() {
      "use strict";
      return function(n2, e3, t2) {
        var r2 = e3.prototype, o3 = /* @__PURE__ */ __name(function(n3) {
          return n3 && (n3.indexOf ? n3 : n3.s);
        }, "o"), u = /* @__PURE__ */ __name(function(n3, e4, t3, r3, u2) {
          var i2 = n3.name ? n3 : n3.$locale(), a2 = o3(i2[e4]), s2 = o3(i2[t3]), f = a2 || s2.map(function(n4) {
            return n4.slice(0, r3);
          });
          if (!u2)
            return f;
          var d = i2.weekStart;
          return f.map(function(n4, e5) {
            return f[(e5 + (d || 0)) % 7];
          });
        }, "u"), i = /* @__PURE__ */ __name(function() {
          return t2.Ls[t2.locale()];
        }, "i"), a = /* @__PURE__ */ __name(function(n3, e4) {
          return n3.formats[e4] || function(n4) {
            return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e5, t3) {
              return e5 || t3.slice(1);
            });
          }(n3.formats[e4.toUpperCase()]);
        }, "a"), s = /* @__PURE__ */ __name(function() {
          var n3 = this;
          return { months: function(e4) {
            return e4 ? e4.format("MMMM") : u(n3, "months");
          }, monthsShort: function(e4) {
            return e4 ? e4.format("MMM") : u(n3, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n3.$locale().weekStart || 0;
          }, weekdays: function(e4) {
            return e4 ? e4.format("dddd") : u(n3, "weekdays");
          }, weekdaysMin: function(e4) {
            return e4 ? e4.format("dd") : u(n3, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e4) {
            return e4 ? e4.format("ddd") : u(n3, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e4) {
            return a(n3.$locale(), e4);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        }, "s");
        r2.localeData = function() {
          return s.bind(this)();
        }, t2.localeData = function() {
          var n3 = i();
          return { firstDayOfWeek: function() {
            return n3.weekStart || 0;
          }, weekdays: function() {
            return t2.weekdays();
          }, weekdaysShort: function() {
            return t2.weekdaysShort();
          }, weekdaysMin: function() {
            return t2.weekdaysMin();
          }, months: function() {
            return t2.months();
          }, monthsShort: function() {
            return t2.monthsShort();
          }, longDateFormat: function(e4) {
            return a(n3, e4);
          }, meridiem: n3.meridiem, ordinal: n3.ordinal };
        }, t2.months = function() {
          return u(i(), "months");
        }, t2.monthsShort = function() {
          return u(i(), "monthsShort", "months", 3);
        }, t2.weekdays = function(n3) {
          return u(i(), "weekdays", null, null, n3);
        }, t2.weekdaysShort = function(n3) {
          return u(i(), "weekdaysShort", "weekdays", 3, n3);
        }, t2.weekdaysMin = function(n3) {
          return u(i(), "weekdaysMin", "weekdays", 2, n3);
        };
      };
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekOfYear.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekOfYear = t2();
    }(exports, function() {
      "use strict";
      var e3 = "week", t2 = "year";
      return function(i, n2, r2) {
        var f = n2.prototype;
        f.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2)
            return this.add(7 * (i2 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e3);
            if (f2.isBefore(s))
              return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e3).subtract(1, "millisecond"), o3 = this.diff(a, e3, true);
          return o3 < 0 ? r2(this).startOf("week").week() : Math.ceil(o3);
        }, f.weeks = function(e4) {
          return void 0 === e4 && (e4 = null), this.week(e4);
        };
      };
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/weekYear.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekYear = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekYear = function() {
          var e4 = this.month(), t3 = this.week(), n2 = this.year();
          return 1 === t3 && 11 === e4 ? n2 + 1 : 0 === e4 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/advancedFormat.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_advancedFormat = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e4) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid())
            return n2.bind(this)(e4);
          var s = this.$utils(), a = (e4 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e5) {
            switch (e5) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s.s(t3.week(), "w" === e5 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t3.isoWeek(), "W" === e5 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e5 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e5;
            }
          });
          return n2.bind(this)(a);
        };
      };
    });
  }
});

// node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.10/node_modules/dayjs/plugin/customParseFormat.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_customParseFormat = t2();
    }(exports, function() {
      "use strict";
      var e3 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o3 = {}, s = /* @__PURE__ */ __name(function(e4) {
        return (e4 = +e4) + (e4 > 68 ? 1900 : 2e3);
      }, "s");
      var a = /* @__PURE__ */ __name(function(e4) {
        return function(t3) {
          this[e4] = +t3;
        };
      }, "a"), f = [/[+-]\d\d:?(\d\d)?|Z/, function(e4) {
        (this.zone || (this.zone = {})).offset = function(e5) {
          if (!e5)
            return 0;
          if ("Z" === e5)
            return 0;
          var t3 = e5.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        }(e4);
      }], h = /* @__PURE__ */ __name(function(e4) {
        var t3 = o3[e4];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, "h"), u = /* @__PURE__ */ __name(function(e4, t3) {
        var n3, r3 = o3.meridiem;
        if (r3) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e4.indexOf(r3(i2, 0, t3)) > -1) {
              n3 = i2 > 12;
              break;
            }
        } else
          n3 = e4 === (t3 ? "pm" : "PM");
        return n3;
      }, "u"), d = { A: [i, function(e4) {
        this.afternoon = u(e4, false);
      }], a: [i, function(e4) {
        this.afternoon = u(e4, true);
      }], S: [/\d/, function(e4) {
        this.milliseconds = 100 * +e4;
      }], SS: [n2, function(e4) {
        this.milliseconds = 10 * +e4;
      }], SSS: [/\d{3}/, function(e4) {
        this.milliseconds = +e4;
      }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(e4) {
        var t3 = o3.ordinal, n3 = e4.match(/\d+/);
        if (this.day = n3[0], t3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            t3(r3).replace(/\[|\]/g, "") === e4 && (this.day = r3);
      }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(e4) {
        var t3 = h("months"), n3 = (h("monthsShort") || t3.map(function(e5) {
          return e5.slice(0, 3);
        })).indexOf(e4) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [i, function(e4) {
        var t3 = h("months").indexOf(e4) + 1;
        if (t3 < 1)
          throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e4) {
        this.year = s(e4);
      }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
      function c(n3) {
        var r3, i2;
        r3 = n3, i2 = o3 && o3.formats;
        for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
          var o4 = r4 && r4.toUpperCase();
          return n4 || i2[r4] || e3[r4] || i2[o4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e4, t4, n5) {
            return t4 || n5.slice(1);
          });
        })).match(t2), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l2 = u2 && u2[1];
          s2[f2] = l2 ? { regex: c2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e4) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i3 = s2[n4];
            if ("string" == typeof i3)
              r4 += i3.length;
            else {
              var o4 = i3.regex, f3 = i3.parser, h3 = e4.slice(r4), u3 = o4.exec(h3)[0];
              f3.call(t3, u3), e4 = e4.replace(u3, "");
            }
          }
          return function(e5) {
            var t4 = e5.afternoon;
            if (void 0 !== t4) {
              var n5 = e5.hours;
              t4 ? n5 < 12 && (e5.hours += 12) : 12 === n5 && (e5.hours = 0), delete e5.afternoon;
            }
          }(t3), t3;
        };
      }
      __name(c, "c");
      return function(e4, t3, n3) {
        n3.p.customParseFormat = true, e4 && e4.parseTwoDigitYear && (s = e4.parseTwoDigitYear);
        var r3 = t3.prototype, i2 = r3.parse;
        r3.parse = function(e5) {
          var t4 = e5.date, r4 = e5.utc, s2 = e5.args;
          this.$u = r4;
          var a2 = s2[1];
          if ("string" == typeof a2) {
            var f2 = true === s2[2], h2 = true === s2[3], u2 = f2 || h2, d2 = s2[2];
            h2 && (d2 = s2[2]), o3 = this.$locale(), !f2 && d2 && (o3 = n3.Ls[d2]), this.$d = function(e6, t5, n4) {
              try {
                if (["x", "X"].indexOf(t5) > -1)
                  return new Date(("X" === t5 ? 1e3 : 1) * e6);
                var r5 = c(t5)(e6), i3 = r5.year, o4 = r5.month, s3 = r5.day, a3 = r5.hours, f3 = r5.minutes, h3 = r5.seconds, u3 = r5.milliseconds, d3 = r5.zone, l3 = /* @__PURE__ */ new Date(), m2 = s3 || (i3 || o4 ? 1 : l3.getDate()), M2 = i3 || l3.getFullYear(), Y = 0;
                i3 && !o4 || (Y = o4 > 0 ? o4 - 1 : l3.getMonth());
                var p = a3 || 0, v = f3 || 0, D = h3 || 0, g = u3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n4 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (e7) {
                return /* @__PURE__ */ new Date("");
              }
            }(t4, a2, r4), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o3 = {};
          } else if (a2 instanceof Array)
            for (var l2 = a2.length, m = 1; m <= l2; m += 1) {
              s2[1] = a2[m - 1];
              var M = n3.apply(this, s2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === l2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e5);
        };
      };
    });
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DotChartOutlined.js
var require_DotChartOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DotChartOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DotChartOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
    exports.default = DotChartOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DotChartOutlined.js
var require_DotChartOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DotChartOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DotChartOutlined = /* @__PURE__ */ _interop_require_default(require_DotChartOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DotChartOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DotChartOutlined.default
      }));
    }, "DotChartOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DotChartOutlined2);
    if (true) {
      RefIcon.displayName = "DotChartOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DotChartOutlined.js
var require_DotChartOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DotChartOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DotChartOutlined = _interopRequireDefault(require_DotChartOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DotChartOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PlusOutlined.js
var require_PlusOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PlusOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlusOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
    exports.default = PlusOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PlusOutlined.js
var require_PlusOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PlusOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _PlusOutlined = /* @__PURE__ */ _interop_require_default(require_PlusOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var PlusOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _PlusOutlined.default
      }));
    }, "PlusOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(PlusOutlined2);
    if (true) {
      RefIcon.displayName = "PlusOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PlusOutlined.js
var require_PlusOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PlusOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _PlusOutlined = _interopRequireDefault(require_PlusOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _PlusOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/string-convert@0.2.1/node_modules/string-convert/camel2hyphen.js
var require_camel2hyphen = __commonJS({
  "node_modules/.pnpm/string-convert@0.2.1/node_modules/string-convert/camel2hyphen.js"(exports, module2) {
    var camel2hyphen = /* @__PURE__ */ __name(function(str) {
      return str.replace(/[A-Z]/g, function(match2) {
        return "-" + match2.toLowerCase();
      }).toLowerCase();
    }, "camel2hyphen");
    module2.exports = camel2hyphen;
  }
});

// node_modules/.pnpm/json2mq@0.2.0/node_modules/json2mq/index.js
var require_json2mq = __commonJS({
  "node_modules/.pnpm/json2mq@0.2.0/node_modules/json2mq/index.js"(exports, module2) {
    var camel2hyphen = require_camel2hyphen();
    var isDimension = /* @__PURE__ */ __name(function(feature) {
      var re = /[height|width]$/;
      return re.test(feature);
    }, "isDimension");
    var obj2mq = /* @__PURE__ */ __name(function(obj) {
      var mq = "";
      var features = Object.keys(obj);
      features.forEach(function(feature, index3) {
        var value = obj[feature];
        feature = camel2hyphen(feature);
        if (isDimension(feature) && typeof value === "number") {
          value = value + "px";
        }
        if (value === true) {
          mq += feature;
        } else if (value === false) {
          mq += "not " + feature;
        } else {
          mq += "(" + feature + ": " + value + ")";
        }
        if (index3 < features.length - 1) {
          mq += " and ";
        }
      });
      return mq;
    }, "obj2mq");
    var json2mq2 = /* @__PURE__ */ __name(function(query) {
      var mq = "";
      if (typeof query === "string") {
        return query;
      }
      if (query instanceof Array) {
        query.forEach(function(q, index3) {
          mq += obj2mq(q);
          if (index3 < query.length - 1) {
            mq += ", ";
          }
        });
        return mq;
      }
      return obj2mq(query);
    }, "json2mq");
    module2.exports = json2mq2;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/UpOutlined.js
var require_UpOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/UpOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
    exports.default = UpOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/UpOutlined.js
var require_UpOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/UpOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _UpOutlined = /* @__PURE__ */ _interop_require_default(require_UpOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var UpOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _UpOutlined.default
      }));
    }, "UpOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(UpOutlined2);
    if (true) {
      RefIcon.displayName = "UpOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/UpOutlined.js
var require_UpOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/UpOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _UpOutlined = _interopRequireDefault(require_UpOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _UpOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EyeInvisibleOutlined.js
var require_EyeInvisibleOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EyeInvisibleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EyeInvisibleOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
    exports.default = EyeInvisibleOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EyeInvisibleOutlined.js
var require_EyeInvisibleOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EyeInvisibleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _EyeInvisibleOutlined = /* @__PURE__ */ _interop_require_default(require_EyeInvisibleOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var EyeInvisibleOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _EyeInvisibleOutlined.default
      }));
    }, "EyeInvisibleOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(EyeInvisibleOutlined2);
    if (true) {
      RefIcon.displayName = "EyeInvisibleOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EyeInvisibleOutlined.js
var require_EyeInvisibleOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EyeInvisibleOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _EyeInvisibleOutlined = _interopRequireDefault(require_EyeInvisibleOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _EyeInvisibleOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EyeOutlined.js
var require_EyeOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EyeOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EyeOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
    exports.default = EyeOutlined4;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EyeOutlined.js
var require_EyeOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EyeOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _EyeOutlined = /* @__PURE__ */ _interop_require_default(require_EyeOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var EyeOutlined4 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _EyeOutlined.default
      }));
    }, "EyeOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(EyeOutlined4);
    if (true) {
      RefIcon.displayName = "EyeOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EyeOutlined.js
var require_EyeOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EyeOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _EyeOutlined = _interopRequireDefault(require_EyeOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _EyeOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CalendarOutlined.js
var require_CalendarOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CalendarOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CalendarOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
    exports.default = CalendarOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CalendarOutlined.js
var require_CalendarOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CalendarOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CalendarOutlined = /* @__PURE__ */ _interop_require_default(require_CalendarOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CalendarOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CalendarOutlined.default
      }));
    }, "CalendarOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CalendarOutlined3);
    if (true) {
      RefIcon.displayName = "CalendarOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CalendarOutlined.js
var require_CalendarOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CalendarOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CalendarOutlined = _interopRequireDefault(require_CalendarOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CalendarOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ClockCircleOutlined.js
var require_ClockCircleOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ClockCircleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ClockCircleOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
    exports.default = ClockCircleOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ClockCircleOutlined.js
var require_ClockCircleOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ClockCircleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _ClockCircleOutlined = /* @__PURE__ */ _interop_require_default(require_ClockCircleOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var ClockCircleOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _ClockCircleOutlined.default
      }));
    }, "ClockCircleOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(ClockCircleOutlined3);
    if (true) {
      RefIcon.displayName = "ClockCircleOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ClockCircleOutlined.js
var require_ClockCircleOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ClockCircleOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ClockCircleOutlined = _interopRequireDefault(require_ClockCircleOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _ClockCircleOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SwapRightOutlined.js
var require_SwapRightOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SwapRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SwapRightOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
    exports.default = SwapRightOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SwapRightOutlined.js
var require_SwapRightOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SwapRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _SwapRightOutlined = /* @__PURE__ */ _interop_require_default(require_SwapRightOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var SwapRightOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _SwapRightOutlined.default
      }));
    }, "SwapRightOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(SwapRightOutlined2);
    if (true) {
      RefIcon.displayName = "SwapRightOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SwapRightOutlined.js
var require_SwapRightOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SwapRightOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _SwapRightOutlined = _interopRequireDefault(require_SwapRightOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _SwapRightOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileTextOutlined.js
var require_FileTextOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileTextOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileTextOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
    exports.default = FileTextOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileTextOutlined.js
var require_FileTextOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileTextOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FileTextOutlined = /* @__PURE__ */ _interop_require_default(require_FileTextOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FileTextOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FileTextOutlined.default
      }));
    }, "FileTextOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FileTextOutlined3);
    if (true) {
      RefIcon.displayName = "FileTextOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileTextOutlined.js
var require_FileTextOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileTextOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FileTextOutlined = _interopRequireDefault(require_FileTextOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FileTextOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/QuestionCircleOutlined.js
var require_QuestionCircleOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/QuestionCircleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var QuestionCircleOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
    exports.default = QuestionCircleOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/QuestionCircleOutlined.js
var require_QuestionCircleOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/QuestionCircleOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _QuestionCircleOutlined = /* @__PURE__ */ _interop_require_default(require_QuestionCircleOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var QuestionCircleOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _QuestionCircleOutlined.default
      }));
    }, "QuestionCircleOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(QuestionCircleOutlined2);
    if (true) {
      RefIcon.displayName = "QuestionCircleOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/QuestionCircleOutlined.js
var require_QuestionCircleOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/QuestionCircleOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _QuestionCircleOutlined = _interopRequireDefault(require_QuestionCircleOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _QuestionCircleOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RotateLeftOutlined.js
var require_RotateLeftOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RotateLeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RotateLeftOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { "tag": "path", "attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, "name": "rotate-left", "theme": "outlined" };
    exports.default = RotateLeftOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RotateLeftOutlined.js
var require_RotateLeftOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RotateLeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _RotateLeftOutlined = /* @__PURE__ */ _interop_require_default(require_RotateLeftOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var RotateLeftOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _RotateLeftOutlined.default
      }));
    }, "RotateLeftOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(RotateLeftOutlined2);
    if (true) {
      RefIcon.displayName = "RotateLeftOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RotateLeftOutlined.js
var require_RotateLeftOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RotateLeftOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _RotateLeftOutlined = _interopRequireDefault(require_RotateLeftOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _RotateLeftOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RotateRightOutlined.js
var require_RotateRightOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/RotateRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RotateRightOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { "tag": "path", "attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, "name": "rotate-right", "theme": "outlined" };
    exports.default = RotateRightOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RotateRightOutlined.js
var require_RotateRightOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/RotateRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _RotateRightOutlined = /* @__PURE__ */ _interop_require_default(require_RotateRightOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var RotateRightOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _RotateRightOutlined.default
      }));
    }, "RotateRightOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(RotateRightOutlined2);
    if (true) {
      RefIcon.displayName = "RotateRightOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RotateRightOutlined.js
var require_RotateRightOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/RotateRightOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _RotateRightOutlined = _interopRequireDefault(require_RotateRightOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _RotateRightOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SwapOutlined.js
var require_SwapOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/SwapOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SwapOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "swap", "theme": "outlined" };
    exports.default = SwapOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SwapOutlined.js
var require_SwapOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/SwapOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _SwapOutlined = /* @__PURE__ */ _interop_require_default(require_SwapOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var SwapOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _SwapOutlined.default
      }));
    }, "SwapOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(SwapOutlined2);
    if (true) {
      RefIcon.displayName = "SwapOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SwapOutlined.js
var require_SwapOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/SwapOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _SwapOutlined = _interopRequireDefault(require_SwapOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _SwapOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ZoomInOutlined.js
var require_ZoomInOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ZoomInOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZoomInOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-in", "theme": "outlined" };
    exports.default = ZoomInOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ZoomInOutlined.js
var require_ZoomInOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ZoomInOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _ZoomInOutlined = /* @__PURE__ */ _interop_require_default(require_ZoomInOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var ZoomInOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _ZoomInOutlined.default
      }));
    }, "ZoomInOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(ZoomInOutlined2);
    if (true) {
      RefIcon.displayName = "ZoomInOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ZoomInOutlined.js
var require_ZoomInOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ZoomInOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ZoomInOutlined = _interopRequireDefault(require_ZoomInOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _ZoomInOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ZoomOutOutlined.js
var require_ZoomOutOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ZoomOutOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZoomOutOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-out", "theme": "outlined" };
    exports.default = ZoomOutOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ZoomOutOutlined.js
var require_ZoomOutOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ZoomOutOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _ZoomOutOutlined = /* @__PURE__ */ _interop_require_default(require_ZoomOutOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var ZoomOutOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _ZoomOutOutlined.default
      }));
    }, "ZoomOutOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(ZoomOutOutlined2);
    if (true) {
      RefIcon.displayName = "ZoomOutOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ZoomOutOutlined.js
var require_ZoomOutOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ZoomOutOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ZoomOutOutlined = _interopRequireDefault(require_ZoomOutOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _ZoomOutOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DoubleLeftOutlined.js
var require_DoubleLeftOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DoubleLeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DoubleLeftOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
    exports.default = DoubleLeftOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DoubleLeftOutlined.js
var require_DoubleLeftOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DoubleLeftOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DoubleLeftOutlined = /* @__PURE__ */ _interop_require_default(require_DoubleLeftOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DoubleLeftOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DoubleLeftOutlined.default
      }));
    }, "DoubleLeftOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DoubleLeftOutlined2);
    if (true) {
      RefIcon.displayName = "DoubleLeftOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DoubleLeftOutlined.js
var require_DoubleLeftOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DoubleLeftOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DoubleLeftOutlined = _interopRequireDefault(require_DoubleLeftOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DoubleLeftOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DoubleRightOutlined.js
var require_DoubleRightOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DoubleRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DoubleRightOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
    exports.default = DoubleRightOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DoubleRightOutlined.js
var require_DoubleRightOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DoubleRightOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DoubleRightOutlined = /* @__PURE__ */ _interop_require_default(require_DoubleRightOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DoubleRightOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DoubleRightOutlined.default
      }));
    }, "DoubleRightOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DoubleRightOutlined2);
    if (true) {
      RefIcon.displayName = "DoubleRightOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DoubleRightOutlined.js
var require_DoubleRightOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DoubleRightOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DoubleRightOutlined = _interopRequireDefault(require_DoubleRightOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DoubleRightOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ReloadOutlined.js
var require_ReloadOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/ReloadOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReloadOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" } }] }, "name": "reload", "theme": "outlined" };
    exports.default = ReloadOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ReloadOutlined.js
var require_ReloadOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/ReloadOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _ReloadOutlined = /* @__PURE__ */ _interop_require_default(require_ReloadOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var ReloadOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _ReloadOutlined.default
      }));
    }, "ReloadOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(ReloadOutlined2);
    if (true) {
      RefIcon.displayName = "ReloadOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ReloadOutlined.js
var require_ReloadOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/ReloadOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ReloadOutlined = _interopRequireDefault(require_ReloadOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _ReloadOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/StarFilled.js
var require_StarFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/StarFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StarFilled2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, "name": "star", "theme": "filled" };
    exports.default = StarFilled2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/StarFilled.js
var require_StarFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/StarFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _StarFilled = /* @__PURE__ */ _interop_require_default(require_StarFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var StarFilled2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _StarFilled.default
      }));
    }, "StarFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(StarFilled2);
    if (true) {
      RefIcon.displayName = "StarFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/StarFilled.js
var require_StarFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/StarFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _StarFilled = _interopRequireDefault(require_StarFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _StarFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/WarningFilled.js
var require_WarningFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/WarningFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var WarningFilled2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "warning", "theme": "filled" };
    exports.default = WarningFilled2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/WarningFilled.js
var require_WarningFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/WarningFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _WarningFilled = /* @__PURE__ */ _interop_require_default(require_WarningFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var WarningFilled2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _WarningFilled.default
      }));
    }, "WarningFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(WarningFilled2);
    if (true) {
      RefIcon.displayName = "WarningFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/WarningFilled.js
var require_WarningFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/WarningFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _WarningFilled = _interopRequireDefault(require_WarningFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _WarningFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FilterFilled.js
var require_FilterFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FilterFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FilterFilled2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
    exports.default = FilterFilled2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FilterFilled.js
var require_FilterFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FilterFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FilterFilled = /* @__PURE__ */ _interop_require_default(require_FilterFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FilterFilled2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FilterFilled.default
      }));
    }, "FilterFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FilterFilled2);
    if (true) {
      RefIcon.displayName = "FilterFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FilterFilled.js
var require_FilterFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FilterFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FilterFilled = _interopRequireDefault(require_FilterFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FilterFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileOutlined.js
var require_FileOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
    exports.default = FileOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileOutlined.js
var require_FileOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FileOutlined = /* @__PURE__ */ _interop_require_default(require_FileOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FileOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FileOutlined.default
      }));
    }, "FileOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FileOutlined3);
    if (true) {
      RefIcon.displayName = "FileOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileOutlined.js
var require_FileOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FileOutlined = _interopRequireDefault(require_FileOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FileOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FolderOpenOutlined.js
var require_FolderOpenOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FolderOpenOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FolderOpenOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
    exports.default = FolderOpenOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FolderOpenOutlined.js
var require_FolderOpenOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FolderOpenOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FolderOpenOutlined = /* @__PURE__ */ _interop_require_default(require_FolderOpenOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FolderOpenOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FolderOpenOutlined.default
      }));
    }, "FolderOpenOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FolderOpenOutlined2);
    if (true) {
      RefIcon.displayName = "FolderOpenOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FolderOpenOutlined.js
var require_FolderOpenOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FolderOpenOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FolderOpenOutlined = _interopRequireDefault(require_FolderOpenOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FolderOpenOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FolderOutlined.js
var require_FolderOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FolderOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FolderOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
    exports.default = FolderOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FolderOutlined.js
var require_FolderOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FolderOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FolderOutlined = /* @__PURE__ */ _interop_require_default(require_FolderOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FolderOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FolderOutlined.default
      }));
    }, "FolderOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FolderOutlined2);
    if (true) {
      RefIcon.displayName = "FolderOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FolderOutlined.js
var require_FolderOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FolderOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FolderOutlined = _interopRequireDefault(require_FolderOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FolderOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/HolderOutlined.js
var require_HolderOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/HolderOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HolderOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
    exports.default = HolderOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/HolderOutlined.js
var require_HolderOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/HolderOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _HolderOutlined = /* @__PURE__ */ _interop_require_default(require_HolderOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var HolderOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _HolderOutlined.default
      }));
    }, "HolderOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(HolderOutlined2);
    if (true) {
      RefIcon.displayName = "HolderOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/HolderOutlined.js
var require_HolderOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/HolderOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _HolderOutlined = _interopRequireDefault(require_HolderOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _HolderOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretDownFilled.js
var require_CaretDownFilled = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretDownFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CaretDownFilled2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
    exports.default = CaretDownFilled2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretDownFilled.js
var require_CaretDownFilled2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretDownFilled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CaretDownFilled = /* @__PURE__ */ _interop_require_default(require_CaretDownFilled());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CaretDownFilled2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CaretDownFilled.default
      }));
    }, "CaretDownFilled");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CaretDownFilled2);
    if (true) {
      RefIcon.displayName = "CaretDownFilled";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretDownFilled.js
var require_CaretDownFilled3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretDownFilled.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CaretDownFilled = _interopRequireDefault(require_CaretDownFilled2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CaretDownFilled;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/MinusSquareOutlined.js
var require_MinusSquareOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/MinusSquareOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MinusSquareOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
    exports.default = MinusSquareOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/MinusSquareOutlined.js
var require_MinusSquareOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/MinusSquareOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _MinusSquareOutlined = /* @__PURE__ */ _interop_require_default(require_MinusSquareOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var MinusSquareOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _MinusSquareOutlined.default
      }));
    }, "MinusSquareOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(MinusSquareOutlined2);
    if (true) {
      RefIcon.displayName = "MinusSquareOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/MinusSquareOutlined.js
var require_MinusSquareOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/MinusSquareOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _MinusSquareOutlined = _interopRequireDefault(require_MinusSquareOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _MinusSquareOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PlusSquareOutlined.js
var require_PlusSquareOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PlusSquareOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlusSquareOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
    exports.default = PlusSquareOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PlusSquareOutlined.js
var require_PlusSquareOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PlusSquareOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _PlusSquareOutlined = /* @__PURE__ */ _interop_require_default(require_PlusSquareOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var PlusSquareOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _PlusSquareOutlined.default
      }));
    }, "PlusSquareOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(PlusSquareOutlined2);
    if (true) {
      RefIcon.displayName = "PlusSquareOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PlusSquareOutlined.js
var require_PlusSquareOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PlusSquareOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _PlusSquareOutlined = _interopRequireDefault(require_PlusSquareOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _PlusSquareOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretDownOutlined.js
var require_CaretDownOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretDownOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CaretDownOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
    exports.default = CaretDownOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretDownOutlined.js
var require_CaretDownOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretDownOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CaretDownOutlined = /* @__PURE__ */ _interop_require_default(require_CaretDownOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CaretDownOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CaretDownOutlined.default
      }));
    }, "CaretDownOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CaretDownOutlined2);
    if (true) {
      RefIcon.displayName = "CaretDownOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretDownOutlined.js
var require_CaretDownOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretDownOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CaretDownOutlined = _interopRequireDefault(require_CaretDownOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CaretDownOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretUpOutlined.js
var require_CaretUpOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CaretUpOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CaretUpOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
    exports.default = CaretUpOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretUpOutlined.js
var require_CaretUpOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CaretUpOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CaretUpOutlined = /* @__PURE__ */ _interop_require_default(require_CaretUpOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CaretUpOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CaretUpOutlined.default
      }));
    }, "CaretUpOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CaretUpOutlined2);
    if (true) {
      RefIcon.displayName = "CaretUpOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretUpOutlined.js
var require_CaretUpOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CaretUpOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CaretUpOutlined = _interopRequireDefault(require_CaretUpOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CaretUpOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DeleteOutlined.js
var require_DeleteOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DeleteOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DeleteOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
    exports.default = DeleteOutlined3;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DeleteOutlined.js
var require_DeleteOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DeleteOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DeleteOutlined = /* @__PURE__ */ _interop_require_default(require_DeleteOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DeleteOutlined3 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DeleteOutlined.default
      }));
    }, "DeleteOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DeleteOutlined3);
    if (true) {
      RefIcon.displayName = "DeleteOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DeleteOutlined.js
var require_DeleteOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DeleteOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DeleteOutlined = _interopRequireDefault(require_DeleteOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DeleteOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EditOutlined.js
var require_EditOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EditOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
    exports.default = EditOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EditOutlined.js
var require_EditOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EditOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _EditOutlined = /* @__PURE__ */ _interop_require_default(require_EditOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var EditOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _EditOutlined.default
      }));
    }, "EditOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(EditOutlined2);
    if (true) {
      RefIcon.displayName = "EditOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EditOutlined.js
var require_EditOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EditOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _EditOutlined = _interopRequireDefault(require_EditOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _EditOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EnterOutlined.js
var require_EnterOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/EnterOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EnterOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
    exports.default = EnterOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EnterOutlined.js
var require_EnterOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/EnterOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _EnterOutlined = /* @__PURE__ */ _interop_require_default(require_EnterOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var EnterOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _EnterOutlined.default
      }));
    }, "EnterOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(EnterOutlined2);
    if (true) {
      RefIcon.displayName = "EnterOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EnterOutlined.js
var require_EnterOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/EnterOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _EnterOutlined = _interopRequireDefault(require_EnterOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _EnterOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js"(exports, module2) {
    module2.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range3) {
            selection.addRange(range3);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js"(exports, module2) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message2) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message2.replace(/#{\s*key\s*}/g, copyKey);
    }
    __name(format2, "format");
    function copy2(text, options) {
      var debug, message2, reselectPrevious, range3, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range3 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e3) {
          e3.stopPropagation();
          if (options.format) {
            e3.preventDefault();
            if (typeof e3.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e3.clipboardData.clearData();
              e3.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e3.preventDefault();
            options.onCopy(e3.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range3.selectNodeContents(mark);
        selection.addRange(range3);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message2 = format2("message" in options ? options.message : defaultMessage);
          window.prompt(message2, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range3);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    __name(copy2, "copy");
    module2.exports = copy2;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CopyOutlined.js
var require_CopyOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/CopyOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CopyOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
    exports.default = CopyOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CopyOutlined.js
var require_CopyOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/CopyOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _CopyOutlined = /* @__PURE__ */ _interop_require_default(require_CopyOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var CopyOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _CopyOutlined.default
      }));
    }, "CopyOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(CopyOutlined2);
    if (true) {
      RefIcon.displayName = "CopyOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CopyOutlined.js
var require_CopyOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/CopyOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _CopyOutlined = _interopRequireDefault(require_CopyOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _CopyOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileTwoTone.js
var require_FileTwoTone = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/FileTwoTone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileTwoTone2 = { "icon": /* @__PURE__ */ __name(function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
    }, "render"), "name": "file", "theme": "twotone" };
    exports.default = FileTwoTone2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileTwoTone.js
var require_FileTwoTone2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/FileTwoTone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _FileTwoTone = /* @__PURE__ */ _interop_require_default(require_FileTwoTone());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var FileTwoTone2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _FileTwoTone.default
      }));
    }, "FileTwoTone");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(FileTwoTone2);
    if (true) {
      RefIcon.displayName = "FileTwoTone";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileTwoTone.js
var require_FileTwoTone3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/FileTwoTone.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _FileTwoTone = _interopRequireDefault(require_FileTwoTone2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _FileTwoTone;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PaperClipOutlined.js
var require_PaperClipOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PaperClipOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PaperClipOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
    exports.default = PaperClipOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PaperClipOutlined.js
var require_PaperClipOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PaperClipOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _PaperClipOutlined = /* @__PURE__ */ _interop_require_default(require_PaperClipOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var PaperClipOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _PaperClipOutlined.default
      }));
    }, "PaperClipOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(PaperClipOutlined2);
    if (true) {
      RefIcon.displayName = "PaperClipOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PaperClipOutlined.js
var require_PaperClipOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PaperClipOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _PaperClipOutlined = _interopRequireDefault(require_PaperClipOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _PaperClipOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PictureTwoTone.js
var require_PictureTwoTone = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/PictureTwoTone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PictureTwoTone2 = { "icon": /* @__PURE__ */ __name(function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
    }, "render"), "name": "picture", "theme": "twotone" };
    exports.default = PictureTwoTone2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PictureTwoTone.js
var require_PictureTwoTone2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/PictureTwoTone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _PictureTwoTone = /* @__PURE__ */ _interop_require_default(require_PictureTwoTone());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var PictureTwoTone2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _PictureTwoTone.default
      }));
    }, "PictureTwoTone");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(PictureTwoTone2);
    if (true) {
      RefIcon.displayName = "PictureTwoTone";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PictureTwoTone.js
var require_PictureTwoTone3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/PictureTwoTone.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _PictureTwoTone = _interopRequireDefault(require_PictureTwoTone2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _PictureTwoTone;
    exports.default = _default;
    module2.exports = _default;
  }
});

// node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DownloadOutlined.js
var require_DownloadOutlined = __commonJS({
  "node_modules/.pnpm/@ant-design+icons-svg@4.4.2/node_modules/@ant-design/icons-svg/lib/asn/DownloadOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DownloadOutlined2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
    exports.default = DownloadOutlined2;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DownloadOutlined.js
var require_DownloadOutlined2 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/lib/icons/DownloadOutlined.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_wildcard(__require("react"));
    var _DownloadOutlined = /* @__PURE__ */ _interop_require_default(require_DownloadOutlined());
    var _AntdIcon = /* @__PURE__ */ _interop_require_default(require_AntdIcon());
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_define_property, "_define_property");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interop_require_default, "_interop_require_default");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interop_require_wildcard, "_interop_require_wildcard");
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys3 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys3.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    __name(_object_spread, "_object_spread");
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object4);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
          });
        }
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    __name(ownKeys2, "ownKeys");
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_object_spread_props, "_object_spread_props");
    var DownloadOutlined2 = /* @__PURE__ */ __name(function(props, ref) {
      return /* @__PURE__ */ _react.createElement(_AntdIcon.default, _object_spread_props(_object_spread({}, props), {
        ref,
        icon: _DownloadOutlined.default
      }));
    }, "DownloadOutlined");
    var RefIcon = /* @__PURE__ */ _react.forwardRef(DownloadOutlined2);
    if (true) {
      RefIcon.displayName = "DownloadOutlined";
    }
    var _default = RefIcon;
  }
});

// node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DownloadOutlined.js
var require_DownloadOutlined3 = __commonJS({
  "node_modules/.pnpm/@ant-design+icons@5.3.6_react-dom@18.2.0_react@18.2.0/node_modules/@ant-design/icons/DownloadOutlined.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _DownloadOutlined = _interopRequireDefault(require_DownloadOutlined2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _default = _DownloadOutlined;
    exports.default = _default;
    module2.exports = _default;
  }
});

// packages/ant-design/components/affix/index.tsx
var import_classnames2 = __toESM(require_classnames());
import React37 from "react";

// packages/resize-observer/src/index.tsx
import * as React7 from "react";

// packages/util/src/Children/toArray.ts
var import_react_is = __toESM(require_react_is());
import React from "react";
function toArray(children, option = {}) {
  let ret = [];
  React.Children.forEach(children, (child) => {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if ((0, import_react_is.isFragment)(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
__name(toArray, "toArray");

// packages/resize-observer/src/index.tsx
init_warning();

// packages/util/src/Dom/findDOMNode.ts
import React2 from "react";
import ReactDOM from "react-dom";
function isDOM(node2) {
  return node2 instanceof HTMLElement || node2 instanceof SVGElement;
}
__name(isDOM, "isDOM");
function findDOMNode(node2) {
  if (isDOM(node2)) {
    return node2;
  }
  if (node2 instanceof React2.Component) {
    return ReactDOM.findDOMNode(node2);
  }
  return null;
}
__name(findDOMNode, "findDOMNode");

// packages/util/src/ref.ts
var import_react_is2 = __toESM(require_react_is());
import { isValidElement } from "react";

// packages/util/src/hooks/useMemo.ts
import * as React3 from "react";
function useMemo(getValue3, condition, shouldUpdate) {
  const cacheRef = React3.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue3();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
__name(useMemo, "useMemo");

// packages/util/src/ref.ts
function fillRef(ref, node2) {
  if (typeof ref === "function") {
    ref(node2);
  } else if (typeof ref === "object" && ref && "current" in ref) {
    ref.current = node2;
  }
}
__name(fillRef, "fillRef");
function composeRef(...refs) {
  const refList = refs.filter((ref) => ref);
  if (refList.length <= 1) {
    return refList[0];
  }
  return (node2) => {
    refs.forEach((ref) => {
      fillRef(ref, node2);
    });
  };
}
__name(composeRef, "composeRef");
function useComposeRef(...refs) {
  return useMemo(
    () => composeRef(...refs),
    refs,
    (prev2, next2) => prev2.length !== next2.length || prev2.every((ref, i) => ref !== next2[i])
  );
}
__name(useComposeRef, "useComposeRef");
function supportRef(nodeOrComponent) {
  const type5 = (0, import_react_is2.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type5 === "function" && !type5.prototype?.render && type5.$$typeof !== import_react_is2.ForwardRef) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !nodeOrComponent.prototype?.render && nodeOrComponent.$$typeof !== import_react_is2.ForwardRef) {
    return false;
  }
  return true;
}
__name(supportRef, "supportRef");
function supportNodeRef(node2) {
  if (!isValidElement(node2)) {
    return false;
  }
  if ((0, import_react_is2.isFragment)(node2)) {
    return false;
  }
  return supportRef(node2);
}
__name(supportNodeRef, "supportNodeRef");

// packages/resize-observer/src/SingleObserver/index.tsx
import * as React6 from "react";

// packages/resize-observer/src/Collection.tsx
import * as React4 from "react";
var CollectionContext = React4.createContext(null);
function Collection({ children, onBatchResize }) {
  const resizeIdRef = React4.useRef(0);
  const resizeInfosRef = React4.useRef([]);
  const onCollectionResize = React4.useContext(CollectionContext);
  const onResize2 = React4.useCallback(
    (size, element, data) => {
      resizeIdRef.current += 1;
      const currentId = resizeIdRef.current;
      resizeInfosRef.current.push({
        size,
        element,
        data
      });
      Promise.resolve().then(() => {
        if (currentId === resizeIdRef.current) {
          onBatchResize?.(resizeInfosRef.current);
          resizeInfosRef.current = [];
        }
      });
      onCollectionResize?.(size, element, data);
    },
    [onBatchResize, onCollectionResize]
  );
  return /* @__PURE__ */ React4.createElement(CollectionContext.Provider, { value: onResize2 }, children);
}
__name(Collection, "Collection");

// node_modules/.pnpm/resize-observer-polyfill@1.5.1/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex2(arr, key) {
    var result = -1;
    arr.some(function(entry, index3) {
      if (entry[0] === key) {
        result = index3;
        return true;
      }
      return false;
    });
    return result;
  }
  __name(getIndex2, "getIndex");
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      __name(class_1, "class_1");
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index3 = getIndex2(this.__entries__, key);
        var entry = this.__entries__[index3];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index3 = getIndex2(this.__entries__, key);
        if (~index3) {
          this.__entries__[index3][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index3 = getIndex2(entries, key);
        if (~index3) {
          entries.splice(index3, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex2(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  __name(resolvePending, "resolvePending");
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  __name(timeoutCallback, "timeoutCallback");
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  __name(proxy, "proxy");
  return proxy;
}
__name(throttle, "throttle");
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    __name(ResizeObserverController2, "ResizeObserverController");
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index3 = observers2.indexOf(observer);
      if (~index3) {
        observers2.splice(index3, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = /* @__PURE__ */ __name(function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
}, "defineConfigurable");
var getWindowOf = /* @__PURE__ */ __name(function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
}, "getWindowOf");
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
__name(toFloat, "toFloat");
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position2) {
    var value = styles["border-" + position2 + "-width"];
    return size + toFloat(value);
  }, 0);
}
__name(getBordersSize, "getBordersSize");
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value = styles["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
__name(getPaddings, "getPaddings");
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
__name(getSVGContentRect, "getSVGContentRect");
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
__name(getHTMLElementContentRect, "getHTMLElementContentRect");
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
__name(isDocumentElement, "isDocumentElement");
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
__name(getContentRect, "getContentRect");
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
__name(createReadOnlyRect, "createReadOnlyRect");
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
__name(createRectInit, "createRectInit");
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    __name(ResizeObservation2, "ResizeObservation");
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    __name(ResizeObserverEntry2, "ResizeObserverEntry");
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    __name(ResizeObserverSPI2, "ResizeObserverSPI");
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver4(callback) {
      if (!(this instanceof ResizeObserver4)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    __name(ResizeObserver4, "ResizeObserver");
    return ResizeObserver4;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver2.prototype[method4] = function() {
    var _a;
    return (_a = observers.get(this))[method4].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver2;
}();
var ResizeObserver_es_default = index;

// packages/resize-observer/src/utils/observerUtil.ts
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach((entity) => {
    const { target } = entity;
    elementListeners.get(target)?.forEach((listener) => listener(target));
  });
}
__name(onResize, "onResize");
var resizeObserver = new ResizeObserver_es_default(onResize);
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
__name(observe, "observe");
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
__name(unobserve, "unobserve");

// packages/resize-observer/src/SingleObserver/DomWrapper.tsx
import * as React5 from "react";
var DomWrapper = class extends React5.Component {
  static {
    __name(this, "DomWrapper");
  }
  render() {
    return this.props.children;
  }
};

// packages/resize-observer/src/SingleObserver/index.tsx
function SingleObserver(props, ref) {
  const { children, disabled } = props;
  const elementRef = React6.useRef(null);
  const wrapperRef = React6.useRef(null);
  const onCollectionResize = React6.useContext(CollectionContext);
  const isRenderProps = typeof children === "function";
  const mergedChildren = isRenderProps ? children(elementRef) : children;
  const sizeRef = React6.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  const canRef = !isRenderProps && React6.isValidElement(mergedChildren) && supportRef(mergedChildren);
  const originRef = canRef ? mergedChildren.ref : null;
  const mergedRef = useComposeRef(originRef, elementRef);
  const getDom = /* @__PURE__ */ __name(() => findDOMNode(elementRef.current) || // Support `nativeElement` format
  (elementRef.current && typeof elementRef.current === "object" ? findDOMNode(elementRef.current?.nativeElement) : null) || findDOMNode(wrapperRef.current), "getDom");
  React6.useImperativeHandle(ref, () => getDom());
  const propsRef = React6.useRef(props);
  propsRef.current = props;
  const onInternalResize = React6.useCallback((target) => {
    const { onResize: onResize2, data } = propsRef.current;
    const { width, height } = target.getBoundingClientRect();
    const { offsetWidth, offsetHeight } = target;
    const fixedWidth = Math.floor(width);
    const fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      const size = { width: fixedWidth, height: fixedHeight, offsetWidth, offsetHeight };
      sizeRef.current = size;
      const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      const sizeInfo = {
        ...size,
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      };
      onCollectionResize?.(sizeInfo, target, data);
      if (onResize2) {
        Promise.resolve().then(() => {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  React6.useEffect(() => {
    const currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return () => unobserve(currentElement, onInternalResize);
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ React6.createElement(DomWrapper, { ref: wrapperRef }, canRef ? React6.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
__name(SingleObserver, "SingleObserver");
var RefSingleObserver = React6.forwardRef(SingleObserver);
if (true) {
  RefSingleObserver.displayName = "SingleObserver";
}
var SingleObserver_default = RefSingleObserver;

// packages/resize-observer/src/index.tsx
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver3(props, ref) {
  const { children } = props;
  const childNodes = typeof children === "function" ? [children] : toArray(children);
  if (true) {
    if (childNodes.length > 1) {
      warning(
        false,
        "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead."
      );
    } else if (childNodes.length === 0) {
      warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
    }
  }
  return childNodes.map((child, index3) => {
    const key = child?.key || `${INTERNAL_PREFIX_KEY}-${index3}`;
    return /* @__PURE__ */ React7.createElement(SingleObserver_default, { ...props, key, ref: index3 === 0 ? ref : void 0 }, child);
  });
}
__name(ResizeObserver3, "ResizeObserver");
var RefResizeObserver = React7.forwardRef(ResizeObserver3);
if (true) {
  RefResizeObserver.displayName = "ResizeObserver";
}
RefResizeObserver.Collection = Collection;
var src_default = RefResizeObserver;

// packages/util/src/omit.ts
function omit(obj, fields) {
  const clone = { ...obj };
  if (Array.isArray(fields)) {
    fields.forEach((key) => {
      delete clone[key];
    });
  }
  return clone;
}
__name(omit, "omit");

// packages/util/src/raf.ts
var raf = /* @__PURE__ */ __name((callback) => +setTimeout(callback, 16), "raf");
var caf = /* @__PURE__ */ __name((num) => clearTimeout(num), "caf");
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = /* @__PURE__ */ __name((callback) => window.requestAnimationFrame(callback), "raf");
  caf = /* @__PURE__ */ __name((handle) => window.cancelAnimationFrame(handle), "caf");
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
__name(cleanup, "cleanup");
var wrapperRaf = /* @__PURE__ */ __name((callback, times = 1) => {
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  __name(callRef, "callRef");
  callRef(times);
  return id;
}, "wrapperRaf");
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(id);
  return caf(realId);
};
if (true) {
  wrapperRaf.ids = () => rafIds;
}
var raf_default = wrapperRaf;

// packages/ant-design/components/_util/throttleByAnimationFrame.ts
function throttleByAnimationFrame(fn) {
  let requestId;
  const later = /* @__PURE__ */ __name((args) => () => {
    requestId = null;
    fn(...args);
  }, "later");
  const throttled = /* @__PURE__ */ __name((...args) => {
    if (requestId == null) {
      requestId = raf_default(later(args));
    }
  }, "throttled");
  throttled.cancel = () => {
    raf_default.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
__name(throttleByAnimationFrame, "throttleByAnimationFrame");
var throttleByAnimationFrame_default = throttleByAnimationFrame;

// packages/ant-design/components/config-provider/index.tsx
import * as React36 from "react";

// node_modules/.pnpm/@emotion+hash@0.8.0/node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
__name(murmur2, "murmur2");
var hash_browser_esm_default = murmur2;

// packages/cssinjs/src/hooks/useCacheToken.tsx
init_dynamicCSS();
import { useContext as useContext5 } from "react";

// packages/util/src/isEqual.ts
init_warning();
function isEqual(obj1, obj2, shallow = false) {
  const refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b, level = 1) {
    const circular = refSet.has(a);
    warning_default(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    const newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      const keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b).length) {
        return false;
      }
      return keys2.every((key) => deepEqual(a[key], b[key], newLevel));
    }
    return false;
  }
  __name(deepEqual, "deepEqual");
  return deepEqual(obj1, obj2);
}
__name(isEqual, "isEqual");
var isEqual_default = isEqual;

// packages/cssinjs/src/StyleContext.tsx
import * as React8 from "react";

// packages/cssinjs/src/Cache.ts
var SPLIT = "%";
function pathKey(keys2) {
  return keys2.join(SPLIT);
}
__name(pathKey, "pathKey");
var Entity = class {
  static {
    __name(this, "Entity");
  }
  instanceId;
  constructor(instanceId) {
    this.instanceId = instanceId;
  }
  /** @private Internal cache map. Do not access this directly */
  cache = /* @__PURE__ */ new Map();
  get(keys2) {
    return this.opGet(pathKey(keys2));
  }
  /** A fast get cache with `get` concat. */
  opGet(keyPathStr) {
    return this.cache.get(keyPathStr) || null;
  }
  update(keys2, valueFn) {
    return this.opUpdate(pathKey(keys2), valueFn);
  }
  /** A fast get cache with `get` concat. */
  opUpdate(keyPathStr, valueFn) {
    const prevValue = this.cache.get(keyPathStr);
    const nextValue = valueFn(prevValue);
    if (nextValue === null) {
      this.cache.delete(keyPathStr);
    } else {
      this.cache.set(keyPathStr, nextValue);
    }
  }
};
var Cache_default = Entity;

// packages/cssinjs/src/StyleContext.tsx
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var ATTR_CACHE_PATH = "data-cache-path";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
  const cssinjsInstanceId = Math.random().toString(12).slice(2);
  if (typeof document !== "undefined" && document.head && document.body) {
    const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
    const { firstChild } = document.head;
    Array.from(styles).forEach((style2) => {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
      if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
        document.head.insertBefore(style2, firstChild);
      }
    });
    const styleHash = {};
    Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach(
      (style2) => {
        const hash = style2.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            style2.parentNode?.removeChild(style2);
          }
        } else {
          styleHash[hash] = true;
        }
      }
    );
  }
  return new Cache_default(cssinjsInstanceId);
}
__name(createCache, "createCache");
var StyleContext = React8.createContext({
  hashPriority: "low",
  cache: createCache(),
  defaultCache: true
});
var StyleContext_default = StyleContext;

// packages/cssinjs/src/util/index.ts
init_canUseDom();
init_dynamicCSS();

// packages/cssinjs/src/theme/ThemeCache.ts
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (let i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) {
      return false;
    }
  }
  return true;
}
__name(sameDerivativeOption, "sameDerivativeOption");
var ThemeCache = class _ThemeCache {
  static {
    __name(this, "ThemeCache");
  }
  static MAX_CACHE_SIZE = 20;
  static MAX_CACHE_OFFSET = 5;
  cache;
  keys;
  cacheCallTimes;
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(derivativeOption, updateCallTimes = false) {
    let cache = { map: this.cache };
    derivativeOption.forEach((derivative4) => {
      if (!cache) {
        cache = void 0;
      } else {
        cache = cache?.map?.get(derivative4);
      }
    });
    if (cache?.value && updateCallTimes) {
      cache.value[1] = this.cacheCallTimes++;
    }
    return cache?.value;
  }
  get(derivativeOption) {
    return this.internalGet(derivativeOption, true)?.[0];
  }
  has(derivativeOption) {
    return !!this.internalGet(derivativeOption);
  }
  set(derivativeOption, value) {
    if (!this.has(derivativeOption)) {
      if (this.size() + 1 > _ThemeCache.MAX_CACHE_SIZE + _ThemeCache.MAX_CACHE_OFFSET) {
        const [targetKey] = this.keys.reduce(
          (result, key) => {
            const [, callTimes] = result;
            if (this.internalGet(key)[1] < callTimes) {
              return [key, this.internalGet(key)[1]];
            }
            return result;
          },
          [this.keys[0], this.cacheCallTimes]
        );
        this.delete(targetKey);
      }
      this.keys.push(derivativeOption);
    }
    let cache = this.cache;
    derivativeOption.forEach((derivative4, index3) => {
      if (index3 === derivativeOption.length - 1) {
        cache.set(derivative4, { value: [value, this.cacheCallTimes++] });
      } else {
        const cacheValue = cache.get(derivative4);
        if (!cacheValue) {
          cache.set(derivative4, { map: /* @__PURE__ */ new Map() });
        } else if (!cacheValue.map) {
          cacheValue.map = /* @__PURE__ */ new Map();
        }
        cache = cache.get(derivative4).map;
      }
    });
  }
  deleteByPath(currentCache, derivatives) {
    const cache = currentCache.get(derivatives[0]);
    if (derivatives.length === 1) {
      if (!cache.map) {
        currentCache.delete(derivatives[0]);
      } else {
        currentCache.set(derivatives[0], { map: cache.map });
      }
      return cache.value?.[0];
    }
    const result = this.deleteByPath(cache.map, derivatives.slice(1));
    if ((!cache.map || cache.map.size === 0) && !cache.value) {
      currentCache.delete(derivatives[0]);
    }
    return result;
  }
  delete(derivativeOption) {
    if (this.has(derivativeOption)) {
      this.keys = this.keys.filter(
        (item) => !sameDerivativeOption(item, derivativeOption)
      );
      return this.deleteByPath(this.cache, derivativeOption);
    }
    return void 0;
  }
};

// packages/cssinjs/src/theme/Theme.ts
init_warning();
var uuid = 0;
var Theme = class {
  static {
    __name(this, "Theme");
  }
  derivatives;
  id;
  constructor(derivatives) {
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid;
    if (derivatives.length === 0) {
      warning(
        derivatives.length > 0,
        "[Ant Design CSS-in-JS] Theme should have at least one derivative function."
      );
    }
    uuid += 1;
  }
  getDerivativeToken(token2) {
    return this.derivatives.reduce(
      (result, derivative4) => derivative4(token2, result),
      void 0
    );
  }
};

// packages/cssinjs/src/theme/createTheme.ts
var cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}
__name(createTheme, "createTheme");

// packages/cssinjs/src/util/index.ts
var resultCache = /* @__PURE__ */ new WeakMap();
var RESULT_VALUE = {};
function memoResult(callback, deps) {
  let current = resultCache;
  for (let i = 0; i < deps.length; i += 1) {
    const dep = deps[i];
    if (!current.has(dep)) {
      current.set(dep, /* @__PURE__ */ new WeakMap());
    }
    current = current.get(dep);
  }
  if (!current.has(RESULT_VALUE)) {
    current.set(RESULT_VALUE, callback());
  }
  return current.get(RESULT_VALUE);
}
__name(memoResult, "memoResult");
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
function flattenToken(token2, hashed = false) {
  let str = flattenTokenCache.get(token2) || "";
  if (!str) {
    Object.keys(token2).forEach((key) => {
      const value = token2[key];
      str += key;
      if (value instanceof Theme) {
        str += value.id;
      } else if (value && typeof value === "object") {
        str += flattenToken(value, hashed);
      } else {
        str += value;
      }
    });
    if (hashed) {
      str = hash_browser_esm_default(str);
    }
    flattenTokenCache.set(token2, str);
  }
  return str;
}
__name(flattenToken, "flattenToken");
function token2key(token2, salt) {
  return hash_browser_esm_default(`${salt}_${flattenToken(token2, true)}`);
}
__name(token2key, "token2key");
var randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(
  /\./g,
  ""
);
var isClientSide = canUseDom();
function unit(num) {
  if (typeof num === "number") {
    return `${num}px`;
  }
  return num;
}
__name(unit, "unit");
function toStyleStr(style2, tokenKey, styleId, customizeAttrs = {}, plain = false) {
  if (plain) {
    return style2;
  }
  const attrs = {
    ...customizeAttrs,
    [ATTR_TOKEN]: tokenKey,
    [ATTR_MARK]: styleId
  };
  const attrStr = Object.keys(attrs).map((attr) => {
    const val = attrs[attr];
    return val ? `${attr}="${val}"` : null;
  }).filter((v) => v).join(" ");
  return `<style ${attrStr}>${style2}</style>`;
}
__name(toStyleStr, "toStyleStr");

// packages/cssinjs/src/util/css-variables.ts
var token2CSSVar = /* @__PURE__ */ __name((token2, prefix = "") => {
  return `--${prefix ? `${prefix}-` : ""}${token2}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, "token2CSSVar");
var serializeCSSVar = /* @__PURE__ */ __name((cssVars, hashId, options) => {
  if (!Object.keys(cssVars).length) {
    return "";
  }
  return `.${hashId}${options?.scope ? `.${options.scope}` : ""}{${Object.entries(cssVars).map(([key, value]) => `${key}:${value};`).join("")}}`;
}, "serializeCSSVar");
var transformToken = /* @__PURE__ */ __name((token2, themeKey, config) => {
  const cssVars = {};
  const result = {};
  Object.entries(token2).forEach(([key, value]) => {
    if (config?.preserve?.[key]) {
      result[key] = value;
    } else if ((typeof value === "string" || typeof value === "number") && !config?.ignore?.[key]) {
      const cssVar = token2CSSVar(key, config?.prefix);
      cssVars[cssVar] = typeof value === "number" && !config?.unitless?.[key] ? `${value}px` : String(value);
      result[key] = `var(${cssVar})`;
    }
  });
  return [result, serializeCSSVar(cssVars, themeKey, { scope: config?.scope })];
}, "transformToken");

// packages/cssinjs/src/hooks/useGlobalCache.tsx
import * as React12 from "react";

// packages/util/src/hooks/useLayoutEffect.ts
init_canUseDom();
import * as React9 from "react";
var useInternalLayoutEffect = canUseDom() ? React9.useLayoutEffect : React9.useEffect;
var useLayoutEffect2 = /* @__PURE__ */ __name((callback, deps) => {
  const firstMountRef = React9.useRef(true);
  useInternalLayoutEffect(() => {
    return callback(firstMountRef.current);
  }, deps);
  useInternalLayoutEffect(() => {
    firstMountRef.current = false;
    return () => {
      firstMountRef.current = true;
    };
  }, []);
}, "useLayoutEffect");
var useLayoutUpdateEffect = /* @__PURE__ */ __name((callback, deps) => {
  useLayoutEffect2((firstMount) => {
    if (!firstMount) {
      return callback();
    }
  }, deps);
}, "useLayoutUpdateEffect");
var useLayoutEffect_default = useLayoutEffect2;

// packages/cssinjs/src/hooks/useCompatibleInsertionEffect.tsx
import * as React10 from "react";
var fullClone = {
  ...React10
};
var { useInsertionEffect } = fullClone;
var useInsertionEffectPolyfill = /* @__PURE__ */ __name((renderEffect, effect, deps) => {
  React10.useMemo(renderEffect, deps);
  useLayoutEffect_default(() => effect(true), deps);
}, "useInsertionEffectPolyfill");
var useCompatibleInsertionEffect = useInsertionEffect ? (renderEffect, effect, deps) => useInsertionEffect(() => {
  renderEffect();
  return effect();
}, deps) : useInsertionEffectPolyfill;
var useCompatibleInsertionEffect_default = useCompatibleInsertionEffect;

// packages/cssinjs/src/hooks/useEffectCleanupRegister.ts
init_warning();
import * as React11 from "react";
var fullClone2 = {
  ...React11
};
var { useInsertionEffect: useInsertionEffect2 } = fullClone2;
var useCleanupRegister = /* @__PURE__ */ __name((deps) => {
  const effectCleanups = [];
  let cleanupFlag = false;
  function register2(fn) {
    if (cleanupFlag) {
      if (true) {
        warning(
          false,
          "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect."
        );
      }
      return;
    }
    effectCleanups.push(fn);
  }
  __name(register2, "register");
  React11.useEffect(() => {
    cleanupFlag = false;
    return () => {
      cleanupFlag = true;
      if (effectCleanups.length) {
        effectCleanups.forEach((fn) => fn());
      }
    };
  }, deps);
  return register2;
}, "useCleanupRegister");
var useRun = /* @__PURE__ */ __name(() => {
  return function(fn) {
    fn();
  };
}, "useRun");
var useEffectCleanupRegister = typeof useInsertionEffect2 !== "undefined" ? useCleanupRegister : useRun;
var useEffectCleanupRegister_default = useEffectCleanupRegister;

// packages/cssinjs/src/hooks/useHMR.ts
var webpackHMR = false;
function useDevHMR() {
  return webpackHMR;
}
__name(useDevHMR, "useDevHMR");
var useHMR_default = false ? useProdHMR : useDevHMR;
if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
  const win = window;
  if (typeof win.webpackHotUpdate === "function") {
    const originWebpackHotUpdate = win.webpackHotUpdate;
    win.webpackHotUpdate = (...args) => {
      webpackHMR = true;
      setTimeout(() => {
        webpackHMR = false;
      }, 0);
      return originWebpackHotUpdate(...args);
    };
  }
}

// packages/cssinjs/src/hooks/useGlobalCache.tsx
function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
  const { cache: globalCache } = React12.useContext(StyleContext_default);
  const fullPath = [prefix, ...keyPath];
  const fullPathStr = pathKey(fullPath);
  const register2 = useEffectCleanupRegister_default([fullPathStr]);
  const HMRUpdate = useHMR_default();
  const buildCache = /* @__PURE__ */ __name((updater) => {
    globalCache.opUpdate(fullPathStr, (prevCache) => {
      const [times = 0, cache] = prevCache || [void 0, void 0];
      let tmpCache = cache;
      if (cache && HMRUpdate) {
        onCacheRemove?.(tmpCache, HMRUpdate);
        tmpCache = null;
      }
      const mergedCache = tmpCache || cacheFn();
      const data = [times, mergedCache];
      return updater ? updater(data) : data;
    });
  }, "buildCache");
  React12.useMemo(
    () => {
      buildCache();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [fullPathStr]
    /* eslint-enable */
  );
  let cacheEntity = globalCache.opGet(fullPathStr);
  if (!cacheEntity) {
    buildCache();
    cacheEntity = globalCache.opGet(fullPathStr);
  }
  const cacheContent = cacheEntity[1];
  useCompatibleInsertionEffect_default(
    () => {
      onCacheEffect?.(cacheContent);
    },
    (polyfill) => {
      buildCache(([times, cache]) => {
        if (polyfill && times === 0) {
          onCacheEffect?.(cacheContent);
        }
        return [times + 1, cache];
      });
      return () => {
        globalCache.opUpdate(fullPathStr, (prevCache) => {
          const [times = 0, cache] = prevCache || [];
          const nextCount = times - 1;
          if (nextCount === 0) {
            register2(() => {
              if (polyfill || !globalCache.opGet(fullPathStr)) {
                onCacheRemove?.(cache, false);
              }
            });
            return null;
          }
          return [times - 1, cache];
        });
      };
    },
    [fullPathStr]
  );
  return cacheContent;
}
__name(useGlobalCache, "useGlobalCache");

// packages/cssinjs/src/hooks/useCacheToken.tsx
var EMPTY_OVERRIDE = {};
var hashPrefix = true ? "css-dev-only-do-not-override" : "css";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
__name(recordCleanToken, "recordCleanToken");
function removeStyleTags(key, instanceId) {
  if (typeof document !== "undefined") {
    const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
    styles.forEach((style2) => {
      if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
        style2.parentNode?.removeChild(style2);
      }
    });
  }
}
__name(removeStyleTags, "removeStyleTags");
var TOKEN_THRESHOLD = 0;
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  const tokenKeyList = Array.from(tokenKeys.keys());
  const cleanableKeyList = tokenKeyList.filter((key) => {
    const count = tokenKeys.get(key) || 0;
    return count <= 0;
  });
  if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
    cleanableKeyList.forEach((key) => {
      removeStyleTags(key, instanceId);
      tokenKeys.delete(key);
    });
  }
}
__name(cleanTokenStyle, "cleanTokenStyle");
var getComputedToken = /* @__PURE__ */ __name((originToken, overrideToken, theme, format2) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  let mergedDerivativeToken = {
    ...derivativeToken,
    ...overrideToken
  };
  if (format2) {
    mergedDerivativeToken = format2(mergedDerivativeToken);
  }
  return mergedDerivativeToken;
}, "getComputedToken");
var TOKEN_PREFIX = "token";
function useCacheToken(theme, tokens, option = {}) {
  const {
    cache: { instanceId },
    container
  } = useContext5(StyleContext_default);
  const {
    salt = "",
    override = EMPTY_OVERRIDE,
    formatToken: formatToken2,
    getComputedToken: compute,
    cssVar
  } = option;
  const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
  const tokenStr = flattenToken(mergedToken);
  const overrideTokenStr = flattenToken(override);
  const cssVarStr = cssVar ? flattenToken(cssVar) : "";
  const cachedToken = useGlobalCache(
    TOKEN_PREFIX,
    [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr],
    () => {
      let mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken2);
      const actualToken = { ...mergedDerivativeToken };
      let cssVarsStr = "";
      if (!!cssVar) {
        [mergedDerivativeToken, cssVarsStr] = transformToken(
          mergedDerivativeToken,
          cssVar.key,
          {
            prefix: cssVar.prefix,
            ignore: cssVar.ignore,
            unitless: cssVar.unitless,
            preserve: cssVar.preserve
          }
        );
      }
      const tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      actualToken._tokenKey = token2key(actualToken, salt);
      const themeKey = cssVar?.key ?? tokenKey;
      mergedDerivativeToken._themeKey = themeKey;
      recordCleanToken(themeKey);
      const hashId = `${hashPrefix}-${hash_browser_esm_default(tokenKey)}`;
      mergedDerivativeToken._hashId = hashId;
      return [
        mergedDerivativeToken,
        hashId,
        actualToken,
        cssVarsStr,
        cssVar?.key || ""
      ];
    },
    (cache) => {
      cleanTokenStyle(cache[0]._themeKey, instanceId);
    },
    ([token2, , , cssVarsStr]) => {
      if (cssVar && cssVarsStr) {
        const style2 = updateCSS(
          cssVarsStr,
          hash_browser_esm_default(`css-variables-${token2._themeKey}`),
          {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: -999
          }
        );
        style2[CSS_IN_JS_INSTANCE] = instanceId;
        style2.setAttribute(ATTR_TOKEN, token2._themeKey);
      }
    }
  );
  return cachedToken;
}
__name(useCacheToken, "useCacheToken");
var extract = /* @__PURE__ */ __name((cache, effectStyles, options) => {
  const [, , realToken, styleStr, cssVarKey] = cache;
  const { plain } = options || {};
  if (!styleStr) {
    return null;
  }
  const styleId = realToken._tokenKey;
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(
    styleStr,
    cssVarKey,
    styleId,
    sharedAttrs,
    plain
  );
  return [order, styleId, styleText];
}, "extract");

// packages/cssinjs/src/hooks/useCSSVarRegister.ts
init_dynamicCSS();
import { useContext as useContext7 } from "react";

// packages/cssinjs/src/hooks/useStyleRegister.tsx
init_dynamicCSS();
import * as React13 from "react";

// node_modules/.pnpm/@emotion+unitless@0.7.5/node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/.pnpm/stylis@4.3.2/node_modules/stylis/src/Enum.js
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/.pnpm/stylis@4.3.2/node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
__name(trim, "trim");
function replace(value, pattern6, replacement) {
  return value.replace(pattern6, replacement);
}
__name(replace, "replace");
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
__name(indexof, "indexof");
function charat(value, index3) {
  return value.charCodeAt(index3) | 0;
}
__name(charat, "charat");
function substr(value, begin, end) {
  return value.slice(begin, end);
}
__name(substr, "substr");
function strlen(value) {
  return value.length;
}
__name(strlen, "strlen");
function sizeof(value) {
  return value.length;
}
__name(sizeof, "sizeof");
function append(value, array4) {
  return array4.push(value), value;
}
__name(append, "append");

// node_modules/.pnpm/stylis@4.3.2/node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type5, props, children, length2, siblings) {
  return { value, root, parent, type: type5, props, children, line, column, length: length2, return: "", siblings };
}
__name(node, "node");
function char() {
  return character;
}
__name(char, "char");
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
__name(prev, "prev");
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
__name(next, "next");
function peek() {
  return charat(characters, position);
}
__name(peek, "peek");
function caret() {
  return position;
}
__name(caret, "caret");
function slice(begin, end) {
  return substr(characters, begin, end);
}
__name(slice, "slice");
function token(type5) {
  switch (type5) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
__name(token, "token");
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
__name(alloc, "alloc");
function dealloc(value) {
  return characters = "", value;
}
__name(dealloc, "dealloc");
function delimit(type5) {
  return trim(slice(position - 1, delimiter(type5 === 91 ? type5 + 2 : type5 === 40 ? type5 + 1 : type5)));
}
__name(delimit, "delimit");
function whitespace(type5) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type5) > 2 || token(character) > 3 ? "" : " ";
}
__name(whitespace, "whitespace");
function escaping(index3, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index3, caret() + (count < 6 && peek() == 32 && next() == 32));
}
__name(escaping, "escaping");
function delimiter(type5) {
  while (next())
    switch (character) {
      case type5:
        return position;
      case 34:
      case 39:
        if (type5 !== 34 && type5 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type5 === 41)
          delimiter(type5);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
__name(delimiter, "delimiter");
function commenter(type5, index3) {
  while (next())
    if (type5 + character === 47 + 10)
      break;
    else if (type5 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index3, position - 1) + "*" + from(type5 === 47 ? type5 : next());
}
__name(commenter, "commenter");
function identifier(index3) {
  while (!token(peek()))
    next();
  return slice(index3, position);
}
__name(identifier, "identifier");

// node_modules/.pnpm/stylis@4.3.2/node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
__name(compile, "compile");
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index3 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type5 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type5;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index3 ? points[index3 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index3++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index3, offset3, rules, points, type5, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type5, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index3 = offset3 = property = 0, variable = ampersand = 1, type5 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type5 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
__name(parse, "parse");
function ruleset(value, root, parent, index3, offset3, rules, points, type5, props, children, length2, siblings) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index3; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset3 === 0 ? RULESET : type5, props, children, length2, siblings);
}
__name(ruleset, "ruleset");
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
__name(comment, "comment");
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
__name(declaration, "declaration");

// node_modules/.pnpm/stylis@4.3.2/node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
__name(serialize, "serialize");
function stringify(element, index3, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
__name(stringify, "stringify");

// packages/cssinjs/src/linters/utils.ts
init_warning();
function lintWarning(message2, info) {
  const { path: path2, parentSelectors } = info;
  warning_default(
    false,
    `[Ant Design CSS-in-JS] ${path2 ? `Error in ${path2}: ` : ""}${message2}${parentSelectors.length ? ` Selector: ${parentSelectors.join(" | ")}` : ""}`
  );
}
__name(lintWarning, "lintWarning");

// packages/cssinjs/src/linters/contentQuotesLinter.ts
var linter = /* @__PURE__ */ __name((key, value, info) => {
  if (key === "content") {
    const contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    const contentValues = ["normal", "none", "initial", "inherit", "unset"];
    if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
      lintWarning(
        `You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${value}"'\`.`,
        info
      );
    }
  }
}, "linter");
var contentQuotesLinter_default = linter;

// packages/cssinjs/src/linters/hashedAnimationLinter.ts
var linter2 = /* @__PURE__ */ __name((key, value, info) => {
  if (key === "animation") {
    if (info.hashId && value !== "none") {
      lintWarning(
        `You seem to be using hashed animation '${value}', in which case 'animationName' with Keyframe as value is recommended.`,
        info
      );
    }
  }
}, "linter");
var hashedAnimationLinter_default = linter2;

// packages/cssinjs/src/util/cacheMapUtil.ts
init_canUseDom();
var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
var CSS_FILE_STYLE = "_FILE_STYLE__";
var cachePathMap;
var fromCSSFile = true;
function prepare() {
  if (!cachePathMap) {
    cachePathMap = {};
    if (canUseDom()) {
      const div = document.createElement("div");
      div.className = ATTR_CACHE_MAP;
      div.style.position = "fixed";
      div.style.visibility = "hidden";
      div.style.top = "-9999px";
      document.body.appendChild(div);
      let content = getComputedStyle(div).content || "";
      content = content.replace(/^"/, "").replace(/"$/, "");
      content.split(";").forEach((item) => {
        const [path2, hash] = item.split(":");
        cachePathMap[path2] = hash;
      });
      const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
      if (inlineMapStyle) {
        fromCSSFile = false;
        inlineMapStyle.parentNode?.removeChild(inlineMapStyle);
      }
      document.body.removeChild(div);
    }
  }
}
__name(prepare, "prepare");
function existPath(path2) {
  prepare();
  return !!cachePathMap[path2];
}
__name(existPath, "existPath");
function getStyleAndHash(path2) {
  const hash = cachePathMap[path2];
  let styleStr = null;
  if (hash && canUseDom()) {
    if (fromCSSFile) {
      styleStr = CSS_FILE_STYLE;
    } else {
      const style2 = document.querySelector(
        `style[${ATTR_MARK}="${cachePathMap[path2]}"]`
      );
      if (style2) {
        styleStr = style2.innerHTML;
      } else {
        delete cachePathMap[path2];
      }
    }
  }
  return [styleStr, hash];
}
__name(getStyleAndHash, "getStyleAndHash");

// packages/cssinjs/src/hooks/useStyleRegister.tsx
var SKIP_CHECK = "_skip_check_";
var MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr) {
  const serialized = serialize(compile(styleStr), stringify);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
__name(normalizeStyle, "normalizeStyle");
function isCompoundCSSProperty(value) {
  return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
__name(isCompoundCSSProperty, "isCompoundCSSProperty");
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  const hashClassName = `.${hashId}`;
  const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
  const keys2 = key.split(",").map((k) => {
    const fullPath = k.trim().split(/\s+/);
    let firstPath = fullPath[0] || "";
    const htmlElement = firstPath.match(/^\w+/)?.[0] || "";
    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(
      htmlElement.length
    )}`;
    return [firstPath, ...fullPath.slice(1)].join(" ");
  });
  return keys2.join(",");
}
__name(injectSelectorHash, "injectSelectorHash");
var parseStyle = /* @__PURE__ */ __name((interpolation, config = {}, { root, injectHash, parentSelectors } = {
  root: true,
  parentSelectors: []
}) => {
  const {
    hashId,
    layer,
    path: path2,
    hashPriority,
    transformers = [],
    linters = []
  } = config;
  let styleStr = "";
  let effectStyle = {};
  function parseKeyframes(keyframes) {
    const animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      const [parsedStr] = parseStyle(keyframes.style, config, {
        root: false,
        parentSelectors
      });
      effectStyle[animationName] = `@keyframes ${keyframes.getName(
        hashId
      )}${parsedStr}`;
    }
  }
  __name(parseKeyframes, "parseKeyframes");
  function flattenList(list, fullList = []) {
    list.forEach((item) => {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  __name(flattenList, "flattenList");
  const flattenStyleList = flattenList(
    Array.isArray(interpolation) ? interpolation : [interpolation]
  );
  flattenStyleList.forEach((originStyle) => {
    const style2 = typeof originStyle === "string" && !root ? {} : originStyle;
    if (typeof style2 === "string") {
      styleStr += `${style2}
`;
    } else if (style2._keyframe) {
      parseKeyframes(style2);
    } else {
      const mergedStyle = transformers.reduce(
        (prev2, trans) => trans?.visit?.(prev2) || prev2,
        style2
      );
      Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          let subInjectHash = false;
          let mergedKey = key.trim();
          let nextRoot = false;
          if ((root || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else {
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          const [parsedStr, childEffectStyle] = parseStyle(
            value,
            config,
            {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [...parentSelectors, mergedKey]
            }
          );
          effectStyle = {
            ...effectStyle,
            ...childEffectStyle
          };
          styleStr += `${mergedKey}${parsedStr}`;
        } else {
          let appendStyle2 = function(cssKey, cssValue) {
            if (typeof value !== "object" || !value?.[SKIP_CHECK]) {
              [contentQuotesLinter_default, hashedAnimationLinter_default, ...linters].forEach(
                (linter3) => linter3(cssKey, cssValue, { path: path2, hashId, parentSelectors })
              );
            }
            const styleName = cssKey.replace(
              /[A-Z]/g,
              (match2) => `-${match2.toLowerCase()}`
            );
            let formatValue2 = cssValue;
            if (!unitless_browser_esm_default[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
              formatValue2 = `${formatValue2}px`;
            }
            if (cssKey === "animationName" && cssValue?._keyframe) {
              parseKeyframes(cssValue);
              formatValue2 = cssValue.getName(hashId);
            }
            styleStr += `${styleName}:${formatValue2};`;
          };
          var appendStyle = appendStyle2;
          __name(appendStyle2, "appendStyle");
          const actualValue = value?.value ?? value;
          if (typeof value === "object" && value?.[MULTI_VALUE] && Array.isArray(actualValue)) {
            actualValue.forEach((item) => {
              appendStyle2(key, item);
            });
          } else {
            appendStyle2(key, actualValue);
          }
        }
      });
    }
  });
  if (!root) {
    styleStr = `{${styleStr}}`;
  } else if (layer) {
    styleStr = `@layer ${layer.name} {${styleStr}}`;
    if (layer.dependencies) {
      effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
    }
  }
  return [styleStr, effectStyle];
}, "parseStyle");
function uniqueHash(path2, styleStr) {
  return hash_browser_esm_default(`${path2.join("%")}${styleStr}`);
}
__name(uniqueHash, "uniqueHash");
function Empty() {
  return null;
}
__name(Empty, "Empty");
var STYLE_PREFIX = "style";
function useStyleRegister(info, styleFn) {
  const { token: token2, path: path2, hashId, layer, nonce, clientOnly, order = 0 } = info;
  const {
    autoClear,
    mock,
    defaultCache,
    hashPriority,
    container,
    ssrInline,
    transformers,
    linters,
    cache,
    layer: enableLayer
  } = React13.useContext(StyleContext_default);
  const tokenKey = token2._tokenKey;
  const fullPath = [tokenKey];
  if (enableLayer) {
    fullPath.push("layer");
  }
  fullPath.push(...path2);
  let isMergedClientSide = isClientSide;
  if (mock !== void 0) {
    isMergedClientSide = mock === "client";
  }
  const [cachedStyleStr, cachedTokenKey, cachedStyleId] = useGlobalCache(
    STYLE_PREFIX,
    fullPath,
    // Create cache if needed
    () => {
      const cachePath = fullPath.join("|");
      if (existPath(cachePath)) {
        const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
        if (inlineCacheStyleStr) {
          return [
            inlineCacheStyleStr,
            tokenKey,
            styleHash,
            {},
            clientOnly,
            order
          ];
        }
      }
      const styleObj = styleFn();
      const [parsedStyle, effectStyle] = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer: enableLayer ? layer : void 0,
        path: path2.join("-"),
        transformers,
        linters
      });
      const styleStr = normalizeStyle(parsedStyle);
      const styleId = uniqueHash(fullPath, styleStr);
      return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
    },
    // Remove cache if no need
    ([, , styleId], fromHMR) => {
      if ((fromHMR || autoClear) && isClientSide) {
        removeCSS(styleId, { mark: ATTR_MARK });
      }
    },
    // Effect: Inject style here
    ([styleStr, _, styleId, effectStyle]) => {
      if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
        const mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: enableLayer ? false : "queue",
          attachTo: container,
          priority: order
        };
        const nonceStr = typeof nonce === "function" ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = { nonce: nonceStr };
        }
        const effectLayerKeys = [];
        const effectRestKeys = [];
        Object.keys(effectStyle).forEach((key) => {
          if (key.startsWith("@layer")) {
            effectLayerKeys.push(key);
          } else {
            effectRestKeys.push(key);
          }
        });
        effectLayerKeys.forEach((effectKey) => {
          updateCSS(
            normalizeStyle(effectStyle[effectKey]),
            `_layer-${effectKey}`,
            { ...mergedCSSConfig, prepend: true }
          );
        });
        const style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
        style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
        style2.setAttribute(ATTR_TOKEN, tokenKey);
        if (true) {
          style2.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
        }
        effectRestKeys.forEach((effectKey) => {
          updateCSS(
            normalizeStyle(effectStyle[effectKey]),
            `_effect-${effectKey}`,
            mergedCSSConfig
          );
        });
      }
    }
  );
  return (node2) => {
    let styleNode;
    if (!ssrInline || isMergedClientSide || !defaultCache) {
      styleNode = /* @__PURE__ */ React13.createElement(Empty, null);
    } else {
      styleNode = /* @__PURE__ */ React13.createElement(
        "style",
        {
          ...{
            [ATTR_TOKEN]: cachedTokenKey,
            [ATTR_MARK]: cachedStyleId
          },
          dangerouslySetInnerHTML: { __html: cachedStyleStr }
        }
      );
    }
    return /* @__PURE__ */ React13.createElement(React13.Fragment, null, styleNode, node2);
  };
}
__name(useStyleRegister, "useStyleRegister");
var extract2 = /* @__PURE__ */ __name((cache, effectStyles, options) => {
  const [
    styleStr,
    tokenKey,
    styleId,
    effectStyle,
    clientOnly,
    order
  ] = cache;
  const { plain } = options || {};
  if (clientOnly) {
    return null;
  }
  let keyStyleText = styleStr;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);
  if (effectStyle) {
    Object.keys(effectStyle).forEach((effectKey) => {
      if (!effectStyles[effectKey]) {
        effectStyles[effectKey] = true;
        const effectStyleStr = normalizeStyle(effectStyle[effectKey]);
        const effectStyleHTML = toStyleStr(
          effectStyleStr,
          tokenKey,
          `_effect-${effectKey}`,
          sharedAttrs,
          plain
        );
        if (effectKey.startsWith("@layer")) {
          keyStyleText = effectStyleHTML + keyStyleText;
        } else {
          keyStyleText += effectStyleHTML;
        }
      }
    });
  }
  return [order, styleId, keyStyleText];
}, "extract");

// packages/cssinjs/src/hooks/useCSSVarRegister.ts
var CSS_VAR_PREFIX = "cssVar";
var useCSSVarRegister = /* @__PURE__ */ __name((config, fn) => {
  const { key, prefix, unitless: unitless2, ignore: ignore2, token: token2, scope = "" } = config;
  const {
    cache: { instanceId },
    container
  } = useContext7(StyleContext_default);
  const { _tokenKey: tokenKey } = token2;
  const stylePath = [...config.path, key, scope, tokenKey];
  const cache = useGlobalCache(
    CSS_VAR_PREFIX,
    stylePath,
    () => {
      const originToken = fn();
      const [mergedToken, cssVarsStr] = transformToken(originToken, key, {
        prefix,
        unitless: unitless2,
        ignore: ignore2,
        scope
      });
      const styleId = uniqueHash(stylePath, cssVarsStr);
      return [mergedToken, cssVarsStr, styleId, key];
    },
    ([, , styleId]) => {
      if (isClientSide) {
        removeCSS(styleId, { mark: ATTR_MARK });
      }
    },
    ([, cssVarsStr, styleId]) => {
      if (!cssVarsStr) {
        return;
      }
      const style2 = updateCSS(cssVarsStr, styleId, {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId;
      style2.setAttribute(ATTR_TOKEN, key);
    }
  );
  return cache;
}, "useCSSVarRegister");
var extract3 = /* @__PURE__ */ __name((cache, effectStyles, options) => {
  const [, styleStr, styleId, cssVarKey] = cache;
  const { plain } = options || {};
  if (!styleStr) {
    return null;
  }
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(
    styleStr,
    cssVarKey,
    styleId,
    sharedAttrs,
    plain
  );
  return [order, styleId, styleText];
}, "extract");
var useCSSVarRegister_default = useCSSVarRegister;

// packages/cssinjs/src/extractStyle.ts
var ExtractStyleFns = {
  [STYLE_PREFIX]: extract2,
  [TOKEN_PREFIX]: extract,
  [CSS_VAR_PREFIX]: extract3
};

// packages/cssinjs/src/Keyframes.ts
var Keyframe = class {
  static {
    __name(this, "Keyframe");
  }
  name;
  style;
  constructor(name, style2) {
    this.name = name;
    this.style = style2;
  }
  getName(hashId = "") {
    return hashId ? `${hashId}-${this.name}` : this.name;
  }
  _keyframe = true;
};
var Keyframes_default = Keyframe;

// packages/cssinjs/src/transformers/legacyLogicalProperties.ts
function noSplit(list) {
  list.notSplit = true;
  return list;
}
__name(noSplit, "noSplit");
var keyMap = {
  // Inset
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  // Margin
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  // Padding
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  // Border
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  // Border width
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  // Border style
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  // Border color
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  // Border radius
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
};

// packages/ant-design/components/config-provider/index.tsx
var import_Context = __toESM(require_Context());

// packages/util/src/utils/get.ts
function get(entity, path2) {
  let current = entity;
  for (let i = 0; i < path2.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i]];
  }
  return current;
}
__name(get, "get");

// packages/util/src/utils/set.ts
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  const [path2, ...restPath] = paths;
  let clone;
  if (!entity && typeof path2 === "number") {
    clone = [];
  } else if (Array.isArray(entity)) {
    clone = [...entity];
  } else {
    clone = { ...entity };
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone[path2][restPath[0]];
  } else {
    clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined);
  }
  return clone;
}
__name(internalSet, "internalSet");
function set(entity, paths, value, removeIfUndefined = false) {
  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
__name(set, "set");
function isObject(obj) {
  return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
__name(isObject, "isObject");
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
__name(createEmpty, "createEmpty");
var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
function merge(...sources) {
  let clone = createEmpty(sources[0]);
  sources.forEach((src) => {
    function internalMerge(path2, parentLoopSet) {
      const loopSet = new Set(parentLoopSet);
      const value = get(src, path2);
      const isArr = Array.isArray(value);
      if (isArr || isObject(value)) {
        if (!loopSet.has(value)) {
          loopSet.add(value);
          const originValue = get(clone, path2);
          if (isArr) {
            clone = set(clone, path2, []);
          } else if (!originValue || typeof originValue !== "object") {
            clone = set(clone, path2, createEmpty(value));
          }
          keys(value).forEach((key) => {
            internalMerge([...path2, key], loopSet);
          });
        }
      } else {
        clone = set(clone, path2, value);
      }
    }
    __name(internalMerge, "internalMerge");
    internalMerge([]);
  });
  return clone;
}
__name(merge, "merge");

// packages/ant-design/components/_util/warning.ts
init_warning();
import * as React14 from "react";
function noop() {
}
__name(noop, "noop");
var deprecatedWarnList = null;
var warning2 = noop;
if (true) {
  warning2 = /* @__PURE__ */ __name((valid, component, message2) => {
    warning_default(valid, `[antd: ${component}] ${message2}`);
    if (false) {
      resetWarned();
    }
  }, "warning");
}
var WarningContext = React14.createContext({});
var devUseWarning = true ? (component) => {
  const { strict } = React14.useContext(WarningContext);
  const typeWarning = /* @__PURE__ */ __name((valid, type5, message2) => {
    if (!valid) {
      if (strict === false && type5 === "deprecated") {
        const existWarning = deprecatedWarnList;
        if (!deprecatedWarnList) {
          deprecatedWarnList = {};
        }
        deprecatedWarnList[component] = deprecatedWarnList[component] || [];
        if (!deprecatedWarnList[component].includes(message2 || "")) {
          deprecatedWarnList[component].push(message2 || "");
        }
        if (!existWarning) {
          console.warn(
            "[antd] There exists deprecated usage in your code:",
            deprecatedWarnList
          );
        }
      } else {
        warning2(valid, component, message2);
      }
    }
  }, "typeWarning");
  typeWarning.deprecated = (valid, oldProp, newProp, message2) => {
    typeWarning(
      valid,
      "deprecated",
      `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message2 ? ` ${message2}` : ""}`
    );
  };
  return typeWarning;
} : () => {
  const noopWarning = /* @__PURE__ */ __name(() => {
  }, "noopWarning");
  noopWarning.deprecated = noop;
  return noopWarning;
};
var warning_default2 = warning2;

// packages/ant-design/components/form/validateMessagesContext.tsx
import { createContext as createContext4 } from "react";
var validateMessagesContext_default = createContext4(void 0);

// packages/ant-design/components/locale/index.tsx
import * as React16 from "react";

// packages/pagination/src/locale/en_US.ts
var locale = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var en_US_default = locale;

// packages/picker/src/locale/en_US.ts
var locale2 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
var en_US_default2 = locale2;

// packages/ant-design/components/time-picker/locale/en_US.ts
var locale3 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var en_US_default3 = locale3;

// packages/ant-design/components/date-picker/locale/en_US.ts
var locale4 = {
  lang: {
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"],
    ...en_US_default2
  },
  timePickerLocale: {
    ...en_US_default3
  }
};
var en_US_default4 = locale4;

// packages/ant-design/components/calendar/locale/en_US.ts
var en_US_default5 = en_US_default4;

// packages/ant-design/components/locale/en_US.ts
var typeTemplate = "${label} is not a valid ${type}";
var localeValues = {
  locale: "en",
  Pagination: en_US_default,
  DatePicker: en_US_default4,
  TimePicker: en_US_default3,
  Calendar: en_US_default5,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty"
  }
};
var en_US_default6 = localeValues;

// packages/ant-design/components/modal/locale.ts
var runtimeLocale = {
  ...en_US_default6.Modal
};
var localeList = [];
var generateLocale = /* @__PURE__ */ __name(() => localeList.reduce(
  (merged, locale6) => ({ ...merged, ...locale6 }),
  en_US_default6.Modal
), "generateLocale");
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    const cloneLocale = { ...newLocale };
    localeList.push(cloneLocale);
    runtimeLocale = generateLocale();
    return () => {
      localeList = localeList.filter((locale6) => locale6 !== cloneLocale);
      runtimeLocale = generateLocale();
    };
  }
  runtimeLocale = {
    ...en_US_default6.Modal
  };
}
__name(changeConfirmLocale, "changeConfirmLocale");
function getConfirmLocale() {
  return runtimeLocale;
}
__name(getConfirmLocale, "getConfirmLocale");

// packages/ant-design/components/locale/context.ts
import { createContext as createContext5 } from "react";
var LocaleContext = createContext5(void 0);
var context_default = LocaleContext;

// packages/ant-design/components/locale/useLocale.ts
import * as React15 from "react";
var useLocale = /* @__PURE__ */ __name((componentName, defaultLocale) => {
  const fullLocale = React15.useContext(context_default);
  const getLocale = React15.useMemo(() => {
    const locale6 = defaultLocale || en_US_default6[componentName];
    const localeFromContext = fullLocale?.[componentName] ?? {};
    return {
      ...typeof locale6 === "function" ? locale6() : locale6,
      ...localeFromContext || {}
    };
  }, [componentName, defaultLocale, fullLocale]);
  const getLocaleCode = React15.useMemo(() => {
    const localeCode = fullLocale?.locale;
    if (fullLocale?.exist && !localeCode) {
      return en_US_default6.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
}, "useLocale");
var useLocale_default = useLocale;

// packages/ant-design/components/locale/index.tsx
var ANT_MARK = "internalMark";
var LocaleProvider = /* @__PURE__ */ __name((props) => {
  const { locale: locale6 = {}, children, _ANT_MARK__ } = props;
  if (true) {
    const warning5 = devUseWarning("LocaleProvider");
    warning5(
      _ANT_MARK__ === ANT_MARK,
      "deprecated",
      "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale"
    );
  }
  React16.useEffect(() => {
    const clearLocale = changeConfirmLocale(locale6 && locale6.Modal);
    return clearLocale;
  }, [locale6]);
  const getMemoizedContextValue = React16.useMemo(
    () => ({ ...locale6, exist: true }),
    [locale6]
  );
  return /* @__PURE__ */ React16.createElement(context_default.Provider, { value: getMemoizedContextValue }, children);
}, "LocaleProvider");
if (true) {
  LocaleProvider.displayName = "LocaleProvider";
}
var locale_default = LocaleProvider;

// packages/ant-design/components/theme/context.ts
import React17 from "react";

// packages/ant-design/components/theme/themes/default/index.ts
init_src();

// packages/ant-design/components/theme/themes/seed.ts
var defaultPresetColors = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
var seedToken = {
  // preset color palettes
  ...defaultPresetColors,
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: false,
  // Motion
  motion: true
};
var seed_default = seedToken;

// packages/ant-design/components/theme/themes/shared/genColorMapToken.ts
init_public_api();
function genColorMapToken(seed, { generateColorPalettes: generateColorPalettes3, generateNeutralColorPalettes: generateNeutralColorPalettes3 }) {
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed;
  const primaryColors = generateColorPalettes3(colorPrimaryBase);
  const successColors = generateColorPalettes3(colorSuccessBase);
  const warningColors = generateColorPalettes3(colorWarningBase);
  const errorColors = generateColorPalettes3(colorErrorBase);
  const infoColors = generateColorPalettes3(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes3(colorBgBase, colorTextBase);
  const colorLink = seed.colorLink || seed.colorInfo;
  const linkColors = generateColorPalettes3(colorLink);
  return {
    ...neutralColors,
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorLinkHover: linkColors[4],
    colorLink: linkColors[6],
    colorLinkActive: linkColors[7],
    colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  };
}
__name(genColorMapToken, "genColorMapToken");

// packages/ant-design/components/theme/themes/shared/genRadius.ts
var genRadius = /* @__PURE__ */ __name((radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
}, "genRadius");
var genRadius_default = genRadius;

// packages/ant-design/components/theme/themes/shared/genCommonMapToken.ts
function genCommonMapToken(token2) {
  const { motionUnit, motionBase, borderRadius, lineWidth } = token2;
  return {
    // motion
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    // line
    lineWidthBold: lineWidth + 1,
    // radius
    ...genRadius_default(borderRadius)
  };
}
__name(genCommonMapToken, "genCommonMapToken");

// packages/ant-design/components/theme/themes/shared/genControlHeight.ts
var genControlHeight = /* @__PURE__ */ __name((token2) => {
  const { controlHeight } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
}, "genControlHeight");
var genControlHeight_default = genControlHeight;

// packages/ant-design/components/theme/themes/shared/genFontSizes.ts
function getLineHeight(fontSize) {
  return (fontSize + 8) / fontSize;
}
__name(getLineHeight, "getLineHeight");
function getFontSizes(base) {
  const fontSizes = new Array(10).fill(null).map((_, index3) => {
    const i = index3 - 1;
    const baseSize = base * 2.71828 ** (i / 5);
    const intSize = index3 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base;
  return fontSizes.map((size) => ({
    size,
    lineHeight: getLineHeight(size)
  }));
}
__name(getFontSizes, "getFontSizes");

// packages/ant-design/components/theme/themes/shared/genFontMapToken.ts
var genFontMapToken = /* @__PURE__ */ __name((fontSize) => {
  const fontSizePairs = getFontSizes(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  const fontSizeMD = fontSizes[1];
  const fontSizeSM = fontSizes[0];
  const fontSizeLG = fontSizes[2];
  const lineHeight = lineHeights[1];
  const lineHeightSM = lineHeights[0];
  const lineHeightLG = lineHeights[2];
  return {
    fontSizeSM,
    fontSize: fontSizeMD,
    fontSizeLG,
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight,
    lineHeightLG,
    lineHeightSM,
    fontHeight: Math.round(lineHeight * fontSizeMD),
    fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
    fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
}, "genFontMapToken");
var genFontMapToken_default = genFontMapToken;

// packages/ant-design/components/theme/themes/shared/genSizeMapToken.ts
function genSizeMapToken(token2) {
  const { sizeUnit, sizeStep } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    // 48
    sizeXL: sizeUnit * (sizeStep + 4),
    // 32
    sizeLG: sizeUnit * (sizeStep + 2),
    // 24
    sizeMD: sizeUnit * (sizeStep + 1),
    // 20
    sizeMS: sizeUnit * sizeStep,
    // 16
    size: sizeUnit * sizeStep,
    // 16
    sizeSM: sizeUnit * (sizeStep - 1),
    // 12
    sizeXS: sizeUnit * (sizeStep - 2),
    // 8
    sizeXXS: sizeUnit * (sizeStep - 3)
    // 4
  };
}
__name(genSizeMapToken, "genSizeMapToken");

// packages/ant-design/components/theme/themes/default/colors.ts
init_src();

// packages/ant-design/components/theme/themes/default/colorAlgorithm.ts
init_public_api();
var getAlphaColor = /* @__PURE__ */ __name((baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), "getAlphaColor");
var getSolidColor = /* @__PURE__ */ __name((baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.darken(brightness).toHexString();
}, "getSolidColor");

// packages/ant-design/components/theme/themes/default/colors.ts
var generateColorPalettes = /* @__PURE__ */ __name((baseColor) => {
  const colors = generate(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, "generateColorPalettes");
var generateNeutralColorPalettes = /* @__PURE__ */ __name((bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.02),
    colorBgLayout: getSolidColor(colorBgBase, 4),
    colorBgContainer: getSolidColor(colorBgBase, 0),
    colorBgElevated: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor(colorTextBase, 0.85),
    colorBgBlur: "transparent",
    colorBorder: getSolidColor(colorBgBase, 15),
    colorBorderSecondary: getSolidColor(colorBgBase, 6)
  };
}, "generateNeutralColorPalettes");

// packages/ant-design/components/theme/themes/default/index.ts
function derivative(token2) {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors[i];
      prev2[`${colorKey}${i + 1}`] = colors[i];
      return prev2;
    }, {});
  }).reduce(
    (prev2, cur) => {
      prev2 = {
        ...prev2,
        ...cur
      };
      return prev2;
    },
    {}
  );
  return {
    ...token2,
    ...colorPalettes,
    // Colors
    ...genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    }),
    // Font
    ...genFontMapToken_default(token2.fontSize),
    // Size
    ...genSizeMapToken(token2),
    // Height
    ...genControlHeight_default(token2),
    // Others
    ...genCommonMapToken(token2)
  };
}
__name(derivative, "derivative");

// packages/ant-design/components/theme/context.ts
var defaultTheme = createTheme(derivative);
var defaultConfig = {
  token: seed_default,
  override: { override: seed_default },
  hashed: true
};
var DesignTokenContext = React17.createContext(defaultConfig);

// packages/ant-design/components/config-provider/context.ts
import * as React18 from "react";
var defaultIconPrefixCls = "anticon";
var defaultGetPrefixCls = /* @__PURE__ */ __name((suffixCls, customizePrefixCls) => {
  if (customizePrefixCls) {
    return customizePrefixCls;
  }
  return suffixCls ? `ant-${suffixCls}` : "ant";
}, "defaultGetPrefixCls");
var ConfigContext = React18.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
});
var { Consumer: ConfigConsumer } = ConfigContext;

// packages/ant-design/components/config-provider/cssVariables.ts
init_src();
init_public_api();
init_canUseDom();
init_dynamicCSS();
var dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle(globalPrefixCls2, theme) {
  const variables = {};
  const formatColor = /* @__PURE__ */ __name((color, updater) => {
    let clone = color.clone();
    clone = updater?.(clone) || clone;
    return clone.toRgbString();
  }, "formatColor");
  const fillColor = /* @__PURE__ */ __name((colorVal, type5) => {
    const baseColor = new TinyColor(colorVal);
    const colorPalettes = generate(baseColor.toRgbString());
    variables[`${type5}-color`] = formatColor(baseColor);
    variables[`${type5}-color-disabled`] = colorPalettes[1];
    variables[`${type5}-color-hover`] = colorPalettes[4];
    variables[`${type5}-color-active`] = colorPalettes[6];
    variables[`${type5}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables[`${type5}-color-deprecated-bg`] = colorPalettes[0];
    variables[`${type5}-color-deprecated-border`] = colorPalettes[2];
  }, "fillColor");
  if (theme.primaryColor) {
    fillColor(theme.primaryColor, "primary");
    const primaryColor = new TinyColor(theme.primaryColor);
    const primaryColors = generate(primaryColor.toRgbString());
    primaryColors.forEach((color, index3) => {
      variables[`primary-${index3 + 1}`] = color;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c) => c.lighten(35));
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c) => c.lighten(20));
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c) => c.tint(20));
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c) => c.tint(50));
    variables["primary-color-deprecated-f-12"] = formatColor(
      primaryColor,
      (c) => c.setAlpha(c.getAlpha() * 0.12)
    );
    const primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(
      primaryActiveColor,
      (c) => c.setAlpha(c.getAlpha() * 0.3)
    );
    variables["primary-color-active-deprecated-d-02"] = formatColor(
      primaryActiveColor,
      (c) => c.darken(2)
    );
  }
  if (theme.successColor) {
    fillColor(theme.successColor, "success");
  }
  if (theme.warningColor) {
    fillColor(theme.warningColor, "warning");
  }
  if (theme.errorColor) {
    fillColor(theme.errorColor, "error");
  }
  if (theme.infoColor) {
    fillColor(theme.infoColor, "info");
  }
  const cssList = Object.keys(variables).map(
    (key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`
  );
  return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
}
__name(getStyle, "getStyle");
function registerTheme(globalPrefixCls2, theme) {
  const style2 = getStyle(globalPrefixCls2, theme);
  if (canUseDom()) {
    updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
  } else {
    warning_default2(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
  }
}
__name(registerTheme, "registerTheme");

// packages/ant-design/components/config-provider/DisabledContext.tsx
import * as React19 from "react";
var DisabledContext = React19.createContext(false);
var DisabledContextProvider = /* @__PURE__ */ __name(({ children, disabled }) => {
  const originDisabled = React19.useContext(DisabledContext);
  return /* @__PURE__ */ React19.createElement(DisabledContext.Provider, { value: disabled ?? originDisabled }, children);
}, "DisabledContextProvider");
var DisabledContext_default = DisabledContext;

// packages/ant-design/components/config-provider/hooks/useConfig.ts
import { useContext as useContext12 } from "react";

// packages/ant-design/components/config-provider/SizeContext.tsx
import * as React20 from "react";
var SizeContext = React20.createContext(void 0);
var SizeContextProvider = /* @__PURE__ */ __name(({ children, size }) => {
  const originSize = React20.useContext(SizeContext);
  return /* @__PURE__ */ React20.createElement(SizeContext.Provider, { value: size || originSize }, children);
}, "SizeContextProvider");
var SizeContext_default = SizeContext;

// packages/ant-design/components/config-provider/hooks/useConfig.ts
function useConfig() {
  const componentDisabled = useContext12(DisabledContext_default);
  const componentSize = useContext12(SizeContext_default);
  return {
    componentDisabled,
    componentSize
  };
}
__name(useConfig, "useConfig");
var useConfig_default = useConfig;

// packages/ant-design/components/theme/interface/presetColors.ts
var PresetColors = [
  "blue",
  "purple",
  "cyan",
  "green",
  "magenta",
  "pink",
  "red",
  "orange",
  "yellow",
  "volcano",
  "geekblue",
  "lime",
  "gold"
];

// packages/ant-design/components/theme/useToken.ts
import React21 from "react";

// packages/ant-design/components/version/index.ts
var version = "5.16.4";
var version_default = version;

// packages/ant-design/components/theme/util/alias.ts
init_public_api();

// packages/ant-design/components/theme/util/getAlphaColor.ts
init_public_api();
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
__name(isStableColor, "isStableColor");
function getAlphaColor2(frontColor, backgroundColor) {
  const { r: fR, g: fG, b: fB, a: originAlpha } = new TinyColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const { r: bR, g: bG, b: bB } = new TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g = Math.round((fG - bG * (1 - fA)) / fA);
    const b = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g) && isStableColor(b)) {
      return new TinyColor({ r: r2, g, b, a: Math.round(fA * 100) / 100 }).toRgbString();
    }
  }
  return new TinyColor({ r: fR, g: fG, b: fB, a: 1 }).toRgbString();
}
__name(getAlphaColor2, "getAlphaColor");
var getAlphaColor_default = getAlphaColor2;

// packages/ant-design/components/theme/util/alias.ts
function formatToken(derivativeToken) {
  const { override, ...restToken } = derivativeToken;
  const overrideTokens = { ...override };
  Object.keys(seed_default).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = {
    ...restToken,
    ...overrideTokens
  };
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  if (mergedToken.motion === false) {
    const fastDuration = "0s";
    mergedToken.motionDurationFast = fastDuration;
    mergedToken.motionDurationMid = fastDuration;
    mergedToken.motionDurationSlow = fastDuration;
  }
  const aliasToken = {
    ...mergedToken,
    // ============== Background ============== //
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    // Font
    fontSizeIcon: mergedToken.fontSizeSM,
    // Line
    lineWidthFocus: mergedToken.lineWidth * 4,
    // Control
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    // Override AliasToken
    ...overrideTokens
  };
  return aliasToken;
}
__name(formatToken, "formatToken");

// packages/ant-design/components/theme/useToken.ts
var unitless = {
  lineHeight: true,
  lineHeightSM: true,
  lineHeightLG: true,
  lineHeightHeading1: true,
  lineHeightHeading2: true,
  lineHeightHeading3: true,
  lineHeightHeading4: true,
  lineHeightHeading5: true,
  opacityLoading: true,
  fontWeightStrong: true,
  zIndexPopupBase: true,
  zIndexBase: true
};
var ignore = {
  size: true,
  sizeSM: true,
  sizeLG: true,
  sizeMD: true,
  sizeXS: true,
  sizeXXS: true,
  sizeMS: true,
  sizeXL: true,
  sizeXXL: true,
  sizeUnit: true,
  sizeStep: true,
  motionBase: true,
  motionUnit: true
};
var preserve = {
  screenXS: true,
  screenXSMin: true,
  screenXSMax: true,
  screenSM: true,
  screenSMMin: true,
  screenSMMax: true,
  screenMD: true,
  screenMDMin: true,
  screenMDMax: true,
  screenLG: true,
  screenLGMin: true,
  screenLGMax: true,
  screenXL: true,
  screenXLMin: true,
  screenXLMax: true,
  screenXXL: true,
  screenXXLMin: true
};
var getComputedToken2 = /* @__PURE__ */ __name((originToken, overrideToken, theme) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  const { override, ...components } = overrideToken;
  let mergedDerivativeToken = {
    ...derivativeToken,
    override
  };
  mergedDerivativeToken = formatToken(mergedDerivativeToken);
  if (components) {
    Object.entries(components).forEach(([key, value]) => {
      const { theme: componentTheme, ...componentTokens } = value;
      let mergedComponentToken = componentTokens;
      if (componentTheme) {
        mergedComponentToken = getComputedToken2(
          {
            ...mergedDerivativeToken,
            ...componentTokens
          },
          {
            override: componentTokens
          },
          componentTheme
        );
      }
      mergedDerivativeToken[key] = mergedComponentToken;
    });
  }
  return mergedDerivativeToken;
}, "getComputedToken");
function useToken() {
  const {
    token: rootDesignToken,
    hashed,
    theme,
    override,
    cssVar
  } = React21.useContext(DesignTokenContext);
  const salt = `${version_default}-${hashed || ""}`;
  const mergedTheme = theme || defaultTheme;
  const [token2, hashId, realToken] = useCacheToken(
    mergedTheme,
    [seed_default, rootDesignToken],
    {
      salt,
      override,
      getComputedToken: getComputedToken2,
      // formatToken will not be consumed after 1.15.0 with getComputedToken.
      // But token will break if @ant-design/cssinjs is under 1.15.0 without it
      formatToken,
      cssVar: cssVar && {
        prefix: cssVar.prefix,
        key: cssVar.key,
        unitless,
        ignore,
        preserve
      }
    }
  );
  return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar];
}
__name(useToken, "useToken");

// packages/ant-design/components/theme/util/calc/calculator.ts
var AbstractCalculator = class {
  static {
    __name(this, "AbstractCalculator");
  }
};
var calculator_default = AbstractCalculator;

// packages/ant-design/components/theme/util/calc/CSSCalculator.ts
var CALC_UNIT = "CALC_UNIT";
var regexp = new RegExp(CALC_UNIT, "g");
function unit2(value) {
  if (typeof value === "number") {
    return `${value}${CALC_UNIT}`;
  }
  return value;
}
__name(unit2, "unit");
var CSSCalculator = class _CSSCalculator extends calculator_default {
  constructor(num) {
    super();
    this.result = "";
    if (num instanceof _CSSCalculator) {
      this.result = `(${num.result})`;
    } else if (typeof num === "number") {
      this.result = unit2(num);
    } else if (typeof num === "string") {
      this.result = num;
    }
  }
  static {
    __name(this, "CSSCalculator");
  }
  add(num) {
    if (num instanceof _CSSCalculator) {
      this.result = `${this.result} + ${num.getResult()}`;
    } else if (typeof num === "number" || typeof num === "string") {
      this.result = `${this.result} + ${unit2(num)}`;
    }
    this.lowPriority = true;
    return this;
  }
  sub(num) {
    if (num instanceof _CSSCalculator) {
      this.result = `${this.result} - ${num.getResult()}`;
    } else if (typeof num === "number" || typeof num === "string") {
      this.result = `${this.result} - ${unit2(num)}`;
    }
    this.lowPriority = true;
    return this;
  }
  mul(num) {
    if (this.lowPriority) {
      this.result = `(${this.result})`;
    }
    if (num instanceof _CSSCalculator) {
      this.result = `${this.result} * ${num.getResult(true)}`;
    } else if (typeof num === "number" || typeof num === "string") {
      this.result = `${this.result} * ${num}`;
    }
    this.lowPriority = false;
    return this;
  }
  div(num) {
    if (this.lowPriority) {
      this.result = `(${this.result})`;
    }
    if (num instanceof _CSSCalculator) {
      this.result = `${this.result} / ${num.getResult(true)}`;
    } else if (typeof num === "number" || typeof num === "string") {
      this.result = `${this.result} / ${num}`;
    }
    this.lowPriority = false;
    return this;
  }
  getResult(force) {
    return this.lowPriority || force ? `(${this.result})` : this.result;
  }
  equal(options) {
    const { unit: cssUnit = true } = options || {};
    this.result = this.result.replace(regexp, cssUnit ? "px" : "");
    if (typeof this.lowPriority !== "undefined") {
      return `calc(${this.result})`;
    }
    return this.result;
  }
};

// packages/ant-design/components/theme/util/calc/NumCalculator.ts
var NumCalculator = class _NumCalculator extends calculator_default {
  constructor(num) {
    super();
    this.result = 0;
    if (num instanceof _NumCalculator) {
      this.result = num.result;
    } else if (typeof num === "number") {
      this.result = num;
    }
  }
  static {
    __name(this, "NumCalculator");
  }
  add(num) {
    if (num instanceof _NumCalculator) {
      this.result += num.result;
    } else if (typeof num === "number") {
      this.result += num;
    }
    return this;
  }
  sub(num) {
    if (num instanceof _NumCalculator) {
      this.result -= num.result;
    } else if (typeof num === "number") {
      this.result -= num;
    }
    return this;
  }
  mul(num) {
    if (num instanceof _NumCalculator) {
      this.result *= num.result;
    } else if (typeof num === "number") {
      this.result *= num;
    }
    return this;
  }
  div(num) {
    if (num instanceof _NumCalculator) {
      this.result /= num.result;
    } else if (typeof num === "number") {
      this.result /= num;
    }
    return this;
  }
  equal() {
    return this.result;
  }
};

// packages/ant-design/components/theme/util/calc/index.ts
var genCalc = /* @__PURE__ */ __name((type5) => {
  const Calculator = type5 === "css" ? CSSCalculator : NumCalculator;
  return (num) => new Calculator(num);
}, "genCalc");
var calc_default = genCalc;

// packages/ant-design/components/theme/util/genComponentStyleHook.tsx
import React24, { useContext as useContext13 } from "react";

// packages/util/src/hooks/useEvent.ts
import * as React22 from "react";
function useEvent(callback) {
  const fnRef = React22.useRef();
  fnRef.current = callback;
  const memoFn = React22.useCallback(
    (...args) => fnRef.current?.(...args),
    []
  );
  return memoFn;
}
__name(useEvent, "useEvent");

// packages/util/src/hooks/useState.ts
import * as React23 from "react";
function useSafeState(defaultValue) {
  const destroyRef = React23.useRef(false);
  const [value, setValue] = React23.useState(defaultValue);
  React23.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  __name(safeSetState, "safeSetState");
  return [value, safeSetState];
}
__name(useSafeState, "useSafeState");

// packages/util/src/hooks/useMergedState.ts
function hasValue(value) {
  return value !== void 0;
}
__name(hasValue, "hasValue");
function useMergedState(defaultStateValue, option) {
  const { defaultValue, value, onChange, postState } = option || {};
  const [innerValue, setInnerValue] = useSafeState(() => {
    if (hasValue(value)) {
      return value;
    } else if (hasValue(defaultValue)) {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    } else {
      return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    }
  });
  const mergedValue = value !== void 0 ? value : innerValue;
  const postMergedValue = postState ? postState(mergedValue) : mergedValue;
  const onChangeFn = useEvent(onChange);
  const [prevValue, setPrevValue] = useSafeState([mergedValue]);
  useLayoutUpdateEffect(() => {
    const prev2 = prevValue[0];
    if (innerValue !== prev2) {
      onChangeFn(innerValue, prev2);
    }
  }, [prevValue]);
  useLayoutUpdateEffect(() => {
    if (!hasValue(value)) {
      setInnerValue(value);
    }
  }, [value]);
  const triggerChange = useEvent((updater, ignoreDestroy) => {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
__name(useMergedState, "useMergedState");

// packages/util/src/index.ts
init_warning();

// packages/ant-design/components/style/operationUnit.ts
var operationUnit = /* @__PURE__ */ __name((token2) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: token2.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${token2.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: token2.colorLinkHover
  },
  "&:active": {
    color: token2.colorLinkActive
  }
}), "operationUnit");

// packages/ant-design/components/style/index.ts
var textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
var resetComponent = /* @__PURE__ */ __name((token2, needInheritFontFamily = false) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: token2.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
}), "resetComponent");
var resetIcon = /* @__PURE__ */ __name(() => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), "resetIcon");
var clearFix = /* @__PURE__ */ __name(() => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), "clearFix");
var genLinkStyle = /* @__PURE__ */ __name((token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    [`&:active,
  &:hover`]: {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), "genLinkStyle");
var genCommonStyle = /* @__PURE__ */ __name((token2, componentPrefixCls, rootCls, resetFont) => {
  const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
  const resetStyle = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let resetFontStyle = {};
  if (resetFont !== false) {
    resetFontStyle = {
      fontFamily: token2.fontFamily,
      fontSize: token2.fontSize
    };
  }
  return {
    [rootPrefixSelector]: {
      ...resetFontStyle,
      ...resetStyle,
      [prefixSelector]: resetStyle
    }
  };
}, "genCommonStyle");
var genFocusOutline = /* @__PURE__ */ __name((token2) => ({
  outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), "genFocusOutline");
var genFocusStyle = /* @__PURE__ */ __name((token2) => ({
  "&:focus-visible": {
    ...genFocusOutline(token2)
  }
}), "genFocusStyle");

// packages/ant-design/components/theme/util/maxmin.ts
function genMaxMin(type5) {
  if (type5 === "js") {
    return {
      max: Math.max,
      min: Math.min
    };
  }
  return {
    max: (...args) => `max(${args.map((value) => unit(value)).join(",")})`,
    min: (...args) => `min(${args.map((value) => unit(value)).join(",")})`
  };
}
__name(genMaxMin, "genMaxMin");

// packages/ant-design/components/theme/util/statistic.ts
var enableStatistic = true;
var recording = true;
function merge2(...objs) {
  if (!enableStatistic) {
    return Object.assign({}, ...objs);
  }
  recording = false;
  const ret = {};
  objs.forEach((obj) => {
    const keys2 = Object.keys(obj);
    keys2.forEach((key) => {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: () => obj[key]
      });
    });
  });
  recording = true;
  return ret;
}
__name(merge2, "merge");
var statistic = {};
function noop2() {
}
__name(noop2, "noop");
var statisticToken = /* @__PURE__ */ __name((token2) => {
  let tokenKeys2;
  let proxy = token2;
  let flush = noop2;
  if (enableStatistic && typeof Proxy !== "undefined") {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get(obj, prop) {
        if (recording) {
          tokenKeys2.add(prop);
        }
        return obj[prop];
      }
    });
    flush = /* @__PURE__ */ __name((componentName, componentToken) => {
      statistic[componentName] = {
        global: Array.from(tokenKeys2),
        component: {
          ...statistic[componentName]?.component,
          ...componentToken
        }
      };
    }, "flush");
  }
  return { token: proxy, keys: tokenKeys2, flush };
}, "statisticToken");
var statistic_default = statisticToken;

// packages/ant-design/components/theme/util/useResetIconStyle.ts
var useResetIconStyle = /* @__PURE__ */ __name((iconPrefixCls, csp) => {
  const [theme, token2] = useToken();
  return useStyleRegister(
    {
      theme,
      token: token2,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls],
      nonce: () => csp?.nonce
    },
    () => [
      {
        [`.${iconPrefixCls}`]: {
          ...resetIcon(),
          [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
            display: "block"
          }
        }
      }
    ]
  );
}, "useResetIconStyle");
var useResetIconStyle_default = useResetIconStyle;

// packages/ant-design/components/theme/util/genComponentStyleHook.tsx
var getDefaultComponentToken = /* @__PURE__ */ __name((component, token2, getDefaultToken) => {
  if (typeof getDefaultToken === "function") {
    return getDefaultToken(merge2(token2, token2[component] ?? {}));
  }
  return getDefaultToken ?? {};
}, "getDefaultComponentToken");
var getComponentToken = /* @__PURE__ */ __name((component, token2, defaultToken, options) => {
  const customToken = { ...token2[component] };
  if (options?.deprecatedTokens) {
    const { deprecatedTokens } = options;
    deprecatedTokens.forEach(([oldTokenKey, newTokenKey]) => {
      if (true) {
        warning_default(
          !customToken?.[oldTokenKey],
          `Component Token \`${String(
            oldTokenKey
          )}\` of ${component} is deprecated. Please use \`${String(newTokenKey)}\` instead.`
        );
      }
      if (customToken?.[oldTokenKey] || customToken?.[newTokenKey]) {
        customToken[newTokenKey] ??= customToken?.[oldTokenKey];
      }
    });
  }
  const mergedToken = { ...defaultToken, ...customToken };
  Object.keys(mergedToken).forEach((key) => {
    if (mergedToken[key] === token2[key]) {
      delete mergedToken[key];
    }
  });
  return mergedToken;
}, "getComponentToken");
var getCompVarPrefix = /* @__PURE__ */ __name((component, prefix) => `${[
  prefix,
  component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")
].filter(Boolean).join("-")}`, "getCompVarPrefix");
function genComponentStyleHook(componentName, styleFn, getDefaultToken, options = {}) {
  const cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
  const [component] = cells;
  const concatComponent = cells.join("-");
  return (prefixCls, rootCls = prefixCls) => {
    const [theme, realToken, hashId, token2, cssVar] = useToken();
    const { getPrefixCls, iconPrefixCls, csp } = useContext13(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const type5 = cssVar ? "css" : "js";
    const calc = calc_default(type5);
    const { max, min } = genMaxMin(type5);
    const sharedConfig = {
      theme,
      token: token2,
      hashId,
      nonce: () => csp?.nonce,
      clientOnly: options.clientOnly,
      // antd is always at top of styles
      order: options.order || -999
    };
    useStyleRegister(
      { ...sharedConfig, clientOnly: false, path: ["Shared", rootPrefixCls] },
      () => [
        {
          // Link
          "&": genLinkStyle(token2)
        }
      ]
    );
    useResetIconStyle_default(iconPrefixCls, csp);
    const wrapSSR = useStyleRegister(
      { ...sharedConfig, path: [concatComponent, prefixCls, iconPrefixCls] },
      () => {
        if (options.injectStyle === false) {
          return [];
        }
        const { token: proxyToken, flush } = statistic_default(token2);
        const defaultComponentToken = getDefaultComponentToken(
          component,
          realToken,
          getDefaultToken
        );
        const componentCls = `.${prefixCls}`;
        const componentToken = getComponentToken(component, realToken, defaultComponentToken, {
          deprecatedTokens: options.deprecatedTokens
        });
        if (cssVar) {
          Object.keys(defaultComponentToken).forEach((key) => {
            defaultComponentToken[key] = `var(${token2CSSVar(
              key,
              getCompVarPrefix(component, cssVar.prefix)
            )})`;
          });
        }
        const mergedToken = merge2(
          proxyToken,
          {
            componentCls,
            prefixCls,
            iconCls: `.${iconPrefixCls}`,
            antCls: `.${rootPrefixCls}`,
            calc,
            // @ts-ignore
            max,
            // @ts-ignore
            min
          },
          cssVar ? defaultComponentToken : componentToken
        );
        const styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls
        });
        flush(component, componentToken);
        return [
          options.resetStyle === false ? null : genCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont),
          styleInterpolation
        ];
      }
    );
    return [wrapSSR, hashId];
  };
}
__name(genComponentStyleHook, "genComponentStyleHook");
var genSubStyleComponent = /* @__PURE__ */ __name((componentName, styleFn, getDefaultToken, options) => {
  const useStyle = genComponentStyleHook(componentName, styleFn, getDefaultToken, {
    resetStyle: false,
    // Sub Style should default after root one
    order: -998,
    ...options
  });
  const StyledComponent = /* @__PURE__ */ __name(({
    prefixCls,
    rootCls = prefixCls
  }) => {
    useStyle(prefixCls, rootCls);
    return null;
  }, "StyledComponent");
  if (true) {
    StyledComponent.displayName = `SubStyle_${Array.isArray(componentName) ? componentName.join(".") : componentName}`;
  }
  return StyledComponent;
}, "genSubStyleComponent");
var genCSSVarRegister = /* @__PURE__ */ __name((component, getDefaultToken, options) => {
  function prefixToken(key) {
    return `${component}${key.slice(0, 1).toUpperCase()}${key.slice(1)}`;
  }
  __name(prefixToken, "prefixToken");
  const { unitless: originUnitless = {}, injectStyle = true } = options ?? {};
  const compUnitless = {
    [prefixToken("zIndexPopup")]: true
  };
  Object.keys(originUnitless).forEach((key) => {
    compUnitless[prefixToken(key)] = originUnitless[key];
  });
  const CSSVarRegister = /* @__PURE__ */ __name(({ rootCls, cssVar }) => {
    const [, realToken] = useToken();
    useCSSVarRegister_default(
      {
        path: [component],
        prefix: cssVar.prefix,
        key: cssVar?.key,
        unitless: {
          ...unitless,
          ...compUnitless
        },
        ignore,
        token: realToken,
        scope: rootCls
      },
      () => {
        const defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
        const componentToken = getComponentToken(component, realToken, defaultToken, {
          deprecatedTokens: options?.deprecatedTokens
        });
        Object.keys(defaultToken).forEach((key) => {
          componentToken[prefixToken(key)] = componentToken[key];
          delete componentToken[key];
        });
        return componentToken;
      }
    );
    return null;
  }, "CSSVarRegister");
  const useCSSVar = /* @__PURE__ */ __name((rootCls) => {
    const [, , , , cssVar] = useToken();
    return [
      (node2) => injectStyle && cssVar ? /* @__PURE__ */ React24.createElement(React24.Fragment, null, /* @__PURE__ */ React24.createElement(CSSVarRegister, { rootCls, cssVar, component }), node2) : node2,
      cssVar?.key
    ];
  }, "useCSSVar");
  return useCSSVar;
}, "genCSSVarRegister");
var genStyleHooks = /* @__PURE__ */ __name((component, styleFn, getDefaultToken, options) => {
  const useStyle = genComponentStyleHook(component, styleFn, getDefaultToken, options);
  const useCSSVar = genCSSVarRegister(
    Array.isArray(component) ? component[0] : component,
    getDefaultToken,
    options
  );
  return (prefixCls, rootCls = prefixCls) => {
    const [, hashId] = useStyle(prefixCls, rootCls);
    const [wrapCSSVar, cssVarCls] = useCSSVar(rootCls);
    return [wrapCSSVar, hashId, cssVarCls];
  };
}, "genStyleHooks");

// packages/ant-design/components/theme/util/genPresetColor.ts
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`];
    const lightBorderColor = token2[`${colorKey}3`];
    const darkColor = token2[`${colorKey}6`];
    const textColor = token2[`${colorKey}7`];
    return {
      ...prev2,
      ...genCss(colorKey, { lightColor, lightBorderColor, darkColor, textColor })
    };
  }, {});
}
__name(genPresetColor, "genPresetColor");

// packages/ant-design/components/config-provider/hooks/useThemeKey.ts
import * as React25 from "react";
var fullClone3 = {
  ...React25
};
var { useId } = fullClone3;
var useEmptyId = /* @__PURE__ */ __name(() => "", "useEmptyId");
var useThemeKey = typeof useId === "undefined" ? useEmptyId : useId;
var useThemeKey_default = useThemeKey;

// packages/ant-design/components/config-provider/hooks/useTheme.ts
function useTheme(theme, parentTheme, config) {
  const warning5 = devUseWarning("ConfigProvider");
  const themeConfig = theme || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
    ...defaultConfig,
    hashed: parentTheme?.hashed ?? defaultConfig.hashed,
    cssVar: parentTheme?.cssVar
  } : parentTheme;
  const themeKey = useThemeKey_default();
  if (true) {
    const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
    const validKey = !!(typeof themeConfig.cssVar === "object" && themeConfig.cssVar?.key || themeKey);
    warning5(
      !cssVarEnabled || validKey,
      "breaking",
      "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider."
    );
  }
  return useMemo(
    () => {
      if (!theme) {
        return parentTheme;
      }
      const mergedComponents = {
        ...parentThemeConfig.components
      };
      Object.keys(theme.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = {
          ...mergedComponents[componentName],
          ...theme.components[componentName]
        };
      });
      const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
      const mergedCssVar = (themeConfig.cssVar ?? parentThemeConfig.cssVar) && {
        prefix: config?.prefixCls,
        // Same as prefixCls by default
        ...typeof parentThemeConfig.cssVar === "object" ? parentThemeConfig.cssVar : {},
        ...typeof themeConfig.cssVar === "object" ? themeConfig.cssVar : {},
        key: typeof themeConfig.cssVar === "object" && themeConfig.cssVar?.key || cssVarKey
      };
      return {
        ...parentThemeConfig,
        ...themeConfig,
        token: {
          ...parentThemeConfig.token,
          ...themeConfig.token
        },
        components: mergedComponents,
        cssVar: mergedCssVar
      };
    },
    [themeConfig, parentThemeConfig],
    (prev2, next2) => prev2.some((prevTheme, index3) => {
      const nextTheme = next2[index3];
      return !isEqual_default(prevTheme, nextTheme, true);
    })
  );
}
__name(useTheme, "useTheme");

// packages/ant-design/components/config-provider/MotionWrapper.tsx
import * as React34 from "react";

// packages/motion/src/CSSMotion.tsx
var import_classnames = __toESM(require_classnames());
import * as React32 from "react";
import { useRef as useRef12 } from "react";

// packages/motion/src/context.tsx
import * as React26 from "react";
var Context = React26.createContext({});
function MotionProvider({
  children,
  ...props
}) {
  return /* @__PURE__ */ React26.createElement(Context.Provider, { value: props }, children);
}
__name(MotionProvider, "MotionProvider");

// packages/motion/src/DomWrapper.tsx
import * as React27 from "react";
var DomWrapper2 = class extends React27.Component {
  static {
    __name(this, "DomWrapper");
  }
  render() {
    return this.props.children;
  }
};
var DomWrapper_default = DomWrapper2;

// packages/motion/src/hooks/useStatus.ts
import * as React31 from "react";
import { useEffect as useEffect10, useRef as useRef10 } from "react";

// packages/motion/src/interface.ts
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
var STEP_PREPARED = "prepared";

// packages/motion/src/hooks/useDomMotionEvents.ts
import * as React28 from "react";
import { useRef as useRef7 } from "react";

// packages/motion/src/util/motion.ts
init_canUseDom();
function makePrefixMap(styleProp, eventName) {
  const prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
  prefixes[`Moz${styleProp}`] = `moz${eventName}`;
  prefixes[`ms${styleProp}`] = `MS${eventName}`;
  prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
  return prefixes;
}
__name(makePrefixMap, "makePrefixMap");
function getVendorPrefixes(domSupport, win) {
  const prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
__name(getVendorPrefixes, "getVendorPrefixes");
var vendorPrefixes = getVendorPrefixes(
  canUseDom(),
  typeof window !== "undefined" ? window : {}
);
var style = {};
if (canUseDom()) {
  ({ style } = document.createElement("div"));
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  const prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    const stylePropList = Object.keys(prefixMap);
    const len = stylePropList.length;
    for (let i = 0; i < len; i += 1) {
      const styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
__name(getVendorPrefixedEventName, "getVendorPrefixedEventName");
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(transitionName, transitionType) {
  if (!transitionName)
    return null;
  if (typeof transitionName === "object") {
    const type5 = transitionType.replace(
      /-\w/g,
      (match2) => match2[1].toUpperCase()
    );
    return transitionName[type5];
  }
  return `${transitionName}-${transitionType}`;
}
__name(getTransitionName, "getTransitionName");

// packages/motion/src/hooks/useDomMotionEvents.ts
var useDomMotionEvents_default = /* @__PURE__ */ __name((callback) => {
  const cacheElementRef = useRef7();
  const callbackRef = useRef7(callback);
  callbackRef.current = callback;
  const onInternalMotionEnd = React28.useCallback((event) => {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  __name(removeMotionEvents, "removeMotionEvents");
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  __name(patchMotionEvents, "patchMotionEvents");
  React28.useEffect(
    () => () => {
      removeMotionEvents(cacheElementRef.current);
    },
    []
  );
  return [patchMotionEvents, removeMotionEvents];
}, "default");

// packages/motion/src/hooks/useIsomorphicLayoutEffect.ts
init_canUseDom();
import { useEffect as useEffect7, useLayoutEffect as useLayoutEffect3 } from "react";
var useIsomorphicLayoutEffect = canUseDom() ? useLayoutEffect3 : useEffect7;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

// packages/motion/src/hooks/useStepQueue.ts
import * as React30 from "react";

// packages/motion/src/hooks/useNextFrame.ts
import * as React29 from "react";
var useNextFrame_default = /* @__PURE__ */ __name(() => {
  const nextFrameRef = React29.useRef(null);
  function cancelNextFrame() {
    raf_default.cancel(nextFrameRef.current);
  }
  __name(cancelNextFrame, "cancelNextFrame");
  function nextFrame(callback, delay = 2) {
    cancelNextFrame();
    const nextFrameId = raf_default(() => {
      if (delay <= 1) {
        callback({ isCanceled: () => nextFrameId !== nextFrameRef.current });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  __name(nextFrame, "nextFrame");
  React29.useEffect(
    () => () => {
      cancelNextFrame();
    },
    []
  );
  return [nextFrame, cancelNextFrame];
}, "default");

// packages/motion/src/hooks/useStepQueue.ts
var FULL_STEP_QUEUE = [
  STEP_PREPARE,
  STEP_START,
  STEP_ACTIVE,
  STEP_ACTIVATED
];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
__name(isActive, "isActive");
var useStepQueue_default = /* @__PURE__ */ __name((status, prepareOnly, callback) => {
  const [step, setStep] = useSafeState(STEP_NONE);
  const [nextFrame, cancelNextFrame] = useNextFrame_default();
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  __name(startQueue, "startQueue");
  const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  useIsomorphicLayoutEffect_default(() => {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      const index3 = STEP_QUEUE.indexOf(step);
      const nextStep = STEP_QUEUE[index3 + 1];
      const result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else if (nextStep) {
        nextFrame((info) => {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          __name(doNext, "doNext");
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  React30.useEffect(
    () => () => {
      cancelNextFrame();
    },
    []
  );
  return [startQueue, step];
}, "default");

// packages/motion/src/hooks/useStatus.ts
function useStatus(supportMotion, visible, getElement, {
  motionEnter = true,
  motionAppear = true,
  motionLeave = true,
  motionDeadline,
  motionLeaveImmediately,
  onAppearPrepare,
  onEnterPrepare,
  onLeavePrepare,
  onAppearStart,
  onEnterStart,
  onLeaveStart,
  onAppearActive,
  onEnterActive,
  onLeaveActive,
  onAppearEnd,
  onEnterEnd,
  onLeaveEnd,
  onVisibleChanged
}) {
  const [asyncVisible, setAsyncVisible] = useSafeState();
  const [status, setStatus] = useSafeState(STATUS_NONE);
  const [style2, setStyle] = useSafeState(null);
  const mountedRef = useRef10(false);
  const deadlineRef = useRef10(null);
  function getDomElement() {
    return getElement();
  }
  __name(getDomElement, "getDomElement");
  const activeRef = useRef10(false);
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE, true);
    setStyle(null, true);
  }
  __name(updateMotionEndStatus, "updateMotionEndStatus");
  function onInternalMotionEnd(event) {
    const element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    const currentActive = activeRef.current;
    let canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd?.(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd?.(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd?.(element, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  }
  __name(onInternalMotionEnd, "onInternalMotionEnd");
  const [patchMotionEvents] = useDomMotionEvents_default(onInternalMotionEnd);
  const getEventHandlers = /* @__PURE__ */ __name((targetStatus) => {
    switch (targetStatus) {
      case STATUS_APPEAR:
        return {
          [STEP_PREPARE]: onAppearPrepare,
          [STEP_START]: onAppearStart,
          [STEP_ACTIVE]: onAppearActive
        };
      case STATUS_ENTER:
        return {
          [STEP_PREPARE]: onEnterPrepare,
          [STEP_START]: onEnterStart,
          [STEP_ACTIVE]: onEnterActive
        };
      case STATUS_LEAVE:
        return {
          [STEP_PREPARE]: onLeavePrepare,
          [STEP_START]: onLeaveStart,
          [STEP_ACTIVE]: onLeaveActive
        };
      default:
        return {};
    }
  }, "getEventHandlers");
  const eventHandlers = React31.useMemo(() => getEventHandlers(status), [status]);
  const [startStep, step] = useStepQueue_default(status, !supportMotion, (newStep) => {
    if (newStep === STEP_PREPARE) {
      const onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      setStyle(eventHandlers[step]?.(getDomElement(), null) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(() => {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    if (step === STEP_PREPARED) {
      updateMotionEndStatus();
    }
    return DoStep;
  });
  const active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect_default(() => {
    setAsyncVisible(visible);
    const isMounted = mountedRef.current;
    mountedRef.current = true;
    let nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    const nextEventHandlers = getEventHandlers(nextStatus);
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      setStatus(STATUS_NONE);
    }
  }, [visible]);
  useEffect10(() => {
    if (
      // Cancel appear
      status === STATUS_APPEAR && !motionAppear || // Cancel enter
      status === STATUS_ENTER && !motionEnter || // Cancel leave
      status === STATUS_LEAVE && !motionLeave
    ) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  useEffect10(
    () => () => {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    },
    []
  );
  const firstMountChangeRef = React31.useRef(false);
  useEffect10(() => {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged?.(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  let mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = {
      transition: "none",
      ...mergedStyle
    };
  }
  return [status, step, mergedStyle, asyncVisible ?? visible];
}
__name(useStatus, "useStatus");

// packages/motion/src/CSSMotion.tsx
function genCSSMotion(config) {
  let transitionSupport = config;
  if (typeof config === "object") {
    ({ transitionSupport } = config);
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  __name(isSupportTransition, "isSupportTransition");
  const CSSMotion = React32.forwardRef((props, ref) => {
    const {
      // Default config
      visible = true,
      removeOnLeave = true,
      forceRender,
      children,
      motionName,
      leavedClassName,
      eventProps
    } = props;
    const { motion: contextMotion } = React32.useContext(Context);
    const supportMotion = isSupportTransition(props, contextMotion);
    const nodeRef = useRef12();
    const wrapperNodeRef = useRef12();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e3) {
        return null;
      }
    }
    __name(getDomElement, "getDomElement");
    const [status, statusStep, statusStyle, mergedVisible] = useStatus(
      supportMotion,
      visible,
      getDomElement,
      props
    );
    const renderedRef = React32.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    const setNodeRef = React32.useCallback(
      (node2) => {
        nodeRef.current = node2;
        fillRef(ref, node2);
      },
      [ref]
    );
    let motionChildren;
    const mergedProps = { ...eventProps, visible };
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      if (mergedVisible) {
        motionChildren = children({ ...mergedProps }, setNodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children(
          { ...mergedProps, className: leavedClassName },
          setNodeRef
        );
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children(
          { ...mergedProps, style: { display: "none" } },
          setNodeRef
        );
      } else {
        motionChildren = null;
      }
    } else {
      let statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      const motionCls = getTransitionName(
        motionName,
        `${status}-${statusSuffix}`
      );
      motionChildren = children(
        {
          ...mergedProps,
          className: (0, import_classnames.default)(getTransitionName(motionName, status), {
            [motionCls]: motionCls && statusSuffix,
            [motionName]: typeof motionName === "string"
          }),
          style: statusStyle
        },
        setNodeRef
      );
    }
    if (React32.isValidElement(motionChildren) && supportRef(motionChildren)) {
      const { ref: originNodeRef } = motionChildren;
      if (!originNodeRef) {
        motionChildren = React32.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ React32.createElement(DomWrapper_default, { ref: wrapperNodeRef }, motionChildren);
  });
  CSSMotion.displayName = "CSSMotion";
  return CSSMotion;
}
__name(genCSSMotion, "genCSSMotion");
var CSSMotion_default = genCSSMotion(supportTransition);

// packages/motion/src/CSSMotionList.tsx
import * as React33 from "react";

// packages/motion/src/util/diff.ts
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  let keyObj;
  if (key && typeof key === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = { key };
  }
  return {
    ...keyObj,
    key: String(keyObj.key)
  };
}
__name(wrapKeyToObject, "wrapKeyToObject");
function parseKeys(keys2 = []) {
  return keys2.map(wrapKeyToObject);
}
__name(parseKeys, "parseKeys");
function diffKeys(prevKeys = [], currentKeys = []) {
  let list = [];
  let currentIndex = 0;
  const currentLen = currentKeys.length;
  const prevKeyObjects = parseKeys(prevKeys);
  const currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach((keyObj) => {
    let hit = false;
    for (let i = currentIndex; i < currentLen; i += 1) {
      const currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i) {
          list = list.concat(
            currentKeyObjects.slice(currentIndex, i).map((obj) => ({ ...obj, status: STATUS_ADD }))
          );
          currentIndex = i;
        }
        list.push({
          ...currentKeyObj,
          status: STATUS_KEEP
        });
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push({
        ...keyObj,
        status: STATUS_REMOVE
      });
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(
      currentKeyObjects.slice(currentIndex).map((obj) => ({ ...obj, status: STATUS_ADD }))
    );
  }
  const keys2 = {};
  list.forEach(({ key }) => {
    keys2[key] = (keys2[key] || 0) + 1;
  });
  const duplicatedKeys = Object.keys(keys2).filter((key) => keys2[key] > 1);
  duplicatedKeys.forEach((matchKey) => {
    list = list.filter(
      ({ key, status }) => key !== matchKey || status !== STATUS_REMOVE
    );
    list.forEach((node2) => {
      if (node2.key === matchKey) {
        node2.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
__name(diffKeys, "diffKeys");

// packages/motion/src/CSSMotionList.tsx
var MOTION_PROP_NAMES = [
  "eventProps",
  "visible",
  "children",
  "motionName",
  "motionAppear",
  "motionEnter",
  "motionLeave",
  "motionLeaveImmediately",
  "motionDeadline",
  "removeOnLeave",
  "leavedClassName",
  "onAppearPrepare",
  "onAppearStart",
  "onAppearActive",
  "onAppearEnd",
  "onEnterStart",
  "onEnterActive",
  "onEnterEnd",
  "onLeaveStart",
  "onLeaveActive",
  "onLeaveEnd"
];
function genCSSMotionList(transitionSupport, CSSMotion = CSSMotion_default) {
  class CSSMotionList extends React33.Component {
    static {
      __name(this, "CSSMotionList");
    }
    static defaultProps = {
      component: "div"
    };
    state = {
      keyEntities: []
    };
    static getDerivedStateFromProps({ keys: keys2 }, { keyEntities }) {
      const parsedKeyObjects = parseKeys(keys2);
      const mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
      return {
        keyEntities: mixedKeyEntities.filter((entity) => {
          const prevEntity = keyEntities.find(({ key }) => entity.key === key);
          if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
            return false;
          }
          return true;
        })
      };
    }
    // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
    removeKey = (removeKey) => {
      const { keyEntities } = this.state;
      const nextKeyEntities = keyEntities.map((entity) => {
        if (entity.key !== removeKey)
          return entity;
        return {
          ...entity,
          status: STATUS_REMOVED
        };
      });
      this.setState({
        keyEntities: nextKeyEntities
      });
      return nextKeyEntities.filter(({ status }) => status !== STATUS_REMOVED).length;
    };
    render() {
      const { keyEntities } = this.state;
      const {
        component,
        children,
        onVisibleChanged,
        onAllRemoved,
        ...restProps
      } = this.props;
      const Component11 = component || React33.Fragment;
      const motionProps = {};
      MOTION_PROP_NAMES.forEach((prop) => {
        motionProps[prop] = restProps[prop];
        delete restProps[prop];
      });
      delete restProps.keys;
      return /* @__PURE__ */ React33.createElement(Component11, { ...restProps }, keyEntities.map(({ status, ...eventProps }, index3) => {
        const visible = status === STATUS_ADD || status === STATUS_KEEP;
        return /* @__PURE__ */ React33.createElement(
          CSSMotion,
          {
            ...motionProps,
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: (changedVisible) => {
              onVisibleChanged?.(changedVisible, { key: eventProps.key });
              if (!changedVisible) {
                const restKeysCount = this.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          },
          (props, ref) => children({ ...props, index: index3 }, ref)
        );
      }));
    }
  }
  return CSSMotionList;
}
__name(genCSSMotionList, "genCSSMotionList");
var CSSMotionList_default = genCSSMotionList(supportTransition);

// packages/motion/src/index.tsx
var src_default2 = CSSMotion_default;

// packages/ant-design/components/config-provider/MotionWrapper.tsx
function MotionWrapper(props) {
  const { children } = props;
  const [, token2] = useToken();
  const { motion: motion2 } = token2;
  const needWrapMotionProviderRef = React34.useRef(false);
  needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion2 === false;
  if (needWrapMotionProviderRef.current) {
    return /* @__PURE__ */ React34.createElement(MotionProvider, { motion: motion2 }, children);
  }
  return children;
}
__name(MotionWrapper, "MotionWrapper");

// packages/ant-design/components/config-provider/PropWarning.tsx
import * as React35 from "react";
var PropWarning = React35.memo(({ dropdownMatchSelectWidth }) => {
  const warning5 = devUseWarning("ConfigProvider");
  warning5.deprecated(
    dropdownMatchSelectWidth === void 0,
    "dropdownMatchSelectWidth",
    "popupMatchSelectWidth"
  );
  return null;
});
if (true) {
  PropWarning.displayName = "PropWarning";
}
var PropWarning_default = true ? PropWarning : () => null;

// packages/ant-design/components/config-provider/index.tsx
var existThemeConfig = false;
var warnContext = true ? (componentName) => {
  warning_default2(
    !existThemeConfig,
    componentName,
    `Static function can not consume context like dynamic theme. Please use 'App' component instead.`
  );
} : (
  /* istanbul ignore next */
  null
);
var PASSED_PROPS = [
  "getTargetContainer",
  "getPopupContainer",
  "renderEmpty",
  "input",
  "pagination",
  "form",
  "select",
  "button"
];
var defaultPrefixCls = "ant";
var globalPrefixCls;
var globalIconPrefixCls;
var globalTheme;
var globalHolderRender;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
__name(getGlobalPrefixCls, "getGlobalPrefixCls");
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
__name(getGlobalIconPrefixCls, "getGlobalIconPrefixCls");
function isLegacyTheme(theme) {
  return Object.keys(theme).some((key) => key.endsWith("Color"));
}
__name(isLegacyTheme, "isLegacyTheme");
var setGlobalConfig = /* @__PURE__ */ __name((props) => {
  const { prefixCls, iconPrefixCls, theme, holderRender } = props;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if ("holderRender" in props) {
    globalHolderRender = holderRender;
  }
  if (theme) {
    if (isLegacyTheme(theme)) {
      warning_default2(
        false,
        "ConfigProvider",
        "`config` of css variable theme is not work in v5. Please use new `theme` config instead."
      );
      registerTheme(getGlobalPrefixCls(), theme);
    } else {
      globalTheme = theme;
    }
  }
}, "setGlobalConfig");
var globalConfig = /* @__PURE__ */ __name(() => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalPrefixCls) {
      return globalPrefixCls;
    }
    return getGlobalPrefixCls();
  },
  getTheme: () => globalTheme,
  holderRender: globalHolderRender
}), "globalConfig");
var ProviderChildren = /* @__PURE__ */ __name((props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    alert,
    anchor,
    form,
    locale: locale6,
    componentSize,
    direction,
    space,
    virtual,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    popupOverflow,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme,
    componentDisabled,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    menu,
    pagination,
    input,
    textArea,
    empty: empty2,
    badge,
    radio,
    rate,
    switch: SWITCH,
    transfer,
    avatar,
    message: message2,
    tag,
    table,
    card,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification: notification2,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    floatButtonGroup
  } = props;
  const getPrefixCls = React36.useCallback(
    (suffixCls, customizePrefixCls) => {
      const { prefixCls } = props;
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    },
    [parentContext.getPrefixCls, props.prefixCls]
  );
  const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
  const csp = customCsp || parentContext.csp;
  useResetIconStyle_default(iconPrefixCls, csp);
  const mergedTheme = useTheme(theme, parentContext.theme, { prefixCls: getPrefixCls("") });
  if (true) {
    existThemeConfig = existThemeConfig || !!mergedTheme;
  }
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    alert,
    anchor,
    locale: locale6 || legacyLocale,
    direction,
    space,
    virtual,
    popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
    popupOverflow,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    input,
    textArea,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    menu,
    pagination,
    empty: empty2,
    badge,
    radio,
    rate,
    switch: SWITCH,
    transfer,
    avatar,
    message: message2,
    tag,
    table,
    card,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification: notification2,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    floatButtonGroup
  };
  const config = {
    ...parentContext
  };
  Object.keys(baseConfig).forEach((key) => {
    if (baseConfig[key] !== void 0) {
      config[key] = baseConfig[key];
    }
  });
  PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  const memoedConfig = useMemo(
    () => config,
    config,
    (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    }
  );
  const memoIconContextValue = React36.useMemo(
    () => ({ prefixCls: iconPrefixCls, csp }),
    [iconPrefixCls, csp]
  );
  let childNode = /* @__PURE__ */ React36.createElement(React36.Fragment, null, /* @__PURE__ */ React36.createElement(PropWarning_default, { dropdownMatchSelectWidth }), children);
  const validateMessages = React36.useMemo(
    () => merge(
      en_US_default6.Form?.defaultValidateMessages || {},
      memoedConfig.locale?.Form?.defaultValidateMessages || {},
      memoedConfig.form?.validateMessages || {},
      form?.validateMessages || {}
    ),
    [memoedConfig, form?.validateMessages]
  );
  if (Object.keys(validateMessages).length > 0) {
    childNode = /* @__PURE__ */ React36.createElement(validateMessagesContext_default.Provider, { value: validateMessages }, childNode);
  }
  if (locale6) {
    childNode = /* @__PURE__ */ React36.createElement(locale_default, { locale: locale6, _ANT_MARK__: ANT_MARK }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = /* @__PURE__ */ React36.createElement(import_Context.default.Provider, { value: memoIconContextValue }, childNode);
  }
  if (componentSize) {
    childNode = /* @__PURE__ */ React36.createElement(SizeContextProvider, { size: componentSize }, childNode);
  }
  childNode = /* @__PURE__ */ React36.createElement(MotionWrapper, null, childNode);
  const memoTheme = React36.useMemo(() => {
    const { algorithm, token: token2, components, cssVar, ...rest } = mergedTheme || {};
    const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
    const parsedComponents = {};
    Object.entries(components || {}).forEach(([componentName, componentToken]) => {
      const parsedToken = {
        ...componentToken
      };
      if ("algorithm" in parsedToken) {
        if (parsedToken.algorithm === true) {
          parsedToken.theme = themeObj;
        } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
          parsedToken.theme = createTheme(parsedToken.algorithm);
        }
        delete parsedToken.algorithm;
      }
      parsedComponents[componentName] = parsedToken;
    });
    const mergedToken = {
      ...seed_default,
      ...token2
    };
    return {
      ...rest,
      theme: themeObj,
      token: mergedToken,
      components: parsedComponents,
      override: {
        override: mergedToken,
        ...parsedComponents
      },
      cssVar
    };
  }, [mergedTheme]);
  if (theme) {
    childNode = /* @__PURE__ */ React36.createElement(DesignTokenContext.Provider, { value: memoTheme }, childNode);
  }
  if (memoedConfig.warning) {
    childNode = /* @__PURE__ */ React36.createElement(WarningContext.Provider, { value: memoedConfig.warning }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = /* @__PURE__ */ React36.createElement(DisabledContextProvider, { disabled: componentDisabled }, childNode);
  }
  return /* @__PURE__ */ React36.createElement(ConfigContext.Provider, { value: memoedConfig }, childNode);
}, "ProviderChildren");
var ConfigProvider = /* @__PURE__ */ __name((props) => {
  const context = React36.useContext(ConfigContext);
  const antLocale = React36.useContext(context_default);
  return /* @__PURE__ */ React36.createElement(ProviderChildren, { parentContext: context, legacyLocale: antLocale, ...props });
}, "ConfigProvider");
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext_default;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig_default;
Object.defineProperty(ConfigProvider, "SizeContext", {
  get: () => {
    warning_default2(
      false,
      "ConfigProvider",
      "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."
    );
    return SizeContext_default;
  }
});
if (true) {
  ConfigProvider.displayName = "ConfigProvider";
}
var config_provider_default = ConfigProvider;

// packages/ant-design/components/affix/style/index.ts
var genSharedAffixStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      position: "fixed",
      zIndex: token2.zIndexPopup
    }
  };
}, "genSharedAffixStyle");
var prepareComponentToken = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexBase + 10
}), "prepareComponentToken");
var style_default = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken);

// packages/ant-design/components/affix/utils.ts
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
__name(getTargetRect, "getTargetRect");
function getFixedTop(placeholderRect, targetRect, offsetTop) {
  if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) {
    return offsetTop + targetRect.top;
  }
  return void 0;
}
__name(getFixedTop, "getFixedTop");
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) {
    const targetBottomOffset = window.innerHeight - targetRect.bottom;
    return offsetBottom + targetBottomOffset;
  }
  return void 0;
}
__name(getFixedBottom, "getFixedBottom");

// packages/ant-design/components/affix/index.tsx
var TRIGGER_EVENTS = [
  "resize",
  "scroll",
  "touchstart",
  "touchmove",
  "touchend",
  "pageshow",
  "load"
];
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
__name(getDefaultTarget, "getDefaultTarget");
var AFFIX_STATUS_NONE = 0;
var AFFIX_STATUS_PREPARE = 1;
var Affix = React37.forwardRef((props, ref) => {
  const {
    style: style2,
    offsetTop,
    offsetBottom,
    prefixCls,
    className,
    rootClassName,
    children,
    target,
    onChange
  } = props;
  const { getPrefixCls, getTargetContainer } = React37.useContext(ConfigContext);
  const affixPrefixCls = getPrefixCls("affix", prefixCls);
  const [lastAffix, setLastAffix] = React37.useState(false);
  const [affixStyle, setAffixStyle] = React37.useState();
  const [placeholderStyle, setPlaceholderStyle] = React37.useState();
  const status = React37.useRef(AFFIX_STATUS_NONE);
  const prevTarget = React37.useRef(null);
  const prevListener = React37.useRef();
  const placeholderNodeRef = React37.useRef(null);
  const fixedNodeRef = React37.useRef(null);
  const timer = React37.useRef(null);
  const targetFunc = target ?? getTargetContainer ?? getDefaultTarget;
  const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
  const measure = /* @__PURE__ */ __name(() => {
    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {
      return;
    }
    const targetNode = targetFunc();
    if (targetNode) {
      const newState = {
        status: AFFIX_STATUS_NONE
      };
      const placeholderRect = getTargetRect(placeholderNodeRef.current);
      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
        return;
      }
      const targetRect = getTargetRect(targetNode);
      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
      if (fixedTop !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      } else if (fixedBottom !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (lastAffix !== newState.lastAffix) {
        onChange?.(newState.lastAffix);
      }
      status.current = newState.status;
      setAffixStyle(newState.affixStyle);
      setPlaceholderStyle(newState.placeholderStyle);
      setLastAffix(newState.lastAffix);
    }
  }, "measure");
  const prepareMeasure = /* @__PURE__ */ __name(() => {
    status.current = AFFIX_STATUS_PREPARE;
    measure();
    if (false) {
      props?.onTestUpdatePosition?.();
    }
  }, "prepareMeasure");
  const updatePosition = throttleByAnimationFrame_default(() => {
    prepareMeasure();
  });
  const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
    if (targetFunc && affixStyle) {
      const targetNode = targetFunc();
      if (targetNode && placeholderNodeRef.current) {
        const targetRect = getTargetRect(targetNode);
        const placeholderRect = getTargetRect(placeholderNodeRef.current);
        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
        if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
          return;
        }
      }
    }
    prepareMeasure();
  });
  const addListeners = /* @__PURE__ */ __name(() => {
    const listenerTarget = targetFunc?.();
    if (!listenerTarget) {
      return;
    }
    TRIGGER_EVENTS.forEach((eventName) => {
      if (prevListener.current) {
        prevTarget.current?.removeEventListener(eventName, prevListener.current);
      }
      listenerTarget?.addEventListener(eventName, lazyUpdatePosition);
    });
    prevTarget.current = listenerTarget;
    prevListener.current = lazyUpdatePosition;
  }, "addListeners");
  const removeListeners = /* @__PURE__ */ __name(() => {
    if (timer.current) {
      clearTimeout(timer.current);
      timer.current = null;
    }
    const newTarget = targetFunc?.();
    TRIGGER_EVENTS.forEach((eventName) => {
      newTarget?.removeEventListener(eventName, lazyUpdatePosition);
      if (prevListener.current) {
        prevTarget.current?.removeEventListener(eventName, prevListener.current);
      }
    });
    updatePosition.cancel();
    lazyUpdatePosition.cancel();
  }, "removeListeners");
  React37.useImperativeHandle(ref, () => ({ updatePosition }));
  React37.useEffect(() => {
    timer.current = setTimeout(addListeners);
    return () => removeListeners();
  }, []);
  React37.useEffect(() => {
    addListeners();
  }, [target, affixStyle]);
  React37.useEffect(() => {
    updatePosition();
  }, [target, offsetTop, offsetBottom]);
  const [wrapCSSVar, hashId, cssVarCls] = style_default(affixPrefixCls);
  const rootCls = (0, import_classnames2.default)(rootClassName, hashId, affixPrefixCls, cssVarCls);
  const mergedCls = (0, import_classnames2.default)({ [rootCls]: affixStyle });
  let otherProps = omit(props, [
    "prefixCls",
    "offsetTop",
    "offsetBottom",
    "target",
    "onChange",
    "rootClassName"
  ]);
  if (false) {
    otherProps = omit(otherProps, ["onTestUpdatePosition"]);
  }
  return wrapCSSVar(
    /* @__PURE__ */ React37.createElement(src_default, { onResize: updatePosition }, /* @__PURE__ */ React37.createElement("div", { style: style2, className, ref: placeholderNodeRef, ...otherProps }, affixStyle && /* @__PURE__ */ React37.createElement("div", { style: placeholderStyle, "aria-hidden": "true" }), /* @__PURE__ */ React37.createElement("div", { className: mergedCls, ref: fixedNodeRef, style: affixStyle }, /* @__PURE__ */ React37.createElement(src_default, { onResize: updatePosition }, children))))
  );
});
if (true) {
  Affix.displayName = "Affix";
}
var affix_default = Affix;

// packages/ant-design/components/alert/Alert.tsx
var import_CheckCircleFilled = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled = __toESM(require_CloseCircleFilled3());
var import_CloseOutlined = __toESM(require_CloseOutlined3());
var import_ExclamationCircleFilled = __toESM(require_ExclamationCircleFilled3());
var import_InfoCircleFilled = __toESM(require_InfoCircleFilled3());
var import_classnames3 = __toESM(require_classnames());
import * as React39 from "react";

// packages/util/src/pickAttrs.ts
var attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
var eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
var propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
__name(match, "match");
function pickAttrs(props, ariaOnly = false) {
  let mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = {
      ...ariaOnly
    };
  }
  const attrs = {};
  Object.keys(props).forEach((key) => {
    if (
      // Aria
      mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
      mergedConfig.data && match(key, dataPrefix) || // Attr
      mergedConfig.attr && propList.includes(key)
    ) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
__name(pickAttrs, "pickAttrs");

// packages/ant-design/components/_util/reactNode.ts
import React38 from "react";
function isFragment3(child) {
  return child && React38.isValidElement(child) && child.type === React38.Fragment;
}
__name(isFragment3, "isFragment");
var replaceElement = /* @__PURE__ */ __name((element, replacement, props) => {
  if (!React38.isValidElement(element)) {
    return replacement;
  }
  return React38.cloneElement(
    element,
    typeof props === "function" ? props(element.props || {}) : props
  );
}, "replaceElement");
function cloneElement3(element, props) {
  return replaceElement(element, element, props);
}
__name(cloneElement3, "cloneElement");

// packages/ant-design/components/alert/style/index.ts
var genAlertTypeStyle = /* @__PURE__ */ __name((bgColor, borderColor, iconColor, token2, alertCls) => ({
  background: bgColor,
  border: `${unit(token2.lineWidth)} ${token2.lineType} ${borderColor}`,
  [`${alertCls}-icon`]: {
    color: iconColor
  }
}), "genAlertTypeStyle");
var genBaseStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow: duration,
    marginXS,
    marginSM,
    fontSize,
    fontSizeLG,
    lineHeight,
    borderRadiusLG: borderRadius,
    motionEaseInOutCirc,
    withDescriptionIconSize,
    colorText,
    colorTextHeading,
    withDescriptionPadding,
    defaultPadding
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: defaultPadding,
      wordWrap: "break-word",
      borderRadius,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-content`]: {
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginXS,
        lineHeight: 0
      },
      [`&-description`]: {
        display: "none",
        fontSize,
        lineHeight
      },
      "&-message": {
        color: colorTextHeading
      },
      [`&${componentCls}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
      },
      [`&${componentCls}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    },
    [`${componentCls}-with-description`]: {
      alignItems: "flex-start",
      padding: withDescriptionPadding,
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginSM,
        fontSize: withDescriptionIconSize,
        lineHeight: 0
      },
      [`${componentCls}-message`]: {
        display: "block",
        marginBottom: marginXS,
        color: colorTextHeading,
        fontSize: fontSizeLG
      },
      [`${componentCls}-description`]: {
        display: "block",
        color: colorText
      }
    },
    [`${componentCls}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
}, "genBaseStyle");
var genTypeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorSuccess,
    colorSuccessBorder,
    colorSuccessBg,
    colorWarning,
    colorWarningBorder,
    colorWarningBg,
    colorError,
    colorErrorBorder,
    colorErrorBg,
    colorInfo,
    colorInfoBorder,
    colorInfoBg
  } = token2;
  return {
    [componentCls]: {
      "&-success": genAlertTypeStyle(
        colorSuccessBg,
        colorSuccessBorder,
        colorSuccess,
        token2,
        componentCls
      ),
      "&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token2, componentCls),
      "&-warning": genAlertTypeStyle(
        colorWarningBg,
        colorWarningBorder,
        colorWarning,
        token2,
        componentCls
      ),
      "&-error": {
        ...genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token2, componentCls),
        [`${componentCls}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      }
    }
  };
}, "genTypeStyle");
var genActionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    motionDurationMid,
    marginXS,
    fontSizeIcon,
    colorIcon,
    colorIconHover
  } = token2;
  return {
    [componentCls]: {
      [`&-action`]: {
        marginInlineStart: marginXS
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: marginXS,
        padding: 0,
        overflow: "hidden",
        fontSize: fontSizeIcon,
        lineHeight: unit(fontSizeIcon),
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${iconCls}-close`]: {
          color: colorIcon,
          transition: `color ${motionDurationMid}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
      "&-close-text": {
        color: colorIcon,
        transition: `color ${motionDurationMid}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
}, "genActionStyle");
var prepareComponentToken2 = /* @__PURE__ */ __name((token2) => {
  const paddingHorizontal = 12;
  return {
    withDescriptionIconSize: token2.fontSizeHeading3,
    defaultPadding: `${token2.paddingContentVerticalSM}px ${paddingHorizontal}px`,
    withDescriptionPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
  };
}, "prepareComponentToken");
var style_default2 = genStyleHooks(
  "Alert",
  (token2) => [genBaseStyle(token2), genTypeStyle(token2), genActionStyle(token2)],
  prepareComponentToken2
);

// packages/ant-design/components/alert/Alert.tsx
var iconMapFilled = {
  success: import_CheckCircleFilled.default,
  info: import_InfoCircleFilled.default,
  error: import_CloseCircleFilled.default,
  warning: import_ExclamationCircleFilled.default
};
var IconNode = /* @__PURE__ */ __name((props) => {
  const { icon, prefixCls, type: type5 } = props;
  const iconType = iconMapFilled[type5] || null;
  if (icon) {
    return replaceElement(icon, /* @__PURE__ */ React39.createElement("span", { className: `${prefixCls}-icon` }, icon), () => ({
      className: (0, import_classnames3.default)(`${prefixCls}-icon`, {
        [icon.props.className]: icon.props.className
      })
    }));
  }
  return React39.createElement(iconType, { className: `${prefixCls}-icon` });
}, "IconNode");
var CloseIconNode = /* @__PURE__ */ __name((props) => {
  const { isClosable, prefixCls, closeIcon, handleClose, ariaProps } = props;
  const mergedCloseIcon = closeIcon === true || closeIcon === void 0 ? /* @__PURE__ */ React39.createElement(import_CloseOutlined.default, null) : closeIcon;
  return isClosable ? /* @__PURE__ */ React39.createElement(
    "button",
    {
      type: "button",
      onClick: handleClose,
      className: `${prefixCls}-close-icon`,
      tabIndex: 0,
      ...ariaProps
    },
    mergedCloseIcon
  ) : null;
}, "CloseIconNode");
var Alert = /* @__PURE__ */ __name((props) => {
  const {
    description,
    prefixCls: customizePrefixCls,
    message: message2,
    banner,
    className,
    rootClassName,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onClick,
    afterClose,
    showIcon,
    closable,
    closeText,
    closeIcon,
    action,
    ...otherProps
  } = props;
  const [closed, setClosed] = React39.useState(false);
  if (true) {
    const warning5 = devUseWarning("Alert");
    warning5.deprecated(!closeText, "closeText", "closable.closeIcon");
  }
  const ref = React39.useRef(null);
  const { getPrefixCls, direction, alert } = React39.useContext(ConfigContext);
  const prefixCls = getPrefixCls("alert", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default2(prefixCls);
  const handleClose = /* @__PURE__ */ __name((e3) => {
    setClosed(true);
    props.onClose?.(e3);
  }, "handleClose");
  const type5 = React39.useMemo(() => {
    if (props.type !== void 0) {
      return props.type;
    }
    return banner ? "warning" : "info";
  }, [props.type, banner]);
  const isClosable = React39.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon)
      return true;
    if (closeText) {
      return true;
    }
    if (typeof closable === "boolean") {
      return closable;
    }
    if (closeIcon !== false && closeIcon !== null && closeIcon !== void 0) {
      return true;
    }
    return !!alert?.closable;
  }, [closeText, closeIcon, closable, alert?.closable]);
  const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
  const alertCls = (0, import_classnames3.default)(
    prefixCls,
    `${prefixCls}-${type5}`,
    {
      [`${prefixCls}-with-description`]: !!description,
      [`${prefixCls}-no-icon`]: !isShowIcon,
      [`${prefixCls}-banner`]: !!banner,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    alert?.className,
    className,
    rootClassName,
    cssVarCls,
    hashId
  );
  const restProps = pickAttrs(otherProps, { aria: true, data: true });
  const mergedCloseIcon = React39.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon) {
      return closable.closeIcon;
    }
    if (closeText) {
      return closeText;
    }
    if (closeIcon !== void 0) {
      return closeIcon;
    }
    if (typeof alert?.closable === "object" && alert?.closable?.closeIcon) {
      return alert?.closable?.closeIcon;
    }
    return alert?.closeIcon;
  }, [closeIcon, closable, closeText, alert?.closeIcon]);
  const mergedAriaProps = React39.useMemo(() => {
    const merged = closable ?? alert?.closable;
    if (typeof merged === "object") {
      const { closeIcon: _, ...ariaProps } = merged;
      return ariaProps;
    }
    return {};
  }, [closable, alert?.closable]);
  return wrapCSSVar(
    /* @__PURE__ */ React39.createElement(
      src_default2,
      {
        visible: !closed,
        motionName: `${prefixCls}-motion`,
        motionAppear: false,
        motionEnter: false,
        onLeaveStart: (node2) => ({ maxHeight: node2.offsetHeight }),
        onLeaveEnd: afterClose
      },
      ({ className: motionClassName, style: motionStyle }) => /* @__PURE__ */ React39.createElement(
        "div",
        {
          ref,
          "data-show": !closed,
          className: (0, import_classnames3.default)(alertCls, motionClassName),
          style: { ...alert?.style, ...style2, ...motionStyle },
          onMouseEnter,
          onMouseLeave,
          onClick,
          role: "alert",
          ...restProps
        },
        isShowIcon ? /* @__PURE__ */ React39.createElement(
          IconNode,
          {
            description,
            icon: props.icon,
            prefixCls,
            type: type5
          }
        ) : null,
        /* @__PURE__ */ React39.createElement("div", { className: `${prefixCls}-content` }, message2 ? /* @__PURE__ */ React39.createElement("div", { className: `${prefixCls}-message` }, message2) : null, description ? /* @__PURE__ */ React39.createElement("div", { className: `${prefixCls}-description` }, description) : null),
        action ? /* @__PURE__ */ React39.createElement("div", { className: `${prefixCls}-action` }, action) : null,
        /* @__PURE__ */ React39.createElement(
          CloseIconNode,
          {
            isClosable,
            prefixCls,
            closeIcon: mergedCloseIcon,
            handleClose,
            ariaProps: mergedAriaProps
          }
        )
      )
    )
  );
}, "Alert");
if (true) {
  Alert.displayName = "Alert";
}
var Alert_default = Alert;

// packages/ant-design/components/alert/ErrorBoundary.tsx
import * as React40 from "react";
var ErrorBoundary = class extends React40.Component {
  constructor() {
    super(...arguments);
    this.state = {
      error: void 0,
      info: {
        componentStack: ""
      }
    };
  }
  static {
    __name(this, "ErrorBoundary");
  }
  componentDidCatch(error, info) {
    this.setState({ error, info });
  }
  render() {
    const { message: message2, description, children } = this.props;
    const { error, info } = this.state;
    const componentStack = info && info.componentStack ? info.componentStack : null;
    const errorMessage = typeof message2 === "undefined" ? (error || "").toString() : message2;
    const errorDescription = typeof description === "undefined" ? componentStack : description;
    if (error) {
      return /* @__PURE__ */ React40.createElement(
        Alert_default,
        {
          type: "error",
          message: errorMessage,
          description: /* @__PURE__ */ React40.createElement("pre", { style: { fontSize: "0.9em", overflowX: "auto" } }, errorDescription)
        }
      );
    }
    return children;
  }
};
var ErrorBoundary_default = ErrorBoundary;

// packages/ant-design/components/alert/index.ts
var Alert2 = Alert_default;
Alert2.ErrorBoundary = ErrorBoundary_default;
var alert_default = Alert2;

// packages/ant-design/components/anchor/Anchor.tsx
var import_classnames5 = __toESM(require_classnames());
import * as React43 from "react";

// node_modules/.pnpm/compute-scroll-into-view@3.1.0/node_modules/compute-scroll-into-view/dist/index.js
var t = /* @__PURE__ */ __name((t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, "t");
var e = /* @__PURE__ */ __name((t2, e3) => (!e3 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), "e");
var n = /* @__PURE__ */ __name((t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o3 = getComputedStyle(t2, null);
    return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t3) => {
      const e3 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
}, "n");
var o = /* @__PURE__ */ __name((t2, e3, n2, o3, l2, r2, i, s) => r2 < t2 && i > e3 || r2 > t2 && i < e3 ? 0 : r2 <= t2 && s <= n2 || i >= e3 && s >= n2 ? r2 - t2 - o3 : i > e3 && s < n2 || r2 < t2 && s > n2 ? i - e3 + l2 : 0, "o");
var l = /* @__PURE__ */ __name((t2) => {
  const e3 = t2.parentElement;
  return null == e3 ? t2.getRootNode().host || null : e3;
}, "l");
var r = /* @__PURE__ */ __name((e3, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
  if (!t(e3))
    throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w = [];
  let W = e3;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
  }
  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e3.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e4 = window.getComputedStyle(t2);
    return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
  })(e3);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e4 = w[t2], { height: n2, width: l2, top: r3, right: i2, bottom: s2, left: d2 } = e4.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && x >= r3 && I <= s2 && R >= d2 && C <= i2)
      return L;
    const h2 = getComputedStyle(e4), a2 = parseInt(h2.borderLeftWidth, 10), g2 = parseInt(h2.borderTopWidth, 10), p2 = parseInt(h2.borderRightWidth, 10), W2 = parseInt(h2.borderBottomWidth, 10);
    let T2 = 0, B2 = 0;
    const F2 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - a2 - p2 : 0, V2 = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - g2 - W2 : 0, S = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : l2 / e4.offsetWidth : 0, X = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : n2 / e4.offsetHeight : 0;
    if (m === e4)
      T2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, g2, W2, M + k, M + k + v, v) : k - H / 2, B2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, a2, p2, y + D, y + D + E, E), T2 = Math.max(0, T2 + M), B2 = Math.max(0, B2 + y);
    else {
      T2 = "start" === f ? k - r3 - g2 : "end" === f ? k - s2 + W2 + V2 : "nearest" === f ? o(r3, s2, n2, g2, W2 + V2, k, k + v, v) : k - (r3 + n2 / 2) + V2 / 2, B2 = "start" === u ? D - d2 - a2 : "center" === u ? D - (d2 + l2 / 2) + F2 / 2 : "end" === u ? D - i2 + p2 + F2 : o(d2, i2, l2, a2, p2 + F2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: h3 } = e4;
      T2 = 0 === X ? 0 : Math.max(0, Math.min(h3 + T2 / X, e4.scrollHeight - n2 / X + V2)), B2 = 0 === S ? 0 : Math.max(0, Math.min(t3 + B2 / S, e4.scrollWidth - l2 / S + F2)), k += h3 - T2, D += t3 - B2;
    }
    L.push({ el: e4, top: T2, left: B2 });
  }
  return L;
}, "r");

// node_modules/.pnpm/scroll-into-view-if-needed@3.1.0/node_modules/scroll-into-view-if-needed/dist/index.js
var o2 = /* @__PURE__ */ __name((t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" }, "o");
function e2(e3, r2) {
  if (!e3.isConnected || !((t2) => {
    let o3 = t2;
    for (; o3 && o3.parentNode; ) {
      if (o3.parentNode === document)
        return true;
      o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
    }
    return false;
  })(e3))
    return;
  const n2 = ((t2) => {
    const o3 = window.getComputedStyle(t2);
    return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
  })(e3);
  if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2))
    return r2.behavior(r(e3, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a, top: i, left: s } of r(e3, o2(r2))) {
    const t2 = i - n2.top + n2.bottom, o3 = s - n2.left + n2.right;
    a.scroll({ top: t2, left: o3, behavior: l2 });
  }
}
__name(e2, "e");

// packages/ant-design/components/_util/getScroll.ts
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
__name(isWindow, "isWindow");
function getScroll(target, top) {
  if (typeof window === "undefined") {
    return 0;
  }
  const method4 = top ? "scrollTop" : "scrollLeft";
  let result = 0;
  if (isWindow(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target instanceof HTMLElement) {
    result = target[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow(target) && typeof result !== "number") {
    result = (target.ownerDocument ?? target).documentElement?.[method4];
  }
  return result;
}
__name(getScroll, "getScroll");

// packages/ant-design/components/_util/easings.ts
function easeInOutCubic(t2, b, c, d) {
  const cc = c - b;
  t2 /= d / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
}
__name(easeInOutCubic, "easeInOutCubic");

// packages/ant-design/components/_util/scrollTo.ts
function scrollTo(y, options = {}) {
  const { getContainer: getContainer2 = /* @__PURE__ */ __name(() => window, "getContainer"), callback, duration = 450 } = options;
  const container = getContainer2();
  const scrollTop = getScroll(container, true);
  const startTime = Date.now();
  const frameFunc = /* @__PURE__ */ __name(() => {
    const timestamp = Date.now();
    const time = timestamp - startTime;
    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
    if (isWindow(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      raf_default(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  }, "frameFunc");
  raf_default(frameFunc);
}
__name(scrollTo, "scrollTo");

// packages/ant-design/components/config-provider/hooks/useCSSVarCls.ts
var useCSSVarCls = /* @__PURE__ */ __name((prefixCls) => {
  const [, , , , cssVar] = useToken();
  return cssVar ? `${prefixCls}-css-var` : "";
}, "useCSSVarCls");
var useCSSVarCls_default = useCSSVarCls;

// packages/ant-design/components/anchor/AnchorLink.tsx
var import_classnames4 = __toESM(require_classnames());
import * as React42 from "react";

// packages/ant-design/components/anchor/context.ts
import * as React41 from "react";
var AnchorContext = React41.createContext(void 0);
var context_default2 = AnchorContext;

// packages/ant-design/components/anchor/AnchorLink.tsx
var AnchorLink = /* @__PURE__ */ __name((props) => {
  const {
    href,
    title,
    prefixCls: customizePrefixCls,
    children,
    className,
    target,
    replace: replace2
  } = props;
  const context = React42.useContext(context_default2);
  const { registerLink, unregisterLink, scrollTo: scrollTo2, onClick, activeLink, direction } = context || {};
  React42.useEffect(() => {
    registerLink?.(href);
    return () => {
      unregisterLink?.(href);
    };
  }, [href]);
  const handleClick = /* @__PURE__ */ __name((e3) => {
    if (replace2) {
      e3.preventDefault();
      window.location.replace(href);
    }
    onClick?.(e3, { title, href });
    scrollTo2?.(href);
  }, "handleClick");
  if (true) {
    const warning5 = devUseWarning("Anchor.Link");
    warning5(
      !children || direction !== "horizontal",
      "usage",
      "`Anchor.Link children` is not supported when `Anchor` direction is horizontal"
    );
  }
  const { getPrefixCls } = React42.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customizePrefixCls);
  const active = activeLink === href;
  const wrapperClassName = (0, import_classnames4.default)(`${prefixCls}-link`, className, {
    [`${prefixCls}-link-active`]: active
  });
  const titleClassName = (0, import_classnames4.default)(`${prefixCls}-link-title`, {
    [`${prefixCls}-link-title-active`]: active
  });
  return /* @__PURE__ */ React42.createElement("div", { className: wrapperClassName }, /* @__PURE__ */ React42.createElement(
    "a",
    {
      className: titleClassName,
      href,
      title: typeof title === "string" ? title : "",
      target,
      onClick: handleClick
    },
    title
  ), direction !== "horizontal" ? children : null);
}, "AnchorLink");
var AnchorLink_default = AnchorLink;

// packages/ant-design/components/anchor/style/index.ts
var genSharedAnchorStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    holderOffsetBlock,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary,
    lineType,
    colorSplit,
    calc
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),
      paddingBlockStart: holderOffsetBlock,
      // delete overflow: auto
      // overflow: 'auto',
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        paddingInlineStart: lineWidthBold,
        [`${componentCls}-link`]: {
          paddingBlock: token2.linkPaddingBlock,
          paddingInline: `${unit(token2.linkPaddingInlineStart)} 0`,
          "&-title": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            marginBlockEnd: token2.anchorTitleBlock,
            color: token2.colorText,
            transition: `all ${token2.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          },
          [`&-active > ${componentCls}-link-title`]: {
            color: token2.colorPrimary
          },
          // link link
          [`${componentCls}-link`]: {
            paddingBlock: token2.anchorPaddingBlockSecondary
          }
        }
      },
      [`&:not(${componentCls}-wrapper-horizontal)`]: {
        [componentCls]: {
          "&::before": {
            position: "absolute",
            insetInlineStart: 0,
            top: 0,
            height: "100%",
            borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,
            content: '" "'
          },
          [`${componentCls}-ink`]: {
            position: "absolute",
            insetInlineStart: 0,
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${motionDurationSlow} ease-in-out`,
            width: lineWidthBold,
            backgroundColor: colorPrimary,
            [`&${componentCls}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: {
        display: "none"
      }
    }
  };
}, "genSharedAnchorStyle");
var genSharedAnchorHorizontalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationSlow, lineWidthBold, colorPrimary } = token2;
  return {
    [`${componentCls}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: 0
        },
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
        content: '" "'
      },
      [componentCls]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
        },
        [`${componentCls}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${componentCls}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
          height: lineWidthBold,
          backgroundColor: colorPrimary
        }
      }
    }
  };
}, "genSharedAnchorHorizontalStyle");
var prepareComponentToken3 = /* @__PURE__ */ __name((token2) => ({
  linkPaddingBlock: token2.paddingXXS,
  linkPaddingInlineStart: token2.padding
}), "prepareComponentToken");
var style_default3 = genStyleHooks(
  "Anchor",
  (token2) => {
    const { fontSize, fontSizeLG, paddingXXS, calc } = token2;
    const anchorToken = merge2(token2, {
      holderOffsetBlock: paddingXXS,
      anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),
      anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),
      anchorBallSize: calc(fontSizeLG).div(2).equal()
    });
    return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
  },
  prepareComponentToken3
);

// packages/ant-design/components/anchor/Anchor.tsx
function getDefaultContainer() {
  return window;
}
__name(getDefaultContainer, "getDefaultContainer");
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  const rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      container = element.ownerDocument.documentElement;
      return rect.top - container.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
__name(getOffsetTop, "getOffsetTop");
var sharpMatcherRegex = /#([\S ]+)$/;
var Anchor = /* @__PURE__ */ __name((props) => {
  const {
    rootClassName,
    prefixCls: customPrefixCls,
    className,
    style: style2,
    offsetTop,
    affix = true,
    showInkInFixed = false,
    children,
    items,
    direction: anchorDirection = "vertical",
    bounds,
    targetOffset: targetOffset4,
    onClick,
    onChange,
    getContainer: getContainer2,
    getCurrentAnchor,
    replace: replace2
  } = props;
  if (true) {
    const warning5 = devUseWarning("Anchor");
    warning5.deprecated(!children, "Anchor children", "items");
    warning5(
      !(anchorDirection === "horizontal" && items?.some((n2) => "children" in n2)),
      "usage",
      "`Anchor items#children` is not supported when `Anchor` direction is horizontal."
    );
  }
  const [links, setLinks] = React43.useState([]);
  const [activeLink, setActiveLink] = React43.useState(null);
  const activeLinkRef = React43.useRef(activeLink);
  const wrapperRef = React43.useRef(null);
  const spanLinkNode = React43.useRef(null);
  const animating = React43.useRef(false);
  const { direction, anchor, getTargetContainer, getPrefixCls } = React43.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customPrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default3(prefixCls, rootCls);
  const getCurrentContainer = getContainer2 ?? getTargetContainer ?? getDefaultContainer;
  const dependencyListItem = JSON.stringify(links);
  const registerLink = useEvent((link) => {
    if (!links.includes(link)) {
      setLinks((prev2) => [...prev2, link]);
    }
  });
  const unregisterLink = useEvent((link) => {
    if (links.includes(link)) {
      setLinks((prev2) => prev2.filter((i) => i !== link));
    }
  });
  const updateInk = /* @__PURE__ */ __name(() => {
    const linkNode = wrapperRef.current?.querySelector(
      `.${prefixCls}-link-title-active`
    );
    if (linkNode && spanLinkNode.current) {
      const { style: inkStyle } = spanLinkNode.current;
      const horizontalAnchor = anchorDirection === "horizontal";
      inkStyle.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
      inkStyle.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
      inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
      inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
      if (horizontalAnchor) {
        e2(linkNode, { scrollMode: "if-needed", block: "nearest" });
      }
    }
  }, "updateInk");
  const getInternalCurrentAnchor = /* @__PURE__ */ __name((_links, _offsetTop = 0, _bounds = 5) => {
    const linkSections = [];
    const container = getCurrentContainer();
    _links.forEach((link) => {
      const sharpLinkMatch = sharpMatcherRegex.exec(link?.toString());
      if (!sharpLinkMatch) {
        return;
      }
      const target = document.getElementById(sharpLinkMatch[1]);
      if (target) {
        const top = getOffsetTop(target, container);
        if (top <= _offsetTop + _bounds) {
          linkSections.push({ link, top });
        }
      }
    });
    if (linkSections.length) {
      const maxSection = linkSections.reduce((prev2, curr) => curr.top > prev2.top ? curr : prev2);
      return maxSection.link;
    }
    return "";
  }, "getInternalCurrentAnchor");
  const setCurrentActiveLink = useEvent((link) => {
    if (activeLinkRef.current === link) {
      return;
    }
    const newLink = typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link;
    setActiveLink(newLink);
    activeLinkRef.current = newLink;
    onChange?.(link);
  });
  const handleScroll = React43.useCallback(() => {
    if (animating.current) {
      return;
    }
    const currentActiveLink = getInternalCurrentAnchor(
      links,
      targetOffset4 !== void 0 ? targetOffset4 : offsetTop || 0,
      bounds
    );
    setCurrentActiveLink(currentActiveLink);
  }, [dependencyListItem, targetOffset4, offsetTop]);
  const handleScrollTo = React43.useCallback(
    (link) => {
      setCurrentActiveLink(link);
      const sharpLinkMatch = sharpMatcherRegex.exec(link);
      if (!sharpLinkMatch) {
        return;
      }
      const targetElement = document.getElementById(sharpLinkMatch[1]);
      if (!targetElement) {
        return;
      }
      const container = getCurrentContainer();
      const scrollTop = getScroll(container, true);
      const eleOffsetTop = getOffsetTop(targetElement, container);
      let y = scrollTop + eleOffsetTop;
      y -= targetOffset4 !== void 0 ? targetOffset4 : offsetTop || 0;
      animating.current = true;
      scrollTo(y, {
        getContainer: getCurrentContainer,
        callback() {
          animating.current = false;
        }
      });
    },
    [targetOffset4, offsetTop]
  );
  const wrapperClass = (0, import_classnames5.default)(
    hashId,
    cssVarCls,
    rootCls,
    rootClassName,
    `${prefixCls}-wrapper`,
    {
      [`${prefixCls}-wrapper-horizontal`]: anchorDirection === "horizontal",
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    anchor?.className
  );
  const anchorClass = (0, import_classnames5.default)(prefixCls, {
    [`${prefixCls}-fixed`]: !affix && !showInkInFixed
  });
  const inkClass = (0, import_classnames5.default)(`${prefixCls}-ink`, {
    [`${prefixCls}-ink-visible`]: activeLink
  });
  const wrapperStyle = {
    maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh",
    ...anchor?.style,
    ...style2
  };
  const createNestedLink = /* @__PURE__ */ __name((options) => Array.isArray(options) ? options.map((item) => /* @__PURE__ */ React43.createElement(AnchorLink_default, { replace: replace2, ...item, key: item.key }, anchorDirection === "vertical" && createNestedLink(item.children))) : null, "createNestedLink");
  const anchorContent = /* @__PURE__ */ React43.createElement("div", { ref: wrapperRef, className: wrapperClass, style: wrapperStyle }, /* @__PURE__ */ React43.createElement("div", { className: anchorClass }, /* @__PURE__ */ React43.createElement("span", { className: inkClass, ref: spanLinkNode }), "items" in props ? createNestedLink(items) : children));
  React43.useEffect(() => {
    const scrollContainer = getCurrentContainer();
    handleScroll();
    scrollContainer?.addEventListener("scroll", handleScroll);
    return () => {
      scrollContainer?.removeEventListener("scroll", handleScroll);
    };
  }, [dependencyListItem]);
  React43.useEffect(() => {
    if (typeof getCurrentAnchor === "function") {
      setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ""));
    }
  }, [getCurrentAnchor]);
  React43.useEffect(() => {
    updateInk();
  }, [anchorDirection, getCurrentAnchor, dependencyListItem, activeLink]);
  const memoizedContextValue = React43.useMemo(
    () => ({
      registerLink,
      unregisterLink,
      scrollTo: handleScrollTo,
      activeLink,
      onClick,
      direction: anchorDirection
    }),
    [activeLink, onClick, handleScrollTo, anchorDirection]
  );
  return wrapCSSVar(
    /* @__PURE__ */ React43.createElement(context_default2.Provider, { value: memoizedContextValue }, affix ? /* @__PURE__ */ React43.createElement(affix_default, { offsetTop, target: getCurrentContainer }, anchorContent) : anchorContent)
  );
}, "Anchor");
if (true) {
  Anchor.displayName = "Anchor";
}
var Anchor_default = Anchor;

// packages/ant-design/components/anchor/index.ts
var Anchor2 = Anchor_default;
Anchor2.Link = AnchorLink_default;
var anchor_default = Anchor2;

// packages/ant-design/components/app/index.tsx
var import_classnames25 = __toESM(require_classnames());
import React103, { useContext as useContext44 } from "react";

// packages/ant-design/components/message/useMessage.tsx
var import_CloseOutlined2 = __toESM(require_CloseOutlined3());
var import_classnames9 = __toESM(require_classnames());
import * as React52 from "react";

// packages/notification/src/hooks/useNotification.tsx
import * as React48 from "react";

// packages/notification/src/Notifications.tsx
import * as React47 from "react";
import { createPortal } from "react-dom";

// packages/notification/src/NoticeList.tsx
var import_classnames7 = __toESM(require_classnames());
import React46, { useContext as useContext19, useEffect as useEffect14, useRef as useRef16, useState as useState5 } from "react";

// packages/notification/src/Notice.tsx
var import_classnames6 = __toESM(require_classnames());

// packages/util/src/KeyCode.ts
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: /* @__PURE__ */ __name(function isTextModifyingKeyEvent(e3) {
    const { keyCode } = e3;
    if (e3.altKey && !e3.ctrlKey || e3.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  }, "isTextModifyingKeyEvent"),
  /**
   * whether character is entered.
   */
  isCharacterKey: /* @__PURE__ */ __name(function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }, "isCharacterKey")
};
var KeyCode_default = KeyCode;

// packages/notification/src/Notice.tsx
import * as React44 from "react";
var Notify = React44.forwardRef((props, ref) => {
  const {
    prefixCls,
    style: style2,
    className,
    duration = 4.5,
    eventKey,
    content,
    closable,
    closeIcon = "x",
    props: divProps,
    onClick,
    onNoticeClose,
    times,
    hovering: forcedHovering
  } = props;
  const [hovering, setHovering] = React44.useState(false);
  const mergedHovering = forcedHovering || hovering;
  const onInternalClose = /* @__PURE__ */ __name(() => {
    onNoticeClose(eventKey);
  }, "onInternalClose");
  const onCloseKeyDown = /* @__PURE__ */ __name((e3) => {
    if (e3.key === "Enter" || e3.code === "Enter" || e3.keyCode === KeyCode_default.ENTER) {
      onInternalClose();
    }
  }, "onCloseKeyDown");
  React44.useEffect(() => {
    if (!mergedHovering && duration > 0) {
      const timeout = setTimeout(() => {
        onInternalClose();
      }, duration * 1e3);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [duration, mergedHovering, times]);
  const closableObj = React44.useMemo(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return { closeIcon };
    }
    return {};
  }, [closable, closeIcon]);
  const ariaProps = pickAttrs(closableObj, true);
  const noticePrefixCls = `${prefixCls}-notice`;
  return /* @__PURE__ */ React44.createElement(
    "div",
    {
      ...divProps,
      ref,
      className: (0, import_classnames6.default)(noticePrefixCls, className, {
        [`${noticePrefixCls}-closable`]: closable
      }),
      style: style2,
      onMouseEnter: (e3) => {
        setHovering(true);
        divProps?.onMouseEnter?.(e3);
      },
      onMouseLeave: (e3) => {
        setHovering(false);
        divProps?.onMouseLeave?.(e3);
      },
      onClick
    },
    /* @__PURE__ */ React44.createElement("div", { className: `${noticePrefixCls}-content` }, content),
    closable && /* @__PURE__ */ React44.createElement(
      "a",
      {
        tabIndex: 0,
        className: `${noticePrefixCls}-close`,
        onKeyDown: onCloseKeyDown,
        "aria-label": "Close",
        ...ariaProps,
        onClick: (e3) => {
          e3.preventDefault();
          e3.stopPropagation();
          onInternalClose();
        }
      },
      closableObj.closeIcon
    )
  );
});
var Notice_default = Notify;

// packages/notification/src/NotificationProvider.tsx
import React45 from "react";
var NotificationContext = React45.createContext({});
var NotificationProvider = /* @__PURE__ */ __name(({ children, classNames: classNames253 }) => {
  return /* @__PURE__ */ React45.createElement(NotificationContext.Provider, { value: { classNames: classNames253 } }, children);
}, "NotificationProvider");
var NotificationProvider_default = NotificationProvider;

// packages/notification/src/hooks/useStack.ts
var DEFAULT_OFFSET = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = /* @__PURE__ */ __name((config) => {
  const result = {
    offset: DEFAULT_OFFSET,
    threshold: DEFAULT_THRESHOLD,
    gap: DEFAULT_GAP
  };
  if (config && typeof config === "object") {
    result.offset = config.offset ?? DEFAULT_OFFSET;
    result.threshold = config.threshold ?? DEFAULT_THRESHOLD;
    result.gap = config.gap ?? DEFAULT_GAP;
  }
  return [!!config, result];
}, "useStack");
var useStack_default = useStack;

// packages/notification/src/NoticeList.tsx
var NoticeList = /* @__PURE__ */ __name((props) => {
  const {
    configList,
    placement,
    prefixCls,
    className,
    style: style2,
    motion: motion2,
    onAllNoticeRemoved,
    onNoticeClose,
    stack: stackConfig
  } = props;
  const { classNames: ctxCls } = useContext19(NotificationContext);
  const dictRef = useRef16({});
  const [latestNotice, setLatestNotice] = useState5(null);
  const [hoverKeys, setHoverKeys] = useState5([]);
  const keys2 = configList.map((config) => ({
    config,
    key: String(config.key)
  }));
  const [stack, { offset: offset3, threshold, gap }] = useStack_default(stackConfig);
  const expanded = stack && (hoverKeys.length > 0 || keys2.length <= threshold);
  const placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
  useEffect14(() => {
    if (stack && hoverKeys.length > 1) {
      setHoverKeys(
        (prev2) => prev2.filter((key) => keys2.some(({ key: dataKey }) => key === dataKey))
      );
    }
  }, [hoverKeys, keys2, stack]);
  useEffect14(() => {
    if (stack && dictRef.current[keys2[keys2.length - 1]?.key]) {
      setLatestNotice(dictRef.current[keys2[keys2.length - 1]?.key]);
    }
  }, [keys2, stack]);
  return /* @__PURE__ */ React46.createElement(
    CSSMotionList_default,
    {
      key: placement,
      className: (0, import_classnames7.default)(prefixCls, `${prefixCls}-${placement}`, ctxCls?.list, className, {
        [`${prefixCls}-stack`]: !!stack,
        [`${prefixCls}-stack-expanded`]: expanded
      }),
      style: style2,
      keys: keys2,
      motionAppear: true,
      ...placementMotion,
      onAllRemoved: () => {
        onAllNoticeRemoved(placement);
      }
    },
    ({ config, className: motionClassName, style: motionStyle, index: motionIndex }, nodeRef) => {
      const { key, times } = config;
      const strKey = String(key);
      const {
        className: configClassName,
        style: configStyle,
        classNames: configClassNames,
        styles: configStyles,
        ...restConfig
      } = config;
      const dataIndex = keys2.findIndex((item) => item.key === strKey);
      const stackStyle = {};
      if (stack) {
        const index3 = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
        const transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
        if (index3 > 0) {
          stackStyle.height = expanded ? dictRef.current[strKey]?.offsetHeight : latestNotice?.offsetHeight;
          let verticalOffset = 0;
          for (let i = 0; i < index3; i++) {
            verticalOffset += dictRef.current[keys2[keys2.length - 1 - i].key]?.offsetHeight + gap;
          }
          const transformY = (expanded ? verticalOffset : index3 * offset3) * (placement.startsWith("top") ? 1 : -1);
          const scaleX = !expanded && latestNotice?.offsetWidth && dictRef.current[strKey]?.offsetWidth ? (latestNotice?.offsetWidth - offset3 * 2 * (index3 < 3 ? index3 : 3)) / dictRef.current[strKey]?.offsetWidth : 1;
          stackStyle.transform = `translate3d(${transformX}, ${transformY}px, 0) scaleX(${scaleX})`;
        } else {
          stackStyle.transform = `translate3d(${transformX}, 0, 0)`;
        }
      }
      return /* @__PURE__ */ React46.createElement(
        "div",
        {
          ref: nodeRef,
          className: (0, import_classnames7.default)(
            `${prefixCls}-notice-wrapper`,
            motionClassName,
            configClassNames?.wrapper
          ),
          style: {
            ...motionStyle,
            ...stackStyle,
            ...configStyles?.wrapper
          },
          onMouseEnter: () => setHoverKeys((prev2) => prev2.includes(strKey) ? prev2 : [...prev2, strKey]),
          onMouseLeave: () => setHoverKeys((prev2) => prev2.filter((k) => k !== strKey))
        },
        /* @__PURE__ */ React46.createElement(
          Notice_default,
          {
            ...restConfig,
            ref: (node2) => {
              if (dataIndex > -1) {
                dictRef.current[strKey] = node2;
              } else {
                delete dictRef.current[strKey];
              }
            },
            prefixCls,
            classNames: configClassNames,
            styles: configStyles,
            className: (0, import_classnames7.default)(configClassName, ctxCls?.notice),
            style: configStyle,
            times,
            key,
            eventKey: key,
            onNoticeClose,
            hovering: stack && hoverKeys.length > 0
          }
        )
      );
    }
  );
}, "NoticeList");
if (true) {
  NoticeList.displayName = "NoticeList";
}
var NoticeList_default = NoticeList;

// packages/notification/src/Notifications.tsx
var Notifications = React47.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-notification",
    container,
    motion: motion2,
    maxCount,
    className,
    style: style2,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3
  } = props;
  const [configList, setConfigList] = React47.useState([]);
  const onNoticeClose = /* @__PURE__ */ __name((key) => {
    const config = configList.find((item) => item.key === key);
    config?.onClose?.();
    setConfigList((list) => list.filter((item) => item.key !== key));
  }, "onNoticeClose");
  React47.useImperativeHandle(ref, () => ({
    open: (config) => {
      setConfigList((list) => {
        let clone = [...list];
        const index3 = clone.findIndex((item) => item.key === config.key);
        const innerConfig = { ...config };
        if (index3 >= 0) {
          innerConfig.times = (list[index3]?.times || 0) + 1;
          clone[index3] = innerConfig;
        } else {
          innerConfig.times = 0;
          clone.push(innerConfig);
        }
        if (maxCount > 0 && clone.length > maxCount) {
          clone = clone.slice(-maxCount);
        }
        return clone;
      });
    },
    close: (key) => {
      onNoticeClose(key);
    },
    destroy: () => {
      setConfigList([]);
    }
  }));
  const [placements5, setPlacements] = React47.useState({});
  React47.useEffect(() => {
    const nextPlacements = {};
    configList.forEach((config) => {
      const { placement = "topRight" } = config;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements5).forEach((placement) => {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  const onAllNoticeRemoved = /* @__PURE__ */ __name((placement) => {
    setPlacements((originPlacements) => {
      const clone = {
        ...originPlacements
      };
      const list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  }, "onAllNoticeRemoved");
  const emptyRef = React47.useRef(false);
  React47.useEffect(() => {
    if (Object.keys(placements5).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved?.();
      emptyRef.current = false;
    }
  }, [placements5]);
  if (!container) {
    return null;
  }
  const placementList = Object.keys(placements5);
  return createPortal(
    /* @__PURE__ */ React47.createElement(React47.Fragment, null, placementList.map((placement) => {
      const placementConfigList = placements5[placement];
      const list = /* @__PURE__ */ React47.createElement(
        NoticeList_default,
        {
          key: placement,
          configList: placementConfigList,
          placement,
          prefixCls,
          className: className?.(placement),
          style: style2?.(placement),
          motion: motion2,
          onNoticeClose,
          onAllNoticeRemoved,
          stack
        }
      );
      return renderNotifications3 ? renderNotifications3(list, { prefixCls, key: placement }) : list;
    })),
    container
  );
});
if (true) {
  Notifications.displayName = "Notifications";
}
var Notifications_default = Notifications;

// packages/notification/src/hooks/useNotification.tsx
var defaultGetContainer = /* @__PURE__ */ __name(() => document.body, "defaultGetContainer");
var uniqueKey = 0;
function mergeConfig(...objList) {
  const clone = {};
  objList.forEach((obj) => {
    if (obj) {
      Object.keys(obj).forEach((key) => {
        const val = obj[key];
        if (val !== void 0) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
__name(mergeConfig, "mergeConfig");
function useNotification(rootConfig = {}) {
  const {
    getContainer: getContainer2 = defaultGetContainer,
    motion: motion2,
    prefixCls,
    maxCount,
    className,
    style: style2,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3,
    ...shareConfig
  } = rootConfig;
  const [container, setContainer] = React48.useState();
  const notificationsRef = React48.useRef();
  const contextHolder = /* @__PURE__ */ React48.createElement(
    Notifications_default,
    {
      container,
      ref: notificationsRef,
      prefixCls,
      motion: motion2,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack,
      renderNotifications: renderNotifications3
    }
  );
  const [taskQueue3, setTaskQueue] = React48.useState([]);
  const api = React48.useMemo(() => {
    return {
      open: (config) => {
        const mergedConfig = mergeConfig(shareConfig, config);
        if (mergedConfig.key === null || mergedConfig.key === void 0) {
          mergedConfig.key = `rc-notification-${uniqueKey}`;
          uniqueKey += 1;
        }
        setTaskQueue((queue) => [...queue, { type: "open", config: mergedConfig }]);
      },
      close: (key) => {
        setTaskQueue((queue) => [...queue, { type: "close", key }]);
      },
      destroy: () => {
        setTaskQueue((queue) => [...queue, { type: "destroy" }]);
      }
    };
  }, []);
  React48.useEffect(() => {
    setContainer(getContainer2());
  });
  React48.useEffect(() => {
    if (notificationsRef.current && taskQueue3.length) {
      taskQueue3.forEach((task) => {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      setTaskQueue((oriQueue) => oriQueue.filter((task) => !taskQueue3.includes(task)));
    }
  }, [taskQueue3]);
  return [api, contextHolder];
}
__name(useNotification, "useNotification");

// packages/ant-design/components/message/PurePanel.tsx
var import_CheckCircleFilled2 = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled2 = __toESM(require_CloseCircleFilled3());
var import_ExclamationCircleFilled2 = __toESM(require_ExclamationCircleFilled3());
var import_InfoCircleFilled2 = __toESM(require_InfoCircleFilled3());
var import_LoadingOutlined = __toESM(require_LoadingOutlined3());
var import_classnames8 = __toESM(require_classnames());
import * as React51 from "react";

// packages/ant-design/components/_util/hooks/useZIndex.ts
import React50 from "react";

// packages/ant-design/components/_util/zindexContext.ts
import React49 from "react";
var zIndexContext = React49.createContext(void 0);
if (true) {
  zIndexContext.displayName = "zIndexContext";
}
var zindexContext_default = zIndexContext;

// packages/ant-design/components/_util/hooks/useZIndex.ts
var CONTAINER_OFFSET = 100;
var CONTAINER_OFFSET_MAX_COUNT = 10;
var CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
var containerBaseZIndexOffset = {
  Modal: CONTAINER_OFFSET,
  Drawer: CONTAINER_OFFSET,
  Popover: CONTAINER_OFFSET,
  Popconfirm: CONTAINER_OFFSET,
  Tooltip: CONTAINER_OFFSET,
  Tour: CONTAINER_OFFSET
};
var consumerBaseZIndexOffset = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function isContainerType(type5) {
  return type5 in containerBaseZIndexOffset;
}
__name(isContainerType, "isContainerType");
function useZIndex(componentType, customZIndex) {
  const [, token2] = useToken();
  const parentZIndex = React50.useContext(zindexContext_default);
  const isContainer = isContainerType(componentType);
  if (customZIndex !== void 0) {
    return [customZIndex, customZIndex];
  }
  let zIndex = parentZIndex ?? 0;
  if (isContainer) {
    zIndex += // Use preset token zIndex by default but not stack when has parent container
    (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
    containerBaseZIndexOffset[componentType];
    zIndex = Math.min(zIndex, token2.zIndexPopupBase + CONTAINER_MAX_OFFSET);
  } else {
    zIndex += consumerBaseZIndexOffset[componentType];
  }
  return [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
}
__name(useZIndex, "useZIndex");

// packages/ant-design/components/message/style/index.ts
var genMessageStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    boxShadow,
    colorText,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    // Custom token
    contentPadding,
    contentBg
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const messageMoveIn = new Keyframes_default("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframes_default("MessageMoveOut", {
    "0%": {
      maxHeight: token2.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  const noticeStyle = {
    padding: paddingXS,
    textAlign: "center",
    [`${componentCls}-custom-content > ${iconCls}`]: {
      verticalAlign: "text-bottom",
      marginInlineEnd: marginXS,
      // affected by ltr or rtl
      fontSize: fontSizeLG
    },
    [`${noticeCls}-content`]: {
      display: "inline-block",
      padding: contentPadding,
      background: contentBg,
      borderRadius: borderRadiusLG,
      boxShadow,
      pointerEvents: "all"
    },
    [`${componentCls}-success > ${iconCls}`]: {
      color: colorSuccess
    },
    [`${componentCls}-error > ${iconCls}`]: {
      color: colorError
    },
    [`${componentCls}-warning > ${iconCls}`]: {
      color: colorWarning
    },
    [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
      color: colorInfo
    }
  };
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token2),
        color: colorText,
        position: "fixed",
        top: marginXS,
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: {
          ...noticeStyle
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${componentCls}-notice-pure-panel`]: {
        ...noticeStyle,
        padding: 0,
        textAlign: "start"
      }
    }
  ];
}, "genMessageStyle");
var prepareComponentToken4 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
  contentBg: token2.colorBgElevated,
  contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
}), "prepareComponentToken");
var style_default4 = genStyleHooks(
  "Message",
  (token2) => {
    const combinedToken = merge2(token2, {
      height: 150
    });
    return [genMessageStyle(combinedToken)];
  },
  prepareComponentToken4
);

// packages/ant-design/components/message/PurePanel.tsx
var TypeIcon = {
  info: /* @__PURE__ */ React51.createElement(import_InfoCircleFilled2.default, null),
  success: /* @__PURE__ */ React51.createElement(import_CheckCircleFilled2.default, null),
  error: /* @__PURE__ */ React51.createElement(import_CloseCircleFilled2.default, null),
  warning: /* @__PURE__ */ React51.createElement(import_ExclamationCircleFilled2.default, null),
  loading: /* @__PURE__ */ React51.createElement(import_LoadingOutlined.default, null)
};
var PureContent = /* @__PURE__ */ __name(({ prefixCls, type: type5, icon, children }) => /* @__PURE__ */ React51.createElement("div", { className: (0, import_classnames8.default)(`${prefixCls}-custom-content`, `${prefixCls}-${type5}`) }, icon || TypeIcon[type5], /* @__PURE__ */ React51.createElement("span", null, children)), "PureContent");
var PurePanel = /* @__PURE__ */ __name((props) => {
  const { prefixCls: staticPrefixCls, className, type: type5, icon, content, ...restProps } = props;
  const { getPrefixCls } = React51.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default4(prefixCls, rootCls);
  return wrapCSSVar(
    /* @__PURE__ */ React51.createElement(
      Notice_default,
      {
        ...restProps,
        prefixCls,
        className: (0, import_classnames8.default)(
          className,
          hashId,
          `${prefixCls}-notice-pure-panel`,
          cssVarCls,
          rootCls
        ),
        eventKey: "pure",
        duration: null,
        content: /* @__PURE__ */ React51.createElement(PureContent, { prefixCls, type: type5, icon }, content)
      }
    )
  );
}, "PurePanel");
var PurePanel_default = PurePanel;

// packages/ant-design/components/message/util.ts
function getMotion(prefixCls, transitionName) {
  return {
    motionName: transitionName ?? `${prefixCls}-move-up`
  };
}
__name(getMotion, "getMotion");
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = /* @__PURE__ */ __name(() => {
    closeFn?.();
  }, "result");
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}
__name(wrapPromiseFn, "wrapPromiseFn");

// packages/ant-design/components/message/useMessage.tsx
var DEFAULT_OFFSET2 = 8;
var DEFAULT_DURATION = 3;
var Wrapper = /* @__PURE__ */ __name(({ children, prefixCls }) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default4(prefixCls, rootCls);
  return wrapCSSVar(
    /* @__PURE__ */ React52.createElement(NotificationProvider_default, { classNames: { list: (0, import_classnames9.default)(hashId, cssVarCls, rootCls) } }, children)
  );
}, "Wrapper");
var renderNotifications = /* @__PURE__ */ __name((node2, { prefixCls, key }) => /* @__PURE__ */ React52.createElement(Wrapper, { prefixCls, key }, node2), "renderNotifications");
var Holder = React52.forwardRef((props, ref) => {
  const {
    top,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    duration = DEFAULT_DURATION,
    rtl,
    transitionName,
    onAllRemoved
  } = props;
  const { getPrefixCls, getPopupContainer, message: message2, direction } = React52.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const getStyle4 = /* @__PURE__ */ __name(() => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: top ?? DEFAULT_OFFSET2
  }), "getStyle");
  const getClassName = /* @__PURE__ */ __name(() => (0, import_classnames9.default)({ [`${prefixCls}-rtl`]: rtl ?? direction === "rtl" }), "getClassName");
  const getNotificationMotion = /* @__PURE__ */ __name(() => getMotion(prefixCls, transitionName), "getNotificationMotion");
  const mergedCloseIcon = /* @__PURE__ */ React52.createElement("span", { className: `${prefixCls}-close-x` }, /* @__PURE__ */ React52.createElement(import_CloseOutlined2.default, { className: `${prefixCls}-close-icon` }));
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle4,
    className: getClassName,
    motion: getNotificationMotion,
    closable: false,
    closeIcon: mergedCloseIcon,
    duration,
    getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
    maxCount,
    onAllRemoved,
    renderNotifications
  });
  React52.useImperativeHandle(ref, () => ({
    ...api,
    prefixCls,
    message: message2
  }));
  return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = React52.useRef(null);
  const warning5 = devUseWarning("Message");
  const wrapAPI = React52.useMemo(() => {
    const close = /* @__PURE__ */ __name((key) => {
      holderRef.current?.close(key);
    }, "close");
    const open3 = /* @__PURE__ */ __name((config) => {
      if (!holderRef.current) {
        warning5(
          false,
          "usage",
          "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead."
        );
        const fakeResult = /* @__PURE__ */ __name(() => {
        }, "fakeResult");
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const { open: originOpen, prefixCls, message: message2 } = holderRef.current;
      const noticePrefixCls = `${prefixCls}-notice`;
      const { content, icon, type: type5, key, className, style: style2, onClose, ...restConfig } = config;
      let mergedKey = key;
      if (mergedKey === void 0 || mergedKey === null) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      return wrapPromiseFn((resolve) => {
        originOpen({
          ...restConfig,
          key: mergedKey,
          content: /* @__PURE__ */ React52.createElement(PureContent, { prefixCls, type: type5, icon }, content),
          placement: "top",
          className: (0, import_classnames9.default)(
            type5 && `${noticePrefixCls}-${type5}`,
            className,
            message2?.className
          ),
          style: { ...message2?.style, ...style2 },
          onClose: () => {
            onClose?.();
            resolve();
          }
        });
        return () => {
          close(mergedKey);
        };
      });
    }, "open");
    const destroy3 = /* @__PURE__ */ __name((key) => {
      if (key !== void 0) {
        close(key);
      } else {
        holderRef.current?.destroy();
      }
    }, "destroy");
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys2 = ["info", "success", "warning", "error", "loading"];
    keys2.forEach((type5) => {
      const typeOpen2 = /* @__PURE__ */ __name((jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = {
          onClose: mergedOnClose,
          duration: mergedDuration,
          ...config,
          type: type5
        };
        return open3(mergedConfig);
      }, "typeOpen");
      clone[type5] = typeOpen2;
    });
    return clone;
  }, []);
  return [wrapAPI, /* @__PURE__ */ React52.createElement(Holder, { key: "message-holder", ...messageConfig, ref: holderRef })];
}
__name(useInternalMessage, "useInternalMessage");
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}
__name(useMessage, "useMessage");

// packages/ant-design/components/modal/useModal/index.tsx
import * as React99 from "react";

// packages/ant-design/components/_util/hooks/usePatchElement.ts
import * as React53 from "react";
function usePatchElement() {
  const [elements, setElements] = React53.useState([]);
  const patchElement = React53.useCallback((element) => {
    setElements((originElements) => [...originElements, element]);
    return () => {
      setElements((originElements) => originElements.filter((ele) => ele !== element));
    };
  }, []);
  return [elements, patchElement];
}
__name(usePatchElement, "usePatchElement");

// packages/ant-design/components/modal/confirm.tsx
import React97, { useContext as useContext40 } from "react";

// packages/util/src/React/render.ts
import * as ReactDOM2 from "react-dom";
var fullClone4 = {
  ...ReactDOM2
};
var { version: version2, render: reactRender, unmountComponentAtNode } = fullClone4;
var createRoot;
try {
  const mainVersion = Number((version2 || "").split(".")[0]);
  if (mainVersion >= 18) {
    ({ createRoot } = fullClone4);
  }
} catch (e3) {
}
function toggleWarning(skip) {
  const { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } = fullClone4;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
__name(toggleWarning, "toggleWarning");
var MARK = "__rc_react_root__";
function modernRender(node2, container) {
  toggleWarning(true);
  const root = container[MARK] || createRoot(container);
  toggleWarning(false);
  root.render(node2);
  container[MARK] = root;
}
__name(modernRender, "modernRender");
function legacyRender(node2, container) {
  reactRender(node2, container);
}
__name(legacyRender, "legacyRender");
function render(node2, container) {
  if (createRoot) {
    modernRender(node2, container);
    return;
  }
  legacyRender(node2, container);
}
__name(render, "render");
async function modernUnmount(container) {
  return Promise.resolve().then(() => {
    container[MARK]?.unmount();
    delete container[MARK];
  });
}
__name(modernUnmount, "modernUnmount");
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
__name(legacyUnmount, "legacyUnmount");
async function unmount(container) {
  if (createRoot !== void 0) {
    return modernUnmount(container);
  }
  legacyUnmount(container);
}
__name(unmount, "unmount");

// packages/ant-design/components/modal/ConfirmDialog.tsx
var import_CheckCircleFilled3 = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled3 = __toESM(require_CloseCircleFilled3());
var import_ExclamationCircleFilled3 = __toESM(require_ExclamationCircleFilled3());
var import_InfoCircleFilled3 = __toESM(require_InfoCircleFilled3());
var import_classnames22 = __toESM(require_classnames());
import * as React96 from "react";

// packages/ant-design/components/_util/motion.ts
var getCollapsedHeight = /* @__PURE__ */ __name(() => ({ height: 0, opacity: 0 }), "getCollapsedHeight");
var getRealHeight = /* @__PURE__ */ __name((node2) => {
  const { scrollHeight } = node2;
  return { height: scrollHeight, opacity: 1 };
}, "getRealHeight");
var getCurrentHeight = /* @__PURE__ */ __name((node2) => ({ height: node2 ? node2.offsetHeight : 0 }), "getCurrentHeight");
var skipOpacityTransition = /* @__PURE__ */ __name((_, event) => event?.deadline === true || event.propertyName === "height", "skipOpacityTransition");
var initCollapseMotion = /* @__PURE__ */ __name((rootCls = "ant") => ({
  motionName: `${rootCls}-motion-collapse`,
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
}), "initCollapseMotion");
var getTransitionName2 = /* @__PURE__ */ __name((rootPrefixCls, motion2, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion2}`;
}, "getTransitionName");
var motion_default = initCollapseMotion;

// packages/ant-design/components/modal/components/ConfirmCancelBtn.tsx
import React66, { useContext as useContext27 } from "react";

// packages/ant-design/components/_util/ActionButton.tsx
import * as React64 from "react";

// packages/ant-design/components/button/button.tsx
var import_classnames16 = __toESM(require_classnames());
import React63, { Children, createRef, useContext as useContext26, useEffect as useEffect18, useMemo as useMemo14, useState as useState10 } from "react";

// packages/ant-design/components/_util/wave/index.ts
var import_classnames11 = __toESM(require_classnames());
import React56, { useContext as useContext23, useRef as useRef22 } from "react";

// packages/util/src/Dom/isVisible.ts
var isVisible_default = /* @__PURE__ */ __name((element) => {
  if (!element) {
    return false;
  }
  if (element instanceof Element) {
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      const { width, height } = element.getBBox();
      if (width || height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      const { width, height } = element.getBoundingClientRect();
      if (width || height) {
        return true;
      }
    }
  }
  return false;
}, "default");

// packages/ant-design/components/_util/wave/style.ts
var genWaveStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, colorPrimary } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [
          `box-shadow 0.4s ${token2.motionEaseOutCirc}`,
          `opacity 2s ${token2.motionEaseOutCirc}`
        ].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        },
        "&.wave-quick": {
          transition: [
            `box-shadow ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
            `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          ].join(",")
        }
      }
    }
  };
}, "genWaveStyle");
var style_default5 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);

// packages/ant-design/components/_util/wave/useWave.ts
import * as React55 from "react";

// packages/ant-design/components/_util/wave/interface.ts
var TARGET_CLS = "ant-wave-target";

// packages/ant-design/components/_util/wave/WaveEffect.tsx
var import_classnames10 = __toESM(require_classnames());
import * as React54 from "react";

// packages/ant-design/components/_util/wave/util.ts
function isNotGrey(color) {
  const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
__name(isNotGrey, "isNotGrey");
function isValidWaveColor(color) {
  return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
  color !== "transparent";
}
__name(isValidWaveColor, "isValidWaveColor");
function getTargetWaveColor(node2) {
  const { borderTopColor, borderColor, backgroundColor } = getComputedStyle(node2);
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  if (isValidWaveColor(backgroundColor)) {
    return backgroundColor;
  }
  return null;
}
__name(getTargetWaveColor, "getTargetWaveColor");

// packages/ant-design/components/_util/wave/WaveEffect.tsx
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
__name(validateNum, "validateNum");
var WaveEffect = /* @__PURE__ */ __name((props) => {
  const { className, target, component } = props;
  const divRef = React54.useRef(null);
  const [color, setWaveColor] = React54.useState(null);
  const [borderRadius, setBorderRadius] = React54.useState([]);
  const [left, setLeft] = React54.useState(0);
  const [top, setTop] = React54.useState(0);
  const [width, setWidth] = React54.useState(0);
  const [height, setHeight] = React54.useState(0);
  const [enabled, setEnabled] = React54.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
  };
  if (color) {
    waveStyle["--wave-color"] = color;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor(target));
    const isStatic = nodeStyle.position === "static";
    const { borderLeftWidth, borderTopWidth } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius(
      [
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomRightRadius,
        borderBottomLeftRadius
      ].map((radius) => validateNum(parseFloat(radius)))
    );
  }
  __name(syncPos, "syncPos");
  React54.useEffect(() => {
    if (target) {
      const id = raf_default(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver2;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver2 = new ResizeObserver(syncPos);
        resizeObserver2.observe(target);
      }
      return () => {
        raf_default.cancel(id);
        resizeObserver2?.disconnect();
      };
    }
  }, []);
  if (!enabled) {
    return null;
  }
  const isSmallComponent = (component === "Checkbox" || component === "Radio") && target?.classList.contains(TARGET_CLS);
  return /* @__PURE__ */ React54.createElement(
    src_default2,
    {
      visible: true,
      motionAppear: true,
      motionName: "wave-motion",
      motionDeadline: 5e3,
      onAppearEnd: (_, event) => {
        if (event.deadline || event.propertyName === "opacity") {
          const holder = divRef.current?.parentElement;
          unmount(holder).then(() => {
            holder?.remove();
          });
        }
        return false;
      }
    },
    ({ className: motionClassName }) => /* @__PURE__ */ React54.createElement(
      "div",
      {
        ref: divRef,
        className: (0, import_classnames10.default)(
          className,
          {
            "wave-quick": isSmallComponent
          },
          motionClassName
        ),
        style: waveStyle
      }
    )
  );
}, "WaveEffect");
var showWaveEffect = /* @__PURE__ */ __name((target, info) => {
  const { component } = info;
  if (component === "Checkbox" && !target.querySelector("input")?.checked) {
    return;
  }
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = "0px";
  holder.style.top = "0px";
  target?.insertBefore(holder, target?.firstChild);
  render(/* @__PURE__ */ React54.createElement(WaveEffect, { ...info, target }), holder);
}, "showWaveEffect");
var WaveEffect_default = showWaveEffect;

// packages/ant-design/components/_util/wave/useWave.ts
var useWave = /* @__PURE__ */ __name((nodeRef, className, component) => {
  const { wave } = React55.useContext(ConfigContext);
  const [, token2, hashId] = useToken();
  const showWave = useEvent((event) => {
    const node2 = nodeRef.current;
    if (wave?.disabled || !node2) {
      return;
    }
    const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
    const { showEffect } = wave || {};
    (showEffect || WaveEffect_default)(targetNode, { className, token: token2, component, event, hashId });
  });
  const rafId = React55.useRef();
  const showDebounceWave = /* @__PURE__ */ __name((event) => {
    raf_default.cancel(rafId.current);
    rafId.current = raf_default(() => {
      showWave(event);
    });
  }, "showDebounceWave");
  return showDebounceWave;
}, "useWave");
var useWave_default = useWave;

// packages/ant-design/components/_util/wave/index.ts
var Wave = /* @__PURE__ */ __name((props) => {
  const { children, disabled, component } = props;
  const { getPrefixCls } = useContext23(ConfigContext);
  const containerRef = useRef22(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = style_default5(prefixCls);
  const showWave = useWave_default(containerRef, (0, import_classnames11.default)(prefixCls, hashId), component);
  React56.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== 1 || disabled) {
      return;
    }
    const onClick = /* @__PURE__ */ __name((e3) => {
      if (!isVisible_default(e3.target) || // No need wave
      !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
        return;
      }
      showWave(e3);
    }, "onClick");
    node2.addEventListener("click", onClick, true);
    return () => {
      node2.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!React56.isValidElement(children)) {
    return children ?? null;
  }
  const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
  return cloneElement3(children, { ref });
}, "Wave");
if (true) {
  Wave.displayName = "Wave";
}
var wave_default = Wave;

// packages/ant-design/components/config-provider/hooks/useSize.ts
import React57 from "react";
var useSize = /* @__PURE__ */ __name((customSize) => {
  const size = React57.useContext(SizeContext_default);
  const mergedSize = React57.useMemo(() => {
    if (!customSize) {
      return size;
    }
    if (typeof customSize === "string") {
      return customSize ?? size;
    }
    if (customSize instanceof Function) {
      return customSize(size);
    }
    return size;
  }, [customSize, size]);
  return mergedSize;
}, "useSize");
var useSize_default = useSize;

// packages/ant-design/components/space/Compact.tsx
var import_classnames12 = __toESM(require_classnames());
import * as React58 from "react";

// packages/ant-design/components/space/style/compact.ts
var genSpaceCompactStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, "genSpaceCompactStyle");
var compact_default = genSpaceCompactStyle;

// packages/ant-design/components/space/style/index.ts
var genSpaceStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item:empty`]: {
        display: "none"
      },
      // https://github.com/ant-design/ant-design/issues/47875
      [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
        display: "block"
      }
    }
  };
}, "genSpaceStyle");
var genSpaceGapStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      "&-gap-row-small": {
        rowGap: token2.spaceGapSmallSize
      },
      "&-gap-row-middle": {
        rowGap: token2.spaceGapMiddleSize
      },
      "&-gap-row-large": {
        rowGap: token2.spaceGapLargeSize
      },
      "&-gap-col-small": {
        columnGap: token2.spaceGapSmallSize
      },
      "&-gap-col-middle": {
        columnGap: token2.spaceGapMiddleSize
      },
      "&-gap-col-large": {
        columnGap: token2.spaceGapLargeSize
      }
    }
  };
}, "genSpaceGapStyle");
var style_default6 = genStyleHooks(
  "Space",
  (token2) => {
    const spaceToken = merge2(token2, {
      spaceGapSmallSize: token2.paddingXS,
      spaceGapMiddleSize: token2.padding,
      spaceGapLargeSize: token2.paddingLG
    });
    return [
      genSpaceStyle(spaceToken),
      genSpaceGapStyle(spaceToken),
      compact_default(spaceToken)
    ];
  },
  () => ({}),
  {
    // Space component don't apply extra font style
    // https://github.com/ant-design/ant-design/issues/40315
    resetStyle: false
  }
);

// packages/ant-design/components/space/Compact.tsx
var SpaceCompactItemContext = React58.createContext(
  null
);
var useCompactItemContext = /* @__PURE__ */ __name((prefixCls, direction) => {
  const compactItemContext = React58.useContext(SpaceCompactItemContext);
  const compactItemClassnames = React58.useMemo(() => {
    if (!compactItemContext) {
      return "";
    }
    const { compactDirection, isFirstItem, isLastItem } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return (0, import_classnames12.default)(`${prefixCls}-compact${separator}item`, {
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext?.compactSize,
    compactDirection: compactItemContext?.compactDirection,
    compactItemClassnames
  };
}, "useCompactItemContext");
var NoCompactStyle = /* @__PURE__ */ __name(({ children }) => /* @__PURE__ */ React58.createElement(SpaceCompactItemContext.Provider, { value: null }, children), "NoCompactStyle");
var CompactItem = /* @__PURE__ */ __name(({
  children,
  ...otherProps
}) => /* @__PURE__ */ React58.createElement(SpaceCompactItemContext.Provider, { value: otherProps }, children), "CompactItem");
var Compact = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction: directionConfig } = React58.useContext(ConfigContext);
  const {
    size,
    direction,
    block,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    ...restProps
  } = props;
  const mergedSize = useSize_default((ctx) => size ?? ctx);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [wrapCSSVar, hashId] = style_default6(prefixCls);
  const clx = (0, import_classnames12.default)(
    prefixCls,
    hashId,
    {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-vertical`]: direction === "vertical"
    },
    className,
    rootClassName
  );
  const compactItemContext = React58.useContext(SpaceCompactItemContext);
  const childNodes = toArray(children);
  const nodes = React58.useMemo(
    () => childNodes.map((child, i) => {
      const key = child && child.key || `${prefixCls}-item-${i}`;
      return /* @__PURE__ */ React58.createElement(
        CompactItem,
        {
          key,
          compactSize: mergedSize,
          compactDirection: direction,
          isFirstItem: i === 0 && (!compactItemContext || compactItemContext?.isFirstItem),
          isLastItem: i === childNodes.length - 1 && (!compactItemContext || compactItemContext?.isLastItem)
        },
        child
      );
    }),
    [size, childNodes, compactItemContext]
  );
  if (childNodes.length === 0) {
    return null;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React58.createElement("div", { className: clx, ...restProps }, nodes)
  );
}, "Compact");
var Compact_default = Compact;

// packages/ant-design/components/button/button-group.tsx
var import_classnames13 = __toESM(require_classnames());
import * as React59 from "react";
var GroupSizeContext = React59.createContext(void 0);
var ButtonGroup = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction } = React59.useContext(ConfigContext);
  const { prefixCls: customizePrefixCls, size, className, ...others } = props;
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = useToken();
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
    case "middle":
    default:
  }
  if (true) {
    const warning5 = devUseWarning("Button.Group");
    warning5(!size || ["large", "small", "middle"].includes(size), "usage", "Invalid prop `size`.");
  }
  const classes = (0, import_classnames13.default)(
    prefixCls,
    {
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    hashId
  );
  return /* @__PURE__ */ React59.createElement(GroupSizeContext.Provider, { value: size }, /* @__PURE__ */ React59.createElement("div", { ...others, className: classes }));
}, "ButtonGroup");
var button_group_default = ButtonGroup;

// packages/ant-design/components/button/buttonHelpers.tsx
import React60 from "react";
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type5) {
  if (type5 === "danger") {
    return { danger: true };
  }
  return { type: type5 };
}
__name(convertLegacyProps, "convertLegacyProps");
function isString(str) {
  return typeof str === "string";
}
__name(isString, "isString");
function isUnBorderedButtonType(type5) {
  return type5 === "text" || type5 === "link";
}
__name(isUnBorderedButtonType, "isUnBorderedButtonType");
function splitCNCharsBySpace(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement3(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (isString(child)) {
    return isTwoCNChar(child) ? /* @__PURE__ */ React60.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React60.createElement("span", null, child);
  }
  if (isFragment3(child)) {
    return /* @__PURE__ */ React60.createElement("span", null, child);
  }
  return child;
}
__name(splitCNCharsBySpace, "splitCNCharsBySpace");
function spaceChildren(children, needInserted) {
  let isPrevChildPure = false;
  const childList = [];
  React60.Children.forEach(children, (child) => {
    const type5 = typeof child;
    const isCurrentChildPure = type5 === "string" || type5 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return React60.Children.map(
    childList,
    (child) => splitCNCharsBySpace(child, needInserted)
  );
}
__name(spaceChildren, "spaceChildren");

// packages/ant-design/components/button/IconWrapper.tsx
var import_classnames14 = __toESM(require_classnames());
import React61, { forwardRef as forwardRef7 } from "react";
var IconWrapper = forwardRef7((props, ref) => {
  const { className, style: style2, children, prefixCls } = props;
  const iconWrapperCls = (0, import_classnames14.default)(`${prefixCls}-icon`, className);
  return /* @__PURE__ */ React61.createElement("span", { ref, className: iconWrapperCls, style: style2 }, children);
});
var IconWrapper_default = IconWrapper;

// packages/ant-design/components/button/LoadingIcon.tsx
var import_LoadingOutlined2 = __toESM(require_LoadingOutlined3());
var import_classnames15 = __toESM(require_classnames());
import React62, { forwardRef as forwardRef8 } from "react";
var InnerLoadingIcon = forwardRef8(
  ({ prefixCls, className, style: style2, iconClassName }, ref) => {
    const mergedIconCls = (0, import_classnames15.default)(`${prefixCls}-loading-icon`, className);
    return /* @__PURE__ */ React62.createElement(IconWrapper_default, { prefixCls, className: mergedIconCls, style: style2, ref }, /* @__PURE__ */ React62.createElement(import_LoadingOutlined2.default, { className: iconClassName }));
  }
);
var getCollapsedWidth = /* @__PURE__ */ __name(() => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), "getCollapsedWidth");
var getRealWidth = /* @__PURE__ */ __name((node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), "getRealWidth");
var LoadingIcon = /* @__PURE__ */ __name((props) => {
  const { prefixCls, loading, existIcon, className, style: style2 } = props;
  const visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ React62.createElement(InnerLoadingIcon, { prefixCls, className, style: style2 });
  }
  return /* @__PURE__ */ React62.createElement(
    src_default2,
    {
      visible,
      motionName: `${prefixCls}-loading-icon-motion`,
      motionLeave: visible,
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth
    },
    ({ className: motionCls, style: motionStyle }, ref) => /* @__PURE__ */ React62.createElement(
      InnerLoadingIcon,
      {
        prefixCls,
        className,
        style: { ...style2, ...motionStyle },
        ref,
        iconClassName: motionCls
      }
    )
  );
}, "LoadingIcon");
var LoadingIcon_default = LoadingIcon;

// packages/ant-design/components/button/style/group.ts
var genButtonBorderStyle = /* @__PURE__ */ __name((buttonTypeCls, borderColor) => ({
  // Border
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
}), "genButtonBorderStyle");
var genGroupStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, fontSize, lineWidth, groupBorderColor, colorErrorHover } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          [`&:hover,
          &:focus,
          &:active`]: {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      // Border Color
      genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
}, "genGroupStyle");
var group_default = genGroupStyle;

// packages/ant-design/components/button/style/token.ts
var prepareToken = /* @__PURE__ */ __name((token2) => {
  const { paddingInline, onlyIconSize, paddingBlock } = token2;
  const buttonToken = merge2(token2, {
    buttonPaddingHorizontal: paddingInline,
    buttonPaddingVertical: paddingBlock,
    buttonIconOnlyFontSize: onlyIconSize
  });
  return buttonToken;
}, "prepareToken");
var prepareComponentToken5 = /* @__PURE__ */ __name((token2) => {
  const contentFontSize = token2.contentFontSize ?? token2.fontSize;
  const contentFontSizeSM = token2.contentFontSizeSM ?? token2.fontSize;
  const contentFontSizeLG = token2.contentFontSizeLG ?? token2.fontSizeLG;
  const contentLineHeight = token2.contentLineHeight ?? getLineHeight(contentFontSize);
  const contentLineHeightSM = token2.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
  const contentLineHeightLG = token2.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
  return {
    fontWeight: 400,
    defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
    primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
    dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
    primaryColor: token2.colorTextLightSolid,
    dangerColor: token2.colorTextLightSolid,
    borderColorDisabled: token2.colorBorder,
    defaultGhostColor: token2.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: token2.colorBgContainer,
    paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineSM: 8 - token2.lineWidth,
    onlyIconSize: token2.fontSizeLG,
    onlyIconSizeSM: token2.fontSizeLG - 2,
    onlyIconSizeLG: token2.fontSizeLG + 2,
    groupBorderColor: token2.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: token2.colorBgTextHover,
    defaultColor: token2.colorText,
    defaultBg: token2.colorBgContainer,
    defaultBorderColor: token2.colorBorder,
    defaultBorderColorDisabled: token2.colorBorder,
    defaultHoverBg: token2.colorBgContainer,
    defaultHoverColor: token2.colorPrimaryHover,
    defaultHoverBorderColor: token2.colorPrimaryHover,
    defaultActiveBg: token2.colorBgContainer,
    defaultActiveColor: token2.colorPrimaryActive,
    defaultActiveBorderColor: token2.colorPrimaryActive,
    contentFontSize,
    contentFontSizeSM,
    contentFontSizeLG,
    contentLineHeight,
    contentLineHeightSM,
    contentLineHeightLG,
    paddingBlock: Math.max(
      (token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth,
      0
    ),
    paddingBlockSM: Math.max(
      (token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth,
      0
    ),
    paddingBlockLG: Math.max(
      (token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth,
      0
    )
  };
}, "prepareComponentToken");

// packages/ant-design/components/button/style/index.ts
var genSharedButtonStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls, fontWeight } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: token2.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      "> span": {
        display: "inline-block"
      },
      [`${componentCls}-icon`]: {
        lineHeight: 0
      },
      // Leave a space between icon and text.
      [`> ${iconCls} + span, > span + ${iconCls}`]: {
        marginInlineStart: token2.marginXS
      },
      [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
        [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
          marginInlineEnd: token2.marginXS
        }
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": {
        ...genFocusStyle(token2)
      },
      [`&${componentCls}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      // make `btn-icon-only` not too narrow
      [`&-icon-only${componentCls}-compact-item`]: {
        flex: "none"
      }
    }
  };
}, "genSharedButtonStyle");
var genHoverActiveButtonStyle = /* @__PURE__ */ __name((btnCls, hoverStyle, activeStyle) => ({
  [`&:not(:disabled):not(${btnCls}-disabled)`]: {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
}), "genHoverActiveButtonStyle");
var genCircleButtonStyle = /* @__PURE__ */ __name((token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), "genCircleButtonStyle");
var genRoundButtonStyle = /* @__PURE__ */ __name((token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.calc(token2.controlHeight).div(2).equal(),
  paddingInlineEnd: token2.calc(token2.controlHeight).div(2).equal()
}), "genRoundButtonStyle");
var genDisabledStyle = /* @__PURE__ */ __name((token2) => ({
  cursor: "not-allowed",
  borderColor: token2.borderColorDisabled,
  color: token2.colorTextDisabled,
  background: token2.colorBgContainerDisabled,
  boxShadow: "none"
}), "genDisabledStyle");
var genGhostButtonStyle = /* @__PURE__ */ __name((btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: {
    color: textColor || void 0,
    background,
    borderColor: borderColor || void 0,
    boxShadow: "none",
    ...genHoverActiveButtonStyle(
      btnCls,
      {
        background,
        ...hoverStyle
      },
      {
        background,
        ...activeStyle
      }
    ),
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  }
}), "genGhostButtonStyle");
var genSolidDisabledButtonStyle = /* @__PURE__ */ __name((token2) => ({
  [`&:disabled, &${token2.componentCls}-disabled`]: {
    ...genDisabledStyle(token2)
  }
}), "genSolidDisabledButtonStyle");
var genSolidButtonStyle = /* @__PURE__ */ __name((token2) => ({
  ...genSolidDisabledButtonStyle(token2)
}), "genSolidButtonStyle");
var genPureDisabledButtonStyle = /* @__PURE__ */ __name((token2) => ({
  [`&:disabled, &${token2.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
}), "genPureDisabledButtonStyle");
var genDefaultButtonStyle = /* @__PURE__ */ __name((token2) => ({
  ...genSolidButtonStyle(token2),
  background: token2.defaultBg,
  borderColor: token2.defaultBorderColor,
  color: token2.defaultColor,
  boxShadow: token2.defaultShadow,
  ...genHoverActiveButtonStyle(
    token2.componentCls,
    {
      color: token2.defaultHoverColor,
      borderColor: token2.defaultHoverBorderColor,
      background: token2.defaultHoverBg
    },
    {
      color: token2.defaultActiveColor,
      borderColor: token2.defaultActiveBorderColor,
      background: token2.defaultActiveBg
    }
  ),
  ...genGhostButtonStyle(
    token2.componentCls,
    token2.ghostBg,
    token2.defaultGhostColor,
    token2.defaultGhostBorderColor,
    token2.colorTextDisabled,
    token2.colorBorder
  ),
  [`&${token2.componentCls}-dangerous`]: {
    color: token2.colorError,
    borderColor: token2.colorError,
    ...genHoverActiveButtonStyle(
      token2.componentCls,
      {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorBorderHover
      },
      {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      }
    ),
    ...genGhostButtonStyle(
      token2.componentCls,
      token2.ghostBg,
      token2.colorError,
      token2.colorError,
      token2.colorTextDisabled,
      token2.colorBorder
    ),
    ...genSolidDisabledButtonStyle(token2)
  }
}), "genDefaultButtonStyle");
var genPrimaryButtonStyle = /* @__PURE__ */ __name((token2) => ({
  ...genSolidButtonStyle(token2),
  color: token2.primaryColor,
  background: token2.colorPrimary,
  boxShadow: token2.primaryShadow,
  ...genHoverActiveButtonStyle(
    token2.componentCls,
    {
      color: token2.colorTextLightSolid,
      background: token2.colorPrimaryHover
    },
    {
      color: token2.colorTextLightSolid,
      background: token2.colorPrimaryActive
    }
  ),
  ...genGhostButtonStyle(
    token2.componentCls,
    token2.ghostBg,
    token2.colorPrimary,
    token2.colorPrimary,
    token2.colorTextDisabled,
    token2.colorBorder,
    {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    },
    {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    }
  ),
  [`&${token2.componentCls}-dangerous`]: {
    background: token2.colorError,
    boxShadow: token2.dangerShadow,
    color: token2.dangerColor,
    ...genHoverActiveButtonStyle(
      token2.componentCls,
      {
        background: token2.colorErrorHover
      },
      {
        background: token2.colorErrorActive
      }
    ),
    ...genGhostButtonStyle(
      token2.componentCls,
      token2.ghostBg,
      token2.colorError,
      token2.colorError,
      token2.colorTextDisabled,
      token2.colorBorder,
      {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorHover
      },
      {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      }
    ),
    ...genSolidDisabledButtonStyle(token2)
  }
}), "genPrimaryButtonStyle");
var genDashedButtonStyle = /* @__PURE__ */ __name((token2) => ({
  ...genDefaultButtonStyle(token2),
  borderStyle: "dashed"
}), "genDashedButtonStyle");
var genLinkButtonStyle = /* @__PURE__ */ __name((token2) => ({
  color: token2.colorLink,
  ...genHoverActiveButtonStyle(
    token2.componentCls,
    {
      color: token2.colorLinkHover,
      background: token2.linkHoverBg
    },
    {
      color: token2.colorLinkActive
    }
  ),
  ...genPureDisabledButtonStyle(token2),
  [`&${token2.componentCls}-dangerous`]: {
    color: token2.colorError,
    ...genHoverActiveButtonStyle(
      token2.componentCls,
      {
        color: token2.colorErrorHover
      },
      {
        color: token2.colorErrorActive
      }
    ),
    ...genPureDisabledButtonStyle(token2)
  }
}), "genLinkButtonStyle");
var genTextButtonStyle = /* @__PURE__ */ __name((token2) => ({
  ...genHoverActiveButtonStyle(
    token2.componentCls,
    {
      color: token2.colorText,
      background: token2.textHoverBg
    },
    {
      color: token2.colorText,
      background: token2.colorBgTextActive
    }
  ),
  ...genPureDisabledButtonStyle(token2),
  [`&${token2.componentCls}-dangerous`]: {
    color: token2.colorError,
    ...genPureDisabledButtonStyle(token2),
    ...genHoverActiveButtonStyle(
      token2.componentCls,
      {
        color: token2.colorErrorHover,
        background: token2.colorErrorBg
      },
      {
        color: token2.colorErrorHover,
        background: token2.colorErrorBg
      }
    )
  }
}), "genTextButtonStyle");
var genTypeButtonStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-default`]: genDefaultButtonStyle(token2),
    [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
    [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
    [`${componentCls}-link`]: genLinkButtonStyle(token2),
    [`${componentCls}-text`]: genTextButtonStyle(token2),
    [`${componentCls}-ghost`]: genGhostButtonStyle(
      token2.componentCls,
      token2.ghostBg,
      token2.colorBgContainer,
      token2.colorBgContainer,
      token2.colorTextDisabled,
      token2.colorBorder
    )
  };
}, "genTypeButtonStyle");
var genButtonStyle = /* @__PURE__ */ __name((token2, prefixCls = "") => {
  const {
    componentCls,
    controlHeight,
    fontSize,
    lineHeight,
    borderRadius,
    buttonPaddingHorizontal,
    iconCls,
    buttonPaddingVertical
  } = token2;
  const iconOnlyCls = `${componentCls}-icon-only`;
  return [
    {
      [`${prefixCls}`]: {
        fontSize,
        lineHeight,
        height: controlHeight,
        padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
        borderRadius,
        [`&${iconOnlyCls}`]: {
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          width: controlHeight,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${componentCls}-round`]: {
            width: "auto"
          },
          [iconCls]: {
            fontSize: token2.buttonIconOnlyFontSize
          }
        },
        // Loading
        [`&${componentCls}-loading`]: {
          opacity: token2.opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${prefixCls}`]: genRoundButtonStyle(token2)
    }
  ];
}, "genButtonStyle");
var genSizeBaseButtonStyle = /* @__PURE__ */ __name((token2) => {
  const baseToken = merge2(token2, {
    fontSize: token2.contentFontSize,
    lineHeight: token2.contentLineHeight
  });
  return genButtonStyle(baseToken, token2.componentCls);
}, "genSizeBaseButtonStyle");
var genSizeSmallButtonStyle = /* @__PURE__ */ __name((token2) => {
  const smallToken = merge2(token2, {
    controlHeight: token2.controlHeightSM,
    fontSize: token2.contentFontSizeSM,
    lineHeight: token2.contentLineHeightSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: token2.paddingInlineSM,
    buttonPaddingVertical: token2.paddingBlockSM,
    borderRadius: token2.borderRadiusSM,
    buttonIconOnlyFontSize: token2.onlyIconSizeSM
  });
  return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
}, "genSizeSmallButtonStyle");
var genSizeLargeButtonStyle = /* @__PURE__ */ __name((token2) => {
  const largeToken = merge2(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.contentFontSizeLG,
    lineHeight: token2.contentLineHeightLG,
    buttonPaddingHorizontal: token2.paddingInlineLG,
    buttonPaddingVertical: token2.paddingBlockLG,
    borderRadius: token2.borderRadiusLG,
    buttonIconOnlyFontSize: token2.onlyIconSizeLG
  });
  return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
}, "genSizeLargeButtonStyle");
var genBlockButtonStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
}, "genBlockButtonStyle");
var style_default7 = genStyleHooks(
  "Button",
  (token2) => {
    const buttonToken = prepareToken(token2);
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeBaseButtonStyle(buttonToken),
      genSizeSmallButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Group (type, ghost, danger, loading)
      genTypeButtonStyle(buttonToken),
      // Button Group
      group_default(buttonToken)
    ];
  },
  prepareComponentToken5,
  {
    unitless: {
      fontWeight: true,
      contentLineHeight: true,
      contentLineHeightSM: true,
      contentLineHeightLG: true
    }
  }
);

// packages/ant-design/components/style/compact-item.ts
function compactItemBorder(token2, parentCls, options) {
  const { focusElCls, focus, borderElCls } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    "&-item": {
      [hoverEffects]: {
        zIndex: 2
      },
      ...focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {},
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    }
  };
}
__name(compactItemBorder, "compactItemBorder");
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const { borderElCls } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
__name(compactItemBorderRadius, "compactItemBorderRadius");
function genCompactItemStyle(token2, options = { focus: true }) {
  const { componentCls } = token2;
  const compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: {
      ...compactItemBorder(token2, compactCls, options),
      ...compactItemBorderRadius(componentCls, compactCls, options)
    }
  };
}
__name(genCompactItemStyle, "genCompactItemStyle");

// packages/ant-design/components/style/compact-item-vertical.ts
function compactItemVerticalBorder(token2, parentCls) {
  return {
    // border collapse
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
__name(compactItemVerticalBorder, "compactItemVerticalBorder");
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
__name(compactItemBorderVerticalRadius, "compactItemBorderVerticalRadius");
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: {
      ...compactItemVerticalBorder(token2, compactCls),
      ...compactItemBorderVerticalRadius(token2.componentCls, compactCls)
    }
  };
}
__name(genCompactItemVerticalStyle, "genCompactItemVerticalStyle");

// packages/ant-design/components/button/style/compactCmp.ts
var genButtonCompactStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, calc } = token2;
  return {
    [componentCls]: {
      // Special styles for Primary Button
      [`&-compact-item${componentCls}-primary`]: {
        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: calc(token2.lineWidth).mul(-1).equal(),
            insetInlineStart: calc(token2.lineWidth).mul(-1).equal(),
            display: "inline-block",
            width: token2.lineWidth,
            height: `calc(100% + ${unit(token2.lineWidth)} * 2)`,
            backgroundColor: token2.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: calc(token2.lineWidth).mul(-1).equal(),
              insetInlineStart: calc(token2.lineWidth).mul(-1).equal(),
              display: "inline-block",
              width: `calc(100% + ${unit(token2.lineWidth)} * 2)`,
              height: token2.lineWidth,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, "genButtonCompactStyle");
var compactCmp_default = genSubStyleComponent(
  ["Button", "compact"],
  (token2) => {
    const buttonToken = prepareToken(token2);
    return [
      // Space Compact
      genCompactItemStyle(buttonToken),
      genCompactItemVerticalStyle(buttonToken),
      genButtonCompactStyle(buttonToken)
    ];
  },
  prepareComponentToken5
);

// packages/ant-design/components/button/button.tsx
function getLoadingConfig(loading) {
  if (typeof loading === "object" && loading) {
    let delay = loading?.delay;
    delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
    return {
      loading: delay <= 0,
      delay
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
__name(getLoadingConfig, "getLoadingConfig");
var InternalCompoundedButton = React63.forwardRef((props, ref) => {
  const {
    loading = false,
    prefixCls: customizePrefixCls,
    type: type5,
    danger,
    shape = "default",
    size: customizeSize,
    styles,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    ghost = false,
    block = false,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType = "button",
    classNames: customClassNames,
    style: customStyle = {},
    ...rest
  } = props;
  const mergedType = type5 || "default";
  const { getPrefixCls, autoInsertSpaceInButton, direction, button } = useContext26(ConfigContext);
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default7(prefixCls);
  const disabled = useContext26(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const groupSize = useContext26(GroupSizeContext);
  const loadingOrDelay = useMemo14(() => getLoadingConfig(loading), [loading]);
  const [innerLoading, setLoading] = useState10(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = useState10(false);
  const internalRef = createRef();
  const buttonRef = composeRef(ref, internalRef);
  const needInserted = Children.count(children) === 1 && !icon && !isUnBorderedButtonType(mergedType);
  useEffect18(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    __name(cleanupTimer, "cleanupTimer");
    return cleanupTimer;
  }, [loadingOrDelay]);
  useEffect18(() => {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    const buttonText = buttonRef.current.textContent;
    if (needInserted && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  }, [buttonRef]);
  const handleClick = /* @__PURE__ */ __name((e3) => {
    const { onClick } = props;
    if (innerLoading || mergedDisabled) {
      e3.preventDefault();
      return;
    }
    onClick?.(e3);
  }, "handleClick");
  if (true) {
    const warning5 = devUseWarning("Button");
    warning5(
      !(typeof icon === "string" && icon.length > 2),
      "breaking",
      `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`
    );
    warning5(
      !(ghost && isUnBorderedButtonType(mergedType)),
      "usage",
      "`link` or `text` button can't be a `ghost` button."
    );
  }
  const autoInsertSpace = autoInsertSpaceInButton !== false;
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const sizeClassNameMap = { large: "lg", small: "sm", middle: void 0 };
  const sizeFullName = useSize_default((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
  const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] || "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const linkButtonRestProps = omit(rest, ["navigate"]);
  const classes = (0, import_classnames16.default)(
    prefixCls,
    hashId,
    cssVarCls,
    {
      [`${prefixCls}-${shape}`]: shape !== "default" && shape,
      [`${prefixCls}-${mergedType}`]: mergedType,
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
      [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(mergedType),
      [`${prefixCls}-loading`]: innerLoading,
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-dangerous`]: !!danger,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    compactItemClassnames,
    className,
    rootClassName,
    button?.className
  );
  const fullStyle = { ...button?.style, ...customStyle };
  const iconClasses = (0, import_classnames16.default)(customClassNames?.icon, button?.classNames?.icon);
  const iconStyle = {
    ...styles?.icon || {},
    ...button?.styles?.icon || {}
  };
  const iconNode = icon && !innerLoading ? /* @__PURE__ */ React63.createElement(IconWrapper_default, { prefixCls, className: iconClasses, style: iconStyle }, icon) : /* @__PURE__ */ React63.createElement(LoadingIcon_default, { existIcon: !!icon, prefixCls, loading: !!innerLoading });
  const kids = children || children === 0 ? spaceChildren(children, needInserted && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return wrapCSSVar(
      /* @__PURE__ */ React63.createElement(
        "a",
        {
          ...linkButtonRestProps,
          className: (0, import_classnames16.default)(classes, {
            [`${prefixCls}-disabled`]: mergedDisabled
          }),
          href: mergedDisabled ? void 0 : linkButtonRestProps.href,
          style: fullStyle,
          onClick: handleClick,
          ref: buttonRef,
          tabIndex: mergedDisabled ? -1 : 0
        },
        iconNode,
        kids
      )
    );
  }
  let buttonNode = /* @__PURE__ */ React63.createElement(
    "button",
    {
      ...rest,
      type: htmlType,
      className: classes,
      style: fullStyle,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: buttonRef
    },
    iconNode,
    kids,
    !!compactItemClassnames && /* @__PURE__ */ React63.createElement(compactCmp_default, { key: "compact", prefixCls })
  );
  if (!isUnBorderedButtonType(mergedType)) {
    buttonNode = /* @__PURE__ */ React63.createElement(wave_default, { component: "Button", disabled: !!innerLoading }, buttonNode);
  }
  return wrapCSSVar(buttonNode);
});
var Button = InternalCompoundedButton;
Button.Group = button_group_default;
Button.__ANT_BUTTON = true;
if (true) {
  Button.displayName = "Button";
}
var button_default = Button;

// packages/ant-design/components/button/index.ts
var button_default2 = button_default;

// packages/ant-design/components/_util/ActionButton.tsx
function isThenable(thing) {
  return !!(thing && thing.then);
}
__name(isThenable, "isThenable");
var ActionButton = /* @__PURE__ */ __name((props) => {
  const {
    type: type5,
    children,
    prefixCls,
    buttonProps,
    close,
    autoFocus,
    emitEvent,
    isSilent,
    quitOnNullishReturnValue,
    actionFn
  } = props;
  const clickedRef = React64.useRef(false);
  const buttonRef = React64.useRef(null);
  const [loading, setLoading] = useSafeState(false);
  const onInternalClose = /* @__PURE__ */ __name((...args) => {
    close?.(...args);
  }, "onInternalClose");
  React64.useEffect(() => {
    let timeoutId = null;
    if (autoFocus) {
      timeoutId = setTimeout(() => {
        buttonRef.current?.focus();
      });
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, []);
  const handlePromiseOnOk = /* @__PURE__ */ __name((returnValueOfOnOk) => {
    if (!isThenable(returnValueOfOnOk)) {
      return;
    }
    setLoading(true);
    returnValueOfOnOk.then(
      (...args) => {
        setLoading(false, true);
        onInternalClose(...args);
        clickedRef.current = false;
      },
      (e3) => {
        setLoading(false, true);
        clickedRef.current = false;
        if (isSilent?.()) {
          return;
        }
        return Promise.reject(e3);
      }
    );
  }, "handlePromiseOnOk");
  const onClick = /* @__PURE__ */ __name((e3) => {
    if (clickedRef.current) {
      return;
    }
    clickedRef.current = true;
    if (!actionFn) {
      onInternalClose();
      return;
    }
    let returnValueOfOnOk;
    if (emitEvent) {
      returnValueOfOnOk = actionFn(e3);
      if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
        clickedRef.current = false;
        onInternalClose(e3);
        return;
      }
    } else if (actionFn.length) {
      returnValueOfOnOk = actionFn(close);
      clickedRef.current = false;
    } else {
      returnValueOfOnOk = actionFn();
      if (!returnValueOfOnOk) {
        onInternalClose();
        return;
      }
    }
    handlePromiseOnOk(returnValueOfOnOk);
  }, "onClick");
  return /* @__PURE__ */ React64.createElement(
    button_default2,
    {
      ...convertLegacyProps(type5),
      onClick,
      loading,
      prefixCls,
      ...buttonProps,
      ref: buttonRef
    },
    children
  );
}, "ActionButton");
var ActionButton_default = ActionButton;

// packages/ant-design/components/modal/context.ts
import React65 from "react";
var ModalContext = React65.createContext({});
var { Provider: ModalContextProvider } = ModalContext;

// packages/ant-design/components/modal/components/ConfirmCancelBtn.tsx
var ConfirmCancelBtn = /* @__PURE__ */ __name(() => {
  const {
    autoFocusButton,
    cancelButtonProps,
    cancelTextLocale,
    isSilent,
    mergedOkCancel,
    rootPrefixCls,
    close,
    onCancel,
    onConfirm
  } = useContext27(ModalContext);
  return mergedOkCancel ? /* @__PURE__ */ React66.createElement(
    ActionButton_default,
    {
      isSilent,
      actionFn: onCancel,
      close: (...args) => {
        close?.(...args);
        onConfirm?.(false);
      },
      autoFocus: autoFocusButton === "cancel",
      buttonProps: cancelButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    },
    cancelTextLocale
  ) : null;
}, "ConfirmCancelBtn");
var ConfirmCancelBtn_default = ConfirmCancelBtn;

// packages/ant-design/components/modal/components/ConfirmOkBtn.tsx
import React67, { useContext as useContext28 } from "react";
var ConfirmOkBtn = /* @__PURE__ */ __name(() => {
  const {
    autoFocusButton,
    close,
    isSilent,
    okButtonProps,
    rootPrefixCls,
    okTextLocale,
    okType,
    onConfirm,
    onOk
  } = useContext28(ModalContext);
  return /* @__PURE__ */ React67.createElement(
    ActionButton_default,
    {
      isSilent,
      type: okType || "primary",
      actionFn: onOk,
      close: (...args) => {
        close?.(...args);
        onConfirm?.(true);
      },
      autoFocus: autoFocusButton === "ok",
      buttonProps: okButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    },
    okTextLocale
  );
}, "ConfirmOkBtn");
var ConfirmOkBtn_default = ConfirmOkBtn;

// packages/ant-design/components/modal/Modal.tsx
var import_CloseOutlined5 = __toESM(require_CloseOutlined3());
var import_classnames21 = __toESM(require_classnames());
import * as React95 from "react";

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
__name(_arrayWithHoles, "_arrayWithHoles");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o3, minLen);
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableRest, "_nonIterableRest");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/Portal.js
init_canUseDom();
init_warning();
import * as React71 from "react";
import { createPortal as createPortal2 } from "react-dom";

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/Context.js
import * as React68 from "react";
var OrderContext = /* @__PURE__ */ React68.createContext(null);
var Context_default = OrderContext;

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
__name(_iterableToArray, "_iterableToArray");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/useDom.js
import * as React69 from "react";
init_canUseDom();
var EMPTY_LIST = [];
function useDom(render2, debug) {
  var _React$useState = React69.useState(function() {
    if (!canUseDom()) {
      return null;
    }
    var defaultEle = document.createElement("div");
    if (debug) {
      defaultEle.setAttribute("data-debug", debug);
    }
    return defaultEle;
  }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
  var appendedRef = React69.useRef(false);
  var queueCreate = React69.useContext(Context_default);
  var _React$useState3 = React69.useState(EMPTY_LIST), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
  var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
    setQueue(function(origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  });
  function append2() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  __name(append2, "append");
  function cleanup2() {
    var _ele$parentElement;
    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
    appendedRef.current = false;
  }
  __name(cleanup2, "cleanup");
  useLayoutEffect_default(function() {
    if (render2) {
      if (queueCreate) {
        queueCreate(append2);
      } else {
        append2();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render2]);
  useLayoutEffect_default(function() {
    if (queue.length) {
      queue.forEach(function(appendFn) {
        return appendFn();
      });
      setQueue(EMPTY_LIST);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}
__name(useDom, "useDom");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/useScrollLocker.js
init_dynamicCSS();
import * as React70 from "react";

// packages/util/src/getScrollBarSize.tsx
init_dynamicCSS();
var cached;
function measureScrollbarSize(ele) {
  const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
  const measureEle = document.createElement("div");
  measureEle.id = randomId;
  const measureStyle = measureEle.style;
  measureStyle.position = "absolute";
  measureStyle.left = "0";
  measureStyle.top = "0";
  measureStyle.width = "100px";
  measureStyle.height = "100px";
  measureStyle.overflow = "scroll";
  let fallbackWidth;
  let fallbackHeight;
  if (ele) {
    const targetStyle = getComputedStyle(ele);
    measureStyle.scrollbarColor = targetStyle.scrollbarColor;
    measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
    const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
    const width = parseInt(webkitScrollbarStyle.width, 10);
    const height = parseInt(webkitScrollbarStyle.height, 10);
    try {
      const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : "";
      const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : "";
      updateCSS(
        `
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`,
        randomId
      );
    } catch (e3) {
      console.error(e3);
      fallbackWidth = width;
      fallbackHeight = height;
    }
  }
  document.body.appendChild(measureEle);
  const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
  const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
  document.body.removeChild(measureEle);
  removeCSS(randomId);
  return {
    width: scrollWidth,
    height: scrollHeight
  };
}
__name(measureScrollbarSize, "measureScrollbarSize");
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    cached = measureScrollbarSize();
  }
  return cached.width;
}
__name(getScrollBarSize, "getScrollBarSize");
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return { width: 0, height: 0 };
  }
  return measureScrollbarSize(target);
}
__name(getTargetScrollBarSize, "getTargetScrollBarSize");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/util.js
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
__name(isBodyOverflowing, "isBodyOverflowing");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
var uuid2 = 0;
function useScrollLocker(lock) {
  var mergedLock = !!lock;
  var _React$useState = React70.useState(function() {
    uuid2 += 1;
    return "".concat(UNIQUE_ID, "_").concat(uuid2);
  }), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
  useLayoutEffect_default(function() {
    if (mergedLock) {
      var scrollbarSize = getTargetScrollBarSize(document.body).width;
      var isOverflow = isBodyOverflowing();
      updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
    } else {
      removeCSS(id);
    }
    return function() {
      removeCSS(id);
    };
  }, [mergedLock, id]);
}
__name(useScrollLocker, "useScrollLocker");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/mock.js
var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === "boolean") {
    inline = nextInline;
  }
  return inline;
}
__name(inlineMock, "inlineMock");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/Portal.js
var getPortalContainer = /* @__PURE__ */ __name(function getPortalContainer2(getContainer2) {
  if (getContainer2 === false) {
    return false;
  }
  if (!canUseDom() || !getContainer2) {
    return null;
  }
  if (typeof getContainer2 === "string") {
    return document.querySelector(getContainer2);
  }
  if (typeof getContainer2 === "function") {
    return getContainer2();
  }
  return getContainer2;
}, "getPortalContainer");
var Portal = /* @__PURE__ */ React71.forwardRef(function(props, ref) {
  var open3 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer, debug = props.debug, _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
  var _React$useState = React71.useState(open3), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
  var mergedRender = shouldRender || open3;
  if (true) {
    warning_default(canUseDom() || !open3, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.");
  }
  React71.useEffect(function() {
    if (autoDestroy || open3) {
      setShouldRender(open3);
    }
  }, [open3, autoDestroy]);
  var _React$useState3 = React71.useState(function() {
    return getPortalContainer(getContainer2);
  }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
  React71.useEffect(function() {
    var customizeContainer = getPortalContainer(getContainer2);
    setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
  });
  var _useDom = useDom(mergedRender && !innerContainer, debug), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1];
  var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer2;
  useScrollLocker(autoLock && open3 && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
  var childRef = null;
  if (children && supportRef(children) && ref) {
    var _ref = children;
    childRef = _ref.ref;
  }
  var mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0) {
    return null;
  }
  var renderInline = mergedContainer === false || inlineMock();
  var reffedChildren = children;
  if (ref) {
    reffedChildren = /* @__PURE__ */ React71.cloneElement(children, {
      ref: mergedRef
    });
  }
  return /* @__PURE__ */ React71.createElement(Context_default.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : /* @__PURE__ */ createPortal2(reffedChildren, mergedContainer));
});
if (true) {
  Portal.displayName = "Portal";
}
var Portal_default = Portal;

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/portal/es/index.js
var es_default = Portal_default;

// packages/dialog/src/DialogWrap.tsx
import * as React79 from "react";

// packages/dialog/src/context.ts
import * as React72 from "react";
var RefContext = React72.createContext({});

// packages/dialog/src/Dialog/index.tsx
var import_classnames20 = __toESM(require_classnames());
init_contains();

// packages/util/src/hooks/useId.ts
import * as React73 from "react";
function getUseId() {
  const fullClone5 = {
    ...React73
  };
  return fullClone5.useId;
}
__name(getUseId, "getUseId");
var uuid3 = 0;
var useOriginId = getUseId();
var useId_default = useOriginId ? (
  // Use React `useId`
  /* @__PURE__ */ __name(function useId2(id) {
    const reactId = useOriginId();
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return reactId;
  }, "useId")
) : (
  // Use compatible of `useId`
  /* @__PURE__ */ __name(function useCompatId(id) {
    const [innerId, setInnerId] = React73.useState("ssr-id");
    React73.useEffect(() => {
      const nextId = uuid3;
      uuid3 += 1;
      setInnerId(`rc_unique_${nextId}`);
    }, []);
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return innerId;
  }, "useCompatId")
);

// packages/dialog/src/Dialog/index.tsx
import * as React78 from "react";
import { useEffect as useEffect22, useRef as useRef27 } from "react";

// packages/dialog/src/util.ts
function getMotionName(prefixCls, transitionName, animationName) {
  let motionName = transitionName;
  if (!motionName && animationName) {
    motionName = `${prefixCls}-${animationName}`;
  }
  return motionName;
}
__name(getMotionName, "getMotionName");
function getScroll2(w, top) {
  let ret = w[`page${top ? "Y" : "X"}Offset`];
  const method4 = `scroll${top ? "Top" : "Left"}`;
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d.body[method4];
    }
  }
  return ret;
}
__name(getScroll2, "getScroll");
function offset(el) {
  const rect = el.getBoundingClientRect();
  const pos = {
    left: rect.left,
    top: rect.top
  };
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll2(w);
  pos.top += getScroll2(w, true);
  return pos;
}
__name(offset, "offset");

// packages/dialog/src/Dialog/Content/index.tsx
var import_classnames18 = __toESM(require_classnames());
import * as React76 from "react";
import { useRef as useRef26 } from "react";

// packages/dialog/src/Dialog/Content/Panel.tsx
var import_classnames17 = __toESM(require_classnames());
import React75, { useMemo as useMemo15, useRef as useRef25 } from "react";

// packages/dialog/src/Dialog/Content/MemoChildren.tsx
import * as React74 from "react";
var MemoChildren_default = React74.memo(
  ({ children }) => children,
  (_, { shouldUpdate }) => !shouldUpdate
);

// packages/dialog/src/Dialog/Content/Panel.tsx
var sentinelStyle = { width: 0, height: 0, overflow: "hidden", outline: "none" };
var entityStyle = { outline: "none" };
var Panel = React75.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style: style2,
    title,
    ariaId,
    footer,
    closable,
    closeIcon,
    onClose,
    children,
    bodyStyle,
    bodyProps,
    modalRender,
    onMouseDown,
    onMouseUp,
    holderRef,
    visible,
    forceRender,
    width,
    height,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  const { panel: panelRef } = React75.useContext(RefContext);
  const mergedRef = useComposeRef(holderRef, panelRef);
  const sentinelStartRef = useRef25();
  const sentinelEndRef = useRef25();
  const entityRef = useRef25();
  React75.useImperativeHandle(ref, () => ({
    focus: () => {
      entityRef.current?.focus();
    },
    changeActive: (next2) => {
      const { activeElement } = document;
      if (next2 && activeElement === sentinelEndRef.current) {
        sentinelStartRef.current.focus();
      } else if (!next2 && activeElement === sentinelStartRef.current) {
        sentinelEndRef.current.focus();
      }
    }
  }));
  const contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  let footerNode;
  if (footer) {
    footerNode = /* @__PURE__ */ React75.createElement("div", { className: (0, import_classnames17.default)(`${prefixCls}-footer`, modalClassNames?.footer), style: { ...modalStyles?.footer } }, footer);
  }
  let headerNode;
  if (title) {
    headerNode = /* @__PURE__ */ React75.createElement("div", { className: (0, import_classnames17.default)(`${prefixCls}-header`, modalClassNames?.header), style: { ...modalStyles?.header } }, /* @__PURE__ */ React75.createElement("div", { className: `${prefixCls}-title`, id: ariaId }, title));
  }
  const closableObj = useMemo15(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return { closeIcon: closeIcon ?? /* @__PURE__ */ React75.createElement("span", { className: `${prefixCls}-close-x` }) };
    }
    return {};
  }, [closable, closeIcon]);
  const ariaProps = pickAttrs(closableObj, true);
  let closer;
  if (closable) {
    closer = /* @__PURE__ */ React75.createElement("button", { type: "button", onClick: onClose, "aria-label": "Close", ...ariaProps, className: `${prefixCls}-close` }, closableObj.closeIcon);
  }
  const content = /* @__PURE__ */ React75.createElement("div", { className: (0, import_classnames17.default)(`${prefixCls}-content`, modalClassNames?.content), style: modalStyles?.content }, closer, headerNode, /* @__PURE__ */ React75.createElement("div", { className: (0, import_classnames17.default)(`${prefixCls}-body`, modalClassNames?.body), style: { ...bodyStyle, ...modalStyles?.body }, ...bodyProps }, children), footerNode);
  return /* @__PURE__ */ React75.createElement(
    "div",
    {
      key: "dialog-element",
      role: "dialog",
      "aria-labelledby": title ? ariaId : null,
      "aria-modal": "true",
      ref: mergedRef,
      style: {
        ...style2,
        ...contentStyle
      },
      className: (0, import_classnames17.default)(prefixCls, className),
      onMouseDown,
      onMouseUp
    },
    /* @__PURE__ */ React75.createElement("div", { tabIndex: 0, ref: sentinelStartRef, style: sentinelStyle, "aria-hidden": "true" }),
    /* @__PURE__ */ React75.createElement("div", { ref: entityRef, tabIndex: -1, style: entityStyle }, /* @__PURE__ */ React75.createElement(MemoChildren_default, { shouldUpdate: visible || forceRender }, modalRender ? modalRender(content) : content)),
    /* @__PURE__ */ React75.createElement("div", { tabIndex: 0, ref: sentinelEndRef, style: sentinelStyle, "aria-hidden": "true" })
  );
});
if (true) {
  Panel.displayName = "Panel";
}
var Panel_default = Panel;

// packages/dialog/src/Dialog/Content/index.tsx
var Content = React76.forwardRef((props, ref) => {
  const {
    prefixCls,
    title,
    style: style2,
    className,
    visible,
    forceRender,
    destroyOnClose,
    motionName,
    ariaId,
    onVisibleChanged,
    mousePosition: mousePosition2
  } = props;
  const dialogRef = useRef26();
  const [transformOrigin, setTransformOrigin] = React76.useState();
  const contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    const elementOffset = offset(dialogRef.current);
    setTransformOrigin(
      mousePosition2 ? `${mousePosition2.x - elementOffset.left}px ${mousePosition2.y - elementOffset.top}px` : ""
    );
  }
  __name(onPrepare, "onPrepare");
  return /* @__PURE__ */ React76.createElement(
    src_default2,
    {
      visible,
      onVisibleChanged,
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      forceRender,
      motionName,
      removeOnLeave: destroyOnClose,
      ref: dialogRef
    },
    ({ className: motionClassName, style: motionStyle }, motionRef) => /* @__PURE__ */ React76.createElement(
      Panel_default,
      {
        ...props,
        ref,
        title,
        ariaId,
        prefixCls,
        holderRef: motionRef,
        style: { ...motionStyle, ...style2, ...contentStyle },
        className: (0, import_classnames18.default)(className, motionClassName)
      }
    )
  );
});
Content.displayName = "Content";
var Content_default = Content;

// packages/dialog/src/Dialog/Mask.tsx
var import_classnames19 = __toESM(require_classnames());
import * as React77 from "react";
function Mask(props) {
  const { prefixCls, style: style2, visible, maskProps, motionName, className } = props;
  return /* @__PURE__ */ React77.createElement(
    src_default2,
    {
      key: "mask",
      visible,
      motionName,
      leavedClassName: `${prefixCls}-mask-hidden`
    },
    ({ className: motionClassName, style: motionStyle }, ref) => /* @__PURE__ */ React77.createElement(
      "div",
      {
        ref,
        style: { ...motionStyle, ...style2 },
        className: (0, import_classnames19.default)(`${prefixCls}-mask`, motionClassName, className),
        ...maskProps
      }
    )
  );
}
__name(Mask, "Mask");

// packages/dialog/src/Dialog/index.tsx
init_warning();
function Dialog(props) {
  const {
    prefixCls = "rc-dialog",
    zIndex,
    visible = false,
    keyboard = true,
    focusTriggerAfterClose = true,
    // scrollLocker,
    // Wrapper
    wrapStyle,
    wrapClassName,
    wrapProps,
    onClose,
    afterOpenChange,
    afterClose,
    // Dialog
    transitionName,
    animation,
    closable = true,
    // Mask
    mask = true,
    maskTransitionName,
    maskAnimation,
    maskClosable = true,
    maskStyle,
    maskProps,
    rootClassName,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  if (true) {
    ["wrapStyle", "bodyStyle", "maskStyle"].forEach((prop) => {
      warning(!(prop in props), `${prop} is deprecated, please use styles instead.`);
    });
    if ("wrapClassName" in props) {
      warning(false, `wrapClassName is deprecated, please use classNames instead.`);
    }
  }
  const lastOutSideActiveElementRef = useRef27();
  const wrapperRef = useRef27();
  const contentRef = useRef27();
  const [animatedVisible, setAnimatedVisible] = React78.useState(visible);
  const ariaId = useId_default();
  function saveLastOutSideActiveElementRef() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  __name(saveLastOutSideActiveElementRef, "saveLastOutSideActiveElementRef");
  function focusDialogContent() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      contentRef.current?.focus();
    }
  }
  __name(focusDialogContent, "focusDialogContent");
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      focusDialogContent();
    } else {
      setAnimatedVisible(false);
      if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({ preventScroll: true });
        } catch (e3) {
        }
        lastOutSideActiveElementRef.current = null;
      }
      if (animatedVisible) {
        afterClose?.();
      }
    }
    afterOpenChange?.(newVisible);
  }
  __name(onDialogVisibleChanged, "onDialogVisibleChanged");
  function onInternalClose(e3) {
    onClose?.(e3);
  }
  __name(onInternalClose, "onInternalClose");
  const contentClickRef = useRef27(false);
  const contentTimeoutRef = useRef27();
  const onContentMouseDown = /* @__PURE__ */ __name(() => {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  }, "onContentMouseDown");
  const onContentMouseUp = /* @__PURE__ */ __name(() => {
    contentTimeoutRef.current = setTimeout(() => {
      contentClickRef.current = false;
    });
  }, "onContentMouseUp");
  let onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = /* @__PURE__ */ __name((e3) => {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e3.target) {
        onInternalClose(e3);
      }
    }, "onWrapperClick");
  }
  function onWrapperKeyDown(e3) {
    if (keyboard && e3.keyCode === KeyCode_default.ESC) {
      e3.stopPropagation();
      onInternalClose(e3);
      return;
    }
    if (visible) {
      if (e3.keyCode === KeyCode_default.TAB) {
        contentRef.current.changeActive(!e3.shiftKey);
      }
    }
  }
  __name(onWrapperKeyDown, "onWrapperKeyDown");
  useEffect22(() => {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    }
  }, [visible]);
  useEffect22(
    () => () => {
      clearTimeout(contentTimeoutRef.current);
    },
    []
  );
  return /* @__PURE__ */ React78.createElement(
    "div",
    {
      className: (0, import_classnames20.default)(`${prefixCls}-root`, rootClassName),
      ...pickAttrs(props, { data: true })
    },
    /* @__PURE__ */ React78.createElement(
      Mask,
      {
        prefixCls,
        visible: mask && visible,
        motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
        style: {
          zIndex,
          ...maskStyle,
          ...modalStyles?.mask
        },
        maskProps,
        className: modalClassNames?.mask
      }
    ),
    /* @__PURE__ */ React78.createElement(
      "div",
      {
        tabIndex: -1,
        onKeyDown: onWrapperKeyDown,
        className: (0, import_classnames20.default)(`${prefixCls}-wrap`, wrapClassName, modalClassNames?.wrapper),
        ref: wrapperRef,
        onClick: onWrapperClick,
        style: { zIndex, ...wrapStyle, ...modalStyles?.wrapper, display: !animatedVisible ? "none" : null },
        ...wrapProps
      },
      /* @__PURE__ */ React78.createElement(
        Content_default,
        {
          ...props,
          onMouseDown: onContentMouseDown,
          onMouseUp: onContentMouseUp,
          ref: contentRef,
          closable,
          ariaId,
          prefixCls,
          visible: visible && animatedVisible,
          onClose: onInternalClose,
          onVisibleChanged: onDialogVisibleChanged,
          motionName: getMotionName(prefixCls, transitionName, animation)
        }
      )
    )
  );
}
__name(Dialog, "Dialog");

// packages/dialog/src/DialogWrap.tsx
var DialogWrap = /* @__PURE__ */ __name((props) => {
  const {
    visible,
    getContainer: getContainer2,
    forceRender,
    destroyOnClose = false,
    afterClose,
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React79.useState(visible);
  const refContext = React79.useMemo(() => ({ panel: panelRef }), [panelRef]);
  React79.useEffect(() => {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (!forceRender && destroyOnClose && !animatedVisible) {
    return null;
  }
  return /* @__PURE__ */ React79.createElement(RefContext.Provider, { value: refContext }, /* @__PURE__ */ React79.createElement(
    es_default,
    {
      open: visible || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer2,
      autoLock: visible || animatedVisible
    },
    /* @__PURE__ */ React79.createElement(
      Dialog,
      {
        ...props,
        destroyOnClose,
        afterClose: () => {
          afterClose?.();
          setAnimatedVisible(false);
        }
      }
    )
  ));
}, "DialogWrap");
DialogWrap.displayName = "Dialog";
var DialogWrap_default = DialogWrap;

// packages/dialog/src/index.ts
var src_default3 = DialogWrap_default;

// packages/ant-design/components/_util/hooks/useClosable.tsx
var import_CloseOutlined3 = __toESM(require_CloseOutlined3());
import React80 from "react";
function pickClosable(context) {
  if (!context) {
    return void 0;
  }
  return {
    closable: context.closable,
    closeIcon: context.closeIcon
  };
}
__name(pickClosable, "pickClosable");
function useClosableConfig(closableCollection) {
  const { closable, closeIcon } = closableCollection || {};
  return React80.useMemo(() => {
    if (
      // If `closable`, whatever rest be should be true
      !closable && (closable === false || closeIcon === false || closeIcon === null)
    ) {
      return false;
    }
    if (closable === void 0 && closeIcon === void 0) {
      return null;
    }
    let closableConfig = {
      closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
    };
    if (closable && typeof closable === "object") {
      closableConfig = {
        ...closableConfig,
        ...closable
      };
    }
    return closableConfig;
  }, [closable, closeIcon]);
}
__name(useClosableConfig, "useClosableConfig");
function assignWithoutUndefined(...objList) {
  const target = {};
  objList.forEach((obj) => {
    if (obj) {
      Object.keys(obj).forEach((key) => {
        if (obj[key] !== void 0) {
          target[key] = obj[key];
        }
      });
    }
  });
  return target;
}
__name(assignWithoutUndefined, "assignWithoutUndefined");
var EmptyFallbackCloseCollection = {};
function useClosable(propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) {
  const propCloseConfig = useClosableConfig(propCloseCollection);
  const contextCloseConfig = useClosableConfig(contextCloseCollection);
  const mergedFallbackCloseCollection = React80.useMemo(
    () => ({
      closeIcon: /* @__PURE__ */ React80.createElement(import_CloseOutlined3.default, null),
      ...fallbackCloseCollection
    }),
    [fallbackCloseCollection]
  );
  const mergedClosableConfig = React80.useMemo(() => {
    if (propCloseConfig === false) {
      return false;
    }
    if (propCloseConfig) {
      return assignWithoutUndefined(
        mergedFallbackCloseCollection,
        contextCloseConfig,
        propCloseConfig
      );
    }
    if (contextCloseConfig === false) {
      return false;
    }
    if (contextCloseConfig) {
      return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig);
    }
    return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;
  }, [propCloseConfig, contextCloseConfig, mergedFallbackCloseCollection]);
  return React80.useMemo(() => {
    if (mergedClosableConfig === false) {
      return [false, null];
    }
    const { closeIconRender } = mergedFallbackCloseCollection;
    const { closeIcon } = mergedClosableConfig;
    let mergedCloseIcon = closeIcon;
    if (mergedCloseIcon !== null && mergedCloseIcon !== void 0) {
      if (closeIconRender) {
        mergedCloseIcon = closeIconRender(closeIcon);
      }
      const ariaProps = pickAttrs(mergedClosableConfig, true);
      if (Object.keys(ariaProps).length) {
        mergedCloseIcon = React80.isValidElement(mergedCloseIcon) ? React80.cloneElement(mergedCloseIcon, ariaProps) : /* @__PURE__ */ React80.createElement("span", { ...ariaProps }, mergedCloseIcon);
      }
    }
    return [true, mergedCloseIcon];
  }, [mergedClosableConfig, mergedFallbackCloseCollection]);
}
__name(useClosable, "useClosable");

// packages/ant-design/components/_util/styleChecker.ts
init_canUseDom();

// packages/util/src/Dom/styleChecker.ts
init_canUseDom();
var isStyleNameSupport = /* @__PURE__ */ __name((styleName) => {
  if (canUseDom() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const { documentElement } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
}, "isStyleNameSupport");
var isStyleValueSupport = /* @__PURE__ */ __name((styleName, value) => {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
}, "isStyleValueSupport");
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
__name(isStyleSupport, "isStyleSupport");

// packages/ant-design/components/_util/styleChecker.ts
var canUseDocElement = /* @__PURE__ */ __name(() => canUseDom() && window.document.documentElement, "canUseDocElement");

// packages/ant-design/components/form/context.tsx
import * as React90 from "react";
import { createContext as createContext19, useContext as useContext35, useMemo as useMemo20 } from "react";

// packages/field-form/src/index.tsx
import * as React89 from "react";

// packages/field-form/src/Field.tsx
init_warning();
import * as React84 from "react";

// packages/field-form/src/FieldContext.ts
init_warning();
import * as React81 from "react";
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = /* @__PURE__ */ __name(() => {
  warning_default(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, "warningFunc");
var Context2 = React81.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: () => {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }
});
var FieldContext_default = Context2;

// packages/field-form/src/ListContext.ts
import * as React82 from "react";
var ListContext = React82.createContext(null);
var ListContext_default = ListContext;

// packages/field-form/src/utils/typeUtil.ts
function toArray2(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
__name(toArray2, "toArray");
function isFormInstance(form) {
  return form && !!form._init;
}
__name(isFormInstance, "isFormInstance");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o3) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof(o3);
}
__name(_typeof, "_typeof");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
__name(toPrimitive, "toPrimitive");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
__name(toPropertyKey, "toPropertyKey");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
__name(_objectSpread2, "_objectSpread2");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
__name(_classCallCheck, "_classCallCheck");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
__name(_createClass, "_createClass");

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/messages.js
function newMessages() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: /* @__PURE__ */ __name(function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }, "clone")
  };
}
__name(newMessages, "newMessages");
var messages = newMessages();

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized, "_assertThisInitialized");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o3, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o4, p2) {
    o4.__proto__ = p2;
    return o4;
  }, "_setPrototypeOf");
  return _setPrototypeOf(o3, p);
}
__name(_setPrototypeOf, "_setPrototypeOf");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
__name(_inherits, "_inherits");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  }, "_getPrototypeOf");
  return _getPrototypeOf(o3);
}
__name(_getPrototypeOf, "_getPrototypeOf");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = /* @__PURE__ */ __name(function _isNativeReflectConstruct2() {
    return !!t2;
  }, "_isNativeReflectConstruct"))();
}
__name(_isNativeReflectConstruct, "_isNativeReflectConstruct");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
__name(_possibleConstructorReturn, "_possibleConstructorReturn");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return /* @__PURE__ */ __name(function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper, "_createSuper");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e3) {
    return typeof fn === "function";
  }
}
__name(_isNativeFunction, "_isNativeFunction");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t2, e3, r2) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o3 = [null];
  o3.push.apply(o3, e3);
  var p = new (t2.bind.apply(t2, o3))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}
__name(_construct, "_construct");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = /* @__PURE__ */ __name(function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper3);
    }
    function Wrapper3() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    __name(Wrapper3, "Wrapper");
    Wrapper3.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper3,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper3, Class2);
  }, "_wrapNativeSuper");
  return _wrapNativeSuper(Class);
}
__name(_wrapNativeSuper, "_wrapNativeSuper");

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/util.js
var formatRegExp = /%[sdj%]/g;
var warning3 = /* @__PURE__ */ __name(function warning4() {
}, "warning");
if (typeof process !== "undefined" && process.env && true && typeof window !== "undefined" && typeof document !== "undefined") {
  warning3 = /* @__PURE__ */ __name(function warning5(type5, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e3) {
        return typeof e3 === "string";
      })) {
        console.warn(type5, errors);
      }
    }
  }, "warning");
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
__name(convertFieldsError, "convertFieldsError");
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
__name(format, "format");
function isNativeStringType(type5) {
  return type5 === "string" || type5 === "url" || type5 === "hex" || type5 === "email" || type5 === "date" || type5 === "pattern";
}
__name(isNativeStringType, "isNativeStringType");
function isEmptyValue(value, type5) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type5 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type5) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
__name(isEmptyValue, "isEmptyValue");
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, _toConsumableArray(errors || []));
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  __name(count, "count");
  arr.forEach(function(a) {
    func(a, count);
  });
}
__name(asyncParallelArray, "asyncParallelArray");
function asyncSerialArray(arr, func, callback) {
  var index3 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index3;
    index3 = index3 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  __name(next2, "next");
  next2([]);
}
__name(asyncSerialArray, "asyncSerialArray");
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
  });
  return ret;
}
__name(flattenObjArr, "flattenObjArr");
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inherits(AsyncValidationError2, _Error);
  var _super = _createSuper(AsyncValidationError2);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _classCallCheck(this, AsyncValidationError2);
    _this = _super.call(this, "Async Validation Error");
    _defineProperty(_assertThisInitialized(_this), "errors", void 0);
    _defineProperty(_assertThisInitialized(_this), "fields", void 0);
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  __name(AsyncValidationError2, "AsyncValidationError");
  return _createClass(AsyncValidationError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = /* @__PURE__ */ __name(function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      }, "next");
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending.catch(function(e3) {
      return e3;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = /* @__PURE__ */ __name(function next3(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    }, "next");
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending.catch(function(e3) {
    return e3;
  });
  return pending;
}
__name(asyncMap, "asyncMap");
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
__name(isErrorObj, "isErrorObj");
function getValue2(value, path2) {
  var v = value;
  for (var i = 0; i < path2.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path2[i]];
  }
  return v;
}
__name(getValue2, "getValue");
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue2(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
__name(complementError, "complementError");
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (_typeof(value) === "object" && _typeof(target[s]) === "object") {
          target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}
__name(deepMerge, "deepMerge");

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/enum.js
var ENUM = "enum";
var enumerable = /* @__PURE__ */ __name(function enumerable2(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(", ")));
  }
}, "enumerable");
var enum_default = enumerable;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/pattern.js
var pattern = /* @__PURE__ */ __name(function pattern2(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}, "pattern");
var pattern_default = pattern;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/range.js
var range = /* @__PURE__ */ __name(function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}, "range");
var range_default = range;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/required.js
var required = /* @__PURE__ */ __name(function required2(rule, value, source, errors, options, type5) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type5 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
}, "required");
var required_default = required;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/url.js
var urlReg;
var url_default = /* @__PURE__ */ __name(function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b = /* @__PURE__ */ __name(function b2(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
  }, "b");
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = "\n(?:\n(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:").concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:").concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:").concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:").concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:").concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:").concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::").concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
  var v4exact = new RegExp("^".concat(v4, "$"));
  var v6exact = new RegExp("^".concat(v6, "$"));
  var ip = /* @__PURE__ */ __name(function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
  }, "ip");
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path2);
  urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
  return urlReg;
}, "default");

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/type.js
var pattern3 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: /* @__PURE__ */ __name(function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  }, "integer"),
  float: /* @__PURE__ */ __name(function float(value) {
    return types.number(value) && !types.integer(value);
  }, "float"),
  array: /* @__PURE__ */ __name(function array(value) {
    return Array.isArray(value);
  }, "array"),
  regexp: /* @__PURE__ */ __name(function regexp2(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e3) {
      return false;
    }
  }, "regexp"),
  date: /* @__PURE__ */ __name(function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  }, "date"),
  number: /* @__PURE__ */ __name(function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  }, "number"),
  object: /* @__PURE__ */ __name(function object(value) {
    return _typeof(value) === "object" && !types.array(value);
  }, "object"),
  method: /* @__PURE__ */ __name(function method(value) {
    return typeof value === "function";
  }, "method"),
  email: /* @__PURE__ */ __name(function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern3.email);
  }, "email"),
  url: /* @__PURE__ */ __name(function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
  }, "url"),
  hex: /* @__PURE__ */ __name(function hex(value) {
    return typeof value === "string" && !!value.match(pattern3.hex);
  }, "hex")
};
var type = /* @__PURE__ */ __name(function type2(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required_default(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && _typeof(value) !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
}, "type");
var type_default = type;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/whitespace.js
var whitespace2 = /* @__PURE__ */ __name(function whitespace3(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
}, "whitespace");
var whitespace_default = whitespace2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/rule/index.js
var rule_default = {
  required: required_default,
  whitespace: whitespace_default,
  type: type_default,
  range: range_default,
  enum: enum_default,
  pattern: pattern_default
};

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/any.js
var any = /* @__PURE__ */ __name(function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
  }
  callback(errors);
}, "any");
var any_default = any;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/array.js
var array2 = /* @__PURE__ */ __name(function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "array");
var array_default = array2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/boolean.js
var boolean = /* @__PURE__ */ __name(function boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "boolean");
var boolean_default = boolean;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/date.js
var date2 = /* @__PURE__ */ __name(function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rule_default.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rule_default.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
}, "date");
var date_default = date2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/enum.js
var ENUM2 = "enum";
var enumerable3 = /* @__PURE__ */ __name(function enumerable4(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default[ENUM2](rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "enumerable");
var enum_default2 = enumerable3;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/float.js
var floatFn = /* @__PURE__ */ __name(function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "floatFn");
var float_default = floatFn;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/integer.js
var integer2 = /* @__PURE__ */ __name(function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "integer");
var integer_default = integer2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/method.js
var method2 = /* @__PURE__ */ __name(function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "method");
var method_default = method2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/number.js
var number2 = /* @__PURE__ */ __name(function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "number");
var number_default = number2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/object.js
var object2 = /* @__PURE__ */ __name(function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "object");
var object_default = object2;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/pattern.js
var pattern4 = /* @__PURE__ */ __name(function pattern5(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rule_default.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "pattern");
var pattern_default2 = pattern4;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/regexp.js
var regexp3 = /* @__PURE__ */ __name(function regexp4(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "regexp");
var regexp_default = regexp3;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/required.js
var required3 = /* @__PURE__ */ __name(function required4(rule, value, callback, source, options) {
  var errors = [];
  var type5 = Array.isArray(value) ? "array" : _typeof(value);
  rule_default.required(rule, value, source, errors, options, type5);
  callback(errors);
}, "required");
var required_default2 = required3;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/string.js
var string = /* @__PURE__ */ __name(function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
      rule_default.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rule_default.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
}, "string");
var string_default = string;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/type.js
var type3 = /* @__PURE__ */ __name(function type4(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
}, "type");
var type_default2 = type3;

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/validator/index.js
var validator_default = {
  string: string_default,
  method: method_default,
  number: number_default,
  boolean: boolean_default,
  regexp: regexp_default,
  integer: integer_default,
  float: float_default,
  array: array_default,
  object: object_default,
  enum: enum_default2,
  pattern: pattern_default2,
  date: date_default,
  url: type_default2,
  hex: type_default2,
  email: type_default2,
  required: required_default2,
  any: any_default
};

// node_modules/.pnpm/@rc-component+async-validator@5.0.1/node_modules/@rc-component/async-validator/es/index.js
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    _classCallCheck(this, Schema2);
    _defineProperty(this, "rules", null);
    _defineProperty(this, "_messages", messages);
    this.define(descriptor);
  }
  __name(Schema2, "Schema");
  _createClass(Schema2, [{
    key: "define",
    value: /* @__PURE__ */ __name(function define2(rules) {
      var _this = this;
      if (!rules) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (_typeof(rules) !== "object" || Array.isArray(rules)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules).forEach(function(name) {
        var item = rules[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    }, "define")
  }, {
    key: "messages",
    value: /* @__PURE__ */ __name(function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    }, "messages")
  }, {
    key: "validate",
    value: /* @__PURE__ */ __name(function validate(source_) {
      var _this2 = this;
      var o3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      };
      var source = source_;
      var options = o3;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e3) {
          if (Array.isArray(e3)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e3));
          } else {
            errors.push(e3);
          }
        }
        __name(add, "add");
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      __name(complete, "complete");
      if (options.messages) {
        var messages2 = this.messages();
        if (messages2 === messages) {
          messages2 = newMessages();
        }
        deepMerge(messages2, options.messages);
        options.messages = messages2;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            var _rule, _rule$type;
            if (source === source_) {
              source = _objectSpread2({}, source);
            }
            value = source[z] = rule.transform(value);
            (_rule$type = (_rule = rule).type) !== null && _rule$type !== void 0 ? _rule$type : _rule.type = Array.isArray(value) ? "array" : _typeof(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _objectSpread2({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _objectSpread2(_objectSpread2({}, schema), {}, {
            fullField: "".concat(rule.fullField, ".").concat(key),
            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
          });
        }
        __name(addFullField, "addFullField");
        function cb() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var errorList = Array.isArray(e3) ? e3 : [e3];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        __name(cb, "cb");
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            var _console$error, _console;
            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e3) {
            return cb(e3);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    }, "validate")
  }, {
    key: "getType",
    value: /* @__PURE__ */ __name(function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    }, "getType")
  }, {
    key: "getValidationMethod",
    value: /* @__PURE__ */ __name(function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validator_default.required;
      }
      return validator_default[this.getType(rule)] || void 0;
    }, "getValidationMethod")
  }]);
  return Schema2;
}();
_defineProperty(Schema, "register", /* @__PURE__ */ __name(function register(type5, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validator_default[type5] = validator;
}, "register"));
_defineProperty(Schema, "warning", warning3);
_defineProperty(Schema, "messages", messages);
_defineProperty(Schema, "validators", validator_default);
var es_default2 = Schema;

// packages/field-form/src/utils/validateUtil.ts
init_warning();
import * as React83 from "react";

// packages/field-form/src/utils/messages.ts
var typeTemplate2 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate2,
    method: typeTemplate2,
    array: typeTemplate2,
    object: typeTemplate2,
    number: typeTemplate2,
    date: typeTemplate2,
    boolean: typeTemplate2,
    integer: typeTemplate2,
    float: typeTemplate2,
    regexp: typeTemplate2,
    email: typeTemplate2,
    url: typeTemplate2,
    hex: typeTemplate2
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};

// packages/field-form/src/utils/validateUtil.ts
var AsyncValidator = es_default2;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, (str) => {
    const key = str.slice(2, -1);
    return kv[key];
  });
}
__name(replaceMessage, "replaceMessage");
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
async function validateRule(name, value, rule, options, messageVariables) {
  const cloneRule = { ...rule };
  delete cloneRule.ruleIndex;
  AsyncValidator.warning = () => void 0;
  if (cloneRule.validator) {
    const originValidator = cloneRule.validator;
    cloneRule.validator = (...args) => {
      try {
        return originValidator(...args);
      } catch (error) {
        console.error(error);
        return Promise.reject(CODE_LOGIC_ERROR);
      }
    };
  }
  let subRuleField = null;
  if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
    subRuleField = cloneRule.defaultField;
    delete cloneRule.defaultField;
  }
  const validator = new AsyncValidator({
    [name]: [cloneRule]
  });
  const messages2 = merge(defaultValidateMessages, options.validateMessages);
  validator.messages(messages2);
  let result = [];
  try {
    await Promise.resolve(validator.validate({ [name]: value }, { ...options }));
  } catch (errObj) {
    if (errObj.errors) {
      result = errObj.errors.map(({ message: message2 }, index3) => {
        const mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
        return React83.isValidElement(mergedMessage) ? (
          // Wrap ReactNode with `key`
          React83.cloneElement(mergedMessage, { key: `error_${index3}` })
        ) : mergedMessage;
      });
    }
  }
  if (!result.length && subRuleField) {
    const subResults = await Promise.all(
      value.map(
        (subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)
      )
    );
    return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
  }
  const kv = {
    ...rule,
    name,
    enum: (rule.enum || []).join(", "),
    ...messageVariables
  };
  const fillVariableResult = result.map((error) => {
    if (typeof error === "string") {
      return replaceMessage(error, kv);
    }
    return error;
  });
  return fillVariableResult;
}
__name(validateRule, "validateRule");
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
  const name = namePath.join(".");
  const filledRules = rules.map((currentRule, ruleIndex) => {
    const originValidatorFunc = currentRule.validator;
    const cloneRule = {
      ...currentRule,
      ruleIndex
    };
    if (originValidatorFunc) {
      cloneRule.validator = (rule, val, callback) => {
        let hasPromise = false;
        const wrappedCallback = /* @__PURE__ */ __name((...args) => {
          Promise.resolve().then(() => {
            warning_default(
              !hasPromise,
              "Your validator function has already return a promise. `callback` will be ignored."
            );
            if (!hasPromise) {
              callback(...args);
            }
          });
        }, "wrappedCallback");
        const promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warning_default(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(() => {
            callback();
          }).catch((err) => {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(({ warningOnly: w1, ruleIndex: i1 }, { warningOnly: w2, ruleIndex: i2 }) => {
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  let summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(async (resolve, reject) => {
      for (let i = 0; i < filledRules.length; i += 1) {
        const rule = filledRules[i];
        const errors = await validateRule(name, value, rule, options, messageVariables);
        if (errors.length) {
          reject([{ errors, rule }]);
          return;
        }
      }
      resolve([]);
    });
  } else {
    const rulePromises = filledRules.map(
      (rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({ errors, rule }))
    );
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch((e3) => e3);
  return summaryPromise;
}
__name(validateRules, "validateRules");
async function finishOnAllFailed(rulePromises) {
  return Promise.all(rulePromises).then(
    (errorsList) => {
      const errors = [].concat(...errorsList);
      return errors;
    }
  );
}
__name(finishOnAllFailed, "finishOnAllFailed");
async function finishOnFirstFailed(rulePromises) {
  let count = 0;
  return new Promise((resolve) => {
    rulePromises.forEach((promise) => {
      promise.then((ruleError) => {
        if (ruleError.errors.length) {
          resolve([ruleError]);
        }
        count += 1;
        if (count === rulePromises.length) {
          resolve([]);
        }
      });
    });
  });
}
__name(finishOnFirstFailed, "finishOnFirstFailed");

// packages/field-form/src/utils/valueUtil.ts
function getNamePath(path2) {
  return toArray2(path2);
}
__name(getNamePath, "getNamePath");
function cloneByNamePathList(store, namePathList) {
  let newStore = {};
  namePathList.forEach((namePath) => {
    const value = get(store, namePath);
    newStore = set(newStore, namePath, value);
  });
  return newStore;
}
__name(cloneByNamePathList, "cloneByNamePathList");
function containsNamePath(namePathList, namePath, partialMatch = false) {
  return namePathList && namePathList.some((path2) => matchNamePath(namePath, path2, partialMatch));
}
__name(containsNamePath, "containsNamePath");
function matchNamePath(namePath, subNamePath, partialMatch = false) {
  if (!namePath || !subNamePath) {
    return false;
  }
  if (!partialMatch && namePath.length !== subNamePath.length) {
    return false;
  }
  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);
}
__name(matchNamePath, "matchNamePath");
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || typeof source !== "object" || typeof target !== "object") {
    return false;
  }
  const sourceKeys = Object.keys(source);
  const targetKeys = Object.keys(target);
  const keys2 = /* @__PURE__ */ new Set([...sourceKeys, ...targetKeys]);
  return [...keys2].every((key) => {
    const sourceValue = source[key];
    const targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
__name(isSimilar, "isSimilar");
function defaultGetValueFromEvent(valuePropName, ...args) {
  const event = args[0];
  if (event && event.target && typeof event.target === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
__name(defaultGetValueFromEvent, "defaultGetValueFromEvent");
function move(array4, moveIndex, toIndex) {
  const { length: length2 } = array4;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  const item = array4[moveIndex];
  const diff = moveIndex - toIndex;
  if (diff > 0) {
    return [
      ...array4.slice(0, toIndex),
      item,
      ...array4.slice(toIndex, moveIndex),
      ...array4.slice(moveIndex + 1, length2)
    ];
  }
  if (diff < 0) {
    return [
      ...array4.slice(0, moveIndex),
      ...array4.slice(moveIndex + 1, toIndex + 1),
      item,
      ...array4.slice(toIndex + 1, length2)
    ];
  }
  return array4;
}
__name(move, "move");

// packages/field-form/src/Field.tsx
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev2, next2, "source" in info ? { source: info.source } : {});
  }
  return prevValue !== nextValue;
}
__name(requireUpdate, "requireUpdate");
var Field = class extends React84.Component {
  static {
    __name(this, "Field");
  }
  static contextType = FieldContext_default;
  static defaultProps = {
    trigger: "onChange",
    valuePropName: "value"
  };
  state = {
    resetCount: 0
  };
  cancelRegisterFunc = null;
  mounted = false;
  /**
   * Follow state should not management in State since it will async update by React.
   * This makes first render of form can not get correct state value.
   */
  touched = false;
  /**
   * Mark when touched & validated. Currently only used for `dependencies`.
   * Note that we do not think field with `initialValue` is dirty
   * but this will be by `isFieldDirty` func.
   */
  dirty = false;
  validatePromise;
  prevValidating;
  errors = EMPTY_ERRORS;
  warnings = EMPTY_ERRORS;
  // ============================== Subscriptions ==============================
  constructor(props) {
    super(props);
    if (props.fieldContext) {
      const { getInternalHooks } = props.fieldContext;
      const { initEntityValue } = getInternalHooks(HOOK_MARK);
      initEntityValue(this);
    }
  }
  componentDidMount() {
    const { shouldUpdate, fieldContext } = this.props;
    this.mounted = true;
    if (fieldContext) {
      const { getInternalHooks } = fieldContext;
      const { registerField } = getInternalHooks(HOOK_MARK);
      this.cancelRegisterFunc = registerField(this);
    }
    if (shouldUpdate === true) {
      this.reRender();
    }
  }
  componentWillUnmount() {
    this.cancelRegister();
    this.triggerMetaEvent(true);
    this.mounted = false;
  }
  cancelRegister = () => {
    const { preserve: preserve2, isListField, name } = this.props;
    if (this.cancelRegisterFunc) {
      this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
    }
    this.cancelRegisterFunc = null;
  };
  // ================================== Utils ==================================
  getNamePath = () => {
    const { name, fieldContext } = this.props;
    const { prefixName = [] } = fieldContext;
    return name !== void 0 ? [...prefixName, ...name] : [];
  };
  getRules = () => {
    const { rules = [], fieldContext } = this.props;
    return rules.map((rule) => {
      if (typeof rule === "function") {
        return rule(fieldContext);
      }
      return rule;
    });
  };
  reRender() {
    if (!this.mounted)
      return;
    this.forceUpdate();
  }
  refresh = () => {
    if (!this.mounted)
      return;
    this.setState(({ resetCount }) => ({
      resetCount: resetCount + 1
    }));
  };
  // Event should only trigger when meta changed
  metaCache = null;
  triggerMetaEvent = (destroy3) => {
    const { onMetaChange } = this.props;
    if (onMetaChange) {
      const meta = { ...this.getMeta(), destroy: destroy3 };
      if (!isEqual_default(this.metaCache, meta)) {
        onMetaChange(meta);
      }
      this.metaCache = meta;
    } else {
      this.metaCache = null;
    }
  };
  // ========================= Field Entity Interfaces =========================
  // Trigger by store update. Check if need update the component
  onStoreChange = (prevStore, namePathList, info) => {
    const { shouldUpdate, dependencies = [], onReset } = this.props;
    const { store } = info;
    const namePath = this.getNamePath();
    const prevValue = this.getValue(prevStore);
    const curValue = this.getValue(store);
    const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
    if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
      this.touched = true;
      this.dirty = true;
      this.validatePromise = null;
      this.errors = EMPTY_ERRORS;
      this.warnings = EMPTY_ERRORS;
      this.triggerMetaEvent();
    }
    switch (info.type) {
      case "reset":
        if (!namePathList || namePathMatch) {
          this.touched = false;
          this.dirty = false;
          this.validatePromise = void 0;
          this.errors = EMPTY_ERRORS;
          this.warnings = EMPTY_ERRORS;
          this.triggerMetaEvent();
          onReset?.();
          this.refresh();
          return;
        }
        break;
      case "remove": {
        if (shouldUpdate) {
          this.reRender();
          return;
        }
        break;
      }
      case "setField": {
        const { data } = info;
        if (namePathMatch) {
          if ("touched" in data) {
            this.touched = data.touched;
          }
          if ("validating" in data && !("originRCField" in data)) {
            this.validatePromise = data.validating ? Promise.resolve([]) : null;
          }
          if ("errors" in data) {
            this.errors = data.errors || EMPTY_ERRORS;
          }
          if ("warnings" in data) {
            this.warnings = data.warnings || EMPTY_ERRORS;
          }
          this.dirty = true;
          this.triggerMetaEvent();
          this.reRender();
          return;
        } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
          this.reRender();
          return;
        }
        if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
          this.reRender();
          return;
        }
        break;
      }
      case "dependenciesUpdate": {
        const dependencyList = dependencies.map(getNamePath);
        if (dependencyList.some((dependency) => containsNamePath(info.relatedFields, dependency))) {
          this.reRender();
          return;
        }
        break;
      }
      default:
        if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
          this.reRender();
          return;
        }
        break;
    }
    if (shouldUpdate === true) {
      this.reRender();
    }
  };
  validateRules = (options) => {
    const namePath = this.getNamePath();
    const currentValue = this.getValue();
    const { triggerName, validateOnly = false } = options || {};
    const rootPromise = Promise.resolve().then(async () => {
      if (!this.mounted) {
        return [];
      }
      const { validateFirst = false, messageVariables, validateDebounce } = this.props;
      let filteredRules = this.getRules();
      if (triggerName) {
        filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
          const { validateTrigger } = rule;
          if (!validateTrigger) {
            return true;
          }
          const triggerList = toArray2(validateTrigger);
          return triggerList.includes(triggerName);
        });
      }
      if (validateDebounce && triggerName) {
        await new Promise((resolve) => {
          setTimeout(resolve, validateDebounce);
        });
        if (this.validatePromise !== rootPromise) {
          return [];
        }
      }
      const promise = validateRules(
        namePath,
        currentValue,
        filteredRules,
        options,
        validateFirst,
        messageVariables
      );
      promise.catch((e3) => e3).then((ruleErrors = EMPTY_ERRORS) => {
        if (this.validatePromise === rootPromise) {
          this.validatePromise = null;
          const nextErrors = [];
          const nextWarnings = [];
          ruleErrors.forEach?.(({ rule: { warningOnly }, errors = EMPTY_ERRORS }) => {
            if (warningOnly) {
              nextWarnings.push(...errors);
            } else {
              nextErrors.push(...errors);
            }
          });
          this.errors = nextErrors;
          this.warnings = nextWarnings;
          this.triggerMetaEvent();
          this.reRender();
        }
      });
      return promise;
    });
    if (validateOnly) {
      return rootPromise;
    }
    this.validatePromise = rootPromise;
    this.dirty = true;
    this.errors = EMPTY_ERRORS;
    this.warnings = EMPTY_ERRORS;
    this.triggerMetaEvent();
    this.reRender();
    return rootPromise;
  };
  isFieldValidating = () => !!this.validatePromise;
  isFieldTouched = () => this.touched;
  isFieldDirty = () => {
    if (this.dirty || this.props.initialValue !== void 0) {
      return true;
    }
    const { fieldContext } = this.props;
    const { getInitialValue } = fieldContext.getInternalHooks(HOOK_MARK);
    if (getInitialValue(this.getNamePath()) !== void 0) {
      return true;
    }
    return false;
  };
  getErrors = () => this.errors;
  getWarnings = () => this.warnings;
  isListField = () => this.props.isListField;
  isList = () => this.props.isList;
  isPreserve = () => this.props.preserve;
  // ============================= Child Component =============================
  getMeta = () => {
    this.prevValidating = this.isFieldValidating();
    const meta = {
      touched: this.isFieldTouched(),
      validating: this.prevValidating,
      errors: this.errors,
      warnings: this.warnings,
      name: this.getNamePath(),
      validated: this.validatePromise === null
    };
    return meta;
  };
  // Only return validate child node. If invalidate, will do nothing about field.
  getOnlyChild = (children) => {
    if (typeof children === "function") {
      const meta = this.getMeta();
      return {
        ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
        isFunction: true
      };
    }
    const childList = toArray(children);
    if (childList.length !== 1 || !React84.isValidElement(childList[0])) {
      return { child: childList, isFunction: false };
    }
    return { child: childList[0], isFunction: false };
  };
  // ============================== Field Control ==============================
  getValue = (store) => {
    const { getFieldsValue } = this.props.fieldContext;
    const namePath = this.getNamePath();
    return get(store || getFieldsValue(true), namePath);
  };
  getControlled = (childProps = {}) => {
    const {
      name,
      trigger,
      validateTrigger,
      getValueFromEvent,
      normalize: normalize2,
      valuePropName,
      getValueProps,
      fieldContext
    } = this.props;
    const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
    const namePath = this.getNamePath();
    const { getInternalHooks, getFieldsValue } = fieldContext;
    const { dispatch } = getInternalHooks(HOOK_MARK);
    const value = this.getValue();
    const mergedGetValueProps = getValueProps || ((val) => ({ [valuePropName]: val }));
    const originTriggerFunc = childProps[trigger];
    const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
    if (valueProps) {
      Object.keys(valueProps).forEach((key) => {
        warning_default(
          typeof valueProps[key] !== "function",
          `It's not recommended to generate dynamic function prop by \`getValueProps\`. Please pass it to child component directly (prop: ${key})`
        );
      });
    }
    const control = {
      ...childProps,
      ...valueProps
    };
    control[trigger] = (...args) => {
      this.touched = true;
      this.dirty = true;
      this.triggerMetaEvent();
      let newValue;
      if (getValueFromEvent) {
        newValue = getValueFromEvent(...args);
      } else {
        newValue = defaultGetValueFromEvent(valuePropName, ...args);
      }
      if (normalize2) {
        newValue = normalize2(newValue, value, getFieldsValue(true));
      }
      dispatch({
        type: "updateValue",
        namePath,
        value: newValue
      });
      if (originTriggerFunc) {
        originTriggerFunc(...args);
      }
    };
    const validateTriggerList = toArray2(mergedValidateTrigger || []);
    validateTriggerList.forEach((triggerName) => {
      const originTrigger = control[triggerName];
      control[triggerName] = (...args) => {
        if (originTrigger) {
          originTrigger(...args);
        }
        const { rules } = this.props;
        if (rules && rules.length) {
          dispatch({
            type: "validateField",
            namePath,
            triggerName
          });
        }
      };
    });
    return control;
  };
  render() {
    const { resetCount } = this.state;
    const { children } = this.props;
    const { child, isFunction } = this.getOnlyChild(children);
    let returnChildNode;
    if (isFunction) {
      returnChildNode = child;
    } else if (React84.isValidElement(child)) {
      returnChildNode = React84.cloneElement(
        child,
        this.getControlled(child.props)
      );
    } else {
      warning_default(!child, "`children` of Field is not validate ReactElement.");
      returnChildNode = child;
    }
    return /* @__PURE__ */ React84.createElement(React84.Fragment, { key: resetCount }, returnChildNode);
  }
};
function WrapperField({ name, ...restProps }) {
  const fieldContext = React84.useContext(FieldContext_default);
  const listContext = React84.useContext(ListContext_default);
  const namePath = name !== void 0 ? getNamePath(name) : void 0;
  let key = "keep";
  if (!restProps.isListField) {
    key = `_${(namePath || []).join("_")}`;
  }
  if (restProps.preserve === false && restProps.isListField && namePath.length <= 1) {
    warning_default(false, "`preserve` should not apply on Form.List fields.");
  }
  return /* @__PURE__ */ React84.createElement(
    Field,
    {
      key,
      name: namePath,
      isListField: !!listContext,
      ...restProps,
      fieldContext
    }
  );
}
__name(WrapperField, "WrapperField");
var Field_default = WrapperField;

// packages/field-form/src/List.tsx
init_warning();
import * as React85 from "react";
function List({
  name,
  initialValue,
  children,
  rules,
  validateTrigger,
  isListField
}) {
  const context = React85.useContext(FieldContext_default);
  const wrapperListContext = React85.useContext(ListContext_default);
  const keyRef = React85.useRef({
    keys: [],
    id: 0
  });
  const keyManager = keyRef.current;
  const prefixName = React85.useMemo(() => {
    const parentPrefixName = getNamePath(context.prefixName) || [];
    return [...parentPrefixName, ...getNamePath(name)];
  }, [context.prefixName, name]);
  const fieldContext = React85.useMemo(() => ({ ...context, prefixName }), [context, prefixName]);
  const listContext = React85.useMemo(
    () => ({
      getKey: (namePath) => {
        const len = prefixName.length;
        const pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    }),
    [prefixName]
  );
  if (typeof children !== "function") {
    warning_default(false, "Form.List only accepts function as children.");
    return null;
  }
  const shouldUpdate = /* @__PURE__ */ __name((prevValue, nextValue, { source }) => {
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  }, "shouldUpdate");
  return /* @__PURE__ */ React85.createElement(ListContext_default.Provider, { value: listContext }, /* @__PURE__ */ React85.createElement(FieldContext_default.Provider, { value: fieldContext }, /* @__PURE__ */ React85.createElement(
    Field_default,
    {
      name: [],
      shouldUpdate,
      rules,
      validateTrigger,
      initialValue,
      isList: true,
      isListField: isListField ?? !!wrapperListContext
    },
    ({ value = [], onChange }, meta) => {
      const { getFieldValue } = context;
      const getNewValue = /* @__PURE__ */ __name(() => {
        const values = getFieldValue(prefixName || []);
        return values || [];
      }, "getNewValue");
      const operations = {
        add: (defaultValue, index3) => {
          const newValue = getNewValue();
          if (index3 >= 0 && index3 <= newValue.length) {
            keyManager.keys = [
              ...keyManager.keys.slice(0, index3),
              keyManager.id,
              ...keyManager.keys.slice(index3)
            ];
            onChange([...newValue.slice(0, index3), defaultValue, ...newValue.slice(index3)]);
          } else {
            if (index3 < 0 || index3 > newValue.length) {
              warning_default(
                false,
                "The second parameter of the add function should be a valid positive number."
              );
            }
            keyManager.keys = [...keyManager.keys, keyManager.id];
            onChange([...newValue, defaultValue]);
          }
          keyManager.id += 1;
        },
        remove: (index3) => {
          const newValue = getNewValue();
          const indexSet = new Set(Array.isArray(index3) ? index3 : [index3]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter(
            (_, keysIndex) => !indexSet.has(keysIndex)
          );
          onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));
        },
        move(from2, to) {
          if (from2 === to) {
            return;
          }
          const newValue = getNewValue();
          if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }
          keyManager.keys = move(keyManager.keys, from2, to);
          onChange(move(newValue, from2, to));
        }
      };
      let listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
        if (true) {
          warning_default(
            false,
            `Current value of '${prefixName.join(" > ")}' is not an array type.`
          );
        }
      }
      return children(
        listValue.map((__, index3) => {
          let key = keyManager.keys[index3];
          if (key === void 0) {
            keyManager.keys[index3] = keyManager.id;
            key = keyManager.keys[index3];
            keyManager.id += 1;
          }
          return {
            name: index3,
            key,
            isListField: true
          };
        }),
        operations,
        meta
      );
    }
  )));
}
__name(List, "List");
var List_default = List;

// packages/field-form/src/useForm.ts
init_warning();
import * as React86 from "react";

// packages/field-form/src/utils/asyncUtil.ts
function allPromiseFinish(promiseList) {
  let hasError = false;
  let count = promiseList.length;
  const results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise((resolve, reject) => {
    promiseList.forEach((promise, index3) => {
      promise.catch((e3) => {
        hasError = true;
        return e3;
      }).then((result) => {
        count -= 1;
        results[index3] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
__name(allPromiseFinish, "allPromiseFinish");

// packages/field-form/src/utils/NameMap.ts
var SPLIT2 = "__@field_split__";
function normalize(namePath) {
  return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT2);
}
__name(normalize, "normalize");
var NameMap = class {
  static {
    __name(this, "NameMap");
  }
  kvs = /* @__PURE__ */ new Map();
  set(key, value) {
    this.kvs.set(normalize(key), value);
  }
  get(key) {
    return this.kvs.get(normalize(key));
  }
  update(key, updater) {
    const origin = this.get(key);
    const next2 = updater(origin);
    if (!next2) {
      this.delete(key);
    } else {
      this.set(key, next2);
    }
  }
  delete(key) {
    this.kvs.delete(normalize(key));
  }
  // Since we only use this in test, let simply realize this
  map(callback) {
    return [...this.kvs.entries()].map(([key, value]) => {
      const cells = key.split(SPLIT2);
      return callback({
        key: cells.map((cell) => {
          const [, type5, unit3] = cell.match(/^([^:]*):(.*)$/);
          return type5 === "number" ? Number(unit3) : unit3;
        }),
        value
      });
    });
  }
  toJSON() {
    const json = {};
    this.map(({ key, value }) => {
      json[key.join(".")] = value;
      return null;
    });
    return json;
  }
};
var NameMap_default = NameMap;

// packages/field-form/src/useForm.ts
var FormStore = class {
  static {
    __name(this, "FormStore");
  }
  formHooked = false;
  forceRootUpdate;
  subscribable = true;
  store = {};
  fieldEntities = [];
  initialValues = {};
  callbacks = {};
  validateMessages = null;
  preserve = null;
  lastValidatePromise = null;
  constructor(forceRootUpdate) {
    this.forceRootUpdate = forceRootUpdate;
  }
  getForm = () => ({
    getFieldValue: this.getFieldValue,
    getFieldsValue: this.getFieldsValue,
    getFieldError: this.getFieldError,
    getFieldWarning: this.getFieldWarning,
    getFieldsError: this.getFieldsError,
    isFieldsTouched: this.isFieldsTouched,
    isFieldTouched: this.isFieldTouched,
    isFieldValidating: this.isFieldValidating,
    isFieldsValidating: this.isFieldsValidating,
    resetFields: this.resetFields,
    setFields: this.setFields,
    setFieldValue: this.setFieldValue,
    setFieldsValue: this.setFieldsValue,
    validateFields: this.validateFields,
    submit: this.submit,
    _init: true,
    getInternalHooks: this.getInternalHooks
  });
  // ======================== Internal Hooks ========================
  getInternalHooks = (key) => {
    if (key === HOOK_MARK) {
      this.formHooked = true;
      return {
        dispatch: this.dispatch,
        initEntityValue: this.initEntityValue,
        registerField: this.registerField,
        useSubscribe: this.useSubscribe,
        setInitialValues: this.setInitialValues,
        destroyForm: this.destroyForm,
        setCallbacks: this.setCallbacks,
        setValidateMessages: this.setValidateMessages,
        getFields: this.getFields,
        setPreserve: this.setPreserve,
        getInitialValue: this.getInitialValue,
        registerWatch: this.registerWatch
      };
    }
    warning_default(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  useSubscribe = (subscribable) => {
    this.subscribable = subscribable;
  };
  /**
   * Record prev Form unmount fieldEntities which config preserve false.
   * This need to be refill with initialValues instead of store value.
   */
  prevWithoutPreserves = null;
  /**
   * First time `setInitialValues` should update store with initial value
   */
  setInitialValues = (initialValues, init) => {
    this.initialValues = initialValues || {};
    if (init) {
      let nextStore = merge(initialValues, this.store);
      this.prevWithoutPreserves?.map(({ key: namePath }) => {
        nextStore = set(nextStore, namePath, get(initialValues, namePath));
      });
      this.prevWithoutPreserves = null;
      this.updateStore(nextStore);
    }
  };
  destroyForm = () => {
    const prevWithoutPreserves = new NameMap_default();
    this.getFieldEntities(true).forEach((entity) => {
      if (!this.isMergedPreserve(entity.isPreserve())) {
        prevWithoutPreserves.set(entity.getNamePath(), true);
      }
    });
    this.prevWithoutPreserves = prevWithoutPreserves;
  };
  getInitialValue = (namePath) => {
    const initValue = get(this.initialValues, namePath);
    return namePath.length ? merge(initValue) : initValue;
  };
  setCallbacks = (callbacks) => {
    this.callbacks = callbacks;
  };
  setValidateMessages = (validateMessages) => {
    this.validateMessages = validateMessages;
  };
  setPreserve = (preserve2) => {
    this.preserve = preserve2;
  };
  // ============================= Watch ============================
  watchList = [];
  registerWatch = (callback) => {
    this.watchList.push(callback);
    return () => {
      this.watchList = this.watchList.filter((fn) => fn !== callback);
    };
  };
  notifyWatch = (namePath = []) => {
    if (this.watchList.length) {
      const values = this.getFieldsValue();
      const allValues = this.getFieldsValue(true);
      this.watchList.forEach((callback) => {
        callback(values, allValues, namePath);
      });
    }
  };
  // ========================== Dev Warning =========================
  timeoutId = null;
  warningUnhooked = () => {
    if (!this.timeoutId && typeof window !== "undefined") {
      this.timeoutId = setTimeout(() => {
        this.timeoutId = null;
        if (!this.formHooked) {
          warning_default(
            false,
            "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?"
          );
        }
      });
    }
  };
  // ============================ Store =============================
  updateStore = (nextStore) => {
    this.store = nextStore;
  };
  // ============================ Fields ============================
  /**
   * Get registered field entities.
   * @param pure Only return field which has a `name`. Default: false
   */
  getFieldEntities = (pure = false) => {
    if (!pure) {
      return this.fieldEntities;
    }
    return this.fieldEntities.filter((field) => field.getNamePath().length);
  };
  getFieldsMap = (pure = false) => {
    const cache = new NameMap_default();
    this.getFieldEntities(pure).forEach((field) => {
      const namePath = field.getNamePath();
      cache.set(namePath, field);
    });
    return cache;
  };
  getFieldEntitiesForNamePathList = (nameList) => {
    if (!nameList) {
      return this.getFieldEntities(true);
    }
    const cache = this.getFieldsMap(true);
    return nameList.map((name) => {
      const namePath = getNamePath(name);
      return cache.get(namePath) || { INVALIDATE_NAME_PATH: getNamePath(name) };
    });
  };
  getFieldsValue = (nameList, filterFunc) => {
    this.warningUnhooked();
    let mergedNameList;
    let mergedFilterFunc;
    let mergedStrict;
    if (nameList === true || Array.isArray(nameList)) {
      mergedNameList = nameList;
      mergedFilterFunc = filterFunc;
    } else if (nameList && typeof nameList === "object") {
      mergedStrict = nameList.strict;
      mergedFilterFunc = nameList.filter;
    }
    if (mergedNameList === true && !mergedFilterFunc) {
      return this.store;
    }
    const fieldEntities = this.getFieldEntitiesForNamePathList(
      Array.isArray(mergedNameList) ? mergedNameList : null
    );
    const filteredNameList = [];
    fieldEntities.forEach((entity) => {
      const namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (mergedStrict) {
        if (entity.isList?.()) {
          return;
        }
      } else if (!mergedNameList && entity.isListField?.()) {
        return;
      }
      if (!mergedFilterFunc) {
        filteredNameList.push(namePath);
      } else {
        const meta = "getMeta" in entity ? entity.getMeta() : null;
        if (mergedFilterFunc(meta)) {
          filteredNameList.push(namePath);
        }
      }
    });
    return cloneByNamePathList(this.store, filteredNameList.map(getNamePath));
  };
  getFieldValue = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    return get(this.store, namePath);
  };
  getFieldsError = (nameList) => {
    this.warningUnhooked();
    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map((entity, index3) => {
      if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath(nameList[index3]),
        errors: [],
        warnings: []
      };
    });
  };
  getFieldError = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    const fieldError = this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  getFieldWarning = (name) => {
    this.warningUnhooked();
    const namePath = getNamePath(name);
    const fieldError = this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  isFieldsTouched = (...args) => {
    this.warningUnhooked();
    const [arg0, arg1] = args;
    let namePathList;
    let isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath);
      isAllFieldsTouched = arg1;
    }
    const fieldEntities = this.getFieldEntities(true);
    const isFieldTouched = /* @__PURE__ */ __name((field) => field.isFieldTouched(), "isFieldTouched");
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
    }
    const map = new NameMap_default();
    namePathList.forEach((shortNamePath) => {
      map.set(shortNamePath, []);
    });
    fieldEntities.forEach((field) => {
      const fieldNamePath = field.getNamePath();
      namePathList.forEach((shortNamePath) => {
        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {
          map.update(shortNamePath, (list) => [...list, field]);
        }
      });
    });
    const isNamePathListTouched = /* @__PURE__ */ __name((entities) => entities.some(isFieldTouched), "isNamePathListTouched");
    const namePathListEntities = map.map(({ value }) => value);
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  isFieldTouched = (name) => {
    this.warningUnhooked();
    return this.isFieldsTouched([name]);
  };
  isFieldsValidating = (nameList) => {
    this.warningUnhooked();
    const fieldEntities = this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some((testField) => testField.isFieldValidating());
    }
    const namePathList = nameList.map(getNamePath);
    return fieldEntities.some((testField) => {
      const fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  isFieldValidating = (name) => {
    this.warningUnhooked();
    return this.isFieldsValidating([name]);
  };
  /**
   * Reset Field with field `initialValue` prop.
   * Can pass `entities` or `namePathList` or just nothing.
   */
  resetWithFieldInitialValue = (info = {}) => {
    const cache = new NameMap_default();
    const fieldEntities = this.getFieldEntities(true);
    fieldEntities.forEach((field) => {
      const { initialValue } = field.props;
      const namePath = field.getNamePath();
      if (initialValue !== void 0) {
        const records = cache.get(namePath) || /* @__PURE__ */ new Set();
        records.add({ entity: field, value: initialValue });
        cache.set(namePath, records);
      }
    });
    const resetWithFields = /* @__PURE__ */ __name((entities) => {
      entities.forEach((field) => {
        const { initialValue } = field.props;
        if (initialValue !== void 0) {
          const namePath = field.getNamePath();
          const formInitialValue = this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warning_default(
              false,
              `Form already set 'initialValues' with path '${namePath.join(
                "."
              )}'. Field can not overwrite it.`
            );
          } else {
            const records = cache.get(namePath);
            if (records && records.size > 1) {
              warning_default(
                false,
                `Multiple Field with path '${namePath.join(
                  "."
                )}' set 'initialValue'. Can not decide which one to pick.`
              );
            } else if (records) {
              const originValue = this.getFieldValue(namePath);
              const isListField = field.isListField();
              if (!isListField && (!info.skipExist || originValue === void 0)) {
                this.updateStore(set(this.store, namePath, [...records][0].value));
              }
            }
          }
        }
      });
    }, "resetWithFields");
    let requiredFieldEntities;
    if (info.entities) {
      requiredFieldEntities = info.entities;
    } else if (info.namePathList) {
      requiredFieldEntities = [];
      info.namePathList.forEach((namePath) => {
        const records = cache.get(namePath);
        if (records) {
          requiredFieldEntities.push(...[...records].map((r2) => r2.entity));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  resetFields = (nameList) => {
    this.warningUnhooked();
    const prevStore = this.store;
    if (!nameList) {
      this.updateStore(merge(this.initialValues));
      this.resetWithFieldInitialValue();
      this.notifyObservers(prevStore, null, { type: "reset" });
      this.notifyWatch();
      return;
    }
    const namePathList = nameList.map(getNamePath);
    namePathList.forEach((namePath) => {
      const initialValue = this.getInitialValue(namePath);
      this.updateStore(set(this.store, namePath, initialValue));
    });
    this.resetWithFieldInitialValue({ namePathList });
    this.notifyObservers(prevStore, namePathList, { type: "reset" });
    this.notifyWatch(namePathList);
  };
  setFields = (fields) => {
    this.warningUnhooked();
    const prevStore = this.store;
    const namePathList = [];
    fields.forEach((fieldData) => {
      const { name, ...data } = fieldData;
      const namePath = getNamePath(name);
      namePathList.push(namePath);
      if ("value" in data) {
        this.updateStore(set(this.store, namePath, data.value));
      }
      this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    this.notifyWatch(namePathList);
  };
  getFields = () => {
    const entities = this.getFieldEntities(true);
    const fields = entities.map((field) => {
      const namePath = field.getNamePath();
      const meta = field.getMeta();
      const fieldData = {
        ...meta,
        name: namePath,
        value: this.getFieldValue(namePath)
      };
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  // =========================== Observer ===========================
  /**
   * This only trigger when a field is on constructor to avoid we get initialValue too late
   */
  initEntityValue = (entity) => {
    const { initialValue } = entity.props;
    if (initialValue !== void 0) {
      const namePath = entity.getNamePath();
      const prevValue = get(this.store, namePath);
      if (prevValue === void 0) {
        this.updateStore(set(this.store, namePath, initialValue));
      }
    }
  };
  isMergedPreserve = (fieldPreserve) => {
    const mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : this.preserve;
    return mergedPreserve ?? true;
  };
  registerField = (entity) => {
    this.fieldEntities.push(entity);
    const namePath = entity.getNamePath();
    this.notifyWatch([namePath]);
    if (entity.props.initialValue !== void 0) {
      const prevStore = this.store;
      this.resetWithFieldInitialValue({ entities: [entity], skipExist: true });
      this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return (isListField, preserve2, subNamePath = []) => {
      this.fieldEntities = this.fieldEntities.filter((item) => item !== entity);
      if (!this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
        const defaultValue = isListField ? void 0 : this.getInitialValue(namePath);
        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(
          (field) => (
            // Only reset when no namePath exist
            !matchNamePath(field.getNamePath(), namePath)
          )
        )) {
          const prevStore = this.store;
          this.updateStore(set(prevStore, namePath, defaultValue, true));
          this.notifyObservers(prevStore, [namePath], { type: "remove" });
          this.triggerDependenciesUpdate(prevStore, namePath);
        }
      }
      this.notifyWatch([namePath]);
    };
  };
  dispatch = (action) => {
    switch (action.type) {
      case "updateValue": {
        const { namePath, value } = action;
        this.updateValue(namePath, value);
        break;
      }
      case "validateField": {
        const { namePath, triggerName } = action;
        this.validateFields([namePath], { triggerName });
        break;
      }
      default:
    }
  };
  notifyObservers = (prevStore, namePathList, info) => {
    if (this.subscribable) {
      const mergedInfo = {
        ...info,
        store: this.getFieldsValue(true)
      };
      this.getFieldEntities().forEach(({ onStoreChange }) => {
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      this.forceRootUpdate();
    }
  };
  /**
   * Notify dependencies children with parent update
   * We need delay to trigger validate in case Field is under render props
   */
  triggerDependenciesUpdate = (prevStore, namePath) => {
    const childrenFields = this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      this.validateFields(childrenFields);
    }
    this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath, ...childrenFields]
    });
    return childrenFields;
  };
  updateValue = (name, value) => {
    const namePath = getNamePath(name);
    const prevStore = this.store;
    this.updateStore(set(this.store, namePath, value));
    this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    this.notifyWatch([namePath]);
    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);
    const { onValuesChange } = this.callbacks;
    if (onValuesChange) {
      const changedValues = cloneByNamePathList(this.store, [namePath]);
      onValuesChange(changedValues, this.getFieldsValue());
    }
    this.triggerOnFieldsChange([namePath, ...childrenFields]);
  };
  // Let all child Field get update.
  setFieldsValue = (store) => {
    this.warningUnhooked();
    const prevStore = this.store;
    if (store) {
      const nextStore = merge(this.store, store);
      this.updateStore(nextStore);
    }
    this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    this.notifyWatch();
  };
  setFieldValue = (name, value) => {
    this.setFields([
      {
        name,
        value
      }
    ]);
  };
  getDependencyChildrenFields = (rootNamePath) => {
    const children = /* @__PURE__ */ new Set();
    const childrenFields = [];
    const dependencies2fields = new NameMap_default();
    this.getFieldEntities().forEach((field) => {
      const { dependencies } = field.props;
      (dependencies || []).forEach((dependency) => {
        const dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, (fields = /* @__PURE__ */ new Set()) => {
          fields.add(field);
          return fields;
        });
      });
    });
    const fillChildren = /* @__PURE__ */ __name((namePath) => {
      const fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach((field) => {
        if (!children.has(field)) {
          children.add(field);
          const fieldNamePath = field.getNamePath();
          if (field.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren(fieldNamePath);
          }
        }
      });
    }, "fillChildren");
    fillChildren(rootNamePath);
    return childrenFields;
  };
  triggerOnFieldsChange = (namePathList, filedErrors) => {
    const { onFieldsChange } = this.callbacks;
    if (onFieldsChange) {
      const fields = this.getFields();
      if (filedErrors) {
        const cache = new NameMap_default();
        filedErrors.forEach(({ name, errors }) => {
          cache.set(name, errors);
        });
        fields.forEach((field) => {
          field.errors = cache.get(field.name) || field.errors;
        });
      }
      const changedFields = fields.filter(
        ({ name: fieldName }) => containsNamePath(namePathList, fieldName)
      );
      if (changedFields.length) {
        onFieldsChange(changedFields, fields);
      }
    }
  };
  // =========================== Validate ===========================
  validateFields = (arg1, arg2) => {
    this.warningUnhooked();
    let nameList;
    let options;
    if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
      nameList = arg1;
      options = arg2;
    } else {
      options = arg1;
    }
    const provideNameList = !!nameList;
    const namePathList = provideNameList ? nameList.map(getNamePath) : [];
    const promiseList = [];
    const TMP_SPLIT = String(Date.now());
    const validateNamePathList = /* @__PURE__ */ new Set();
    const { recursive, dirty } = options || {};
    this.getFieldEntities(true).forEach((field) => {
      if (!provideNameList) {
        namePathList.push(field.getNamePath());
      }
      if (!field.props.rules || !field.props.rules.length) {
        return;
      }
      if (dirty && !field.isFieldDirty()) {
        return;
      }
      const fieldNamePath = field.getNamePath();
      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
        const promise = field.validateRules({
          validateMessages: {
            ...defaultValidateMessages,
            ...this.validateMessages
          },
          ...options
        });
        promiseList.push(
          promise.then(() => ({ name: fieldNamePath, errors: [], warnings: [] })).catch((ruleErrors) => {
            const mergedErrors = [];
            const mergedWarnings = [];
            ruleErrors.forEach?.(({ rule: { warningOnly }, errors }) => {
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          })
        );
      }
    });
    const summaryPromise = allPromiseFinish(promiseList);
    this.lastValidatePromise = summaryPromise;
    summaryPromise.catch((results) => results).then((results) => {
      const resultNamePathList = results.map(({ name }) => name);
      this.notifyObservers(this.store, resultNamePathList, {
        type: "validateFinish"
      });
      this.triggerOnFieldsChange(resultNamePathList, results);
    });
    const returnPromise = summaryPromise.then(() => {
      if (this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(this.getFieldsValue(namePathList));
      }
      return Promise.reject([]);
    }).catch((results) => {
      const errorList = results.filter((result) => result && result.errors.length);
      return Promise.reject({
        values: this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch((e3) => e3);
    const triggerNamePathList = namePathList.filter(
      (namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT))
    );
    this.triggerOnFieldsChange(triggerNamePathList);
    return returnPromise;
  };
  // ============================ Submit ============================
  submit = () => {
    this.warningUnhooked();
    this.validateFields().then((values) => {
      const { onFinish } = this.callbacks;
      if (onFinish) {
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch((e3) => {
      const { onFinishFailed } = this.callbacks;
      if (onFinishFailed) {
        onFinishFailed(e3);
      }
    });
  };
};
function useForm(form) {
  const formRef = React86.useRef();
  const [, forceUpdate] = React86.useState({});
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      const forceReRender = /* @__PURE__ */ __name(() => {
        forceUpdate({});
      }, "forceReRender");
      const formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
__name(useForm, "useForm");
var useForm_default = useForm;

// packages/field-form/src/Form.tsx
import * as React88 from "react";

// packages/field-form/src/FormContext.tsx
import * as React87 from "react";
var FormContext = React87.createContext({
  triggerFormChange: () => {
  },
  triggerFormFinish: () => {
  },
  registerForm: () => {
  },
  unregisterForm: () => {
  }
});
var FormProvider = /* @__PURE__ */ __name(({
  validateMessages,
  onFormChange,
  onFormFinish,
  children
}) => {
  const formContext = React87.useContext(FormContext);
  const formsRef = React87.useRef({});
  return /* @__PURE__ */ React87.createElement(
    FormContext.Provider,
    {
      value: {
        ...formContext,
        validateMessages: {
          ...formContext.validateMessages,
          ...validateMessages
        },
        // =========================================================
        // =                  Global Form Control                  =
        // =========================================================
        triggerFormChange: (name, changedFields) => {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: (name, values) => {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: (name, form) => {
          if (name) {
            formsRef.current = {
              ...formsRef.current,
              [name]: form
            };
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: (name) => {
          const newForms = { ...formsRef.current };
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      }
    },
    children
  );
}, "FormProvider");
var FormContext_default = FormContext;

// packages/field-form/src/Form.tsx
var Form = /* @__PURE__ */ __name(({
  name,
  initialValues,
  fields,
  form,
  preserve: preserve2,
  children,
  component: Component11 = "form",
  validateMessages,
  validateTrigger = "onChange",
  onValuesChange,
  onFieldsChange,
  onFinish,
  onFinishFailed,
  ...restProps
}, ref) => {
  const formContext = React88.useContext(FormContext_default);
  const [formInstance] = useForm_default(form);
  const {
    useSubscribe,
    setInitialValues,
    setCallbacks,
    setValidateMessages,
    setPreserve,
    destroyForm
  } = formInstance.getInternalHooks(HOOK_MARK);
  React88.useImperativeHandle(ref, () => formInstance);
  React88.useEffect(() => {
    formContext.registerForm(name, formInstance);
    return () => {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]);
  setValidateMessages({
    ...formContext.validateMessages,
    ...validateMessages
  });
  setCallbacks({
    onValuesChange,
    onFieldsChange: (changedFields, ...rest) => {
      formContext.triggerFormChange(name, changedFields);
      if (onFieldsChange) {
        onFieldsChange(changedFields, ...rest);
      }
    },
    onFinish: (values) => {
      formContext.triggerFormFinish(name, values);
      if (onFinish) {
        onFinish(values);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve2);
  const mountRef = React88.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  React88.useEffect(
    () => destroyForm,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  let childrenNode;
  const childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    const values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  const prevFieldsRef = React88.useRef();
  React88.useEffect(() => {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  const formContextValue = React88.useMemo(
    () => ({
      ...formInstance,
      validateTrigger
    }),
    [formInstance, validateTrigger]
  );
  const wrapperNode = /* @__PURE__ */ React88.createElement(ListContext_default.Provider, { value: null }, /* @__PURE__ */ React88.createElement(FieldContext_default.Provider, { value: formContextValue }, childrenNode));
  if (Component11 === false) {
    return wrapperNode;
  }
  return /* @__PURE__ */ React88.createElement(
    Component11,
    {
      ...restProps,
      onSubmit: (event) => {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: (event) => {
        event.preventDefault();
        formInstance.resetFields();
        restProps.onReset?.(event);
      }
    },
    wrapperNode
  );
}, "Form");
var Form_default = Form;

// packages/field-form/src/useWatch.ts
init_warning();
import { useContext as useContext34, useEffect as useEffect25, useMemo as useMemo19, useRef as useRef32, useState as useState19 } from "react";
function stringify2(value) {
  try {
    return JSON.stringify(value);
  } catch (err) {
    return Math.random();
  }
}
__name(stringify2, "stringify");
var useWatchWarning = true ? (namePath) => {
  const fullyStr = namePath.join("__RC_FIELD_FORM_SPLIT__");
  const nameStrRef = useRef32(fullyStr);
  warning_default(
    nameStrRef.current === fullyStr,
    "`useWatch` is not support dynamic `namePath`. Please provide static instead."
  );
} : () => {
};
function useWatch(...args) {
  const [dependencies, _form = {}] = args;
  const options = isFormInstance(_form) ? { form: _form } : _form;
  const form = options.form;
  const [value, setValue] = useState19();
  const valueStr = useMemo19(() => stringify2(value), [value]);
  const valueStrRef = useRef32(valueStr);
  valueStrRef.current = valueStr;
  const fieldContext = useContext34(FieldContext_default);
  const formInstance = form || fieldContext;
  const isValidForm = formInstance && formInstance._init;
  if (true) {
    warning_default(
      args.length === 2 ? form ? isValidForm : true : isValidForm,
      "useWatch requires a form instance since it can not auto detect from context."
    );
  }
  const namePath = getNamePath(dependencies);
  const namePathRef = useRef32(namePath);
  namePathRef.current = namePath;
  useWatchWarning(namePath);
  useEffect25(
    () => {
      if (!isValidForm) {
        return;
      }
      const { getFieldsValue, getInternalHooks } = formInstance;
      const { registerWatch } = getInternalHooks(HOOK_MARK);
      const getWatchValue = /* @__PURE__ */ __name((values, allValues) => {
        const watchValue = options.preserve ? allValues : values;
        return typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, namePathRef.current);
      }, "getWatchValue");
      const cancelRegister = registerWatch((values, allValues) => {
        const newValue = getWatchValue(values, allValues);
        const nextValueStr = stringify2(newValue);
        if (valueStrRef.current !== nextValueStr) {
          valueStrRef.current = nextValueStr;
          setValue(newValue);
        }
      });
      const initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));
      if (value !== initialValue) {
        setValue(initialValue);
      }
      return cancelRegister;
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isValidForm]
  );
  return value;
}
__name(useWatch, "useWatch");
var useWatch_default = useWatch;

// packages/field-form/src/index.tsx
var InternalForm = React89.forwardRef(Form_default);
var RefForm = InternalForm;
RefForm.FormProvider = FormProvider;
RefForm.Field = Field_default;
RefForm.List = List_default;
RefForm.useForm = useForm_default;
RefForm.useWatch = useWatch_default;
var src_default4 = RefForm;

// packages/ant-design/components/form/context.tsx
var FormContext2 = React90.createContext({
  labelAlign: "right",
  vertical: false,
  itemRef: () => {
  }
});
var NoStyleItemContext = React90.createContext(null);
var FormProvider2 = /* @__PURE__ */ __name((props) => {
  const providerProps = omit(props, ["prefixCls"]);
  return /* @__PURE__ */ React90.createElement(FormProvider, { ...providerProps });
}, "FormProvider");
var FormItemPrefixContext = React90.createContext({
  prefixCls: ""
});
var FormItemInputContext = React90.createContext({});
if (true) {
  FormItemInputContext.displayName = "FormItemInputContext";
}
var NoFormStyle = /* @__PURE__ */ __name(({ children, status, override }) => {
  const formItemInputContext = useContext35(FormItemInputContext);
  const newFormItemInputContext = useMemo20(() => {
    const newContext = { ...formItemInputContext };
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ React90.createElement(FormItemInputContext.Provider, { value: newFormItemInputContext }, children);
}, "NoFormStyle");
var VariantContext = createContext19(void 0);

// packages/ant-design/components/watermark/context.ts
import * as React91 from "react";
function voidFunc() {
}
__name(voidFunc, "voidFunc");
var WatermarkContext = React91.createContext({
  add: voidFunc,
  remove: voidFunc
});
function usePanelRef(panelSelector) {
  const watermark = React91.useContext(WatermarkContext);
  const panelEleRef = React91.useRef();
  const panelRef = useEvent((ele) => {
    if (ele) {
      const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
      watermark.add(innerContentEle);
      panelEleRef.current = innerContentEle;
    } else {
      watermark.remove(panelEleRef.current);
    }
  });
  return panelRef;
}
__name(usePanelRef, "usePanelRef");
var context_default3 = WatermarkContext;

// packages/ant-design/components/modal/shared.tsx
var import_CloseOutlined4 = __toESM(require_CloseOutlined3());
import React94 from "react";

// packages/ant-design/components/modal/components/NormalCancelBtn.tsx
import React92, { useContext as useContext37 } from "react";
var NormalCancelBtn = /* @__PURE__ */ __name(() => {
  const { cancelButtonProps, cancelTextLocale, onCancel } = useContext37(ModalContext);
  return /* @__PURE__ */ React92.createElement(button_default2, { onClick: onCancel, ...cancelButtonProps }, cancelTextLocale);
}, "NormalCancelBtn");
var NormalCancelBtn_default = NormalCancelBtn;

// packages/ant-design/components/modal/components/NormalOkBtn.tsx
import React93, { useContext as useContext38 } from "react";
var NormalOkBtn = /* @__PURE__ */ __name(() => {
  const { confirmLoading, okButtonProps, okType, okTextLocale, onOk } = useContext38(ModalContext);
  return /* @__PURE__ */ React93.createElement(
    button_default2,
    {
      ...convertLegacyProps(okType),
      loading: confirmLoading,
      onClick: onOk,
      ...okButtonProps
    },
    okTextLocale
  );
}, "NormalOkBtn");
var NormalOkBtn_default = NormalOkBtn;

// packages/ant-design/components/modal/shared.tsx
function renderCloseIcon(prefixCls, closeIcon) {
  return /* @__PURE__ */ React94.createElement("span", { className: `${prefixCls}-close-x` }, closeIcon || /* @__PURE__ */ React94.createElement(import_CloseOutlined4.default, { className: `${prefixCls}-close-icon` }));
}
__name(renderCloseIcon, "renderCloseIcon");
var Footer = /* @__PURE__ */ __name((props) => {
  const {
    okText,
    okType = "primary",
    cancelText,
    confirmLoading,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps,
    footer
  } = props;
  const [locale6] = useLocale_default("Modal", getConfirmLocale());
  const okTextLocale = okText || locale6?.okText;
  const cancelTextLocale = cancelText || locale6?.cancelText;
  const btnCtxValue = {
    confirmLoading,
    okButtonProps,
    cancelButtonProps,
    okTextLocale,
    cancelTextLocale,
    okType,
    onOk,
    onCancel
  };
  const btnCtxValueMemo = React94.useMemo(() => btnCtxValue, [...Object.values(btnCtxValue)]);
  let footerNode;
  if (typeof footer === "function" || typeof footer === "undefined") {
    footerNode = /* @__PURE__ */ React94.createElement(React94.Fragment, null, /* @__PURE__ */ React94.createElement(NormalCancelBtn_default, null), /* @__PURE__ */ React94.createElement(NormalOkBtn_default, null));
    if (typeof footer === "function") {
      footerNode = footer(footerNode, {
        OkBtn: NormalOkBtn_default,
        CancelBtn: NormalCancelBtn_default
      });
    }
    footerNode = /* @__PURE__ */ React94.createElement(ModalContextProvider, { value: btnCtxValueMemo }, footerNode);
  } else {
    footerNode = footer;
  }
  return /* @__PURE__ */ React94.createElement(DisabledContextProvider, { disabled: false }, footerNode);
}, "Footer");

// packages/ant-design/components/style/motion/collapse.ts
var genCollapseMotion = /* @__PURE__ */ __name((token2) => ({
  [token2.componentCls]: {
    // For common/openAnimation
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
}), "genCollapseMotion");
var collapse_default = genCollapseMotion;

// packages/ant-design/components/style/motion/motion.ts
var initMotionCommon = /* @__PURE__ */ __name((duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
}), "initMotionCommon");
var initMotionCommonLeave = /* @__PURE__ */ __name((duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
}), "initMotionCommonLeave");
var initMotion = /* @__PURE__ */ __name((motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: {
      ...initMotionCommon(duration),
      animationPlayState: "paused"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      ...initMotionCommonLeave(duration),
      animationPlayState: "paused"
    },
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, "initMotion");

// packages/ant-design/components/style/motion/fade.ts
var fadeIn = new Keyframes_default("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var fadeOut = new Keyframes_default("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
var initFadeMotion = /* @__PURE__ */ __name((token2, sameLevel = false) => {
  const { antCls } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [
    initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel),
    {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }
  ];
}, "initFadeMotion");

// packages/ant-design/components/style/motion/move.ts
var moveDownIn = new Keyframes_default("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveDownOut = new Keyframes_default("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveLeftIn = new Keyframes_default("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveLeftOut = new Keyframes_default("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveRightIn = new Keyframes_default("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveRightOut = new Keyframes_default("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveUpIn = new Keyframes_default("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveUpOut = new Keyframes_default("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
var initMoveMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const { antCls } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const { inKeyframes, outKeyframes } = moveMotion[motionName];
  return [
    initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid),
    {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }
  ];
}, "initMoveMotion");

// packages/ant-design/components/style/motion/slide.ts
var slideUpIn = new Keyframes_default("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideUpOut = new Keyframes_default("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideDownIn = new Keyframes_default("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
var slideDownOut = new Keyframes_default("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
var slideLeftIn = new Keyframes_default("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideLeftOut = new Keyframes_default("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideRightIn = new Keyframes_default("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
var slideRightOut = new Keyframes_default("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
var slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
var initSlideMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const { antCls } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const { inKeyframes, outKeyframes } = slideMotion[motionName];
  return [
    initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid),
    {
      [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
        transform: "scale(0)",
        transformOrigin: "0% 0%",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutQuint,
        [`&-prepare`]: {
          transform: "scale(1)"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInQuint
      }
    }
  ];
}, "initSlideMotion");

// packages/ant-design/components/style/motion/zoom.ts
var zoomIn = new Keyframes_default("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomOut = new Keyframes_default("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
var zoomBigIn = new Keyframes_default("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomBigOut = new Keyframes_default("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
var zoomUpIn = new Keyframes_default("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
var zoomUpOut = new Keyframes_default("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
var zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
var zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
var zoomRightIn = new Keyframes_default("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
var zoomRightOut = new Keyframes_default("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
var zoomDownIn = new Keyframes_default("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
var zoomDownOut = new Keyframes_default("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
var zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
var initZoomMotion = /* @__PURE__ */ __name((token2, motionName) => {
  const { antCls } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const { inKeyframes, outKeyframes } = zoomMotion[motionName];
  return [
    initMotion(
      motionCls,
      inKeyframes,
      outKeyframes,
      motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid
    ),
    {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }
  ];
}, "initZoomMotion");

// packages/ant-design/components/modal/style/index.ts
function box(position2) {
  return {
    position: position2,
    inset: 0
  };
}
__name(box, "box");
var genModalMaskStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  return [
    {
      [`${componentCls}-root`]: {
        [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
          // reset scale avoid mousePosition bug
          transform: "none",
          opacity: 0,
          animationDuration: token2.motionDurationSlow,
          // https://github.com/ant-design/ant-design/issues/11777
          userSelect: "none"
        },
        // https://github.com/ant-design/ant-design/issues/37329
        // https://github.com/ant-design/ant-design/issues/40272
        [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-mask`]: {
          ...box("fixed"),
          zIndex: token2.zIndexPopupBase,
          height: "100%",
          backgroundColor: token2.colorBgMask,
          pointerEvents: "none",
          [`${componentCls}-hidden`]: {
            display: "none"
          }
        },
        [`${componentCls}-wrap`]: {
          ...box("fixed"),
          zIndex: token2.zIndexPopupBase,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        }
      }
    },
    { [`${componentCls}-root`]: initFadeMotion(token2) }
  ];
}, "genModalMaskStyle");
var genModalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return [
    // ======================== Root =========================
    {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [componentCls]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${token2.screenSMMax}px)`]: {
          [componentCls]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${unit(token2.marginXS)} auto`
          },
          [`${componentCls}-centered`]: {
            [componentCls]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [componentCls]: {
        ...resetComponent(token2),
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${unit(token2.calc(token2.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: token2.paddingLG,
        [`${componentCls}-title`]: {
          margin: 0,
          color: token2.titleColor,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.titleFontSize,
          lineHeight: token2.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-content`]: {
          position: "relative",
          backgroundColor: token2.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: token2.borderRadiusLG,
          boxShadow: token2.boxShadow,
          pointerEvents: "auto",
          padding: token2.contentPadding
        },
        [`${componentCls}-close`]: {
          position: "absolute",
          top: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
          zIndex: token2.calc(token2.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: token2.modalCloseIconColor,
          fontWeight: token2.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: token2.borderRadiusSM,
          width: token2.modalCloseBtnSize,
          height: token2.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: token2.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${unit(token2.modalCloseBtnSize)}`,
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: token2.modalCloseIconHoverColor,
            backgroundColor: token2.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          },
          ...genFocusStyle(token2)
        },
        [`${componentCls}-header`]: {
          color: token2.colorText,
          background: token2.headerBg,
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
          marginBottom: token2.headerMarginBottom,
          padding: token2.headerPadding,
          borderBottom: token2.headerBorderBottom
        },
        [`${componentCls}-body`]: {
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          wordWrap: "break-word",
          padding: token2.bodyPadding
        },
        [`${componentCls}-footer`]: {
          textAlign: "end",
          background: token2.footerBg,
          marginTop: token2.footerMarginTop,
          padding: token2.footerPadding,
          borderTop: token2.footerBorderTop,
          borderRadius: token2.footerBorderRadius,
          [`> ${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginInlineStart: token2.marginXS
          }
        },
        [`${componentCls}-open`]: {
          overflow: "hidden"
        }
      }
    },
    // ======================== Pure =========================
    {
      [`${componentCls}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${componentCls}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, "genModalStyle");
var genRTLStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-root`]: {
      [`${componentCls}-wrap-rtl`]: {
        direction: "rtl",
        [`${componentCls}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, "genRTLStyle");
var prepareToken2 = /* @__PURE__ */ __name((token2) => {
  const headerPaddingVertical = token2.padding;
  const headerFontSize = token2.fontSizeHeading5;
  const headerLineHeight = token2.lineHeightHeading5;
  const modalToken = merge2(token2, {
    modalHeaderHeight: token2.calc(token2.calc(headerLineHeight).mul(headerFontSize).equal()).add(token2.calc(headerPaddingVertical).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: token2.colorSplit,
    modalFooterBorderStyle: token2.lineType,
    modalFooterBorderWidth: token2.lineWidth,
    modalCloseIconColor: token2.colorIcon,
    modalCloseIconHoverColor: token2.colorIconHover,
    modalCloseBtnSize: token2.controlHeight,
    modalConfirmIconSize: token2.fontHeight,
    modalTitleHeight: token2.calc(token2.titleFontSize).mul(token2.titleLineHeight).equal()
  });
  return modalToken;
}, "prepareToken");
var prepareComponentToken6 = /* @__PURE__ */ __name((token2) => ({
  footerBg: "transparent",
  headerBg: token2.colorBgElevated,
  titleLineHeight: token2.lineHeightHeading5,
  titleFontSize: token2.fontSizeHeading5,
  contentBg: token2.colorBgElevated,
  titleColor: token2.colorTextHeading,
  // internal
  contentPadding: token2.wireframe ? 0 : `${unit(token2.paddingMD)} ${unit(token2.paddingContentHorizontalLG)}`,
  headerPadding: token2.wireframe ? `${unit(token2.padding)} ${unit(token2.paddingLG)}` : 0,
  headerBorderBottom: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
  headerMarginBottom: token2.wireframe ? 0 : token2.marginXS,
  bodyPadding: token2.wireframe ? token2.paddingLG : 0,
  footerPadding: token2.wireframe ? `${unit(token2.paddingXS)} ${unit(token2.padding)}` : 0,
  footerBorderTop: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
  footerBorderRadius: token2.wireframe ? `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}` : 0,
  footerMarginTop: token2.wireframe ? 0 : token2.marginSM,
  confirmBodyPadding: token2.wireframe ? `${unit(token2.padding * 2)} ${unit(token2.padding * 2)} ${unit(token2.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: token2.wireframe ? token2.margin : token2.marginSM,
  confirmBtnsMarginTop: token2.wireframe ? token2.marginLG : token2.marginSM
}), "prepareComponentToken");
var style_default8 = genStyleHooks(
  "Modal",
  (token2) => {
    const modalToken = prepareToken2(token2);
    return [
      genModalStyle(modalToken),
      genRTLStyle(modalToken),
      genModalMaskStyle(modalToken),
      initZoomMotion(modalToken, "zoom")
    ];
  },
  prepareComponentToken6,
  {
    unitless: {
      titleLineHeight: true
    }
  }
);

// packages/ant-design/components/modal/Modal.tsx
var mousePosition;
var getClickPosition = /* @__PURE__ */ __name((e3) => {
  mousePosition = {
    x: e3.pageX,
    y: e3.pageY
  };
  setTimeout(() => {
    mousePosition = null;
  }, 100);
}, "getClickPosition");
if (canUseDocElement()) {
  document.documentElement.addEventListener("click", getClickPosition, true);
}
var Modal = /* @__PURE__ */ __name((props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    modal: modalContext
  } = React95.useContext(ConfigContext);
  const handleCancel = /* @__PURE__ */ __name((e3) => {
    const { onCancel } = props;
    onCancel?.(e3);
  }, "handleCancel");
  const handleOk = /* @__PURE__ */ __name((e3) => {
    const { onOk } = props;
    onOk?.(e3);
  }, "handleOk");
  if (true) {
    const warning5 = devUseWarning("Modal");
    [
      ["visible", "open"],
      ["bodyStyle", "styles.body"],
      ["maskStyle", "styles.mask"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    open: open3,
    wrapClassName,
    centered,
    getContainer: getContainer2,
    focusTriggerAfterClose = true,
    style: style2,
    // Deprecated
    visible,
    width = 520,
    footer,
    classNames: modalClassNames,
    styles: modalStyles,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("modal", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default8(prefixCls, rootCls);
  const wrapClassNameExtended = (0, import_classnames21.default)(wrapClassName, {
    [`${prefixCls}-centered`]: !!centered,
    [`${prefixCls}-wrap-rtl`]: direction === "rtl"
  });
  const dialogFooter = footer !== null && /* @__PURE__ */ React95.createElement(Footer, { ...props, onOk: handleOk, onCancel: handleCancel });
  const [mergedClosable, mergedCloseIcon] = useClosable(
    pickClosable(props),
    pickClosable(modalContext),
    {
      closable: true,
      closeIcon: /* @__PURE__ */ React95.createElement(import_CloseOutlined5.default, { className: `${prefixCls}-close-icon` }),
      closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
    }
  );
  const panelRef = usePanelRef(`.${prefixCls}-content`);
  const [zIndex, contextZIndex] = useZIndex("Modal", restProps.zIndex);
  return wrapCSSVar(
    /* @__PURE__ */ React95.createElement(NoCompactStyle, null, /* @__PURE__ */ React95.createElement(NoFormStyle, { status: true, override: true }, /* @__PURE__ */ React95.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ React95.createElement(
      src_default3,
      {
        width,
        ...restProps,
        zIndex,
        getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
        prefixCls,
        rootClassName: (0, import_classnames21.default)(hashId, rootClassName, cssVarCls, rootCls),
        footer: dialogFooter,
        visible: open3 ?? visible,
        mousePosition: restProps.mousePosition ?? mousePosition,
        onClose: handleCancel,
        closable: mergedClosable,
        closeIcon: mergedCloseIcon,
        focusTriggerAfterClose,
        transitionName: getTransitionName2(rootPrefixCls, "zoom", props.transitionName),
        maskTransitionName: getTransitionName2(rootPrefixCls, "fade", props.maskTransitionName),
        className: (0, import_classnames21.default)(hashId, className, modalContext?.className),
        style: { ...modalContext?.style, ...style2 },
        classNames: {
          ...modalContext?.classNames,
          ...modalClassNames,
          wrapper: (0, import_classnames21.default)(wrapClassNameExtended, modalClassNames?.wrapper)
        },
        styles: {
          ...modalContext?.styles,
          ...modalStyles
        },
        panelRef
      }
    ))))
  );
}, "Modal");
var Modal_default = Modal;

// packages/ant-design/components/modal/style/confirm.ts
var genModalConfirmStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    titleFontSize,
    titleLineHeight,
    modalConfirmIconSize,
    fontSize,
    lineHeight,
    modalTitleHeight,
    fontHeight,
    confirmBodyPadding
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [confirmComponentCls]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${token2.antCls}-modal-header`]: {
        display: "none"
      },
      [`${confirmComponentCls}-body-wrapper`]: {
        ...clearFix()
      },
      [`&${componentCls} ${componentCls}-body`]: {
        padding: confirmBodyPadding
      },
      // ====================== Body ======================
      [`${confirmComponentCls}-body`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${token2.iconCls}`]: {
          flex: "none",
          fontSize: modalConfirmIconSize,
          marginInlineEnd: token2.confirmIconMarginInlineEnd,
          marginTop: token2.calc(token2.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        },
        [`&-has-title > ${token2.iconCls}`]: {
          marginTop: token2.calc(token2.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        }
      },
      [`${confirmComponentCls}-paragraph`]: {
        display: "flex",
        flexDirection: "column",
        flex: "auto",
        rowGap: token2.marginXS
      },
      // https://github.com/ant-design/ant-design/issues/48159
      [`${token2.iconCls} + ${confirmComponentCls}-paragraph`]: {
        maxWidth: `calc(100% - ${unit(
          token2.calc(token2.modalConfirmIconSize).add(token2.marginSM).equal()
        )})`
      },
      [`${confirmComponentCls}-title`]: {
        color: token2.colorTextHeading,
        fontWeight: token2.fontWeightStrong,
        fontSize: titleFontSize,
        lineHeight: titleLineHeight
      },
      [`${confirmComponentCls}-content`]: {
        color: token2.colorText,
        fontSize,
        lineHeight
      },
      // ===================== Footer =====================
      [`${confirmComponentCls}-btns`]: {
        textAlign: "end",
        marginTop: token2.confirmBtnsMarginTop,
        [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorError
    },
    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorWarning
    },
    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorInfo
    },
    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorSuccess
    }
  };
}, "genModalConfirmStyle");
var confirm_default = genSubStyleComponent(
  ["Modal", "confirm"],
  (token2) => {
    const modalToken = prepareToken2(token2);
    return [genModalConfirmStyle(modalToken)];
  },
  prepareComponentToken6,
  {
    // confirm is weak than modal since no conflict here
    order: -1e3
  }
);

// packages/ant-design/components/modal/ConfirmDialog.tsx
function ConfirmContent(props) {
  const {
    prefixCls,
    icon,
    okText,
    cancelText,
    confirmPrefixCls,
    type: type5,
    okCancel,
    footer,
    // Legacy for static function usage
    locale: staticLocale,
    ...resetProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Modal");
    warning5(
      !(typeof icon === "string" && icon.length > 2),
      "breaking",
      `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`
    );
  }
  let mergedIcon = icon;
  if (!icon && icon !== null) {
    switch (type5) {
      case "info":
        mergedIcon = /* @__PURE__ */ React96.createElement(import_InfoCircleFilled3.default, null);
        break;
      case "success":
        mergedIcon = /* @__PURE__ */ React96.createElement(import_CheckCircleFilled3.default, null);
        break;
      case "error":
        mergedIcon = /* @__PURE__ */ React96.createElement(import_CloseCircleFilled3.default, null);
        break;
      default:
        mergedIcon = /* @__PURE__ */ React96.createElement(import_ExclamationCircleFilled3.default, null);
    }
  }
  const mergedOkCancel = okCancel ?? type5 === "confirm";
  const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
  const [locale6] = useLocale_default("Modal");
  const mergedLocale = staticLocale || locale6;
  const okTextLocale = okText || (mergedOkCancel ? mergedLocale?.okText : mergedLocale?.justOkText);
  const cancelTextLocale = cancelText || mergedLocale?.cancelText;
  const btnCtxValue = {
    autoFocusButton,
    cancelTextLocale,
    okTextLocale,
    mergedOkCancel,
    ...resetProps
  };
  const btnCtxValueMemo = React96.useMemo(() => btnCtxValue, [...Object.values(btnCtxValue)]);
  const footerOriginNode = /* @__PURE__ */ React96.createElement(React96.Fragment, null, /* @__PURE__ */ React96.createElement(ConfirmCancelBtn_default, null), /* @__PURE__ */ React96.createElement(ConfirmOkBtn_default, null));
  const hasTitle = props.title !== void 0 && props.title !== null;
  const bodyCls = `${confirmPrefixCls}-body`;
  return /* @__PURE__ */ React96.createElement("div", { className: `${confirmPrefixCls}-body-wrapper` }, /* @__PURE__ */ React96.createElement(
    "div",
    {
      className: (0, import_classnames22.default)(bodyCls, {
        [`${bodyCls}-has-title`]: hasTitle
      })
    },
    mergedIcon,
    /* @__PURE__ */ React96.createElement("div", { className: `${confirmPrefixCls}-paragraph` }, hasTitle && /* @__PURE__ */ React96.createElement("span", { className: `${confirmPrefixCls}-title` }, props.title), /* @__PURE__ */ React96.createElement("div", { className: `${confirmPrefixCls}-content` }, props.content))
  ), footer === void 0 || typeof footer === "function" ? /* @__PURE__ */ React96.createElement(ModalContextProvider, { value: btnCtxValueMemo }, /* @__PURE__ */ React96.createElement("div", { className: `${confirmPrefixCls}-btns` }, typeof footer === "function" ? footer(footerOriginNode, {
    OkBtn: ConfirmOkBtn_default,
    CancelBtn: ConfirmCancelBtn_default
  }) : footerOriginNode)) : footer, /* @__PURE__ */ React96.createElement(confirm_default, { prefixCls }));
}
__name(ConfirmContent, "ConfirmContent");
var ConfirmDialog = /* @__PURE__ */ __name((props) => {
  const {
    close,
    zIndex,
    afterClose,
    open: open3,
    keyboard,
    centered,
    getContainer: getContainer2,
    maskStyle,
    direction,
    prefixCls,
    wrapClassName,
    rootPrefixCls,
    bodyStyle,
    closable = false,
    closeIcon,
    modalRender,
    focusTriggerAfterClose,
    onConfirm,
    styles
  } = props;
  if (true) {
    const warning5 = devUseWarning("Modal");
    [
      ["visible", "open"],
      ["bodyStyle", "styles.body"],
      ["maskStyle", "styles.mask"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const confirmPrefixCls = `${prefixCls}-confirm`;
  const width = props.width || 416;
  const style2 = props.style || {};
  const mask = props.mask === void 0 ? true : props.mask;
  const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
  const classString = (0, import_classnames22.default)(
    confirmPrefixCls,
    `${confirmPrefixCls}-${props.type}`,
    { [`${confirmPrefixCls}-rtl`]: direction === "rtl" },
    props.className
  );
  const [, token2] = useToken();
  const mergedZIndex = React96.useMemo(() => {
    if (zIndex !== void 0) {
      return zIndex;
    }
    return token2.zIndexPopupBase + CONTAINER_MAX_OFFSET;
  }, [zIndex, token2]);
  return /* @__PURE__ */ React96.createElement(
    Modal_default,
    {
      prefixCls,
      className: classString,
      wrapClassName: (0, import_classnames22.default)(
        { [`${confirmPrefixCls}-centered`]: !!props.centered },
        wrapClassName
      ),
      onCancel: () => {
        close?.({ triggerCancel: true });
        onConfirm?.(false);
      },
      open: open3,
      title: "",
      footer: null,
      transitionName: getTransitionName2(rootPrefixCls || "", "zoom", props.transitionName),
      maskTransitionName: getTransitionName2(rootPrefixCls || "", "fade", props.maskTransitionName),
      mask,
      maskClosable,
      style: style2,
      styles: { body: bodyStyle, mask: maskStyle, ...styles },
      width,
      zIndex: mergedZIndex,
      afterClose,
      keyboard,
      centered,
      getContainer: getContainer2,
      closable,
      closeIcon,
      modalRender,
      focusTriggerAfterClose
    },
    /* @__PURE__ */ React96.createElement(ConfirmContent, { ...props, confirmPrefixCls })
  );
}, "ConfirmDialog");
var ConfirmDialogWrapper = /* @__PURE__ */ __name((props) => {
  const { rootPrefixCls, iconPrefixCls, direction, theme } = props;
  return /* @__PURE__ */ React96.createElement(
    config_provider_default,
    {
      prefixCls: rootPrefixCls,
      iconPrefixCls,
      direction,
      theme
    },
    /* @__PURE__ */ React96.createElement(ConfirmDialog, { ...props })
  );
}, "ConfirmDialogWrapper");
if (true) {
  ConfirmDialog.displayName = "ConfirmDialog";
  ConfirmDialogWrapper.displayName = "ConfirmDialogWrapper";
}
var ConfirmDialog_default = ConfirmDialogWrapper;

// packages/ant-design/components/modal/destroyFns.ts
var destroyFns = [];
var destroyFns_default = destroyFns;

// packages/ant-design/components/modal/confirm.tsx
var defaultRootPrefixCls = "";
function getRootPrefixCls() {
  return defaultRootPrefixCls;
}
__name(getRootPrefixCls, "getRootPrefixCls");
var ConfirmDialogWrapper2 = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, getContainer: getContainer2, direction } = props;
  const runtimeLocale2 = getConfirmLocale();
  const config = useContext40(ConfigContext);
  const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
  const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
  let mergedGetContainer = getContainer2;
  if (mergedGetContainer === false) {
    mergedGetContainer = void 0;
    if (true) {
      warning_default2(
        false,
        "Modal",
        "Static method not support `getContainer` to be `false` since it do not have context env."
      );
    }
  }
  return /* @__PURE__ */ React97.createElement(
    ConfirmDialog_default,
    {
      ...props,
      rootPrefixCls,
      prefixCls,
      iconPrefixCls: config.iconPrefixCls,
      theme: config.theme,
      direction: direction ?? config.direction,
      locale: config.locale?.Modal ?? runtimeLocale2,
      getContainer: mergedGetContainer
    }
  );
}, "ConfirmDialogWrapper");
function confirm(config) {
  const global2 = globalConfig();
  if (!global2.holderRender) {
    warnContext("Modal");
  }
  const container = document.createDocumentFragment();
  let currentConfig = { ...config, close, open: true };
  let timeoutId;
  function destroy3(...args) {
    const triggerCancel = args.some((param) => param && param.triggerCancel);
    if (config.onCancel && triggerCancel) {
      config.onCancel(() => {
      }, ...args.slice(1));
    }
    for (let i = 0; i < destroyFns_default.length; i++) {
      const fn = destroyFns_default[i];
      if (fn === close) {
        destroyFns_default.splice(i, 1);
        break;
      }
    }
    unmount(container);
  }
  __name(destroy3, "destroy");
  function render2(props) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      const rootPrefixCls = global2.getPrefixCls(void 0, getRootPrefixCls());
      const iconPrefixCls = global2.getIconPrefixCls();
      const theme = global2.getTheme();
      const dom = /* @__PURE__ */ React97.createElement(ConfirmDialogWrapper2, { ...props });
      render(
        /* @__PURE__ */ React97.createElement(config_provider_default, { prefixCls: rootPrefixCls, iconPrefixCls, theme }, global2.holderRender ? global2.holderRender(dom) : dom),
        container
      );
    });
  }
  __name(render2, "render");
  function close(...args) {
    currentConfig = {
      ...currentConfig,
      open: false,
      afterClose: () => {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy3.apply(this, args);
      }
    };
    if (currentConfig.visible) {
      delete currentConfig.visible;
    }
    render2(currentConfig);
  }
  __name(close, "close");
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = {
        ...currentConfig,
        ...configUpdate
      };
    }
    render2(currentConfig);
  }
  __name(update, "update");
  render2(currentConfig);
  destroyFns_default.push(close);
  return {
    destroy: close,
    update
  };
}
__name(confirm, "confirm");
function withWarn(props) {
  return {
    ...props,
    type: "warning"
  };
}
__name(withWarn, "withWarn");
function withInfo(props) {
  return {
    ...props,
    type: "info"
  };
}
__name(withInfo, "withInfo");
function withSuccess(props) {
  return {
    ...props,
    type: "success"
  };
}
__name(withSuccess, "withSuccess");
function withError(props) {
  return {
    ...props,
    type: "error"
  };
}
__name(withError, "withError");
function withConfirm(props) {
  return {
    ...props,
    type: "confirm"
  };
}
__name(withConfirm, "withConfirm");
function modalGlobalConfig({ rootPrefixCls }) {
  warning_default2(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.");
  defaultRootPrefixCls = rootPrefixCls;
}
__name(modalGlobalConfig, "modalGlobalConfig");

// packages/ant-design/components/modal/useModal/HookModal.tsx
import * as React98 from "react";
var HookModal = /* @__PURE__ */ __name(({ afterClose: hookAfterClose, config, ...restProps }, ref) => {
  const [open3, setOpen] = React98.useState(true);
  const [innerConfig, setInnerConfig] = React98.useState(config);
  const { direction, getPrefixCls } = React98.useContext(ConfigContext);
  const prefixCls = getPrefixCls("modal");
  const rootPrefixCls = getPrefixCls();
  const afterClose = /* @__PURE__ */ __name(() => {
    hookAfterClose();
    innerConfig.afterClose?.();
  }, "afterClose");
  const close = /* @__PURE__ */ __name((...args) => {
    setOpen(false);
    const triggerCancel = args.some((param) => param && param.triggerCancel);
    if (innerConfig.onCancel && triggerCancel) {
      innerConfig.onCancel(() => {
      }, ...args.slice(1));
    }
  }, "close");
  React98.useImperativeHandle(ref, () => ({
    destroy: close,
    update: (newConfig) => {
      setInnerConfig((originConfig) => ({
        ...originConfig,
        ...newConfig
      }));
    }
  }));
  const mergedOkCancel = innerConfig.okCancel ?? innerConfig.type === "confirm";
  const [contextLocale] = useLocale_default("Modal", en_US_default6.Modal);
  return /* @__PURE__ */ React98.createElement(
    ConfirmDialog_default,
    {
      prefixCls,
      rootPrefixCls,
      ...innerConfig,
      close,
      open: open3,
      afterClose,
      okText: innerConfig.okText || (mergedOkCancel ? contextLocale?.okText : contextLocale?.justOkText),
      direction: innerConfig.direction || direction,
      cancelText: innerConfig.cancelText || contextLocale?.cancelText,
      ...restProps
    }
  );
}, "HookModal");
var HookModal_default = React98.forwardRef(HookModal);

// packages/ant-design/components/modal/useModal/index.tsx
var uuid4 = 0;
var ElementsHolder = React99.memo(
  React99.forwardRef((_props, ref) => {
    const [elements, patchElement] = usePatchElement();
    React99.useImperativeHandle(
      ref,
      () => ({
        patchElement
      }),
      []
    );
    return /* @__PURE__ */ React99.createElement(React99.Fragment, null, elements);
  })
);
function useModal() {
  const holderRef = React99.useRef(null);
  const [actionQueue, setActionQueue] = React99.useState([]);
  React99.useEffect(() => {
    if (actionQueue.length) {
      const cloneQueue = [...actionQueue];
      cloneQueue.forEach((action) => {
        action();
      });
      setActionQueue([]);
    }
  }, [actionQueue]);
  const getConfirmFunc = React99.useCallback(
    (withFunc) => /* @__PURE__ */ __name(function hookConfirm(config) {
      uuid4 += 1;
      const modalRef = React99.createRef();
      let resolvePromise;
      const promise = new Promise((resolve) => {
        resolvePromise = resolve;
      });
      let silent = false;
      let closeFunc;
      const modal = /* @__PURE__ */ React99.createElement(
        HookModal_default,
        {
          key: `modal-${uuid4}`,
          config: withFunc(config),
          ref: modalRef,
          afterClose: () => {
            closeFunc?.();
          },
          isSilent: () => silent,
          onConfirm: (confirmed) => {
            resolvePromise(confirmed);
          }
        }
      );
      closeFunc = holderRef.current?.patchElement(modal);
      if (closeFunc) {
        destroyFns_default.push(closeFunc);
      }
      const instance = {
        destroy: () => {
          function destroyAction() {
            modalRef.current?.destroy();
          }
          __name(destroyAction, "destroyAction");
          if (modalRef.current) {
            destroyAction();
          } else {
            setActionQueue((prev2) => [...prev2, destroyAction]);
          }
        },
        update: (newConfig) => {
          function updateAction() {
            modalRef.current?.update(newConfig);
          }
          __name(updateAction, "updateAction");
          if (modalRef.current) {
            updateAction();
          } else {
            setActionQueue((prev2) => [...prev2, updateAction]);
          }
        },
        then: (resolve) => {
          silent = true;
          return promise.then(resolve);
        }
      };
      return instance;
    }, "hookConfirm"),
    []
  );
  const fns = React99.useMemo(
    () => ({
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    }),
    []
  );
  return [fns, /* @__PURE__ */ React99.createElement(ElementsHolder, { key: "modal-holder", ref: holderRef })];
}
__name(useModal, "useModal");
var useModal_default = useModal;

// packages/ant-design/components/notification/useNotification.tsx
var import_classnames24 = __toESM(require_classnames());
import React101, { useContext as useContext43 } from "react";

// packages/ant-design/components/notification/PurePanel.tsx
var import_CheckCircleFilled4 = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled4 = __toESM(require_CloseCircleFilled3());
var import_CloseOutlined6 = __toESM(require_CloseOutlined3());
var import_ExclamationCircleFilled4 = __toESM(require_ExclamationCircleFilled3());
var import_InfoCircleFilled4 = __toESM(require_InfoCircleFilled3());
import * as React100 from "react";
var import_classnames23 = __toESM(require_classnames());

// packages/ant-design/components/notification/style/placement.ts
var genNotificationPlacementStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, notificationMarginEdge, animationMaxHeight } = token2;
  const noticeCls = `${componentCls}-notice`;
  const rightFadeIn = new Keyframes_default("antNotificationFadeIn", {
    "0%": {
      transform: `translate3d(100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  const topFadeIn = new Keyframes_default("antNotificationTopFadeIn", {
    "0%": {
      top: -animationMaxHeight,
      opacity: 0
    },
    "100%": {
      top: 0,
      opacity: 1
    }
  });
  const bottomFadeIn = new Keyframes_default("antNotificationBottomFadeIn", {
    "0%": {
      bottom: token2.calc(animationMaxHeight).mul(-1).equal(),
      opacity: 0
    },
    "100%": {
      bottom: 0,
      opacity: 1
    }
  });
  const leftFadeIn = new Keyframes_default("antNotificationLeftFadeIn", {
    "0%": {
      transform: `translate3d(-100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  return {
    [componentCls]: {
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        marginInline: 0,
        [noticeCls]: {
          marginInline: "auto auto"
        }
      },
      [`&${componentCls}-top`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: topFadeIn
        }
      },
      [`&${componentCls}-bottom`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: bottomFadeIn
        }
      },
      [`&${componentCls}-topRight, &${componentCls}-bottomRight`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: rightFadeIn
        }
      },
      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
        marginRight: {
          value: 0,
          _skip_check_: true
        },
        marginLeft: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [noticeCls]: {
          marginInlineEnd: "auto",
          marginInlineStart: 0
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: leftFadeIn
        }
      }
    }
  };
}, "genNotificationPlacementStyle");
var placement_default = genNotificationPlacementStyle;

// packages/ant-design/components/notification/interface.ts
var NotificationPlacements = [
  "top",
  "topLeft",
  "topRight",
  "bottom",
  "bottomLeft",
  "bottomRight"
];

// packages/ant-design/components/notification/style/stack.ts
var placementAlignProperty = {
  topLeft: "left",
  topRight: "right",
  bottomLeft: "left",
  bottomRight: "right",
  top: "left",
  bottom: "left"
};
var genPlacementStackStyle = /* @__PURE__ */ __name((token2, placement) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-${placement}`]: {
      [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
        [placement.startsWith("top") ? "top" : "bottom"]: 0,
        [placementAlignProperty[placement]]: { value: 0, _skip_check_: true }
      }
    }
  };
}, "genPlacementStackStyle");
var genStackChildrenStyle = /* @__PURE__ */ __name((token2) => {
  const childrenStyle = {};
  for (let i = 1; i < token2.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      overflow: "hidden",
      [`& > ${token2.componentCls}-notice`]: {
        opacity: 0,
        transition: `opacity ${token2.motionDurationMid}`
      }
    };
  }
  return {
    [`&:not(:nth-last-child(-n+${token2.notificationStackLayer}))`]: {
      opacity: 0,
      overflow: "hidden",
      color: "transparent",
      pointerEvents: "none"
    },
    ...childrenStyle
  };
}, "genStackChildrenStyle");
var genStackedNoticeStyle = /* @__PURE__ */ __name((token2) => {
  const childrenStyle = {};
  for (let i = 1; i < token2.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      background: token2.colorBgBlur,
      backdropFilter: "blur(10px)",
      "-webkit-backdrop-filter": "blur(10px)"
    };
  }
  return {
    ...childrenStyle
  };
}, "genStackedNoticeStyle");
var genStackStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-stack`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        transition: `all ${token2.motionDurationSlow}, backdrop-filter 0s`,
        position: "absolute",
        ...genStackChildrenStyle(token2)
      }
    },
    [`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        ...genStackedNoticeStyle(token2)
      }
    },
    [`${componentCls}-stack${componentCls}-stack-expanded`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        "&:not(:nth-last-child(-n + 1))": {
          opacity: 1,
          overflow: "unset",
          color: "inherit",
          pointerEvents: "auto",
          [`& > ${token2.componentCls}-notice`]: {
            opacity: 1
          }
        },
        "&:after": {
          content: '""',
          position: "absolute",
          height: token2.margin,
          width: "100%",
          insetInline: 0,
          bottom: token2.calc(token2.margin).mul(-1).equal(),
          background: "transparent",
          pointerEvents: "auto"
        }
      }
    },
    ...NotificationPlacements.map((placement) => genPlacementStackStyle(token2, placement)).reduce(
      (acc, cur) => ({ ...acc, ...cur }),
      {}
    )
  };
}, "genStackStyle");
var stack_default = genStackStyle;

// packages/ant-design/components/notification/style/index.ts
var genNoticeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    iconCls,
    componentCls,
    // .ant-notification
    boxShadow,
    fontSizeLG,
    notificationMarginBottom,
    borderRadiusLG,
    colorSuccess,
    colorInfo,
    colorWarning,
    colorError,
    colorTextHeading,
    notificationBg,
    notificationPadding,
    notificationMarginEdge,
    fontSize,
    lineHeight,
    width,
    notificationIconSize,
    colorText
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  return {
    position: "relative",
    marginBottom: notificationMarginBottom,
    marginInlineStart: "auto",
    background: notificationBg,
    borderRadius: borderRadiusLG,
    boxShadow,
    [noticeCls]: {
      padding: notificationPadding,
      width,
      maxWidth: `calc(100vw - ${unit(token2.calc(notificationMarginEdge).mul(2).equal())})`,
      overflow: "hidden",
      lineHeight,
      wordWrap: "break-word"
    },
    [`${noticeCls}-message`]: {
      marginBottom: token2.marginXS,
      color: colorTextHeading,
      fontSize: fontSizeLG,
      lineHeight: token2.lineHeightLG
    },
    [`${noticeCls}-description`]: {
      fontSize,
      color: colorText
    },
    [`${noticeCls}-closable ${noticeCls}-message`]: {
      paddingInlineEnd: token2.paddingLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-message`]: {
      marginBottom: token2.marginXS,
      marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
      fontSize: fontSizeLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-description`]: {
      marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
      fontSize
    },
    // Icon & color style in different selector level
    // https://github.com/ant-design/ant-design/issues/16503
    // https://github.com/ant-design/ant-design/issues/15512
    [`${noticeCls}-icon`]: {
      position: "absolute",
      fontSize: notificationIconSize,
      lineHeight: 1,
      // icon-font
      [`&-success${iconCls}`]: {
        color: colorSuccess
      },
      [`&-info${iconCls}`]: {
        color: colorInfo
      },
      [`&-warning${iconCls}`]: {
        color: colorWarning
      },
      [`&-error${iconCls}`]: {
        color: colorError
      }
    },
    [`${noticeCls}-close`]: {
      position: "absolute",
      top: token2.notificationPaddingVertical,
      insetInlineEnd: token2.notificationPaddingHorizontal,
      color: token2.colorIcon,
      outline: "none",
      width: token2.notificationCloseButtonSize,
      height: token2.notificationCloseButtonSize,
      borderRadius: token2.borderRadiusSM,
      transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      "&:hover": {
        color: token2.colorIconHover,
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      },
      ...genFocusStyle(token2)
    },
    [`${noticeCls}-btn`]: {
      float: "right",
      marginTop: token2.marginSM
    }
  };
}, "genNoticeStyle");
var genNotificationStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    // .ant-notification
    notificationMarginBottom,
    notificationMarginEdge,
    motionDurationMid,
    motionEaseInOut
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const fadeOut2 = new Keyframes_default("antNotificationFadeOut", {
    "0%": {
      maxHeight: token2.animationMaxHeight,
      marginBottom: notificationMarginBottom
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "fixed",
        zIndex: token2.zIndexPopup,
        marginRight: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [`${componentCls}-hook-holder`]: {
          position: "relative"
        },
        //  animation
        [`${componentCls}-fade-appear-prepare`]: {
          opacity: "0 !important"
        },
        [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-leave`]: {
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          animationDuration: motionDurationMid,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationPlayState: "running"
        },
        [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
          animationName: fadeOut2,
          animationPlayState: "running"
        },
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${noticeCls}-btn`]: {
            float: "left"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: {
          ...genNoticeStyle(token2)
        }
      }
    }
  ];
}, "genNotificationStyle");
var prepareComponentToken7 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
  width: 384
}), "prepareComponentToken");
var prepareNotificationToken = /* @__PURE__ */ __name((token2) => {
  const notificationPaddingVertical = token2.paddingMD;
  const notificationPaddingHorizontal = token2.paddingLG;
  const notificationToken = merge2(token2, {
    notificationBg: token2.colorBgElevated,
    notificationPaddingVertical,
    notificationPaddingHorizontal,
    notificationIconSize: token2.calc(token2.fontSizeLG).mul(token2.lineHeightLG).equal(),
    notificationCloseButtonSize: token2.calc(token2.controlHeightLG).mul(0.55).equal(),
    notificationMarginBottom: token2.margin,
    notificationPadding: `${unit(token2.paddingMD)} ${unit(token2.paddingContentHorizontalLG)}`,
    notificationMarginEdge: token2.marginLG,
    animationMaxHeight: 150,
    notificationStackLayer: 3
  });
  return notificationToken;
}, "prepareNotificationToken");
var style_default9 = genStyleHooks(
  "Notification",
  (token2) => {
    const notificationToken = prepareNotificationToken(token2);
    return [
      genNotificationStyle(notificationToken),
      placement_default(notificationToken),
      stack_default(notificationToken)
    ];
  },
  prepareComponentToken7
);

// packages/ant-design/components/notification/style/pure-panel.ts
var pure_panel_default = genSubStyleComponent(
  ["Notification", "PurePanel"],
  (token2) => {
    const noticeCls = `${token2.componentCls}-notice`;
    const notificationToken = prepareNotificationToken(token2);
    return {
      [`${noticeCls}-pure-panel`]: {
        ...genNoticeStyle(notificationToken),
        width: notificationToken.width,
        maxWidth: `calc(100vw - ${unit(
          token2.calc(notificationToken.notificationMarginEdge).mul(2).equal()
        )})`,
        margin: 0
      }
    };
  },
  prepareComponentToken7
);

// packages/ant-design/components/notification/PurePanel.tsx
function getCloseIcon(prefixCls, closeIcon) {
  if (closeIcon === null || closeIcon === false) {
    return null;
  }
  return closeIcon || /* @__PURE__ */ React100.createElement(import_CloseOutlined6.default, { className: `${prefixCls}-close-icon` });
}
__name(getCloseIcon, "getCloseIcon");
var typeToIcon = {
  success: import_CheckCircleFilled4.default,
  info: import_InfoCircleFilled4.default,
  error: import_CloseCircleFilled4.default,
  warning: import_ExclamationCircleFilled4.default
};
var PureContent2 = /* @__PURE__ */ __name((props) => {
  const { prefixCls, icon, type: type5, message: message2, description, btn, role = "alert" } = props;
  let iconNode = null;
  if (icon) {
    iconNode = /* @__PURE__ */ React100.createElement("span", { className: `${prefixCls}-icon` }, icon);
  } else if (type5) {
    iconNode = React100.createElement(typeToIcon[type5] || null, {
      className: (0, import_classnames23.default)(`${prefixCls}-icon`, `${prefixCls}-icon-${type5}`)
    });
  }
  return /* @__PURE__ */ React100.createElement("div", { className: (0, import_classnames23.default)({ [`${prefixCls}-with-icon`]: iconNode }), role }, iconNode, /* @__PURE__ */ React100.createElement("div", { className: `${prefixCls}-message` }, message2), /* @__PURE__ */ React100.createElement("div", { className: `${prefixCls}-description` }, description), btn && /* @__PURE__ */ React100.createElement("div", { className: `${prefixCls}-btn` }, btn));
}, "PureContent");
var PurePanel2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: staticPrefixCls,
    className,
    icon,
    type: type5,
    message: message2,
    description,
    btn,
    closable = true,
    closeIcon,
    className: notificationClassName,
    ...restProps
  } = props;
  const { getPrefixCls } = React100.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const noticePrefixCls = `${prefixCls}-notice`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default9(prefixCls, rootCls);
  return wrapCSSVar(
    /* @__PURE__ */ React100.createElement(
      "div",
      {
        className: (0, import_classnames23.default)(`${noticePrefixCls}-pure-panel`, hashId, className, cssVarCls, rootCls)
      },
      /* @__PURE__ */ React100.createElement(pure_panel_default, { prefixCls }),
      /* @__PURE__ */ React100.createElement(
        Notice_default,
        {
          ...restProps,
          prefixCls,
          eventKey: "pure",
          duration: null,
          closable,
          className: (0, import_classnames23.default)({
            notificationClassName
          }),
          closeIcon: getCloseIcon(prefixCls, closeIcon),
          content: /* @__PURE__ */ React100.createElement(
            PureContent2,
            {
              prefixCls: noticePrefixCls,
              icon,
              type: type5,
              message: message2,
              description,
              btn
            }
          )
        }
      )
    )
  );
}, "PurePanel");
var PurePanel_default2 = PurePanel2;

// packages/ant-design/components/notification/util.ts
function getPlacementStyle(placement, top, bottom) {
  let style2;
  switch (placement) {
    case "top":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style2 = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style2 = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
__name(getPlacementStyle, "getPlacementStyle");
function getMotion2(prefixCls) {
  return {
    motionName: `${prefixCls}-fade`
  };
}
__name(getMotion2, "getMotion");

// packages/ant-design/components/notification/useNotification.tsx
var DEFAULT_OFFSET3 = 24;
var DEFAULT_DURATION2 = 4.5;
var DEFAULT_PLACEMENT = "topRight";
var Wrapper2 = /* @__PURE__ */ __name(({ children, prefixCls }) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default9(prefixCls, rootCls);
  return wrapCSSVar(
    /* @__PURE__ */ React101.createElement(NotificationProvider_default, { classNames: { list: (0, import_classnames24.default)(hashId, cssVarCls, rootCls) } }, children)
  );
}, "Wrapper");
var renderNotifications2 = /* @__PURE__ */ __name((node2, { prefixCls, key }) => /* @__PURE__ */ React101.createElement(Wrapper2, { prefixCls, key }, node2), "renderNotifications");
var Holder2 = React101.forwardRef((props, ref) => {
  const {
    top,
    bottom,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    rtl,
    onAllRemoved,
    stack,
    duration
  } = props;
  const { getPrefixCls, getPopupContainer, notification: notification2, direction } = useContext43(ConfigContext);
  const [, token2] = useToken();
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const getStyle4 = /* @__PURE__ */ __name((placement) => getPlacementStyle(placement, top ?? DEFAULT_OFFSET3, bottom ?? DEFAULT_OFFSET3), "getStyle");
  const getClassName = /* @__PURE__ */ __name(() => (0, import_classnames24.default)({ [`${prefixCls}-rtl`]: rtl ?? direction === "rtl" }), "getClassName");
  const getNotificationMotion = /* @__PURE__ */ __name(() => getMotion2(prefixCls), "getNotificationMotion");
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle4,
    className: getClassName,
    motion: getNotificationMotion,
    closable: true,
    closeIcon: getCloseIcon(prefixCls),
    duration: duration ?? DEFAULT_DURATION2,
    getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
    maxCount,
    onAllRemoved,
    renderNotifications: renderNotifications2,
    stack: stack === false ? false : {
      threshold: typeof stack === "object" ? stack?.threshold : void 0,
      offset: 8,
      gap: token2.margin
    }
  });
  React101.useImperativeHandle(ref, () => ({ ...api, prefixCls, notification: notification2 }));
  return holder;
});
function useInternalNotification(notificationConfig) {
  const holderRef = React101.useRef(null);
  const warning5 = devUseWarning("Notification");
  const wrapAPI = React101.useMemo(() => {
    const open3 = /* @__PURE__ */ __name((config) => {
      if (!holderRef.current) {
        warning5(
          false,
          "usage",
          "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead."
        );
        return;
      }
      const { open: originOpen, prefixCls, notification: notification2 } = holderRef.current;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        message: message2,
        description,
        icon,
        type: type5,
        btn,
        className,
        style: style2,
        role = "alert",
        closeIcon,
        closable,
        ...restConfig
      } = config;
      const realCloseIcon = getCloseIcon(
        noticePrefixCls,
        typeof closeIcon !== "undefined" ? closeIcon : notification2?.closeIcon
      );
      return originOpen({
        // use placement from props instead of hard-coding "topRight"
        placement: notificationConfig?.placement ?? DEFAULT_PLACEMENT,
        ...restConfig,
        content: /* @__PURE__ */ React101.createElement(
          PureContent2,
          {
            prefixCls: noticePrefixCls,
            icon,
            type: type5,
            message: message2,
            description,
            btn,
            role
          }
        ),
        className: (0, import_classnames24.default)(
          type5 && `${noticePrefixCls}-${type5}`,
          className,
          notification2?.className
        ),
        style: { ...notification2?.style, ...style2 },
        closeIcon: realCloseIcon,
        closable: closable ?? !!realCloseIcon
      });
    }, "open");
    const destroy3 = /* @__PURE__ */ __name((key) => {
      if (key !== void 0) {
        holderRef.current?.close(key);
      } else {
        holderRef.current?.destroy();
      }
    }, "destroy");
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys2 = ["success", "info", "warning", "error"];
    keys2.forEach((type5) => {
      clone[type5] = (config) => open3({
        ...config,
        type: type5
      });
    });
    return clone;
  }, []);
  return [
    wrapAPI,
    /* @__PURE__ */ React101.createElement(Holder2, { key: "notification-holder", ...notificationConfig, ref: holderRef })
  ];
}
__name(useInternalNotification, "useInternalNotification");
function useNotification2(notificationConfig) {
  return useInternalNotification(notificationConfig);
}
__name(useNotification2, "useNotification");

// packages/ant-design/components/app/context.ts
import React102 from "react";
var AppConfigContext = React102.createContext({});
var AppContext = React102.createContext({
  message: {},
  notification: {},
  modal: {}
});
var context_default4 = AppContext;

// packages/ant-design/components/app/style/index.ts
var genBaseStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, colorText, fontSize, lineHeight, fontFamily } = token2;
  return {
    [componentCls]: {
      color: colorText,
      fontSize,
      lineHeight,
      fontFamily
    }
  };
}, "genBaseStyle");
var prepareComponentToken8 = /* @__PURE__ */ __name(() => ({}), "prepareComponentToken");
var style_default10 = genStyleHooks("App", genBaseStyle2, prepareComponentToken8);

// packages/ant-design/components/app/index.tsx
var useApp = /* @__PURE__ */ __name(() => React103.useContext(context_default4), "useApp");
var App = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    className,
    rootClassName,
    message: message2,
    notification: notification2,
    style: style2,
    component = "div"
  } = props;
  const { getPrefixCls } = useContext44(ConfigContext);
  const prefixCls = getPrefixCls("app", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default10(prefixCls);
  const customClassName = (0, import_classnames25.default)(hashId, prefixCls, className, rootClassName, cssVarCls);
  const appConfig = useContext44(AppConfigContext);
  const mergedAppConfig = React103.useMemo(
    () => ({
      message: { ...appConfig.message, ...message2 },
      notification: { ...appConfig.notification, ...notification2 }
    }),
    [message2, notification2, appConfig.message, appConfig.notification]
  );
  const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
  const [notificationApi, notificationContextHolder] = useNotification2(
    mergedAppConfig.notification
  );
  const [ModalApi, ModalContextHolder] = useModal_default();
  const memoizedContextValue = React103.useMemo(
    () => ({
      message: messageApi,
      notification: notificationApi,
      modal: ModalApi
    }),
    [messageApi, notificationApi, ModalApi]
  );
  const Component11 = component === false ? React103.Fragment : component;
  const rootProps = {
    className: customClassName,
    style: style2
  };
  return wrapCSSVar(
    /* @__PURE__ */ React103.createElement(context_default4.Provider, { value: memoizedContextValue }, /* @__PURE__ */ React103.createElement(AppConfigContext.Provider, { value: mergedAppConfig }, /* @__PURE__ */ React103.createElement(Component11, { ...component === false ? void 0 : rootProps }, ModalContextHolder, messageContextHolder, notificationContextHolder, children)))
  );
}, "App");
if (true) {
  App.displayName = "App";
}
App.useApp = useApp;
var app_default = App;

// packages/ant-design/components/auto-complete/index.tsx
var import_classnames45 = __toESM(require_classnames());
import * as React162 from "react";

// packages/ant-design/components/_util/PurePanel.tsx
import * as React104 from "react";
function withPureRenderTheme(Component11) {
  return (props) => /* @__PURE__ */ React104.createElement(config_provider_default, { theme: { token: { motion: false, zIndexPopupBase: 0 } } }, /* @__PURE__ */ React104.createElement(Component11, { ...props }));
}
__name(withPureRenderTheme, "withPureRenderTheme");
var genPurePanel = /* @__PURE__ */ __name((Component11, defaultPrefixCls2, getDropdownCls, postProps) => {
  const PurePanel19 = /* @__PURE__ */ __name((props) => {
    const { prefixCls: customizePrefixCls, style: style2 } = props;
    const holderRef = React104.useRef(null);
    const [popupHeight, setPopupHeight] = React104.useState(0);
    const [popupWidth, setPopupWidth] = React104.useState(0);
    const [open3, setOpen] = useMergedState(false, {
      value: props.open
    });
    const { getPrefixCls } = React104.useContext(ConfigContext);
    const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
    React104.useEffect(() => {
      setOpen(true);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver2 = new ResizeObserver((entries) => {
          const element = entries[0].target;
          setPopupHeight(element.offsetHeight + 8);
          setPopupWidth(element.offsetWidth);
        });
        const interval = setInterval(() => {
          const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
          const popup = holderRef.current?.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver2.observe(popup);
          }
        }, 10);
        return () => {
          clearInterval(interval);
          resizeObserver2.disconnect();
        };
      }
    }, []);
    let mergedProps = {
      ...props,
      style: {
        ...style2,
        margin: 0
      },
      open: open3,
      visible: open3,
      getPopupContainer: () => holderRef.current
    };
    if (postProps) {
      mergedProps = postProps(mergedProps);
    }
    const mergedStyle = {
      paddingBottom: popupHeight,
      position: "relative",
      minWidth: popupWidth
    };
    return /* @__PURE__ */ React104.createElement("div", { ref: holderRef, style: mergedStyle }, /* @__PURE__ */ React104.createElement(Component11, { ...mergedProps }));
  }, "PurePanel");
  return withPureRenderTheme(PurePanel19);
}, "genPurePanel");
var PurePanel_default3 = genPurePanel;

// packages/ant-design/components/select/index.tsx
var import_classnames44 = __toESM(require_classnames());
import * as React161 from "react";

// packages/select/src/Select.tsx
init_warning();
import * as React155 from "react";

// packages/select/src/BaseSelect.tsx
var import_classnames37 = __toESM(require_classnames());

// packages/util/src/isMobile.ts
var isMobile_default = /* @__PURE__ */ __name(() => {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
    agent
  ) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
    agent?.substr(0, 4)
  );
}, "default");

// packages/select/src/BaseSelect.tsx
import * as React137 from "react";

// packages/select/src/TransBtn.tsx
var import_classnames26 = __toESM(require_classnames());
import * as React105 from "react";
var TransBtn = /* @__PURE__ */ __name((props) => {
  const { className, customizeIcon, customizeIconProps, children, onMouseDown, onClick } = props;
  const icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
  return /* @__PURE__ */ React105.createElement(
    "span",
    {
      className,
      onMouseDown: (event) => {
        event.preventDefault();
        onMouseDown?.(event);
      },
      style: { userSelect: "none", WebkitUserSelect: "none" },
      unselectable: "on",
      onClick,
      "aria-hidden": true
    },
    icon !== void 0 ? icon : /* @__PURE__ */ React105.createElement("span", { className: (0, import_classnames26.default)(className.split(/\s+/).map((cls5) => `${cls5}-icon`)) }, children)
  );
}, "TransBtn");
var TransBtn_default = TransBtn;

// packages/select/src/hooks/useAllowClear.tsx
import React106 from "react";
var useAllowClear = /* @__PURE__ */ __name((prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode) => {
  const mergedClearIcon = React106.useMemo(() => {
    if (typeof allowClear === "object") {
      return allowClear.clearIcon;
    }
    if (clearIcon) {
      return clearIcon;
    }
  }, [allowClear, clearIcon]);
  const mergedAllowClear = React106.useMemo(() => {
    if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
      return true;
    }
    return false;
  }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
  return {
    allowClear: mergedAllowClear,
    clearIcon: /* @__PURE__ */ React106.createElement(
      TransBtn_default,
      {
        className: `${prefixCls}-clear`,
        onMouseDown: onClearMouseDown,
        customizeIcon: mergedClearIcon
      },
      "\xD7"
    )
  };
}, "useAllowClear");

// packages/select/src/hooks/useBaseProps.ts
import * as React107 from "react";
var BaseSelectContext = React107.createContext(null);
function useBaseProps() {
  return React107.useContext(BaseSelectContext);
}
__name(useBaseProps, "useBaseProps");

// packages/select/src/hooks/useDelayReset.ts
import * as React108 from "react";
function useDelayReset(timeout = 10) {
  const [bool, setBool] = React108.useState(false);
  const delayRef = React108.useRef(null);
  const cancelLatest = /* @__PURE__ */ __name(() => {
    window.clearTimeout(delayRef.current);
  }, "cancelLatest");
  React108.useEffect(() => cancelLatest, []);
  const delaySetBool = /* @__PURE__ */ __name((value, callback) => {
    cancelLatest();
    delayRef.current = window.setTimeout(() => {
      setBool(value);
      if (callback) {
        callback();
      }
    }, timeout);
  }, "delaySetBool");
  return [bool, delaySetBool, cancelLatest];
}
__name(useDelayReset, "useDelayReset");

// packages/select/src/hooks/useLock.ts
import * as React109 from "react";
function useLock(duration = 250) {
  const lockRef = React109.useRef(null);
  const timeoutRef = React109.useRef(null);
  React109.useEffect(
    () => () => {
      window.clearTimeout(timeoutRef.current);
    },
    []
  );
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(() => {
      lockRef.current = null;
    }, duration);
  }
  __name(doLock, "doLock");
  return [() => lockRef.current, doLock];
}
__name(useLock, "useLock");

// packages/select/src/hooks/useSelectTriggerControl.ts
import * as React110 from "react";
function useSelectTriggerControl(elements, open3, triggerOpen, customizedTrigger) {
  const propsRef = React110.useRef(null);
  propsRef.current = {
    open: open3,
    triggerOpen,
    customizedTrigger
  };
  React110.useEffect(() => {
    function onGlobalMouseDown(event) {
      if (propsRef.current?.customizedTrigger) {
        return;
      }
      let target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      if (propsRef.current.open && elements().filter((element) => element).every((element) => !element.contains(target) && element !== target)) {
        propsRef.current.triggerOpen(false);
      }
    }
    __name(onGlobalMouseDown, "onGlobalMouseDown");
    window.addEventListener("mousedown", onGlobalMouseDown);
    return () => window.removeEventListener("mousedown", onGlobalMouseDown);
  }, []);
}
__name(useSelectTriggerControl, "useSelectTriggerControl");

// packages/select/src/Selector/index.tsx
import * as React120 from "react";
import { useRef as useRef41 } from "react";

// packages/select/src/utils/keyUtil.ts
function isValidateOpenKey(currentKeyCode) {
  return ![
    // System function button
    KeyCode_default.ESC,
    KeyCode_default.SHIFT,
    KeyCode_default.BACKSPACE,
    KeyCode_default.TAB,
    KeyCode_default.WIN_KEY,
    KeyCode_default.ALT,
    KeyCode_default.META,
    KeyCode_default.WIN_KEY_RIGHT,
    KeyCode_default.CTRL,
    KeyCode_default.SEMICOLON,
    KeyCode_default.EQUALS,
    KeyCode_default.CAPS_LOCK,
    KeyCode_default.CONTEXT_MENU,
    // F1-F12
    KeyCode_default.F1,
    KeyCode_default.F2,
    KeyCode_default.F3,
    KeyCode_default.F4,
    KeyCode_default.F5,
    KeyCode_default.F6,
    KeyCode_default.F7,
    KeyCode_default.F8,
    KeyCode_default.F9,
    KeyCode_default.F10,
    KeyCode_default.F11,
    KeyCode_default.F12
  ].includes(currentKeyCode);
}
__name(isValidateOpenKey, "isValidateOpenKey");

// packages/select/src/Selector/MultipleSelector.tsx
var import_classnames31 = __toESM(require_classnames());
import * as React118 from "react";
import { useState as useState26 } from "react";

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");

// node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/Overflow.js
var import_classnames29 = __toESM(require_classnames());
import * as React115 from "react";
import { useState as useState25, useMemo as useMemo24, useCallback as useCallback10 } from "react";

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/Item.js
var import_classnames27 = __toESM(require_classnames());
import * as React111 from "react";
var _excluded = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = void 0;
function InternalItem(props, ref) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem2 = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey3 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component11 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey3, width);
  }
  __name(internalRegisterSize, "internalRegisterSize");
  React111.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem2 && item !== UNDEFINED ? renderItem2(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ React111.createElement(Component11, _extends({
    className: (0, import_classnames27.default)(!invalidate && prefixCls, className),
    style: _objectSpread2(_objectSpread2({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ React111.createElement(src_default, {
      onResize: /* @__PURE__ */ __name(function onResize2(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      }, "onResize"),
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
__name(InternalItem, "InternalItem");
var Item = /* @__PURE__ */ React111.forwardRef(InternalItem);
Item.displayName = "Item";
var Item_default = Item;

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/hooks/useEffectState.js
import * as React112 from "react";
import { unstable_batchedUpdates } from "react-dom";

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/hooks/channelUpdate.js
function channelUpdate(callback) {
  if (typeof MessageChannel === "undefined") {
    raf_default(callback);
  } else {
    var channel = new MessageChannel();
    channel.port1.onmessage = function() {
      return callback();
    };
    channel.port2.postMessage(void 0);
  }
}
__name(channelUpdate, "channelUpdate");

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/hooks/useEffectState.js
function useBatcher() {
  var updateFuncRef = React112.useRef(null);
  var notifyEffectUpdate = /* @__PURE__ */ __name(function notifyEffectUpdate2(callback) {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate(function() {
        unstable_batchedUpdates(function() {
          updateFuncRef.current.forEach(function(fn) {
            fn();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  }, "notifyEffectUpdate");
  return notifyEffectUpdate;
}
__name(useBatcher, "useBatcher");
function useEffectState(notifyEffectUpdate, defaultValue) {
  var _React$useState = React112.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
  var setEffectVal = useEvent(function(nextValue) {
    notifyEffectUpdate(function() {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}
__name(useEffectState, "useEffectState");

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/RawItem.js
var import_classnames28 = __toESM(require_classnames());
import * as React114 from "react";

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/context.js
import React113 from "react";
var OverflowContext = /* @__PURE__ */ React113.createContext(null);

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/RawItem.js
var _excluded2 = ["component"];
var _excluded22 = ["className"];
var _excluded3 = ["className"];
var InternalRawItem = /* @__PURE__ */ __name(function InternalRawItem2(props, ref) {
  var context = React114.useContext(OverflowContext);
  if (!context) {
    var _props$component = props.component, Component11 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded2);
    return /* @__PURE__ */ React114.createElement(Component11, _extends({}, _restProps, {
      ref
    }));
  }
  var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded22);
  var className = props.className, restProps = _objectWithoutProperties(props, _excluded3);
  return /* @__PURE__ */ React114.createElement(OverflowContext.Provider, {
    value: null
  }, /* @__PURE__ */ React114.createElement(Item_default, _extends({
    ref,
    className: (0, import_classnames28.default)(contextClassName, className)
  }, restContext, restProps)));
}, "InternalRawItem");
var RawItem = /* @__PURE__ */ React114.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var RawItem_default = RawItem;

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/Overflow.js
var _excluded4 = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
__name(defaultRenderRest, "defaultRenderRest");
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem2 = props.renderItem, renderRawItem = props.renderRawItem, itemKey3 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component11 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded4);
  var fullySSR = ssr === "full";
  var notifyEffectUpdate = useBatcher();
  var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
  var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
  var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
  var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
  var _useState = useState25(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = useState25(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = React115.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = useState25(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
  var mergedData = useMemo24(function() {
    var items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = useMemo24(function() {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey4 = useCallback10(function(item, index3) {
    var _ref;
    if (typeof itemKey3 === "function") {
      return itemKey3(item);
    }
    return (_ref = itemKey3 && (item === null || item === void 0 ? void 0 : item[itemKey3])) !== null && _ref !== void 0 ? _ref : index3;
  }, [itemKey3]);
  var mergedRenderItem = useCallback10(renderItem2 || function(item) {
    return item;
  }, [renderItem2]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  __name(updateDisplayCount, "updateDisplayCount");
  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  __name(onOverflowResize, "onOverflowResize");
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  }
  __name(registerSize, "registerSize");
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  __name(registerOverflowSize, "registerOverflowSize");
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  }
  __name(registerSuffixSize, "registerSuffixSize");
  function getItemWidth(index3) {
    return itemWidths.get(getKey4(mergedData[index3], index3));
  }
  __name(getItemWidth, "getItemWidth");
  useLayoutEffect_default(function() {
    if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (
          // Only one means `totalWidth` is the final width
          lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
          i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
        ) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey4, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index3) {
    var key = getKey4(item, index3);
    return /* @__PURE__ */ React115.createElement(OverflowContext.Provider, {
      key,
      value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
        order: index3,
        item,
        itemKey: key,
        registerSize,
        display: index3 <= mergedDisplayCount
      })
    }, renderRawItem(item, index3));
  } : function(item, index3) {
    var key = getKey4(item, index3);
    return /* @__PURE__ */ React115.createElement(Item_default, _extends({}, itemSharedProps, {
      order: index3,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index3 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /* @__PURE__ */ React115.createElement(Item_default, _extends({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ React115.createElement(OverflowContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ React115.createElement(Component11, _extends({
    className: (0, import_classnames29.default)(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ React115.createElement(Item_default, _extends({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ React115.createElement(src_default, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
__name(Overflow, "Overflow");
var ForwardOverflow = /* @__PURE__ */ React115.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem_default;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var Overflow_default = ForwardOverflow;

// node_modules/.pnpm/rc-overflow@1.3.2_react-dom@18.2.0_react@18.2.0/node_modules/rc-overflow/es/index.js
var es_default3 = Overflow_default;

// packages/select/src/Selector/Input.tsx
var import_classnames30 = __toESM(require_classnames());
import * as React116 from "react";
init_warning();
var Input = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls,
    id,
    inputElement,
    disabled,
    tabIndex,
    autoFocus,
    autoComplete,
    editable,
    activeDescendantId,
    value,
    maxLength,
    onKeyDown: onKeyDown2,
    onMouseDown,
    onChange,
    onPaste,
    onCompositionStart,
    onCompositionEnd,
    open: open3,
    attrs
  } = props;
  let inputNode = inputElement || /* @__PURE__ */ React116.createElement("input", null);
  const { ref: originRef, props: originProps } = inputNode;
  const {
    onKeyDown: onOriginKeyDown,
    onChange: onOriginChange,
    onMouseDown: onOriginMouseDown,
    onCompositionStart: onOriginCompositionStart,
    onCompositionEnd: onOriginCompositionEnd,
    style: style2
  } = originProps;
  warning(
    !("maxLength" in inputNode.props),
    `Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled.`
  );
  inputNode = React116.cloneElement(inputNode, {
    type: "search",
    ...originProps,
    // Override over origin props
    id,
    ref: composeRef(ref, originRef),
    disabled,
    tabIndex,
    autoComplete: autoComplete || "off",
    autoFocus,
    className: (0, import_classnames30.default)(`${prefixCls}-selection-search-input`, inputNode?.props?.className),
    role: "combobox",
    "aria-expanded": open3 || false,
    "aria-haspopup": "listbox",
    "aria-owns": `${id}_list`,
    "aria-autocomplete": "list",
    "aria-controls": `${id}_list`,
    "aria-activedescendant": open3 ? activeDescendantId : void 0,
    ...attrs,
    value: editable ? value : "",
    maxLength,
    readOnly: !editable,
    unselectable: !editable ? "on" : null,
    style: { ...style2, opacity: editable ? null : 0 },
    onKeyDown: (event) => {
      onKeyDown2(event);
      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: (event) => {
      onMouseDown(event);
      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: (event) => {
      onChange(event);
      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart(event) {
      onCompositionStart(event);
      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd(event) {
      onCompositionEnd(event);
      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste
  });
  return inputNode;
}, "Input");
var RefInput = React116.forwardRef(Input);
if (true) {
  RefInput.displayName = "Input";
}
var Input_default = RefInput;

// packages/select/src/hooks/useLayoutEffect.ts
import * as React117 from "react";

// packages/select/src/utils/commonUtil.ts
function toArray3(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
__name(toArray3, "toArray");
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
var isBrowserClient = isClient;
function hasValue2(value) {
  return value !== void 0 && value !== null;
}
__name(hasValue2, "hasValue");
function isComboNoValue(value) {
  return !value && value !== 0;
}
__name(isComboNoValue, "isComboNoValue");
function isTitleType(title) {
  return ["string", "number"].includes(typeof title);
}
__name(isTitleType, "isTitleType");
function getTitle(item) {
  let title = void 0;
  if (item) {
    if (isTitleType(item.title)) {
      title = item.title.toString();
    } else if (isTitleType(item.label)) {
      title = item.label.toString();
    }
  }
  return title;
}
__name(getTitle, "getTitle");

// packages/select/src/hooks/useLayoutEffect.ts
function useLayoutEffect5(effect, deps) {
  if (isBrowserClient) {
    React117.useLayoutEffect(effect, deps);
  } else {
    React117.useEffect(effect, deps);
  }
}
__name(useLayoutEffect5, "useLayoutEffect");

// packages/select/src/Selector/MultipleSelector.tsx
function itemKey(value) {
  return value.key ?? value.value;
}
__name(itemKey, "itemKey");
var onPreventMouseDown = /* @__PURE__ */ __name((event) => {
  event.preventDefault();
  event.stopPropagation();
}, "onPreventMouseDown");
var SelectSelector = /* @__PURE__ */ __name((props) => {
  const {
    id,
    prefixCls,
    values,
    open: open3,
    searchValue,
    autoClearSearchValue,
    inputRef,
    placeholder,
    disabled,
    mode,
    showSearch,
    autoFocus,
    autoComplete,
    activeDescendantId,
    tabIndex,
    removeIcon,
    maxTagCount,
    maxTagTextLength,
    maxTagPlaceholder = /* @__PURE__ */ __name((omittedValues) => `+ ${omittedValues.length} ...`, "maxTagPlaceholder"),
    tagRender,
    onToggleOpen,
    onRemove,
    onInputChange,
    onInputPaste,
    onInputKeyDown,
    onInputMouseDown,
    onInputCompositionStart,
    onInputCompositionEnd
  } = props;
  const measureRef = React118.useRef(null);
  const [inputWidth, setInputWidth] = useState26(0);
  const [focused, setFocused] = useState26(false);
  const selectionPrefixCls = `${prefixCls}-selection`;
  const inputValue = open3 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
  const inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open3 || focused);
  useLayoutEffect5(() => {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]);
  const defaultRenderSelector = /* @__PURE__ */ __name((item, content, itemDisabled, closable, onClose) => /* @__PURE__ */ React118.createElement(
    "span",
    {
      title: getTitle(item),
      className: (0, import_classnames31.default)(`${selectionPrefixCls}-item`, {
        [`${selectionPrefixCls}-item-disabled`]: itemDisabled
      })
    },
    /* @__PURE__ */ React118.createElement("span", { className: `${selectionPrefixCls}-item-content` }, content),
    closable && /* @__PURE__ */ React118.createElement(
      TransBtn_default,
      {
        className: `${selectionPrefixCls}-item-remove`,
        onMouseDown: onPreventMouseDown,
        onClick: onClose,
        customizeIcon: removeIcon
      },
      "\xD7"
    )
  ), "defaultRenderSelector");
  const customizeRenderSelector = /* @__PURE__ */ __name((value, content, itemDisabled, closable, onClose) => {
    const onMouseDown = /* @__PURE__ */ __name((e3) => {
      onPreventMouseDown(e3);
      onToggleOpen(!open3);
    }, "onMouseDown");
    return /* @__PURE__ */ React118.createElement("span", { onMouseDown }, tagRender({ label: content, value, disabled: itemDisabled, closable, onClose }));
  }, "customizeRenderSelector");
  const renderItem2 = /* @__PURE__ */ __name((valueItem) => {
    const { disabled: itemDisabled, label, value } = valueItem;
    const closable = !disabled && !itemDisabled;
    let displayLabel = label;
    if (typeof maxTagTextLength === "number") {
      if (typeof label === "string" || typeof label === "number") {
        const strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
        }
      }
    }
    const onClose = /* @__PURE__ */ __name((event) => {
      if (event) {
        event.stopPropagation();
      }
      onRemove(valueItem);
    }, "onClose");
    return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  }, "renderItem");
  const renderRest = /* @__PURE__ */ __name((omittedValues) => {
    const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector({ title: content }, content, false);
  }, "renderRest");
  const inputNode = /* @__PURE__ */ React118.createElement(
    "div",
    {
      className: `${selectionPrefixCls}-search`,
      style: { width: inputWidth },
      onFocus: () => {
        setFocused(true);
      },
      onBlur: () => {
        setFocused(false);
      }
    },
    /* @__PURE__ */ React118.createElement(
      Input_default,
      {
        ref: inputRef,
        open: open3,
        prefixCls,
        id,
        inputElement: null,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: onInputChange,
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        tabIndex,
        attrs: pickAttrs(props, true)
      }
    ),
    /* @__PURE__ */ React118.createElement("span", { ref: measureRef, className: `${selectionPrefixCls}-search-mirror`, "aria-hidden": true }, inputValue, "\xA0")
  );
  const selectionNode = /* @__PURE__ */ React118.createElement(
    es_default3,
    {
      prefixCls: `${selectionPrefixCls}-overflow`,
      data: values,
      renderItem: renderItem2,
      renderRest,
      suffix: inputNode,
      itemKey,
      maxCount: maxTagCount
    }
  );
  return /* @__PURE__ */ React118.createElement(React118.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ React118.createElement("span", { className: `${selectionPrefixCls}-placeholder` }, placeholder));
}, "SelectSelector");
var MultipleSelector_default = SelectSelector;

// packages/select/src/Selector/SingleSelector.tsx
import * as React119 from "react";
var SingleSelector = /* @__PURE__ */ __name((props) => {
  const {
    inputElement,
    prefixCls,
    id,
    inputRef,
    disabled,
    autoFocus,
    autoComplete,
    activeDescendantId,
    mode,
    open: open3,
    values,
    placeholder,
    tabIndex,
    showSearch,
    searchValue,
    activeValue,
    maxLength,
    onInputKeyDown,
    onInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd,
    title
  } = props;
  const [inputChanged, setInputChanged] = React119.useState(false);
  const combobox = mode === "combobox";
  const inputEditable = combobox || showSearch;
  const item = values[0];
  let inputValue = searchValue || "";
  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }
  React119.useEffect(() => {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  const hasTextInput = mode !== "combobox" && !open3 && !showSearch ? false : !!inputValue;
  const selectionTitle = title === void 0 ? getTitle(item) : title;
  const placeholderNode = React119.useMemo(() => {
    if (item) {
      return null;
    }
    return /* @__PURE__ */ React119.createElement(
      "span",
      {
        className: `${prefixCls}-selection-placeholder`,
        style: hasTextInput ? { visibility: "hidden" } : void 0
      },
      placeholder
    );
  }, [item, hasTextInput, placeholder, prefixCls]);
  return /* @__PURE__ */ React119.createElement(React119.Fragment, null, /* @__PURE__ */ React119.createElement("span", { className: `${prefixCls}-selection-search` }, /* @__PURE__ */ React119.createElement(
    Input_default,
    {
      ref: inputRef,
      prefixCls,
      id,
      open: open3,
      inputElement,
      disabled,
      autoFocus,
      autoComplete,
      editable: inputEditable,
      activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: (e3) => {
        setInputChanged(true);
        onInputChange(e3);
      },
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      tabIndex,
      attrs: pickAttrs(props, true),
      maxLength: combobox ? maxLength : void 0
    }
  )), !combobox && item ? /* @__PURE__ */ React119.createElement(
    "span",
    {
      className: `${prefixCls}-selection-item`,
      title: selectionTitle,
      style: hasTextInput ? { visibility: "hidden" } : void 0
    },
    item.label
  ) : null, placeholderNode);
}, "SingleSelector");
var SingleSelector_default = SingleSelector;

// packages/select/src/Selector/index.tsx
var Selector = /* @__PURE__ */ __name((props, ref) => {
  const inputRef = useRef41(null);
  const compositionStatusRef = useRef41(false);
  const {
    prefixCls,
    open: open3,
    mode,
    showSearch,
    tokenWithEnter,
    autoClearSearchValue,
    onSearch,
    onSearchSubmit,
    onToggleOpen,
    onInputKeyDown,
    domRef
  } = props;
  React120.useImperativeHandle(ref, () => ({
    focus: (options) => {
      inputRef.current.focus(options);
    },
    blur: () => {
      inputRef.current.blur();
    }
  }));
  const [getInputMouseDown, setInputMouseDown] = useLock(0);
  const onInternalInputKeyDown = /* @__PURE__ */ __name((event) => {
    const { which } = event;
    if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (which === KeyCode_default.ENTER && mode === "tags" && !compositionStatusRef.current && !open3) {
      onSearchSubmit?.(event.target.value);
    }
    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  }, "onInternalInputKeyDown");
  const onInternalInputMouseDown = /* @__PURE__ */ __name(() => {
    setInputMouseDown(true);
  }, "onInternalInputMouseDown");
  const pastedTextRef = useRef41(null);
  const triggerOnSearch = /* @__PURE__ */ __name((value) => {
    if (onSearch(value, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  }, "triggerOnSearch");
  const onInputCompositionStart = /* @__PURE__ */ __name(() => {
    compositionStatusRef.current = true;
  }, "onInputCompositionStart");
  const onInputCompositionEnd = /* @__PURE__ */ __name((e3) => {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      triggerOnSearch(e3.target.value);
    }
  }, "onInputCompositionEnd");
  const onInputChange = /* @__PURE__ */ __name((event) => {
    let {
      target: { value }
    } = event;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      value = value.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    triggerOnSearch(value);
  }, "onInputChange");
  const onInputPaste = /* @__PURE__ */ __name((e3) => {
    const { clipboardData } = e3;
    const value = clipboardData?.getData("text");
    pastedTextRef.current = value || "";
  }, "onInputPaste");
  const onClick = /* @__PURE__ */ __name(({ target }) => {
    if (target !== inputRef.current) {
      const isIE = document.body.style.msTouchAction !== void 0;
      if (isIE) {
        setTimeout(() => {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  }, "onClick");
  const onMouseDown = /* @__PURE__ */ __name((event) => {
    const inputMouseDown = getInputMouseDown();
    if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
      event.preventDefault();
    }
    if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open3) {
      if (open3 && autoClearSearchValue !== false) {
        onSearch("", true, false);
      }
      onToggleOpen();
    }
  }, "onMouseDown");
  const sharedProps = {
    inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd
  };
  const selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ React120.createElement(MultipleSelector_default, { ...props, ...sharedProps }) : /* @__PURE__ */ React120.createElement(SingleSelector_default, { ...props, ...sharedProps });
  return /* @__PURE__ */ React120.createElement(
    "div",
    {
      ref: domRef,
      className: `${prefixCls}-selector`,
      onClick,
      onMouseDown
    },
    selectNode
  );
}, "Selector");
var ForwardSelector = React120.forwardRef(Selector);
if (true) {
  ForwardSelector.displayName = "Selector";
}
var Selector_default = ForwardSelector;

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/Portal.js
init_canUseDom();
init_warning();
import * as React124 from "react";
import { createPortal as createPortal3 } from "react-dom";

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/Context.js
import * as React121 from "react";
var OrderContext2 = /* @__PURE__ */ React121.createContext(null);
var Context_default2 = OrderContext2;

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/useDom.js
import * as React122 from "react";
init_canUseDom();
var EMPTY_LIST2 = [];
function useDom2(render2, debug) {
  var _React$useState = React122.useState(function() {
    if (!canUseDom()) {
      return null;
    }
    var defaultEle = document.createElement("div");
    if (debug) {
      defaultEle.setAttribute("data-debug", debug);
    }
    return defaultEle;
  }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
  var appendedRef = React122.useRef(false);
  var queueCreate = React122.useContext(Context_default2);
  var _React$useState3 = React122.useState(EMPTY_LIST2), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
  var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
    setQueue(function(origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  });
  function append2() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  __name(append2, "append");
  function cleanup2() {
    var _ele$parentElement;
    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
    appendedRef.current = false;
  }
  __name(cleanup2, "cleanup");
  useLayoutEffect_default(function() {
    if (render2) {
      if (queueCreate) {
        queueCreate(append2);
      } else {
        append2();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render2]);
  useLayoutEffect_default(function() {
    if (queue.length) {
      queue.forEach(function(appendFn) {
        return appendFn();
      });
      setQueue(EMPTY_LIST2);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}
__name(useDom2, "useDom");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/useScrollLocker.js
init_dynamicCSS();
import * as React123 from "react";

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/util.js
function isBodyOverflowing2() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
__name(isBodyOverflowing2, "isBodyOverflowing");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID2 = "rc-util-locker-".concat(Date.now());
var uuid5 = 0;
function useScrollLocker2(lock) {
  var mergedLock = !!lock;
  var _React$useState = React123.useState(function() {
    uuid5 += 1;
    return "".concat(UNIQUE_ID2, "_").concat(uuid5);
  }), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
  useLayoutEffect_default(function() {
    if (mergedLock) {
      var scrollbarSize = getTargetScrollBarSize(document.body).width;
      var isOverflow = isBodyOverflowing2();
      updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
    } else {
      removeCSS(id);
    }
    return function() {
      removeCSS(id);
    };
  }, [mergedLock, id]);
}
__name(useScrollLocker2, "useScrollLocker");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/mock.js
var inline2 = false;
function inlineMock2(nextInline) {
  if (typeof nextInline === "boolean") {
    inline2 = nextInline;
  }
  return inline2;
}
__name(inlineMock2, "inlineMock");

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/Portal.js
var getPortalContainer3 = /* @__PURE__ */ __name(function getPortalContainer4(getContainer2) {
  if (getContainer2 === false) {
    return false;
  }
  if (!canUseDom() || !getContainer2) {
    return null;
  }
  if (typeof getContainer2 === "string") {
    return document.querySelector(getContainer2);
  }
  if (typeof getContainer2 === "function") {
    return getContainer2();
  }
  return getContainer2;
}, "getPortalContainer");
var Portal2 = /* @__PURE__ */ React124.forwardRef(function(props, ref) {
  var open3 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer, debug = props.debug, _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
  var _React$useState = React124.useState(open3), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
  var mergedRender = shouldRender || open3;
  if (true) {
    warning_default(canUseDom() || !open3, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.");
  }
  React124.useEffect(function() {
    if (autoDestroy || open3) {
      setShouldRender(open3);
    }
  }, [open3, autoDestroy]);
  var _React$useState3 = React124.useState(function() {
    return getPortalContainer3(getContainer2);
  }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
  React124.useEffect(function() {
    var customizeContainer = getPortalContainer3(getContainer2);
    setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
  });
  var _useDom = useDom2(mergedRender && !innerContainer, debug), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1];
  var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer2;
  useScrollLocker2(autoLock && open3 && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
  var childRef = null;
  if (children && supportRef(children) && ref) {
    var _ref = children;
    childRef = _ref.ref;
  }
  var mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0) {
    return null;
  }
  var renderInline = mergedContainer === false || inlineMock2();
  var reffedChildren = children;
  if (ref) {
    reffedChildren = /* @__PURE__ */ React124.cloneElement(children, {
      ref: mergedRef
    });
  }
  return /* @__PURE__ */ React124.createElement(Context_default2.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : /* @__PURE__ */ createPortal3(reffedChildren, mergedContainer));
});
if (true) {
  Portal2.displayName = "Portal";
}
var Portal_default2 = Portal2;

// node_modules/.pnpm/@rc-component+portal@1.1.2_react-dom@18.2.0_react@18.2.0/node_modules/@rc-component/portal/es/index.js
var es_default4 = Portal_default2;

// packages/trigger/src/index.tsx
var import_classnames35 = __toESM(require_classnames());
init_shadow();
import * as React134 from "react";

// packages/trigger/src/Popup/index.tsx
var import_classnames34 = __toESM(require_classnames());
import * as React128 from "react";

// packages/trigger/src/Popup/Arrow.tsx
var import_classnames32 = __toESM(require_classnames());
import * as React125 from "react";
function Arrow(props) {
  const { prefixCls, align, arrow, arrowPos } = props;
  const { className, content } = arrow || {};
  const { x = 0, y = 0 } = arrowPos;
  const arrowRef = React125.useRef();
  if (!align || !align.points) {
    return null;
  }
  const alignStyle = {
    position: "absolute"
  };
  if (align.autoArrow !== false) {
    const popupPoints = align.points[0];
    const targetPoints = align.points[1];
    const popupTB = popupPoints[0];
    const popupLR = popupPoints[1];
    const targetTB = targetPoints[0];
    const targetLR = targetPoints[1];
    if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
      alignStyle.top = y;
    } else if (popupTB === "t") {
      alignStyle.top = 0;
    } else {
      alignStyle.bottom = 0;
    }
    if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
      alignStyle.left = x;
    } else if (popupLR === "l") {
      alignStyle.left = 0;
    } else {
      alignStyle.right = 0;
    }
  }
  return /* @__PURE__ */ React125.createElement(
    "div",
    {
      ref: arrowRef,
      className: (0, import_classnames32.default)(`${prefixCls}-arrow`, className),
      style: alignStyle
    },
    content
  );
}
__name(Arrow, "Arrow");

// packages/trigger/src/Popup/Mask.tsx
var import_classnames33 = __toESM(require_classnames());
import * as React126 from "react";
function Mask2(props) {
  const {
    prefixCls,
    open: open3,
    zIndex,
    mask,
    motion: motion2
  } = props;
  if (!mask) {
    return null;
  }
  return /* @__PURE__ */ React126.createElement(src_default2, { ...motion2, motionAppear: true, visible: open3, removeOnLeave: true }, ({ className }) => /* @__PURE__ */ React126.createElement(
    "div",
    {
      style: { zIndex },
      className: (0, import_classnames33.default)(`${prefixCls}-mask`, className)
    }
  ));
}
__name(Mask2, "Mask");

// packages/trigger/src/Popup/PopupContent.tsx
import * as React127 from "react";
var PopupContent = React127.memo(
  ({ children }) => children,
  (_, next2) => next2.cache
);
if (true) {
  PopupContent.displayName = "PopupContent";
}
var PopupContent_default = PopupContent;

// packages/trigger/src/Popup/index.tsx
var Popup = React128.forwardRef((props, ref) => {
  const {
    popup,
    className,
    prefixCls,
    style: style2,
    target,
    onVisibleChanged,
    // Open
    open: open3,
    keepDom,
    fresh,
    // Click
    onClick,
    // Mask
    mask,
    // Arrow
    arrow,
    arrowPos,
    align,
    // Motion
    motion: motion2,
    maskMotion,
    // Portal
    forceRender,
    getPopupContainer,
    autoDestroy,
    portal: Portal3,
    zIndex,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    onAlign,
    onPrepare,
    stretch,
    targetWidth,
    targetHeight
  } = props;
  const childNode = typeof popup === "function" ? popup() : popup;
  const isNodeVisible = open3 || keepDom;
  const getPopupContainerNeedParams = getPopupContainer?.length > 0;
  const [show, setShow] = React128.useState(
    !getPopupContainer || !getPopupContainerNeedParams
  );
  useLayoutEffect_default(() => {
    if (!show && getPopupContainerNeedParams && target) {
      setShow(true);
    }
  }, [show, getPopupContainerNeedParams, target]);
  if (!show) {
    return null;
  }
  const AUTO = "auto";
  const offsetStyle = {
    left: "-1000vw",
    top: "-1000vh",
    right: AUTO,
    bottom: AUTO
  };
  if (ready || !open3) {
    const { points } = align;
    const dynamicInset = align.dynamicInset || align._experimental?.dynamicInset;
    const alignRight = dynamicInset && points[0][1] === "r";
    const alignBottom = dynamicInset && points[0][0] === "b";
    if (alignRight) {
      offsetStyle.right = offsetR;
      offsetStyle.left = AUTO;
    } else {
      offsetStyle.left = offsetX;
      offsetStyle.right = AUTO;
    }
    if (alignBottom) {
      offsetStyle.bottom = offsetB;
      offsetStyle.top = AUTO;
    } else {
      offsetStyle.top = offsetY;
      offsetStyle.bottom = AUTO;
    }
  }
  const miscStyle = {};
  if (stretch) {
    if (stretch.includes("height") && targetHeight) {
      miscStyle.height = targetHeight;
    } else if (stretch.includes("minHeight") && targetHeight) {
      miscStyle.minHeight = targetHeight;
    }
    if (stretch.includes("width") && targetWidth) {
      miscStyle.width = targetWidth;
    } else if (stretch.includes("minWidth") && targetWidth) {
      miscStyle.minWidth = targetWidth;
    }
  }
  if (!open3) {
    miscStyle.pointerEvents = "none";
  }
  return /* @__PURE__ */ React128.createElement(
    Portal3,
    {
      open: forceRender || isNodeVisible,
      getContainer: getPopupContainer && (() => getPopupContainer(target)),
      autoDestroy
    },
    /* @__PURE__ */ React128.createElement(
      Mask2,
      {
        prefixCls,
        open: open3,
        zIndex,
        mask,
        motion: maskMotion
      }
    ),
    /* @__PURE__ */ React128.createElement(src_default, { onResize: onAlign, disabled: !open3 }, (resizeObserverRef) => {
      return /* @__PURE__ */ React128.createElement(
        src_default2,
        {
          motionAppear: true,
          motionEnter: true,
          motionLeave: true,
          removeOnLeave: false,
          forceRender,
          leavedClassName: `${prefixCls}-hidden`,
          ...motion2,
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          visible: open3,
          onVisibleChanged: (nextVisible) => {
            motion2?.onVisibleChanged?.(nextVisible);
            onVisibleChanged(nextVisible);
          }
        },
        ({ className: motionClassName, style: motionStyle }, motionRef) => {
          const cls5 = (0, import_classnames34.default)(prefixCls, motionClassName, className);
          return /* @__PURE__ */ React128.createElement(
            "div",
            {
              ref: composeRef(resizeObserverRef, ref, motionRef),
              className: cls5,
              style: {
                "--arrow-x": `${arrowPos.x || 0}px`,
                "--arrow-y": `${arrowPos.y || 0}px`,
                ...offsetStyle,
                ...miscStyle,
                ...motionStyle,
                boxSizing: "border-box",
                zIndex,
                ...style2
              },
              onMouseEnter,
              onMouseLeave,
              onPointerEnter,
              onClick
            },
            arrow && /* @__PURE__ */ React128.createElement(
              Arrow,
              {
                prefixCls,
                arrow,
                arrowPos,
                align
              }
            ),
            /* @__PURE__ */ React128.createElement(PopupContent_default, { cache: !open3 && !fresh }, childNode)
          );
        }
      );
    })
  );
});
if (true) {
  Popup.displayName = "Popup";
}
var Popup_default = Popup;

// packages/trigger/src/TriggerWrapper.tsx
import * as React129 from "react";
var TriggerWrapper = React129.forwardRef(
  (props, ref) => {
    const { children, getTriggerDOMNode } = props;
    const canUseRef = supportRef(children);
    const setRef = React129.useCallback(
      (node2) => {
        fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
      },
      [getTriggerDOMNode]
    );
    const mergedRef = useComposeRef(setRef, children.ref);
    return canUseRef ? React129.cloneElement(children, {
      ref: mergedRef
    }) : children;
  }
);
if (true) {
  TriggerWrapper.displayName = "TriggerWrapper";
}
var TriggerWrapper_default = TriggerWrapper;

// packages/trigger/src/context.ts
import * as React130 from "react";
var TriggerContext = React130.createContext(null);
var context_default5 = TriggerContext;

// packages/trigger/src/hooks/useAction.ts
import * as React131 from "react";
function toArray4(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
__name(toArray4, "toArray");
function useAction(mobile, action, showAction, hideAction) {
  return React131.useMemo(() => {
    const mergedShowAction = toArray4(showAction ?? action);
    const mergedHideAction = toArray4(hideAction ?? action);
    const showActionSet = new Set(mergedShowAction);
    const hideActionSet = new Set(mergedHideAction);
    if (mobile) {
      if (showActionSet.has("hover")) {
        showActionSet.delete("hover");
        showActionSet.add("click");
      }
      if (hideActionSet.has("hover")) {
        hideActionSet.delete("hover");
        hideActionSet.add("click");
      }
    }
    return [showActionSet, hideActionSet];
  }, [mobile, action, showAction, hideAction]);
}
__name(useAction, "useAction");

// packages/trigger/src/hooks/useAlign.ts
import * as React132 from "react";

// packages/trigger/src/util.ts
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
__name(isPointsEq, "isPointsEq");
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  const { points } = align;
  const placements5 = Object.keys(builtinPlacements);
  for (let i = 0; i < placements5.length; i += 1) {
    const placement = placements5[i];
    if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {
      return `${prefixCls}-placement-${placement}`;
    }
  }
  return "";
}
__name(getAlignPopupClassName, "getAlignPopupClassName");
function getMotion3(prefixCls, motion2, animation, transitionName) {
  if (motion2) {
    return motion2;
  }
  if (animation) {
    return {
      motionName: `${prefixCls}-${animation}`
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
__name(getMotion3, "getMotion");
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}
__name(getWin, "getWin");
function collectScroller(ele) {
  const scrollerList = [];
  let current = ele?.parentElement;
  const scrollStyle = ["hidden", "scroll", "clip", "auto"];
  while (current) {
    const { overflowX, overflowY, overflow } = getWin(current).getComputedStyle(current);
    if ([overflowX, overflowY, overflow].some((o3) => scrollStyle.includes(o3))) {
      scrollerList.push(current);
    }
    current = current.parentElement;
  }
  return scrollerList;
}
__name(collectScroller, "collectScroller");
function toNum(num, defaultValue = 1) {
  return Number.isNaN(num) ? defaultValue : num;
}
__name(toNum, "toNum");
function getPxValue(val) {
  return toNum(parseFloat(val), 0);
}
__name(getPxValue, "getPxValue");
function getVisibleArea(initArea, scrollerList) {
  const visibleArea = { ...initArea };
  (scrollerList || []).forEach((ele) => {
    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
      return;
    }
    const {
      overflow,
      overflowClipMargin,
      borderTopWidth,
      borderBottomWidth,
      borderLeftWidth,
      borderRightWidth
    } = getWin(ele).getComputedStyle(ele);
    const eleRect = ele.getBoundingClientRect();
    const {
      offsetHeight: eleOutHeight,
      clientHeight: eleInnerHeight,
      offsetWidth: eleOutWidth,
      clientWidth: eleInnerWidth
    } = ele;
    const borderTopNum = getPxValue(borderTopWidth);
    const borderBottomNum = getPxValue(borderBottomWidth);
    const borderLeftNum = getPxValue(borderLeftWidth);
    const borderRightNum = getPxValue(borderRightWidth);
    const scaleX = toNum(
      Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3
    );
    const scaleY = toNum(
      Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3
    );
    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
    const scaledBorderTopWidth = borderTopNum * scaleY;
    const scaledBorderBottomWidth = borderBottomNum * scaleY;
    const scaledBorderLeftWidth = borderLeftNum * scaleX;
    const scaledBorderRightWidth = borderRightNum * scaleX;
    let clipMarginWidth = 0;
    let clipMarginHeight = 0;
    if (overflow === "clip") {
      const clipNum = getPxValue(overflowClipMargin);
      clipMarginWidth = clipNum * scaleX;
      clipMarginHeight = clipNum * scaleY;
    }
    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
    visibleArea.left = Math.max(visibleArea.left, eleLeft);
    visibleArea.top = Math.max(visibleArea.top, eleTop);
    visibleArea.right = Math.min(visibleArea.right, eleRight);
    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
  });
  return visibleArea;
}
__name(getVisibleArea, "getVisibleArea");

// packages/trigger/src/hooks/useAlign.ts
function getUnitOffset(size, offset3 = 0) {
  const offsetStr = `${offset3}`;
  const cells = offsetStr.match(/^(.*)\%$/);
  if (cells) {
    return size * (parseFloat(cells[1]) / 100);
  }
  return parseFloat(offsetStr);
}
__name(getUnitOffset, "getUnitOffset");
function getNumberOffset(rect, offset3) {
  const [offsetX, offsetY] = offset3 || [];
  return [
    getUnitOffset(rect.width, offsetX),
    getUnitOffset(rect.height, offsetY)
  ];
}
__name(getNumberOffset, "getNumberOffset");
function splitPoints(points = "") {
  return [points[0], points[1]];
}
__name(splitPoints, "splitPoints");
function getAlignPoint(rect, points) {
  const topBottom = points[0];
  const leftRight = points[1];
  let x;
  let y;
  if (topBottom === "t") {
    y = rect.y;
  } else if (topBottom === "b") {
    y = rect.y + rect.height;
  } else {
    y = rect.y + rect.height / 2;
  }
  if (leftRight === "l") {
    x = rect.x;
  } else if (leftRight === "r") {
    x = rect.x + rect.width;
  } else {
    x = rect.x + rect.width / 2;
  }
  return { x, y };
}
__name(getAlignPoint, "getAlignPoint");
function reversePoints(points, index3) {
  const reverseMap = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return points.map((point, i) => {
    if (i === index3) {
      return reverseMap[point] || "c";
    }
    return point;
  }).join("");
}
__name(reversePoints, "reversePoints");
function useAlign(open3, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
  const [offsetInfo, setOffsetInfo] = React132.useState({
    ready: false,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: builtinPlacements[placement] || {}
  });
  const alignCountRef = React132.useRef(0);
  const scrollerList = React132.useMemo(() => {
    if (!popupEle) {
      return [];
    }
    return collectScroller(popupEle);
  }, [popupEle]);
  const prevFlipRef = React132.useRef({});
  const resetFlipCache = /* @__PURE__ */ __name(() => {
    prevFlipRef.current = {};
  }, "resetFlipCache");
  if (!open3) {
    resetFlipCache();
  }
  const onAlign = useEvent(() => {
    if (popupEle && target && open3) {
      let getIntersectionVisibleArea = function(offsetX, offsetY, area = visibleArea) {
        const l2 = popupRect.x + offsetX;
        const t2 = popupRect.y + offsetY;
        const r2 = l2 + popupWidth;
        const b = t2 + popupHeight;
        const visibleL = Math.max(l2, area.left);
        const visibleT = Math.max(t2, area.top);
        const visibleR = Math.min(r2, area.right);
        const visibleB = Math.min(b, area.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }, syncNextPopupPosition = function() {
        nextPopupY = popupRect.y + nextOffsetY;
        nextPopupBottom = nextPopupY + popupHeight;
        nextPopupX = popupRect.x + nextOffsetX;
        nextPopupRight = nextPopupX + popupWidth;
      };
      __name(getIntersectionVisibleArea, "getIntersectionVisibleArea");
      __name(syncNextPopupPosition, "syncNextPopupPosition");
      const popupElement = popupEle;
      const doc = popupElement.ownerDocument;
      const win = getWin(popupElement);
      const {
        width,
        height,
        position: popupPosition
      } = win.getComputedStyle(popupElement);
      const originLeft = popupElement.style.left;
      const originTop = popupElement.style.top;
      const originRight = popupElement.style.right;
      const originBottom = popupElement.style.bottom;
      const originOverflow = popupElement.style.overflow;
      const placementInfo = {
        ...builtinPlacements[placement],
        ...popupAlign
      };
      const placeholderElement = doc.createElement("div");
      popupElement.parentElement?.appendChild(placeholderElement);
      placeholderElement.style.left = `${popupElement.offsetLeft}px`;
      placeholderElement.style.top = `${popupElement.offsetTop}px`;
      placeholderElement.style.position = popupPosition;
      placeholderElement.style.height = `${popupElement.offsetHeight}px`;
      placeholderElement.style.width = `${popupElement.offsetWidth}px`;
      popupElement.style.left = "0";
      popupElement.style.top = "0";
      popupElement.style.right = "auto";
      popupElement.style.bottom = "auto";
      popupElement.style.overflow = "hidden";
      let targetRect;
      if (Array.isArray(target)) {
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      } else {
        const rect = target.getBoundingClientRect();
        targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      const popupRect = popupElement.getBoundingClientRect();
      const {
        clientWidth,
        clientHeight,
        scrollWidth,
        scrollHeight,
        scrollTop,
        scrollLeft
      } = doc.documentElement;
      const popupHeight = popupRect.height;
      const popupWidth = popupRect.width;
      const targetHeight = targetRect.height;
      const targetWidth = targetRect.width;
      const visibleRegion = {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      };
      const scrollRegion = {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      };
      let { htmlRegion } = placementInfo;
      const VISIBLE = "visible";
      const VISIBLE_FIRST = "visibleFirst";
      if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
        htmlRegion = VISIBLE;
      }
      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
      popupElement.style.left = "auto";
      popupElement.style.top = "auto";
      popupElement.style.right = "0";
      popupElement.style.bottom = "0";
      const popupMirrorRect = popupElement.getBoundingClientRect();
      popupElement.style.left = originLeft;
      popupElement.style.top = originTop;
      popupElement.style.right = originRight;
      popupElement.style.bottom = originBottom;
      popupElement.style.overflow = originOverflow;
      popupElement.parentElement?.removeChild(placeholderElement);
      const scaleX = toNum(
        Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3
      );
      const scaleY = toNum(
        Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3
      );
      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible_default(target)) {
        return;
      }
      const { offset: offset3, targetOffset: targetOffset4 } = placementInfo;
      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset3);
      const [targetOffsetX, targetOffsetY] = getNumberOffset(
        targetRect,
        targetOffset4
      );
      targetRect.x -= targetOffsetX;
      targetRect.y -= targetOffsetY;
      const [popupPoint, targetPoint] = placementInfo.points || [];
      const targetPoints = splitPoints(targetPoint);
      const popupPoints = splitPoints(popupPoint);
      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
      const nextAlignInfo = {
        ...placementInfo
      };
      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
      const originIntersectionVisibleArea = getIntersectionVisibleArea(
        nextOffsetX,
        nextOffsetY
      );
      const originIntersectionRecommendArea = getIntersectionVisibleArea(
        nextOffsetX,
        nextOffsetY,
        visibleRegionArea
      );
      const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
      const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
      const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
      const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
      const overflow = placementInfo.overflow || {};
      const { adjustX, adjustY, shiftX, shiftY } = overflow;
      const supportAdjust = /* @__PURE__ */ __name((val) => {
        if (typeof val === "boolean") {
          return val;
        }
        return val >= 0;
      }, "supportAdjust");
      let nextPopupY;
      let nextPopupBottom;
      let nextPopupX;
      let nextPopupRight;
      syncNextPopupPosition();
      const needAdjustY = supportAdjust(adjustY);
      const sameTB = popupPoints[0] === targetPoints[0];
      if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY -= popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(
          nextOffsetX,
          tmpNextOffsetY
        );
        const newVisibleRecommendArea = getIntersectionVisibleArea(
          nextOffsetX,
          tmpNextOffsetY,
          visibleRegionArea
        );
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.bt = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [
            reversePoints(popupPoints, 0),
            reversePoints(targetPoints, 0)
          ];
        } else {
          prevFlipRef.current.bt = false;
        }
      }
      if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY += popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(
          nextOffsetX,
          tmpNextOffsetY
        );
        const newVisibleRecommendArea = getIntersectionVisibleArea(
          nextOffsetX,
          tmpNextOffsetY,
          visibleRegionArea
        );
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.tb = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [
            reversePoints(popupPoints, 0),
            reversePoints(targetPoints, 0)
          ];
        } else {
          prevFlipRef.current.tb = false;
        }
      }
      const needAdjustX = supportAdjust(adjustX);
      const sameLR = popupPoints[1] === targetPoints[1];
      if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX -= popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(
          tmpNextOffsetX,
          nextOffsetY
        );
        const newVisibleRecommendArea = getIntersectionVisibleArea(
          tmpNextOffsetX,
          nextOffsetY,
          visibleRegionArea
        );
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.rl = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [
            reversePoints(popupPoints, 1),
            reversePoints(targetPoints, 1)
          ];
        } else {
          prevFlipRef.current.rl = false;
        }
      }
      if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX += popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(
          tmpNextOffsetX,
          nextOffsetY
        );
        const newVisibleRecommendArea = getIntersectionVisibleArea(
          tmpNextOffsetX,
          nextOffsetY,
          visibleRegionArea
        );
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.lr = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [
            reversePoints(popupPoints, 1),
            reversePoints(targetPoints, 1)
          ];
        } else {
          prevFlipRef.current.lr = false;
        }
      }
      syncNextPopupPosition();
      const numShiftX = shiftX === true ? 0 : shiftX;
      if (typeof numShiftX === "number") {
        if (nextPopupX < visibleRegionArea.left) {
          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
          }
        }
        if (nextPopupRight > visibleRegionArea.right) {
          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
          if (targetRect.x > visibleRegionArea.right - numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
          }
        }
      }
      const numShiftY = shiftY === true ? 0 : shiftY;
      if (typeof numShiftY === "number") {
        if (nextPopupY < visibleRegionArea.top) {
          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
          }
        }
        if (nextPopupBottom > visibleRegionArea.bottom) {
          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
          }
        }
      }
      const popupLeft = popupRect.x + nextOffsetX;
      const popupRight = popupLeft + popupWidth;
      const popupTop = popupRect.y + nextOffsetY;
      const popupBottom = popupTop + popupHeight;
      const targetLeft = targetRect.x;
      const targetRight = targetLeft + targetWidth;
      const targetTop = targetRect.y;
      const targetBottom = targetTop + targetHeight;
      const maxLeft = Math.max(popupLeft, targetLeft);
      const minRight = Math.min(popupRight, targetRight);
      const xCenter = (maxLeft + minRight) / 2;
      const nextArrowX = xCenter - popupLeft;
      const maxTop = Math.max(popupTop, targetTop);
      const minBottom = Math.min(popupBottom, targetBottom);
      const yCenter = (maxTop + minBottom) / 2;
      const nextArrowY = yCenter - popupTop;
      onPopupAlign?.(popupEle, nextAlignInfo);
      const offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
      const offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
      setOffsetInfo({
        ready: true,
        offsetX: nextOffsetX / scaleX,
        offsetY: nextOffsetY / scaleY,
        offsetR: offsetX4Right / scaleX,
        offsetB: offsetY4Bottom / scaleY,
        arrowX: nextArrowX / scaleX,
        arrowY: nextArrowY / scaleY,
        scaleX,
        scaleY,
        align: nextAlignInfo
      });
    }
  });
  const triggerAlign = /* @__PURE__ */ __name(() => {
    alignCountRef.current += 1;
    const id = alignCountRef.current;
    Promise.resolve().then(() => {
      if (alignCountRef.current === id) {
        onAlign();
      }
    });
  }, "triggerAlign");
  const resetReady = /* @__PURE__ */ __name(() => {
    setOffsetInfo((ori) => ({
      ...ori,
      ready: false
    }));
  }, "resetReady");
  useLayoutEffect_default(resetReady, [placement]);
  useLayoutEffect_default(() => {
    if (!open3) {
      resetReady();
    }
  }, [open3]);
  return [
    offsetInfo.ready,
    offsetInfo.offsetX,
    offsetInfo.offsetY,
    offsetInfo.offsetR,
    offsetInfo.offsetB,
    offsetInfo.arrowX,
    offsetInfo.arrowY,
    offsetInfo.scaleX,
    offsetInfo.scaleY,
    offsetInfo.align,
    triggerAlign
  ];
}
__name(useAlign, "useAlign");

// packages/trigger/src/hooks/useWatch.ts
function useWatch2(open3, target, popup, onAlign, onScroll) {
  useLayoutEffect_default(() => {
    if (open3 && target && popup) {
      let notifyScroll = function() {
        onAlign();
        onScroll();
      };
      __name(notifyScroll, "notifyScroll");
      const targetElement = target;
      const popupElement = popup;
      const targetScrollList = collectScroller(targetElement);
      const popupScrollList = collectScroller(popupElement);
      const win = getWin(popupElement);
      const mergedList = /* @__PURE__ */ new Set([
        win,
        ...targetScrollList,
        ...popupScrollList
      ]);
      mergedList.forEach((scroller) => {
        scroller.addEventListener("scroll", notifyScroll, { passive: true });
      });
      win.addEventListener("resize", notifyScroll, { passive: true });
      onAlign();
      return () => {
        mergedList.forEach((scroller) => {
          scroller.removeEventListener("scroll", notifyScroll);
          win.removeEventListener("resize", notifyScroll);
        });
      };
    }
  }, [open3, target, popup]);
}
__name(useWatch2, "useWatch");

// packages/trigger/src/hooks/useWinClick.ts
init_shadow();
init_warning();
import * as React133 from "react";
function useWinClick(open3, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
  const openRef = React133.useRef(open3);
  openRef.current = open3;
  React133.useEffect(() => {
    if (clickToHide && popupEle && (!mask || maskClosable)) {
      const onTriggerClose = /* @__PURE__ */ __name(({ target }) => {
        if (openRef.current && !inPopupOrChild(target)) {
          triggerOpen(false);
        }
      }, "onTriggerClose");
      const win = getWin(popupEle);
      win.addEventListener("mousedown", onTriggerClose, true);
      win.addEventListener("contextmenu", onTriggerClose, true);
      const targetShadowRoot = getShadowRoot(targetEle);
      if (targetShadowRoot) {
        targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
        targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
      }
      if (true) {
        const targetRoot = targetEle?.getRootNode?.();
        const popupRoot = popupEle.getRootNode?.();
        warning(
          targetRoot === popupRoot,
          `trigger element and popup element should in same shadow root.`
        );
      }
      return () => {
        win.removeEventListener("mousedown", onTriggerClose, true);
        win.removeEventListener("contextmenu", onTriggerClose, true);
        if (targetShadowRoot) {
          targetShadowRoot.removeEventListener(
            "mousedown",
            onTriggerClose,
            true
          );
          targetShadowRoot.removeEventListener(
            "contextmenu",
            onTriggerClose,
            true
          );
        }
      };
    }
  }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
}
__name(useWinClick, "useWinClick");

// packages/trigger/src/index.tsx
function generateTrigger(PortalComponent = es_default4) {
  const Trigger = React134.forwardRef((props, ref) => {
    const {
      prefixCls = "rc-trigger-popup",
      children,
      // Action
      action = "hover",
      showAction,
      hideAction,
      // Open
      popupVisible,
      defaultPopupVisible,
      onPopupVisibleChange,
      afterPopupVisibleChange,
      // Delay
      mouseEnterDelay,
      mouseLeaveDelay = 0.1,
      focusDelay,
      blurDelay,
      // Mask
      mask,
      maskClosable = true,
      // Portal
      getPopupContainer,
      forceRender,
      autoDestroy,
      destroyPopupOnHide,
      // Popup
      popup,
      popupClassName,
      popupStyle,
      popupPlacement,
      builtinPlacements = {},
      popupAlign,
      zIndex,
      stretch,
      getPopupClassNameFromAlign,
      fresh,
      alignPoint,
      onPopupClick,
      onPopupAlign,
      // Arrow
      arrow,
      // Motion
      popupMotion,
      maskMotion,
      popupTransitionName,
      popupAnimation,
      maskTransitionName,
      maskAnimation,
      // Deprecated
      className,
      // Private
      getTriggerDOMNode,
      ...restProps
    } = props;
    const mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
    const [mobile, setMobile] = React134.useState(false);
    useLayoutEffect_default(() => {
      setMobile(isMobile_default());
    }, []);
    const subPopupElements = React134.useRef({});
    const parentContext = React134.useContext(context_default5);
    const context = React134.useMemo(() => {
      return {
        registerSubPopup: (id2, subPopupEle) => {
          subPopupElements.current[id2] = subPopupEle;
          parentContext?.registerSubPopup(id2, subPopupEle);
        }
      };
    }, [parentContext]);
    const id = useId_default();
    const [popupEle, setPopupEle] = React134.useState(null);
    const externalPopupRef = React134.useRef(null);
    const setPopupRef = useEvent((node2) => {
      externalPopupRef.current = node2;
      if (isDOM(node2) && popupEle !== node2) {
        setPopupEle(node2);
      }
      parentContext?.registerSubPopup(id, node2);
    });
    const [targetEle, setTargetEle] = React134.useState(null);
    const externalForwardRef = React134.useRef(null);
    const setTargetRef = useEvent((node2) => {
      if (isDOM(node2) && targetEle !== node2) {
        setTargetEle(node2);
        externalForwardRef.current = node2;
      }
    });
    const child = React134.Children.only(children);
    const originChildProps = child?.props || {};
    const cloneProps = {};
    const inPopupOrChild = useEvent((ele) => {
      const childDOM = targetEle;
      return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some(
        (subPopupEle) => subPopupEle?.contains(ele) || ele === subPopupEle
      );
    });
    const mergePopupMotion = getMotion3(
      prefixCls,
      popupMotion,
      popupAnimation,
      popupTransitionName
    );
    const mergeMaskMotion = getMotion3(
      prefixCls,
      maskMotion,
      maskAnimation,
      maskTransitionName
    );
    const [internalOpen, setInternalOpen] = React134.useState(
      defaultPopupVisible || false
    );
    const mergedOpen = popupVisible ?? internalOpen;
    const setMergedOpen = useEvent((nextOpen) => {
      if (popupVisible === void 0) {
        setInternalOpen(nextOpen);
      }
    });
    useLayoutEffect_default(() => {
      setInternalOpen(popupVisible || false);
    }, [popupVisible]);
    const openRef = React134.useRef(mergedOpen);
    openRef.current = mergedOpen;
    const lastTriggerRef = React134.useRef([]);
    lastTriggerRef.current = [];
    const internalTriggerOpen = useEvent((nextOpen) => {
      setMergedOpen(nextOpen);
      if ((lastTriggerRef.current[lastTriggerRef.current.length - 1] ?? mergedOpen) !== nextOpen) {
        lastTriggerRef.current.push(nextOpen);
        onPopupVisibleChange?.(nextOpen);
      }
    });
    const delayRef = React134.useRef();
    const clearDelay = /* @__PURE__ */ __name(() => {
      clearTimeout(delayRef.current);
    }, "clearDelay");
    const triggerOpen = /* @__PURE__ */ __name((nextOpen, delay = 0) => {
      clearDelay();
      if (delay === 0) {
        internalTriggerOpen(nextOpen);
      } else {
        delayRef.current = setTimeout(() => {
          internalTriggerOpen(nextOpen);
        }, delay * 1e3);
      }
    }, "triggerOpen");
    React134.useEffect(() => clearDelay, []);
    const [inMotion, setInMotion] = React134.useState(false);
    useLayoutEffect_default(
      (firstMount) => {
        if (!firstMount || mergedOpen) {
          setInMotion(true);
        }
      },
      [mergedOpen]
    );
    const [motionPrepareResolve, setMotionPrepareResolve] = React134.useState(null);
    const [mousePos, setMousePos] = React134.useState([
      0,
      0
    ]);
    const setMousePosByEvent = /* @__PURE__ */ __name((event) => {
      setMousePos([event.clientX, event.clientY]);
    }, "setMousePosByEvent");
    const [
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      arrowX,
      arrowY,
      scaleX,
      scaleY,
      alignInfo,
      onAlign
    ] = useAlign(
      mergedOpen,
      popupEle,
      alignPoint ? mousePos : targetEle,
      popupPlacement,
      builtinPlacements,
      popupAlign,
      onPopupAlign
    );
    const [showActions, hideActions] = useAction(
      mobile,
      action,
      showAction,
      hideAction
    );
    const clickToShow = showActions.has("click");
    const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
    const triggerAlign = useEvent(() => {
      if (!inMotion) {
        onAlign();
      }
    });
    const onScroll = /* @__PURE__ */ __name(() => {
      if (openRef.current && alignPoint && clickToHide) {
        triggerOpen(false);
      }
    }, "onScroll");
    useWatch2(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
    useLayoutEffect_default(() => {
      triggerAlign();
    }, [mousePos, popupPlacement]);
    useLayoutEffect_default(() => {
      if (mergedOpen && !builtinPlacements?.[popupPlacement]) {
        triggerAlign();
      }
    }, [JSON.stringify(popupAlign)]);
    const alignedClassName = React134.useMemo(() => {
      const baseClassName = getAlignPopupClassName(
        builtinPlacements,
        prefixCls,
        alignInfo,
        alignPoint
      );
      return (0, import_classnames35.default)(baseClassName, getPopupClassNameFromAlign?.(alignInfo));
    }, [
      alignInfo,
      getPopupClassNameFromAlign,
      builtinPlacements,
      prefixCls,
      alignPoint
    ]);
    React134.useImperativeHandle(ref, () => ({
      nativeElement: externalForwardRef.current,
      popupElement: externalPopupRef.current,
      forceAlign: triggerAlign
    }));
    const [targetWidth, setTargetWidth] = React134.useState(0);
    const [targetHeight, setTargetHeight] = React134.useState(0);
    const syncTargetSize = /* @__PURE__ */ __name(() => {
      if (stretch && targetEle) {
        const rect = targetEle.getBoundingClientRect();
        setTargetWidth(rect.width);
        setTargetHeight(rect.height);
      }
    }, "syncTargetSize");
    const onTargetResize = /* @__PURE__ */ __name(() => {
      syncTargetSize();
      triggerAlign();
    }, "onTargetResize");
    const onVisibleChanged = /* @__PURE__ */ __name((visible) => {
      setInMotion(false);
      onAlign();
      afterPopupVisibleChange?.(visible);
    }, "onVisibleChanged");
    const onPrepare = /* @__PURE__ */ __name(() => new Promise((resolve) => {
      syncTargetSize();
      setMotionPrepareResolve(() => resolve);
    }), "onPrepare");
    useLayoutEffect_default(() => {
      if (motionPrepareResolve) {
        onAlign();
        motionPrepareResolve();
        setMotionPrepareResolve(null);
      }
    }, [motionPrepareResolve]);
    function wrapperAction(eventName, nextOpen, delay, preEvent) {
      cloneProps[eventName] = (event, ...args) => {
        preEvent?.(event);
        triggerOpen(nextOpen, delay);
        originChildProps[eventName]?.(event, ...args);
      };
    }
    __name(wrapperAction, "wrapperAction");
    if (clickToShow || clickToHide) {
      cloneProps.onClick = (event, ...args) => {
        if (openRef.current && clickToHide) {
          triggerOpen(false);
        } else if (!openRef.current && clickToShow) {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        originChildProps.onClick?.(event, ...args);
      };
    }
    useWinClick(
      mergedOpen,
      clickToHide,
      targetEle,
      popupEle,
      mask,
      maskClosable,
      inPopupOrChild,
      triggerOpen
    );
    const hoverToShow = showActions.has("hover");
    const hoverToHide = hideActions.has("hover");
    let onPopupMouseEnter;
    let onPopupMouseLeave;
    if (hoverToShow) {
      wrapperAction(
        "onMouseEnter",
        true,
        mouseEnterDelay,
        (event) => {
          setMousePosByEvent(event);
        }
      );
      wrapperAction(
        "onPointerEnter",
        true,
        mouseEnterDelay,
        (event) => {
          setMousePosByEvent(event);
        }
      );
      onPopupMouseEnter = /* @__PURE__ */ __name((event) => {
        if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {
          triggerOpen(true, mouseEnterDelay);
        }
      }, "onPopupMouseEnter");
      if (alignPoint) {
        cloneProps.onMouseMove = (event) => {
          originChildProps.onMouseMove?.(event);
        };
      }
    }
    if (hoverToHide) {
      wrapperAction("onMouseLeave", false, mouseLeaveDelay);
      wrapperAction("onPointerLeave", false, mouseLeaveDelay);
      onPopupMouseLeave = /* @__PURE__ */ __name(() => {
        triggerOpen(false, mouseLeaveDelay);
      }, "onPopupMouseLeave");
    }
    if (showActions.has("focus")) {
      wrapperAction("onFocus", true, focusDelay);
    }
    if (hideActions.has("focus")) {
      wrapperAction("onBlur", false, blurDelay);
    }
    if (showActions.has("contextMenu")) {
      cloneProps.onContextMenu = (event, ...args) => {
        if (openRef.current && hideActions.has("contextMenu")) {
          triggerOpen(false);
        } else {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        event.preventDefault();
        originChildProps.onContextMenu?.(event, ...args);
      };
    }
    if (className) {
      cloneProps.className = (0, import_classnames35.default)(originChildProps.className, className);
    }
    const mergedChildrenProps = {
      ...originChildProps,
      ...cloneProps
    };
    const passedProps = {};
    const passedEventList = [
      "onContextMenu",
      "onClick",
      "onMouseDown",
      "onTouchStart",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur"
    ];
    passedEventList.forEach((eventName) => {
      if (restProps[eventName]) {
        passedProps[eventName] = (...args) => {
          mergedChildrenProps[eventName]?.(...args);
          restProps[eventName](...args);
        };
      }
    });
    const triggerNode = React134.cloneElement(child, {
      ...mergedChildrenProps,
      ...passedProps
    });
    const arrowPos = {
      x: arrowX,
      y: arrowY
    };
    const innerArrow = arrow ? {
      // true and Object likely
      ...arrow !== true ? arrow : {}
    } : null;
    return /* @__PURE__ */ React134.createElement(React134.Fragment, null, /* @__PURE__ */ React134.createElement(
      src_default,
      {
        disabled: !mergedOpen,
        ref: setTargetRef,
        onResize: onTargetResize
      },
      /* @__PURE__ */ React134.createElement(TriggerWrapper_default, { getTriggerDOMNode }, triggerNode)
    ), /* @__PURE__ */ React134.createElement(context_default5.Provider, { value: context }, /* @__PURE__ */ React134.createElement(
      Popup_default,
      {
        portal: PortalComponent,
        ref: setPopupRef,
        prefixCls,
        popup,
        className: (0, import_classnames35.default)(popupClassName, alignedClassName),
        style: popupStyle,
        target: targetEle,
        onMouseEnter: onPopupMouseEnter,
        onMouseLeave: onPopupMouseLeave,
        onPointerEnter: onPopupMouseEnter,
        zIndex,
        open: mergedOpen,
        keepDom: inMotion,
        fresh,
        onClick: onPopupClick,
        mask,
        motion: mergePopupMotion,
        maskMotion: mergeMaskMotion,
        onVisibleChanged,
        onPrepare,
        forceRender,
        autoDestroy: mergedAutoDestroy,
        getPopupContainer,
        align: alignInfo,
        arrow: innerArrow,
        arrowPos,
        ready,
        offsetX,
        offsetY,
        offsetR,
        offsetB,
        onAlign: triggerAlign,
        stretch,
        targetWidth: targetWidth / scaleX,
        targetHeight: targetHeight / scaleY
      }
    )));
  });
  if (true) {
    Trigger.displayName = "Trigger";
  }
  return Trigger;
}
__name(generateTrigger, "generateTrigger");
var src_default5 = generateTrigger(es_default4);

// packages/select/src/SelectTrigger.tsx
var import_classnames36 = __toESM(require_classnames());
import * as React135 from "react";
var getBuiltInPlacements = /* @__PURE__ */ __name((dropdownMatchSelectWidth) => {
  const adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
}, "getBuiltInPlacements");
var SelectTrigger = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls,
    disabled,
    visible,
    children,
    popupElement,
    animation,
    transitionName,
    dropdownStyle,
    dropdownClassName,
    direction = "ltr",
    placement,
    builtinPlacements,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    getPopupContainer,
    empty: empty2,
    getTriggerDOMNode,
    onPopupVisibleChange,
    onPopupMouseEnter,
    ...restProps
  } = props;
  const dropdownPrefixCls = `${prefixCls}-dropdown`;
  let popupNode = popupElement;
  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }
  const mergedBuiltinPlacements2 = React135.useMemo(
    () => builtinPlacements || getBuiltInPlacements(dropdownMatchSelectWidth),
    [builtinPlacements, dropdownMatchSelectWidth]
  );
  const mergedTransitionName = animation ? `${dropdownPrefixCls}-${animation}` : transitionName;
  const isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
  const stretch = React135.useMemo(() => {
    if (isNumberPopupWidth) {
      return null;
    }
    return dropdownMatchSelectWidth === false ? "minWidth" : "width";
  }, [dropdownMatchSelectWidth, isNumberPopupWidth]);
  let popupStyle = dropdownStyle;
  if (isNumberPopupWidth) {
    popupStyle = {
      ...popupStyle,
      width: dropdownMatchSelectWidth
    };
  }
  const triggerPopupRef = React135.useRef(null);
  React135.useImperativeHandle(ref, () => ({
    getPopupElement: () => triggerPopupRef.current?.popupElement
  }));
  return /* @__PURE__ */ React135.createElement(
    src_default5,
    {
      ...restProps,
      showAction: onPopupVisibleChange ? ["click"] : [],
      hideAction: onPopupVisibleChange ? ["click"] : [],
      popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
      builtinPlacements: mergedBuiltinPlacements2,
      prefixCls: dropdownPrefixCls,
      popupTransitionName: mergedTransitionName,
      popup: /* @__PURE__ */ React135.createElement("div", { onMouseEnter: onPopupMouseEnter }, popupNode),
      ref: triggerPopupRef,
      stretch,
      popupAlign: dropdownAlign,
      popupVisible: visible,
      getPopupContainer,
      popupClassName: (0, import_classnames36.default)(dropdownClassName, {
        [`${dropdownPrefixCls}-empty`]: empty2
      }),
      popupStyle,
      getTriggerDOMNode,
      onPopupVisibleChange
    },
    children
  );
}, "SelectTrigger");
var RefSelectTrigger = React135.forwardRef(SelectTrigger);
if (true) {
  RefSelectTrigger.displayName = "SelectTrigger";
}
var SelectTrigger_default = RefSelectTrigger;

// packages/select/src/utils/valueUtil.ts
init_warning();
function getKey(data, index3) {
  const { key } = data;
  let value;
  if ("value" in data) {
    ({ value } = data);
  }
  if (key !== null && key !== void 0) {
    return key;
  }
  if (value !== void 0) {
    return value;
  }
  return `rc-index-key-${index3}`;
}
__name(getKey, "getKey");
function isValidCount(value) {
  return typeof value !== "undefined" && !Number.isNaN(value);
}
__name(isValidCount, "isValidCount");
function fillFieldNames(fieldNames, childrenAsData) {
  const { label, value, options, groupLabel } = fieldNames || {};
  const mergedLabel = label || (childrenAsData ? "children" : "label");
  return {
    label: mergedLabel,
    value: value || "value",
    options: options || "options",
    groupLabel: groupLabel || mergedLabel
  };
}
__name(fillFieldNames, "fillFieldNames");
function flattenOptions(options, { fieldNames, childrenAsData } = {}) {
  const flattenList = [];
  const {
    label: fieldLabel,
    value: fieldValue,
    options: fieldOptions,
    groupLabel
  } = fillFieldNames(fieldNames, false);
  function dig(list, isGroupOption) {
    if (!Array.isArray(list)) {
      return;
    }
    list.forEach((data) => {
      if (isGroupOption || !(fieldOptions in data)) {
        const value = data[fieldValue];
        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label: data[fieldLabel],
          value
        });
      } else {
        let grpLabel = data[groupLabel];
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data.label;
        }
        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }
  __name(dig, "dig");
  dig(options, false);
  return flattenList;
}
__name(flattenOptions, "flattenOptions");
function injectPropsWithOption(option) {
  const newOption = { ...option };
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get() {
        warning_default(
          false,
          "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."
        );
        return newOption;
      }
    });
  }
  return newOption;
}
__name(injectPropsWithOption, "injectPropsWithOption");
var getSeparatedContent = /* @__PURE__ */ __name((text, tokens, end) => {
  if (!tokens || !tokens.length) {
    return null;
  }
  let match2 = false;
  const separate = /* @__PURE__ */ __name((str, [token2, ...restTokens]) => {
    if (!token2) {
      return [str];
    }
    const list2 = str.split(token2);
    match2 = match2 || list2.length > 1;
    return list2.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);
  }, "separate");
  const list = separate(text, tokens);
  if (match2) {
    return typeof end !== "undefined" ? list.slice(0, end) : list;
  } else {
    return null;
  }
}, "getSeparatedContent");

// packages/select/src/SelectContext.ts
import * as React136 from "react";
var SelectContext = React136.createContext(null);
var SelectContext_default = SelectContext;

// packages/select/src/BaseSelect.tsx
var DEFAULT_OMIT_PROPS = [
  "value",
  "onChange",
  "removeIcon",
  "placeholder",
  "autoFocus",
  "maxTagCount",
  "maxTagTextLength",
  "maxTagPlaceholder",
  "choiceTransitionName",
  "onInputKeyDown",
  "onPopupScroll",
  "tabIndex"
];
var isMultiple = /* @__PURE__ */ __name((mode) => mode === "tags" || mode === "multiple", "isMultiple");
var BaseSelect = React137.forwardRef((props, ref) => {
  const {
    id,
    prefixCls,
    className,
    showSearch,
    tagRender,
    direction,
    omitDomProps,
    // Value
    displayValues,
    onDisplayValuesChange,
    emptyOptions,
    notFoundContent = "Not Found",
    onClear,
    // Mode
    mode,
    // Status
    disabled,
    loading,
    // Customize Input
    getInputElement,
    getRawInputElement,
    // Open
    open: open3,
    defaultOpen,
    onDropdownVisibleChange,
    // Active
    activeValue,
    onActiveValueChange,
    activeDescendantId,
    // Search
    searchValue,
    autoClearSearchValue,
    onSearch,
    onSearchSplit,
    tokenSeparators,
    // Icons
    allowClear,
    suffixIcon,
    clearIcon,
    // Dropdown
    OptionList: OptionList3,
    animation,
    transitionName,
    dropdownStyle,
    dropdownClassName,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    // Focus
    showAction = [],
    onFocus,
    onBlur,
    // Rest Events
    onKeyUp,
    onKeyDown: onKeyDown2,
    onMouseDown,
    // Rest Props
    ...restProps
  } = props;
  const multiple = isMultiple(mode);
  const mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
  const domProps = {
    ...restProps
  };
  DEFAULT_OMIT_PROPS.forEach((propName) => {
    delete domProps[propName];
  });
  omitDomProps?.forEach((propName) => {
    delete domProps[propName];
  });
  const [mobile, setMobile] = React137.useState(false);
  React137.useEffect(() => {
    setMobile(isMobile_default());
  }, []);
  const containerRef = React137.useRef(null);
  const selectorDomRef = React137.useRef(null);
  const triggerRef = React137.useRef(null);
  const selectorRef = React137.useRef(null);
  const listRef = React137.useRef(null);
  const blurRef = React137.useRef(false);
  const [mockFocused, setMockFocused, cancelSetMockFocused] = useDelayReset();
  React137.useImperativeHandle(ref, () => ({
    focus: selectorRef.current?.focus,
    blur: selectorRef.current?.blur,
    scrollTo: (arg) => listRef.current?.scrollTo(arg)
  }));
  const mergedSearchValue = React137.useMemo(() => {
    if (mode !== "combobox") {
      return searchValue;
    }
    const val = displayValues[0]?.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  const customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
  const customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
  const customizeRawInputRef = useComposeRef(
    selectorDomRef,
    customizeRawInputElement?.props?.ref
  );
  const [rendered, setRendered] = React137.useState(false);
  useLayoutEffect_default(() => {
    setRendered(true);
  }, []);
  const [innerOpen, setInnerOpen] = useMergedState(false, {
    defaultValue: defaultOpen,
    value: open3
  });
  let mergedOpen = rendered ? innerOpen : false;
  const emptyListContent = !notFoundContent && emptyOptions;
  if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
    mergedOpen = false;
  }
  const triggerOpen = emptyListContent ? false : mergedOpen;
  const onToggleOpen = React137.useCallback(
    (newOpen) => {
      const nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
      if (!disabled) {
        setInnerOpen(nextOpen);
        if (mergedOpen !== nextOpen) {
          onDropdownVisibleChange?.(nextOpen);
        }
      }
    },
    [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]
  );
  const tokenWithEnter = React137.useMemo(
    () => (tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)),
    [tokenSeparators]
  );
  const { maxCount, rawValues } = React137.useContext(SelectContext_default) || {};
  const onInternalSearch = /* @__PURE__ */ __name((searchText, fromTyping, isCompositing) => {
    if (multiple && isValidCount(maxCount) && rawValues?.size >= maxCount) {
      return;
    }
    let ret = true;
    let newSearchText = searchText;
    onActiveValueChange?.(null);
    const separatedList = getSeparatedContent(
      searchText,
      tokenSeparators,
      isValidCount(maxCount) ? maxCount - rawValues.size : void 0
    );
    const patchLabels = isCompositing ? null : separatedList;
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit?.(patchLabels);
      onToggleOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    return ret;
  }, "onInternalSearch");
  const onInternalSearchSubmit = /* @__PURE__ */ __name((searchText) => {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, { source: "submit" });
  }, "onInternalSearchSubmit");
  React137.useEffect(() => {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  React137.useEffect(() => {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }
    if (disabled && !blurRef.current) {
      setMockFocused(false);
    }
  }, [disabled]);
  const [getClearLock, setClearLock] = useLock();
  const onInternalKeyDown = /* @__PURE__ */ __name((event, ...rest) => {
    const clearLock = getClearLock();
    const { which } = event;
    if (which === KeyCode_default.ENTER) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (which === KeyCode_default.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      const cloneDisplayValues = [...displayValues];
      let removedDisplayValue = null;
      for (let i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        const current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    if (mergedOpen) {
      listRef.current?.onKeyDown(event, ...rest);
    }
    onKeyDown2?.(event, ...rest);
  }, "onInternalKeyDown");
  const onInternalKeyUp = /* @__PURE__ */ __name((event, ...rest) => {
    if (mergedOpen) {
      listRef.current?.onKeyUp(event, ...rest);
    }
    onKeyUp?.(event, ...rest);
  }, "onInternalKeyUp");
  const onSelectorRemove = /* @__PURE__ */ __name((val) => {
    const newValues = displayValues.filter((i) => i !== val);
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  }, "onSelectorRemove");
  const focusRef = React137.useRef(false);
  const onContainerFocus = /* @__PURE__ */ __name((...args) => {
    setMockFocused(true);
    if (!disabled) {
      if (onFocus && !focusRef.current) {
        onFocus(...args);
      }
      if (showAction.includes("focus")) {
        onToggleOpen(true);
      }
    }
    focusRef.current = true;
  }, "onContainerFocus");
  const onContainerBlur = /* @__PURE__ */ __name((...args) => {
    blurRef.current = true;
    setMockFocused(false, () => {
      focusRef.current = false;
      blurRef.current = false;
      onToggleOpen(false);
    });
    if (disabled) {
      return;
    }
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, { source: "submit" });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    if (onBlur) {
      onBlur(...args);
    }
  }, "onContainerBlur");
  const activeTimeoutIds = [];
  React137.useEffect(
    () => () => {
      activeTimeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    },
    []
  );
  const onInternalMouseDown = /* @__PURE__ */ __name((event, ...restArgs) => {
    const { target } = event;
    const popupElement = triggerRef.current?.getPopupElement();
    if (popupElement && popupElement.contains(target)) {
      const timeoutId = setTimeout(() => {
        const index3 = activeTimeoutIds.indexOf(timeoutId);
        if (index3 !== -1) {
          activeTimeoutIds.splice(index3, 1);
        }
        cancelSetMockFocused();
        if (!mobile && !popupElement.contains(document.activeElement)) {
          selectorRef.current?.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    onMouseDown?.(event, ...restArgs);
  }, "onInternalMouseDown");
  const [, forceUpdate] = React137.useState({});
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  __name(onPopupMouseEnter, "onPopupMouseEnter");
  let onTriggerVisibleChange;
  if (customizeRawInputElement) {
    onTriggerVisibleChange = /* @__PURE__ */ __name((newOpen) => {
      onToggleOpen(newOpen);
    }, "onTriggerVisibleChange");
  }
  useSelectTriggerControl(
    () => [containerRef.current, triggerRef.current?.getPopupElement()],
    triggerOpen,
    onToggleOpen,
    !!customizeRawInputElement
  );
  const baseSelectContext = React137.useMemo(
    () => ({
      ...props,
      notFoundContent,
      open: mergedOpen,
      triggerOpen,
      id,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    }),
    [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]
  );
  const showSuffixIcon = !!suffixIcon || loading;
  let arrowNode;
  if (showSuffixIcon) {
    arrowNode = /* @__PURE__ */ React137.createElement(
      TransBtn_default,
      {
        className: (0, import_classnames37.default)(`${prefixCls}-arrow`, {
          [`${prefixCls}-arrow-loading`]: loading
        }),
        customizeIcon: suffixIcon,
        customizeIconProps: {
          loading,
          searchValue: mergedSearchValue,
          open: mergedOpen,
          focused: mockFocused,
          showSearch: mergedShowSearch
        }
      }
    );
  }
  const onClearMouseDown = /* @__PURE__ */ __name(() => {
    onClear?.();
    selectorRef.current?.focus();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  }, "onClearMouseDown");
  const { allowClear: mergedAllowClear, clearIcon: clearNode } = useAllowClear(
    prefixCls,
    onClearMouseDown,
    displayValues,
    allowClear,
    clearIcon,
    disabled,
    mergedSearchValue,
    mode
  );
  const optionList = /* @__PURE__ */ React137.createElement(OptionList3, { ref: listRef });
  const mergedClassName = (0, import_classnames37.default)(prefixCls, className, {
    [`${prefixCls}-focused`]: mockFocused,
    [`${prefixCls}-multiple`]: multiple,
    [`${prefixCls}-single`]: !multiple,
    [`${prefixCls}-allow-clear`]: allowClear,
    [`${prefixCls}-show-arrow`]: showSuffixIcon,
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-open`]: mergedOpen,
    [`${prefixCls}-customize-input`]: customizeInputElement,
    [`${prefixCls}-show-search`]: mergedShowSearch
  });
  const selectorNode = /* @__PURE__ */ React137.createElement(
    SelectTrigger_default,
    {
      ref: triggerRef,
      disabled,
      prefixCls,
      visible: triggerOpen,
      popupElement: optionList,
      animation,
      transitionName,
      dropdownStyle,
      dropdownClassName,
      direction,
      dropdownMatchSelectWidth,
      dropdownRender,
      dropdownAlign,
      placement,
      builtinPlacements,
      getPopupContainer,
      empty: emptyOptions,
      getTriggerDOMNode: () => selectorDomRef.current,
      onPopupVisibleChange: onTriggerVisibleChange,
      onPopupMouseEnter
    },
    customizeRawInputElement ? React137.cloneElement(customizeRawInputElement, {
      ref: customizeRawInputRef
    }) : /* @__PURE__ */ React137.createElement(
      Selector_default,
      {
        ...props,
        domRef: selectorDomRef,
        prefixCls,
        inputElement: customizeInputElement,
        ref: selectorRef,
        id,
        showSearch: mergedShowSearch,
        autoClearSearchValue,
        mode,
        activeDescendantId,
        tagRender,
        values: displayValues,
        open: mergedOpen,
        onToggleOpen,
        activeValue,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        onSearchSubmit: onInternalSearchSubmit,
        onRemove: onSelectorRemove,
        tokenWithEnter
      }
    )
  );
  let renderNode;
  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode = /* @__PURE__ */ React137.createElement(
      "div",
      {
        className: mergedClassName,
        ...domProps,
        ref: containerRef,
        onMouseDown: onInternalMouseDown,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onFocus: onContainerFocus,
        onBlur: onContainerBlur
      },
      mockFocused && !mergedOpen && /* @__PURE__ */ React137.createElement(
        "span",
        {
          "aria-live": "polite",
          style: { width: 0, height: 0, position: "absolute", overflow: "hidden", opacity: 0 }
        },
        `${displayValues.map(
          ({ label, value }) => ["number", "string"].includes(typeof label) ? label : value
        ).join(", ")}`
      ),
      selectorNode,
      arrowNode,
      mergedAllowClear && clearNode
    );
  }
  return /* @__PURE__ */ React137.createElement(BaseSelectContext.Provider, { value: baseSelectContext }, renderNode);
});
if (true) {
  BaseSelect.displayName = "BaseSelect";
}
var BaseSelect_default = BaseSelect;

// packages/select/src/OptGroup.tsx
var OptGroup = /* @__PURE__ */ __name(() => null, "OptGroup");
OptGroup.isSelectOptGroup = true;
var OptGroup_default = OptGroup;

// packages/select/src/Option.tsx
var Option = /* @__PURE__ */ __name(() => null, "Option");
Option.isSelectOption = true;
var Option_default = Option;

// packages/select/src/OptionList.tsx
var import_classnames41 = __toESM(require_classnames());

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/List.js
var import_classnames40 = __toESM(require_classnames());
import * as React146 from "react";
import { useRef as useRef55, useState as useState40 } from "react";
import { flushSync } from "react-dom";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/Filler.js
import * as React138 from "react";
var import_classnames38 = __toESM(require_classnames());
var Filler = /* @__PURE__ */ React138.forwardRef(function(_ref, ref) {
  var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offsetY !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      transform: "translateY(".concat(offsetY, "px)")
    }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0));
  }
  return /* @__PURE__ */ React138.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ React138.createElement(src_default, {
    onResize: /* @__PURE__ */ __name(function onResize2(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }, "onResize")
  }, /* @__PURE__ */ React138.createElement("div", _extends({
    style: innerStyle,
    className: (0, import_classnames38.default)(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref
  }, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var Filler_default = Filler;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/ScrollBar.js
var import_classnames39 = __toESM(require_classnames());
import * as React139 from "react";
function getPageXY(e3, horizontal) {
  var obj = "touches" in e3 ? e3.touches[0] : e3;
  return obj[horizontal ? "pageX" : "pageY"];
}
__name(getPageXY, "getPageXY");
var ScrollBar = /* @__PURE__ */ React139.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle;
  var _React$useState = React139.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
  var _React$useState3 = React139.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
  var _React$useState5 = React139.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
  var isLTR = !rtl;
  var scrollbarRef = React139.useRef();
  var thumbRef = React139.useRef();
  var _React$useState7 = React139.useState(false), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
  var visibleTimeoutRef = React139.useRef();
  var delayHidden = /* @__PURE__ */ __name(function delayHidden2() {
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(function() {
      setVisible(false);
    }, 3e3);
  }, "delayHidden");
  var enableScrollRange = scrollRange - containerSize || 0;
  var enableOffsetRange = containerSize - spinSize || 0;
  var top = React139.useMemo(function() {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    var ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);
  var onContainerMouseDown = /* @__PURE__ */ __name(function onContainerMouseDown2(e3) {
    e3.stopPropagation();
    e3.preventDefault();
  }, "onContainerMouseDown");
  var stateRef = React139.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  var onThumbMouseDown = /* @__PURE__ */ __name(function onThumbMouseDown2(e3) {
    setDragging(true);
    setPageXY(getPageXY(e3, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e3.stopPropagation();
    e3.preventDefault();
  }, "onThumbMouseDown");
  React139.useEffect(function() {
    var onScrollbarTouchStart = /* @__PURE__ */ __name(function onScrollbarTouchStart2(e3) {
      e3.preventDefault();
    }, "onScrollbarTouchStart");
    var scrollbarEle = scrollbarRef.current;
    var thumbEle = thumbRef.current;
    scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart);
    thumbEle.addEventListener("touchstart", onThumbMouseDown);
    return function() {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  var enableScrollRangeRef = React139.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  var enableOffsetRangeRef = React139.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  React139.useEffect(function() {
    if (dragging) {
      var moveRafId;
      var onMouseMove = /* @__PURE__ */ __name(function onMouseMove2(e3) {
        var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
        raf_default.cancel(moveRafId);
        if (stateDragging) {
          var offset3 = getPageXY(e3, horizontal) - statePageY;
          var newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset3;
          } else {
            newTop += offset3;
          }
          var tmpEnableScrollRange = enableScrollRangeRef.current;
          var tmpEnableOffsetRange = enableOffsetRangeRef.current;
          var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = raf_default(function() {
            onScroll(newScrollTop, horizontal);
          });
        }
      }, "onMouseMove");
      var onMouseUp = /* @__PURE__ */ __name(function onMouseUp2() {
        setDragging(false);
        onStopMove();
      }, "onMouseUp");
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("touchmove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      window.addEventListener("touchend", onMouseUp);
      return function() {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
        window.removeEventListener("touchend", onMouseUp);
        raf_default.cancel(moveRafId);
      };
    }
  }, [dragging]);
  React139.useEffect(function() {
    delayHidden();
  }, [scrollOffset]);
  React139.useImperativeHandle(ref, function() {
    return {
      delayHidden
    };
  });
  var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
  var containerStyle = {
    position: "absolute",
    visibility: visible ? null : "hidden"
  };
  var thumbStyle = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  if (horizontal) {
    containerStyle.height = 8;
    containerStyle.left = 0;
    containerStyle.right = 0;
    containerStyle.bottom = 0;
    thumbStyle.height = "100%";
    thumbStyle.width = spinSize;
    if (isLTR) {
      thumbStyle.left = top;
    } else {
      thumbStyle.right = top;
    }
  } else {
    containerStyle.width = 8;
    containerStyle.top = 0;
    containerStyle.bottom = 0;
    if (isLTR) {
      containerStyle.right = 0;
    } else {
      containerStyle.left = 0;
    }
    thumbStyle.width = "100%";
    thumbStyle.height = spinSize;
    thumbStyle.top = top;
  }
  return /* @__PURE__ */ React139.createElement("div", {
    ref: scrollbarRef,
    className: (0, import_classnames39.default)(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
    style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, /* @__PURE__ */ React139.createElement("div", {
    ref: thumbRef,
    className: (0, import_classnames39.default)("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
    style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
    onMouseDown: onThumbMouseDown
  }));
});
if (true) {
  ScrollBar.displayName = "ScrollBar";
}
var ScrollBar_default = ScrollBar;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useChildren.js
import * as React141 from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/Item.js
import * as React140 from "react";
function Item2(_ref) {
  var children = _ref.children, setRef = _ref.setRef;
  var refFunc = React140.useCallback(function(node2) {
    setRef(node2);
  }, []);
  return /* @__PURE__ */ React140.cloneElement(children, {
    ref: refFunc
  });
}
__name(Item2, "Item");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useChildren.js
function useChildren(list, startIndex, endIndex, scrollWidth, setNodeRef, renderFunc, _ref) {
  var getKey4 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index3) {
    var eleIndex = startIndex + index3;
    var node2 = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      }
    });
    var key = getKey4(item);
    return /* @__PURE__ */ React141.createElement(Item2, {
      key,
      setRef: /* @__PURE__ */ __name(function setRef(ele) {
        return setNodeRef(item, ele);
      }, "setRef")
    }, node2);
  });
}
__name(useChildren, "useChildren");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useHeights.js
import * as React142 from "react";
import { useRef as useRef50, useEffect as useEffect39 } from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/utils/CacheMap.js
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap3() {
    _classCallCheck(this, CacheMap3);
    _defineProperty(this, "maps", void 0);
    _defineProperty(this, "id", 0);
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  __name(CacheMap3, "CacheMap");
  _createClass(CacheMap3, [{
    key: "set",
    value: /* @__PURE__ */ __name(function set2(key, value) {
      this.maps[key] = value;
      this.id += 1;
    }, "set")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(key) {
      return this.maps[key];
    }, "get")
  }]);
  return CacheMap3;
}();
var CacheMap_default = CacheMap;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useHeights.js
function useHeights(getKey4, onItemAdd, onItemRemove) {
  var _React$useState = React142.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = useRef50(/* @__PURE__ */ new Map());
  var heightsRef = useRef50(new CacheMap_default());
  var collectRafRef = useRef50();
  function cancelRaf() {
    raf_default.cancel(collectRafRef.current);
  }
  __name(cancelRaf, "cancelRaf");
  function collectHeight() {
    var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    cancelRaf();
    var doCollect = /* @__PURE__ */ __name(function doCollect2() {
      instanceRef.current.forEach(function(element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c) {
        return c + 1;
      });
    }, "doCollect");
    if (sync) {
      doCollect();
    } else {
      collectRafRef.current = raf_default(doCollect);
    }
  }
  __name(collectHeight, "collectHeight");
  function setInstanceRef(item, instance) {
    var key = getKey4(item);
    var origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
      }
    }
  }
  __name(setInstanceRef, "setInstanceRef");
  useEffect39(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
__name(useHeights, "useHeights");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useScrollTo.js
import * as React143 from "react";
var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey4, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = React143.useRef();
  var _React$useState = React143.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
  useLayoutEffect_default(function() {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState(function(ori) {
          return _objectSpread2({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index3 = syncState.index, offset3 = syncState.offset;
      var height = containerRef.current.clientHeight;
      var needCollectHeight = false;
      var newTargetAlign = targetAlign;
      var targetTop = null;
      if (height) {
        var mergedAlign = targetAlign || originAlign;
        var stackTop = 0;
        var itemTop = 0;
        var itemBottom = 0;
        var maxLen = Math.min(data.length - 1, index3);
        for (var i = 0; i <= maxLen; i += 1) {
          var key = getKey4(data[i]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        var leftHeight = mergedAlign === "top" ? offset3 : height - offset3;
        for (var _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey4(data[_i]);
          var _cacheHeight = heights.get(_key);
          if (_cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= _cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset3;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset3;
            break;
          default: {
            var scrollTop = containerRef.current.scrollTop;
            var scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        }));
      }
    } else if ((syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {
      warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
    }
  }, [syncState, containerRef.current]);
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    raf_default.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof(arg) === "object") {
      var index3;
      var align = arg.align;
      if ("index" in arg) {
        index3 = arg.index;
      } else {
        index3 = data.findIndex(function(item) {
          return getKey4(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index: index3,
        offset: offset3,
        originAlign: align
      });
    }
  };
}
__name(useScrollTo, "useScrollTo");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useDiffItem.js
import * as React144 from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/utils/algorithmUtil.js
function findListDiffIndex(originList, targetList, getKey4) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey4(item);
    }
    return notExistKey;
  }
  __name(getItemKey, "getItemKey");
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
__name(findListDiffIndex, "findListDiffIndex");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useDiffItem.js
function useDiffItem(data, getKey4, onDiff) {
  var _React$useState = React144.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = React144.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  React144.useEffect(function() {
    var diff = findListDiffIndex(prevData || [], data || [], getKey4);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
      onDiff === null || onDiff === void 0 || onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}
__name(useDiffItem, "useDiffItem");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
import { useRef as useRef53 } from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/utils/isFirefox.js
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default = isFF;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useOriginScroll.js
import { useRef as useRef52 } from "react";
var useOriginScroll_default = /* @__PURE__ */ __name(function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = useRef52(false);
  var lockTimeoutRef = useRef52(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  __name(lockScroll, "lockScroll");
  var scrollPingRef = useRef52({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = (
      // Pass origin wheel when on the top
      deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
      deltaY > 0 && scrollPingRef.current.bottom
    );
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
}, "default");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, horizontalScroll, onWheelDelta) {
  var offsetRef = useRef53(0);
  var nextFrameRef = useRef53(null);
  var wheelValueRef = useRef53(null);
  var isMouseScrollRef = useRef53(false);
  var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom);
  function onWheelY(event, deltaY) {
    raf_default.cancel(nextFrameRef.current);
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFirefox_default) {
      event.preventDefault();
    }
    nextFrameRef.current = raf_default(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  __name(onWheelY, "onWheelY");
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFirefox_default) {
      event.preventDefault();
    }
  }
  __name(onWheelX, "onWheelX");
  var wheelDirectionRef = useRef53(null);
  var wheelDirectionCleanRef = useRef53(null);
  function onWheel(event) {
    if (!inVirtual)
      return;
    raf_default.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = raf_default(function() {
      wheelDirectionRef.current = null;
    }, 2);
    var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
    var mergedDeltaX = deltaX;
    var mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = "sx";
    }
    var absX = Math.abs(mergedDeltaX);
    var absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
    }
    if (wheelDirectionRef.current === "y") {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }
  __name(onWheel, "onWheel");
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  __name(onFireFoxScroll, "onFireFoxScroll");
  return [onWheel, onFireFoxScroll];
}
__name(useFrameWheel, "useFrameWheel");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js
import { useRef as useRef54 } from "react";
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = useRef54(false);
  var touchYRef = useRef54(0);
  var elementRef = useRef54(null);
  var intervalRef = useRef54(null);
  var cleanUpEvents;
  var onTouchMove = /* @__PURE__ */ __name(function onTouchMove2(e3) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e3.touches[0].pageY);
      var _offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(_offsetY)) {
        e3.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        _offsetY *= SMOOTH_PTG;
        if (!callback(_offsetY, true) || Math.abs(_offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  }, "onTouchMove");
  var onTouchEnd = /* @__PURE__ */ __name(function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  }, "onTouchEnd");
  var onTouchStart = /* @__PURE__ */ __name(function onTouchStart2(e3) {
    cleanUpEvents();
    if (e3.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e3.touches[0].pageY);
      elementRef.current = e3.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  }, "onTouchStart");
  cleanUpEvents = /* @__PURE__ */ __name(function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  }, "cleanUpEvents");
  useLayoutEffect_default(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
__name(useMobileTouchMove, "useMobileTouchMove");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize() {
  var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var baseSize = containerSize / scrollRange * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  return Math.floor(baseSize);
}
__name(getSpinSize, "getSpinSize");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/hooks/useGetSize.js
import * as React145 from "react";
function useGetSize(mergedData, getKey4, heights, itemHeight) {
  var _React$useMemo = React145.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
  var getSize3 = /* @__PURE__ */ __name(function getSize4(startKey) {
    var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
    var startIndex = key2Index.get(startKey);
    var endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0) {
      var dataLen = mergedData.length;
      for (var i = bottomList.length; i < dataLen; i += 1) {
        var _heights$get;
        var item = mergedData[i];
        var key = getKey4(item);
        key2Index.set(key, i);
        var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }
        if (startIndex !== void 0 && endIndex !== void 0) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  }, "getSize");
  return getSize3;
}
__name(useGetSize, "useGetSize");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/List.js
var _excluded5 = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"];
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey3 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component11 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, restProps = _objectWithoutProperties(props, _excluded5);
  var getKey4 = React146.useCallback(function(item) {
    if (typeof itemKey3 === "function") {
      return itemKey3(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey3];
  }, [itemKey3]);
  var _useHeights = useHeights(getKey4, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var containerHeight = React146.useMemo(function() {
    return Object.values(heights.maps).reduce(function(total, curr) {
      return total + curr;
    }, 0);
  }, [heights.id, heights.maps]);
  var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  var isRTL = direction === "rtl";
  var mergedClassName = (0, import_classnames40.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
  var mergedData = data || EMPTY_DATA;
  var componentRef = useRef55();
  var fillerInnerRef = useRef55();
  var _useState = useState40(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
  var _useState3 = useState40(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
  var _useState5 = useState40(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
  var onScrollbarStartMove = /* @__PURE__ */ __name(function onScrollbarStartMove2() {
    setScrollMoving(true);
  }, "onScrollbarStartMove");
  var onScrollbarStopMove = /* @__PURE__ */ __name(function onScrollbarStopMove2() {
    setScrollMoving(false);
  }, "onScrollbarStopMove");
  var sharedConfig = {
    getKey: getKey4
  };
  function syncScrollTop(newTop) {
    setOffsetTop(function(origin) {
      var value;
      if (typeof newTop === "function") {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  __name(syncScrollTop, "syncScrollTop");
  var rangeRef = useRef55({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = useRef55();
  var _useDiffItem = useDiffItem(mergedData, getKey4), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _React$useMemo = React146.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i = 0; i < dataLen; i += 1) {
      var _item = mergedData[i];
      var key = getKey4(_item);
      var cacheHeight = heights.get(key);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= offsetTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > offsetTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var _React$useState = React146.useState({
    width: 0,
    height
  }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
  var onHolderResize = /* @__PURE__ */ __name(function onHolderResize2(sizeInfo) {
    setSize({
      width: sizeInfo.width || sizeInfo.offsetWidth,
      height: sizeInfo.height || sizeInfo.offsetHeight
    });
  }, "onHolderResize");
  var verticalScrollBarRef = useRef55();
  var horizontalScrollBarRef = useRef55();
  var horizontalScrollBarSpinSize = React146.useMemo(function() {
    return getSpinSize(size.width, scrollWidth);
  }, [size.width, scrollWidth]);
  var verticalScrollBarSpinSize = React146.useMemo(function() {
    return getSpinSize(size.height, scrollHeight);
  }, [size.height, scrollHeight]);
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = useRef55(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  __name(keepInRange, "keepInRange");
  var isScrollAtTop = offsetTop <= 0;
  var isScrollAtBottom = offsetTop >= maxScrollHeight;
  var originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom);
  var getVirtualScrollInfo = /* @__PURE__ */ __name(function getVirtualScrollInfo2() {
    return {
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    };
  }, "getVirtualScrollInfo");
  var lastVirtualScrollInfoRef = useRef55(getVirtualScrollInfo());
  var triggerScroll = useEvent(function() {
    if (onVirtualScroll) {
      var nextInfo = getVirtualScrollInfo();
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    var newOffset = newScrollOffset;
    if (horizontal) {
      flushSync(function() {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }
  __name(onScrollBar, "onScrollBar");
  function onFallbackScroll(e3) {
    var newScrollTop = e3.currentTarget.scrollTop;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 || onScroll(e3);
    triggerScroll();
  }
  __name(onFallbackScroll, "onFallbackScroll");
  var keepInHorizontalRange = /* @__PURE__ */ __name(function keepInHorizontalRange2(nextOffsetLeft) {
    var tmpOffsetLeft = nextOffsetLeft;
    var max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
    return tmpOffsetLeft;
  }, "keepInHorizontalRange");
  var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
    if (fromHorizontal) {
      flushSync(function() {
        setOffsetLeft(function(left) {
          var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop(function(top) {
        var newTop = top + offsetXY;
        return newTop;
      });
    }
  });
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: /* @__PURE__ */ __name(function preventDefault() {
      }, "preventDefault"),
      deltaY
    });
    return true;
  });
  useLayoutEffect_default(function() {
    function onMozMousePixelScroll(e3) {
      if (useVirtual) {
        e3.preventDefault();
      }
    }
    __name(onMozMousePixelScroll, "onMozMousePixelScroll");
    var componentEle = componentRef.current;
    componentEle.addEventListener("wheel", onRawWheel);
    componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      componentEle.removeEventListener("wheel", onRawWheel);
      componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual]);
  useLayoutEffect_default(function() {
    if (scrollWidth) {
      setOffsetLeft(function(left) {
        return keepInHorizontalRange(left);
      });
    }
  }, [size.width, scrollWidth]);
  var delayHideScrollBar = /* @__PURE__ */ __name(function delayHideScrollBar2() {
    var _verticalScrollBarRef, _horizontalScrollBarR;
    (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
    (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
  }, "delayHideScrollBar");
  var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey4, function() {
    return collectHeight(true);
  }, syncScrollTop, delayHideScrollBar);
  React146.useImperativeHandle(ref, function() {
    return {
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: /* @__PURE__ */ __name(function scrollTo2(config) {
        function isPosScroll(arg) {
          return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
        }
        __name(isPosScroll, "isPosScroll");
        if (isPosScroll(config)) {
          if (config.left !== void 0) {
            setOffsetLeft(keepInHorizontalRange(config.left));
          }
          _scrollTo(config.top);
        } else {
          _scrollTo(config);
        }
      }, "scrollTo")
    };
  });
  useLayoutEffect_default(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var getSize3 = useGetSize(mergedData, getKey4, heights, itemHeight);
  var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize: getSize3
  });
  var listChildren = useChildren(mergedData, start, end, scrollWidth, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollWidth) {
        componentStyle.overflowX = "hidden";
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  var containerProps = {};
  if (isRTL) {
    containerProps.dir = "rtl";
  }
  return /* @__PURE__ */ React146.createElement("div", _extends({
    style: _objectSpread2(_objectSpread2({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, containerProps, restProps), /* @__PURE__ */ React146.createElement(src_default, {
    onResize: onHolderResize
  }, /* @__PURE__ */ React146.createElement(Component11, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, /* @__PURE__ */ React146.createElement(Filler_default, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ React146.createElement(ScrollBar_default, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb
  }), inVirtual && scrollWidth > size.width && /* @__PURE__ */ React146.createElement(ScrollBar_default, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb
  }));
}
__name(RawList, "RawList");
var List2 = /* @__PURE__ */ React146.forwardRef(RawList);
List2.displayName = "List";
var List_default2 = List2;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@18.2.0_react@18.2.0/node_modules/rc-virtual-list/es/index.js
var es_default5 = List_default2;

// packages/select/src/OptionList.tsx
import * as React147 from "react";
import { useEffect as useEffect41 } from "react";

// packages/select/src/utils/platformUtil.ts
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
__name(isPlatformMac, "isPlatformMac");

// packages/select/src/OptionList.tsx
function isTitleType2(content) {
  return typeof content === "string" || typeof content === "number";
}
__name(isTitleType2, "isTitleType");
var OptionList = /* @__PURE__ */ __name((_, ref) => {
  const {
    prefixCls,
    id,
    open: open3,
    multiple,
    mode,
    searchValue,
    toggleOpen,
    notFoundContent,
    onPopupScroll
  } = useBaseProps();
  const {
    maxCount,
    flattenOptions: flattenOptions2,
    onActiveValue,
    defaultActiveFirstOption,
    onSelect,
    menuItemSelectedIcon,
    rawValues,
    fieldNames,
    virtual,
    direction,
    listHeight,
    listItemHeight,
    optionRender
  } = React147.useContext(SelectContext_default);
  const itemPrefixCls = `${prefixCls}-item`;
  const memoFlattenOptions = useMemo(
    () => flattenOptions2,
    [open3, flattenOptions2],
    (prev2, next2) => next2[0] && prev2[1] !== next2[1]
  );
  const listRef = React147.useRef(null);
  const overMaxCount = React147.useMemo(
    () => multiple && isValidCount(maxCount) && rawValues?.size >= maxCount,
    [multiple, maxCount, rawValues?.size]
  );
  const onListMouseDown = /* @__PURE__ */ __name((event) => {
    event.preventDefault();
  }, "onListMouseDown");
  const scrollIntoView = /* @__PURE__ */ __name((args) => {
    listRef.current?.scrollTo(typeof args === "number" ? { index: args } : args);
  }, "scrollIntoView");
  const getEnabledActiveIndex = /* @__PURE__ */ __name((index3, offset3 = 1) => {
    const len = memoFlattenOptions.length;
    for (let i = 0; i < len; i += 1) {
      const current = (index3 + i * offset3 + len) % len;
      const { group, data } = memoFlattenOptions[current] || {};
      if (!group && !data?.disabled && !overMaxCount) {
        return current;
      }
    }
    return -1;
  }, "getEnabledActiveIndex");
  const [activeIndex, setActiveIndex] = React147.useState(() => getEnabledActiveIndex(0));
  const setActive = /* @__PURE__ */ __name((index3, fromKeyboard = false) => {
    setActiveIndex(index3);
    const info = { source: fromKeyboard ? "keyboard" : "mouse" };
    const flattenItem = memoFlattenOptions[index3];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index3, info);
  }, "setActive");
  useEffect41(() => {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  const isSelected = React147.useCallback(
    (value) => rawValues.has(value) && mode !== "combobox",
    [mode, [...rawValues].toString(), rawValues.size]
  );
  useEffect41(() => {
    const timeoutId = setTimeout(() => {
      if (!multiple && open3 && rawValues.size === 1) {
        const value = Array.from(rawValues)[0];
        const index3 = memoFlattenOptions.findIndex(({ data }) => data.value === value);
        if (index3 !== -1) {
          setActive(index3);
          scrollIntoView(index3);
        }
      }
    });
    if (open3) {
      listRef.current?.scrollTo(void 0);
    }
    return () => clearTimeout(timeoutId);
  }, [open3, searchValue]);
  const onSelectValue = /* @__PURE__ */ __name((value) => {
    if (value !== void 0) {
      onSelect(value, { selected: !rawValues.has(value) });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  }, "onSelectValue");
  React147.useImperativeHandle(ref, () => ({
    onKeyDown: (event) => {
      const { which, ctrlKey } = event;
      switch (which) {
        case KeyCode_default.N:
        case KeyCode_default.P:
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset3 = 0;
          if (which === KeyCode_default.UP) {
            offset3 = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset3 = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode_default.N) {
              offset3 = 1;
            } else if (which === KeyCode_default.P) {
              offset3 = -1;
            }
          }
          if (offset3 !== 0) {
            const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
            scrollIntoView(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        case KeyCode_default.ENTER: {
          const item = memoFlattenOptions[activeIndex];
          if (item && !item?.data?.disabled && !overMaxCount) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (open3) {
            event.preventDefault();
          }
          break;
        }
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open3) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    },
    scrollTo: (index3) => {
      scrollIntoView(index3);
    }
  }));
  if (memoFlattenOptions.length === 0) {
    return /* @__PURE__ */ React147.createElement(
      "div",
      {
        role: "listbox",
        id: `${id}_list`,
        className: `${itemPrefixCls}-empty`,
        onMouseDown: onListMouseDown
      },
      notFoundContent
    );
  }
  const omitFieldNameList = Object.keys(fieldNames).map((key) => fieldNames[key]);
  const getLabel = /* @__PURE__ */ __name((item) => item.label, "getLabel");
  function getItemAriaProps(item, index3) {
    const { group } = item;
    return {
      role: group ? "presentation" : "option",
      id: `${id}_list_${index3}`
    };
  }
  __name(getItemAriaProps, "getItemAriaProps");
  const renderItem2 = /* @__PURE__ */ __name((index3) => {
    const item = memoFlattenOptions[index3];
    if (!item) {
      return null;
    }
    const itemData = item.data || {};
    const { value } = itemData;
    const { group } = item;
    const attrs = pickAttrs(itemData, true);
    const mergedLabel = getLabel(item);
    return item ? /* @__PURE__ */ React147.createElement(
      "div",
      {
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null,
        ...attrs,
        key: index3,
        ...getItemAriaProps(item, index3),
        "aria-selected": isSelected(value)
      },
      value
    ) : null;
  }, "renderItem");
  const a11yProps = {
    role: "listbox",
    id: `${id}_list`
  };
  return /* @__PURE__ */ React147.createElement(React147.Fragment, null, virtual && /* @__PURE__ */ React147.createElement("div", { ...a11yProps, style: { height: 0, width: 0, overflow: "hidden" } }, renderItem2(activeIndex - 1), renderItem2(activeIndex), renderItem2(activeIndex + 1)), /* @__PURE__ */ React147.createElement(
    es_default5,
    {
      itemKey: "key",
      ref: listRef,
      data: memoFlattenOptions,
      height: listHeight,
      itemHeight: listItemHeight,
      fullHeight: false,
      onMouseDown: onListMouseDown,
      onScroll: onPopupScroll,
      virtual,
      direction,
      innerProps: virtual ? null : a11yProps
    },
    (item, itemIndex) => {
      const { group, groupOption, data, label, value } = item;
      const { key } = data;
      if (group) {
        const groupTitle = data.title ?? (isTitleType2(label) ? label.toString() : void 0);
        return /* @__PURE__ */ React147.createElement(
          "div",
          {
            className: (0, import_classnames41.default)(itemPrefixCls, `${itemPrefixCls}-group`, data.className),
            title: groupTitle
          },
          label !== void 0 ? label : key
        );
      }
      const { disabled, title, children, style: style2, className, ...otherProps } = data;
      const passedProps = omit(otherProps, omitFieldNameList);
      const selected = isSelected(value);
      const mergedDisabled = disabled || !selected && overMaxCount;
      const optionPrefixCls = `${itemPrefixCls}-option`;
      const optionClassName = (0, import_classnames41.default)(itemPrefixCls, optionPrefixCls, className, {
        [`${optionPrefixCls}-grouped`]: groupOption,
        [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
        [`${optionPrefixCls}-disabled`]: mergedDisabled,
        [`${optionPrefixCls}-selected`]: selected
      });
      const mergedLabel = getLabel(item);
      const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
      const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
      let optionTitle = isTitleType2(content) ? content.toString() : void 0;
      if (title !== void 0) {
        optionTitle = title;
      }
      return /* @__PURE__ */ React147.createElement(
        "div",
        {
          ...pickAttrs(passedProps),
          ...!virtual ? getItemAriaProps(item, itemIndex) : {},
          "aria-selected": selected,
          className: optionClassName,
          title: optionTitle,
          onMouseMove: () => {
            if (activeIndex === itemIndex || mergedDisabled) {
              return;
            }
            setActive(itemIndex);
          },
          onClick: () => {
            if (!mergedDisabled) {
              onSelectValue(value);
            }
          },
          style: style2
        },
        /* @__PURE__ */ React147.createElement("div", { className: `${optionPrefixCls}-content` }, typeof optionRender === "function" ? optionRender(item, { index: itemIndex }) : content),
        React147.isValidElement(menuItemSelectedIcon) || selected,
        iconVisible && /* @__PURE__ */ React147.createElement(
          TransBtn_default,
          {
            className: `${itemPrefixCls}-option-state`,
            customizeIcon: menuItemSelectedIcon,
            customizeIconProps: {
              value,
              disabled: mergedDisabled,
              isSelected: selected
            }
          },
          selected ? "\u2713" : null
        )
      );
    }
  ));
}, "OptionList");
var RefOptionList = React147.forwardRef(OptionList);
if (true) {
  RefOptionList.displayName = "OptionList";
}
var OptionList_default = RefOptionList;

// packages/select/src/hooks/useCache.ts
import * as React148 from "react";
var useCache_default = /* @__PURE__ */ __name((labeledValues, valueOptions) => {
  const cacheRef = React148.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  const filledLabeledValues = React148.useMemo(() => {
    const { values: prevValueCache, options: prevOptionCache } = cacheRef.current;
    const patchedValues = labeledValues.map((item) => {
      if (item.label === void 0) {
        return {
          ...item,
          label: prevValueCache.get(item.value)?.label
        };
      }
      return item;
    });
    const valueCache = /* @__PURE__ */ new Map();
    const optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach((item) => {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  const getOption = React148.useCallback(
    (val) => valueOptions.get(val) || cacheRef.current.options.get(val),
    [valueOptions]
  );
  return [filledLabeledValues, getOption];
}, "default");

// packages/select/src/hooks/useFilterOptions.ts
import * as React149 from "react";
function includes(test, search) {
  return toArray3(test).join("").toUpperCase().includes(search);
}
__name(includes, "includes");
var useFilterOptions_default = /* @__PURE__ */ __name((options, fieldNames, searchValue, filterOption2, optionFilterProp) => React149.useMemo(() => {
  if (!searchValue || filterOption2 === false) {
    return options;
  }
  const { options: fieldOptions, label: fieldLabel, value: fieldValue } = fieldNames;
  const filteredOptions = [];
  const customizeFilter = typeof filterOption2 === "function";
  const upperSearch = searchValue.toUpperCase();
  const filterFunc = customizeFilter ? filterOption2 : (_, option) => {
    if (optionFilterProp) {
      return includes(option[optionFilterProp], upperSearch);
    }
    if (option[fieldOptions]) {
      return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
    }
    return includes(option[fieldValue], upperSearch);
  };
  const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
  options.forEach((item) => {
    if (item[fieldOptions]) {
      const matchGroup = filterFunc(searchValue, wrapOption(item));
      if (matchGroup) {
        filteredOptions.push(item);
      } else {
        const subOptions = item[fieldOptions].filter(
          (subItem) => filterFunc(searchValue, wrapOption(subItem))
        );
        if (subOptions.length) {
          filteredOptions.push({
            ...item,
            [fieldOptions]: subOptions
          });
        }
      }
      return;
    }
    if (filterFunc(searchValue, wrapOption(item))) {
      filteredOptions.push(item);
    }
  });
  return filteredOptions;
}, [options, filterOption2, optionFilterProp, searchValue, fieldNames]), "default");

// packages/select/src/hooks/useId.ts
init_canUseDom();
import * as React150 from "react";
var uuid6 = 0;
var isBrowserClient2 = canUseDom();
function getUUID() {
  let retId;
  if (isBrowserClient2) {
    retId = uuid6;
    uuid6 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
__name(getUUID, "getUUID");
function useId3(id) {
  const [innerId, setInnerId] = React150.useState();
  React150.useEffect(() => {
    setInnerId(`rc_select_${getUUID()}`);
  }, []);
  return id || innerId;
}
__name(useId3, "useId");

// packages/select/src/hooks/useOptions.ts
import * as React152 from "react";

// packages/select/src/utils/legacyUtil.ts
import * as React151 from "react";
function convertNodeToOption(node2) {
  const {
    key,
    props: { children, value, ...restProps }
  } = node2;
  return { key, value: value !== void 0 ? value : key, children, ...restProps };
}
__name(convertNodeToOption, "convertNodeToOption");
function convertChildrenToData(nodes, optionOnly = false) {
  return toArray(nodes).map((node2, index3) => {
    if (!React151.isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      type: { isSelectOptGroup },
      key,
      props: { children, ...restProps }
    } = node2;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node2);
    }
    return {
      key: `__RC_SELECT_GRP__${key === null ? index3 : key}__`,
      label: key,
      ...restProps,
      options: convertChildrenToData(children)
    };
  }).filter((data) => data);
}
__name(convertChildrenToData, "convertChildrenToData");

// packages/select/src/hooks/useOptions.ts
var useOptions = /* @__PURE__ */ __name((options, children, fieldNames, optionFilterProp, optionLabelProp) => {
  return React152.useMemo(() => {
    let mergedOptions = options;
    const childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    const valueOptions = /* @__PURE__ */ new Map();
    const labelOptions = /* @__PURE__ */ new Map();
    const setLabelOptions = /* @__PURE__ */ __name((labelOptionsMap, option, key) => {
      if (key && typeof key === "string") {
        labelOptionsMap.set(option[key], option);
      }
    }, "setLabelOptions");
    const dig = /* @__PURE__ */ __name((optionList, isChildren = false) => {
      for (let i = 0; i < optionList.length; i += 1) {
        const option = optionList[i];
        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }, "dig");
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}, "useOptions");
var useOptions_default = useOptions;

// packages/select/src/hooks/useRefFunc.ts
import * as React153 from "react";
function useRefFunc(callback) {
  const funcRef = React153.useRef();
  funcRef.current = callback;
  const cacheFn = React153.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}
__name(useRefFunc, "useRefFunc");

// packages/select/src/utils/warningPropsUtil.ts
init_warning();
import * as React154 from "react";
function warningProps(props) {
  const {
    mode,
    options,
    children,
    backfill,
    allowClear,
    placeholder,
    getInputElement,
    showSearch,
    onSearch,
    defaultOpen,
    autoFocus,
    labelInValue,
    value,
    inputValue,
    optionLabelProp
  } = props;
  const multiple = isMultiple(mode);
  const mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
  const mergedOptions = options || convertChildrenToData(children);
  warning_default(
    mode !== "tags" || mergedOptions.every((opt) => !opt.disabled),
    "Please avoid setting option to disabled in tags mode since user can always type text as tag."
  );
  if (mode === "tags" || mode === "combobox") {
    const hasNumberValue = mergedOptions.some((item) => {
      if (item.options) {
        return item.options.some(
          (opt) => typeof ("value" in opt ? opt.value : opt.key) === "number"
        );
      }
      return typeof ("value" in item ? item.value : item.key) === "number";
    });
    warning_default(
      !hasNumberValue,
      "`value` of Option should not use number type when `mode` is `tags` or `combobox`."
    );
  }
  warning_default(
    mode !== "combobox" || !optionLabelProp,
    "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."
  );
  warning_default(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
  warning_default(
    mode === "combobox" || !getInputElement,
    "`getInputElement` only work with `combobox` mode."
  );
  noteOnce(
    mode !== "combobox" || !getInputElement || !allowClear || !placeholder,
    "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."
  );
  if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") {
    warning_default(false, "`onSearch` should work with `showSearch` instead of use alone.");
  }
  noteOnce(
    !defaultOpen || autoFocus,
    "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed."
  );
  if (value !== void 0 && value !== null) {
    const values = toArray3(value);
    warning_default(
      !labelInValue || values.every((val) => typeof val === "object" && ("key" in val || "value" in val)),
      "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`"
    );
    warning_default(
      !multiple || Array.isArray(value),
      "`value` should be array when `mode` is `multiple` or `tags`"
    );
  }
  if (children) {
    let invalidateChildType = null;
    toArray(children).some((node2) => {
      if (!React154.isValidElement(node2) || !node2.type) {
        return false;
      }
      const { type: type5 } = node2;
      if (type5.isSelectOption) {
        return false;
      }
      if (type5.isSelectOptGroup) {
        const allChildrenValid = toArray(node2.props.children).every(
          (subNode) => {
            if (!React154.isValidElement(subNode) || !node2.type || subNode.type.isSelectOption) {
              return true;
            }
            invalidateChildType = subNode.type;
            return false;
          }
        );
        if (allChildrenValid) {
          return false;
        }
        return true;
      }
      invalidateChildType = type5;
      return true;
    });
    if (invalidateChildType) {
      warning_default(
        false,
        `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${invalidateChildType.displayName || invalidateChildType.name || invalidateChildType}\`.`
      );
    }
    warning_default(
      inputValue === void 0,
      "`inputValue` is deprecated, please use `searchValue` instead."
    );
  }
}
__name(warningProps, "warningProps");
function warningNullOptions(options, fieldNames) {
  if (options) {
    const recursiveOptions = /* @__PURE__ */ __name((optionsList, inGroup = false) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames?.value] === null) {
          warning_default(false, "`value` in Select options should not be `null`.");
          return true;
        }
        if (!inGroup && Array.isArray(option[fieldNames?.options]) && recursiveOptions(option[fieldNames?.options], true)) {
          break;
        }
      }
    }, "recursiveOptions");
    recursiveOptions(options);
  }
}
__name(warningNullOptions, "warningNullOptions");
var warningPropsUtil_default = warningProps;

// packages/select/src/Select.tsx
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value) {
  return !value || typeof value !== "object";
}
__name(isRawValue, "isRawValue");
var Select = React155.forwardRef(
  (props, ref) => {
    const {
      id,
      mode,
      prefixCls = "rc-select",
      backfill,
      fieldNames,
      // Search
      inputValue,
      searchValue,
      onSearch,
      autoClearSearchValue = true,
      // Select
      onSelect,
      onDeselect,
      dropdownMatchSelectWidth = true,
      // Options
      filterOption: filterOption2,
      filterSort,
      optionFilterProp,
      optionLabelProp,
      options,
      optionRender,
      children,
      defaultActiveFirstOption,
      menuItemSelectedIcon,
      virtual,
      direction,
      listHeight = 200,
      listItemHeight = 20,
      labelRender,
      // Value
      value,
      defaultValue,
      labelInValue,
      onChange,
      maxCount,
      ...restProps
    } = props;
    const mergedId = useId3(id);
    const multiple = isMultiple(mode);
    const childrenAsData = !!(!options && children);
    const mergedFilterOption = React155.useMemo(() => {
      if (filterOption2 === void 0 && mode === "combobox") {
        return false;
      }
      return filterOption2;
    }, [filterOption2, mode]);
    const mergedFieldNames = React155.useMemo(
      () => fillFieldNames(fieldNames, childrenAsData),
      /* eslint-disable react-hooks/exhaustive-deps */
      [
        // We stringify fieldNames to avoid unnecessary re-renders.
        JSON.stringify(fieldNames),
        childrenAsData
      ]
      /* eslint-enable react-hooks/exhaustive-deps */
    );
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: searchValue !== void 0 ? searchValue : inputValue,
      postState: (search) => search || ""
    });
    const parsedOptions = useOptions_default(
      options,
      children,
      mergedFieldNames,
      optionFilterProp,
      optionLabelProp
    );
    const { valueOptions, labelOptions, options: mergedOptions } = parsedOptions;
    const convert2LabelValues = React155.useCallback(
      (draftValues) => {
        const valueList = toArray3(draftValues);
        return valueList.map((val) => {
          let rawValue;
          let rawLabel;
          let rawKey;
          let rawDisabled;
          let rawTitle;
          if (isRawValue(val)) {
            rawValue = val;
          } else {
            rawKey = val.key;
            rawLabel = val.label;
            rawValue = val.value ?? rawKey;
          }
          const option = valueOptions.get(rawValue);
          if (option) {
            if (rawLabel === void 0)
              rawLabel = option?.[optionLabelProp || mergedFieldNames.label];
            if (rawKey === void 0)
              rawKey = option?.key ?? rawValue;
            rawDisabled = option?.disabled;
            rawTitle = option?.title;
            if (!optionLabelProp) {
              const optionLabel = option?.[mergedFieldNames.label];
              if (optionLabel !== void 0 && !React155.isValidElement(optionLabel) && !React155.isValidElement(rawLabel) && optionLabel !== rawLabel) {
                warning_default(false, "`label` of `value` is not same as `label` in Select options.");
              }
            }
          }
          return {
            label: rawLabel,
            value: rawValue,
            key: rawKey,
            disabled: rawDisabled,
            title: rawTitle
          };
        });
      },
      [mergedFieldNames, optionLabelProp, valueOptions]
    );
    const [internalValue, setInternalValue] = useMergedState(defaultValue, {
      value
    });
    const rawLabeledValues = React155.useMemo(() => {
      const newInternalValue = multiple && internalValue === null ? [] : internalValue;
      const values = convert2LabelValues(newInternalValue);
      if (mode === "combobox" && isComboNoValue(values[0]?.value)) {
        return [];
      }
      return values;
    }, [internalValue, convert2LabelValues, mode, multiple]);
    const [mergedValues, getMixedOption] = useCache_default(rawLabeledValues, valueOptions);
    const displayValues = React155.useMemo(() => {
      if (!mode && mergedValues.length === 1) {
        const firstValue = mergedValues[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.map((item) => ({
        ...item,
        label: (typeof labelRender === "function" ? labelRender(item) : item.label) ?? item.value
      }));
    }, [mode, mergedValues, labelRender]);
    const rawValues = React155.useMemo(
      () => new Set(mergedValues.map((val) => val.value)),
      [mergedValues]
    );
    React155.useEffect(() => {
      if (mode === "combobox") {
        const strValue = mergedValues[0]?.value;
        setSearchValue(hasValue2(strValue) ? String(strValue) : "");
      }
    }, [mergedValues]);
    const createTagOption = useRefFunc((val, label) => {
      const mergedLabel = label ?? val;
      return {
        [mergedFieldNames.value]: val,
        [mergedFieldNames.label]: mergedLabel
      };
    });
    const filledTagOptions = React155.useMemo(() => {
      if (mode !== "tags") {
        return mergedOptions;
      }
      const cloneOptions = [...mergedOptions];
      const existOptions = /* @__PURE__ */ __name((val) => valueOptions.has(val), "existOptions");
      [...mergedValues].sort((a, b) => a.value < b.value ? -1 : 1).forEach((item) => {
        const val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      return cloneOptions;
    }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
    const filteredOptions = useFilterOptions_default(
      filledTagOptions,
      mergedFieldNames,
      mergedSearchValue,
      mergedFilterOption,
      optionFilterProp
    );
    const filledSearchOptions = React155.useMemo(() => {
      if (mode !== "tags" || !mergedSearchValue || filteredOptions.some((item) => item[optionFilterProp || "value"] === mergedSearchValue)) {
        return filteredOptions;
      }
      if (filteredOptions.some((item) => item[mergedFieldNames.value] === mergedSearchValue)) {
        return filteredOptions;
      }
      return [createTagOption(mergedSearchValue), ...filteredOptions];
    }, [
      createTagOption,
      optionFilterProp,
      mode,
      filteredOptions,
      mergedSearchValue,
      mergedFieldNames
    ]);
    const orderedFilteredOptions = React155.useMemo(() => {
      if (!filterSort) {
        return filledSearchOptions;
      }
      return [...filledSearchOptions].sort((a, b) => filterSort(a, b));
    }, [filledSearchOptions, filterSort]);
    const displayOptions = React155.useMemo(
      () => flattenOptions(orderedFilteredOptions, {
        fieldNames: mergedFieldNames,
        childrenAsData
      }),
      [orderedFilteredOptions, mergedFieldNames, childrenAsData]
    );
    const triggerChange = /* @__PURE__ */ __name((values) => {
      const labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (onChange && // Trigger event only when value changed
      (labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index3) => mergedValues[index3]?.value !== newVal?.value))) {
        const returnValues = labelInValue ? labeledValues : labeledValues.map((v) => v.value);
        const returnOptions = labeledValues.map(
          (v) => injectPropsWithOption(getMixedOption(v.value))
        );
        onChange(
          // Value
          multiple ? returnValues : returnValues[0],
          // Option
          multiple ? returnOptions : returnOptions[0]
        );
      }
    }, "triggerChange");
    const [activeValue, setActiveValue] = React155.useState(null);
    const [accessibilityIndex, setAccessibilityIndex] = React155.useState(0);
    const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
    const onActiveValue = React155.useCallback(
      (active, index3, { source = "keyboard" } = {}) => {
        setAccessibilityIndex(index3);
        if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
          setActiveValue(String(active));
        }
      },
      [backfill, mode]
    );
    const triggerSelect = /* @__PURE__ */ __name((val, selected, type5) => {
      const getSelectEnt = /* @__PURE__ */ __name(() => {
        const option = getMixedOption(val);
        return [
          labelInValue ? {
            label: option?.[mergedFieldNames.label],
            value: val,
            key: option?.key ?? val
          } : val,
          injectPropsWithOption(option)
        ];
      }, "getSelectEnt");
      if (selected && onSelect) {
        const [wrappedValue, option] = getSelectEnt();
        onSelect(wrappedValue, option);
      } else if (!selected && onDeselect && type5 !== "clear") {
        const [wrappedValue, option] = getSelectEnt();
        onDeselect(wrappedValue, option);
      }
    }, "triggerSelect");
    const onInternalSelect = useRefFunc((val, info) => {
      let cloneValues;
      const mergedSelect = multiple ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple ? [...mergedValues, val] : [val];
      } else {
        cloneValues = mergedValues.filter((v) => v.value !== val);
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (mode === "combobox") {
        setActiveValue("");
      } else if (!isMultiple || autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    });
    const onDisplayValuesChange = /* @__PURE__ */ __name((nextValues, info) => {
      triggerChange(nextValues);
      const { type: type5, values } = info;
      if (type5 === "remove" || type5 === "clear") {
        values.forEach((item) => {
          triggerSelect(item.value, false, type5);
        });
      }
    }, "onDisplayValuesChange");
    const onInternalSearch = /* @__PURE__ */ __name((searchText, info) => {
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        const formatted = (searchText || "").trim();
        if (formatted) {
          const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, formatted]));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        if (mode === "combobox") {
          triggerChange(searchText);
        }
        onSearch?.(searchText);
      }
    }, "onInternalSearch");
    const onInternalSearchSplit = /* @__PURE__ */ __name((words) => {
      let patchValues = words;
      if (mode !== "tags") {
        patchValues = words.map((word) => {
          const opt = labelOptions.get(word);
          return opt?.value;
        }).filter((val) => val !== void 0);
      }
      const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, ...patchValues]));
      triggerChange(newRawValues);
      newRawValues.forEach((newRawValue) => {
        triggerSelect(newRawValue, true);
      });
    }, "onInternalSearchSplit");
    const selectContext = React155.useMemo(() => {
      const realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
      return {
        ...parsedOptions,
        flattenOptions: displayOptions,
        onActiveValue,
        defaultActiveFirstOption: mergedDefaultActiveFirstOption,
        onSelect: onInternalSelect,
        menuItemSelectedIcon,
        rawValues,
        fieldNames: mergedFieldNames,
        virtual: realVirtual,
        direction,
        listHeight,
        listItemHeight,
        childrenAsData,
        maxCount,
        optionRender
      };
    }, [
      maxCount,
      parsedOptions,
      displayOptions,
      onActiveValue,
      mergedDefaultActiveFirstOption,
      onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      mergedFieldNames,
      virtual,
      dropdownMatchSelectWidth,
      direction,
      listHeight,
      listItemHeight,
      childrenAsData,
      optionRender
    ]);
    if (true) {
      warningPropsUtil_default(props);
      warningNullOptions(mergedOptions, mergedFieldNames);
    }
    return /* @__PURE__ */ React155.createElement(SelectContext_default.Provider, { value: selectContext }, /* @__PURE__ */ React155.createElement(
      BaseSelect_default,
      {
        ...restProps,
        id: mergedId,
        prefixCls,
        ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode,
        displayValues,
        onDisplayValuesChange,
        direction,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        dropdownMatchSelectWidth,
        OptionList: OptionList_default,
        emptyOptions: !displayOptions.length,
        activeValue,
        activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
      }
    ));
  }
);
if (true) {
  Select.displayName = "Select";
}
var TypedSelect = Select;
TypedSelect.Option = Option_default;
TypedSelect.OptGroup = OptGroup_default;
var Select_default = TypedSelect;

// packages/select/src/index.ts
var src_default6 = Select_default;

// packages/ant-design/components/_util/statusUtils.ts
var import_classnames42 = __toESM(require_classnames());
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return (0, import_classnames42.default)({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
__name(getStatusClassNames, "getStatusClassNames");
var getMergedStatus = /* @__PURE__ */ __name((contextStatus, customStatus) => customStatus || contextStatus, "getMergedStatus");

// packages/ant-design/components/config-provider/defaultRenderEmpty.tsx
import React159, { useContext as useContext53 } from "react";

// packages/ant-design/components/empty/index.tsx
var import_classnames43 = __toESM(require_classnames());
import * as React158 from "react";

// packages/ant-design/components/empty/empty.tsx
init_public_api();
import * as React156 from "react";
var Empty2 = /* @__PURE__ */ __name(() => {
  const [, token2] = useToken();
  const bgColor = new TinyColor(token2.colorBgBase);
  const themeStyle = bgColor.toHsl().l < 0.5 ? { opacity: 0.65 } : {};
  return /* @__PURE__ */ React156.createElement(
    "svg",
    {
      style: themeStyle,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    },
    /* @__PURE__ */ React156.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ React156.createElement("g", { transform: "translate(24 31.67)" }, /* @__PURE__ */ React156.createElement(
      "ellipse",
      {
        fillOpacity: ".8",
        fill: "#F5F5F7",
        cx: "67.797",
        cy: "106.89",
        rx: "67.797",
        ry: "12.668"
      }
    ), /* @__PURE__ */ React156.createElement(
      "path",
      {
        d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        fill: "#AEB8C2"
      }
    ), /* @__PURE__ */ React156.createElement(
      "path",
      {
        d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        fill: "url(#linearGradient-1)",
        transform: "translate(13.56)"
      }
    ), /* @__PURE__ */ React156.createElement(
      "path",
      {
        d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        fill: "#F5F5F7"
      }
    ), /* @__PURE__ */ React156.createElement(
      "path",
      {
        d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        fill: "#DCE0E6"
      }
    )), /* @__PURE__ */ React156.createElement(
      "path",
      {
        d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        fill: "#DCE0E6"
      }
    ), /* @__PURE__ */ React156.createElement("g", { transform: "translate(149.65 15.383)", fill: "#FFF" }, /* @__PURE__ */ React156.createElement("ellipse", { cx: "20.654", cy: "3.167", rx: "2.849", ry: "2.815" }), /* @__PURE__ */ React156.createElement("path", { d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" })))
  );
}, "Empty");
if (true) {
  Empty2.displayName = "EmptyImage";
}
var empty_default = Empty2;

// packages/ant-design/components/empty/simple.tsx
init_public_api();
import * as React157 from "react";
import { useMemo as useMemo39 } from "react";
var Simple = /* @__PURE__ */ __name(() => {
  const [, token2] = useToken();
  const { colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer } = token2;
  const { borderColor, shadowColor, contentColor } = useMemo39(
    () => ({
      borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
      shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
      contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
    }),
    [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]
  );
  return /* @__PURE__ */ React157.createElement("svg", { width: "64", height: "41", viewBox: "0 0 64 41", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ React157.createElement("g", { transform: "translate(0 1)", fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ React157.createElement("ellipse", { fill: shadowColor, cx: "32", cy: "33", rx: "32", ry: "7" }), /* @__PURE__ */ React157.createElement("g", { fillRule: "nonzero", stroke: borderColor }, /* @__PURE__ */ React157.createElement("path", { d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z" }), /* @__PURE__ */ React157.createElement(
    "path",
    {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: contentColor
    }
  ))));
}, "Simple");
if (true) {
  Simple.displayName = "SimpleImage";
}
var simple_default = Simple;

// packages/ant-design/components/empty/style/index.ts
var genSharedEmptyStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, margin, marginXS, marginXL, fontSize, lineHeight } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${componentCls}-description`]: {
        color: token2.colorText
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDescription,
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDescription,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
}, "genSharedEmptyStyle");
var style_default11 = genStyleHooks("Empty", (token2) => {
  const { componentCls, controlHeightLG, calc } = token2;
  const emptyToken = merge2(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
  });
  return [genSharedEmptyStyle(emptyToken)];
});

// packages/ant-design/components/empty/index.tsx
var defaultEmptyImg = /* @__PURE__ */ React158.createElement(empty_default, null);
var simpleEmptyImg = /* @__PURE__ */ React158.createElement(simple_default, null);
var Empty3 = /* @__PURE__ */ __name(({
  className,
  rootClassName,
  prefixCls: customizePrefixCls,
  image = defaultEmptyImg,
  description,
  children,
  imageStyle,
  style: style2,
  ...restProps
}) => {
  const { getPrefixCls, direction, empty: empty2 } = React158.useContext(ConfigContext);
  const prefixCls = getPrefixCls("empty", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default11(prefixCls);
  const [locale6] = useLocale_default("Empty");
  const des = typeof description !== "undefined" ? description : locale6?.description;
  const alt = typeof des === "string" ? des : "empty";
  let imageNode = null;
  if (typeof image === "string") {
    imageNode = /* @__PURE__ */ React158.createElement("img", { alt, src: image });
  } else {
    imageNode = image;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React158.createElement(
      "div",
      {
        className: (0, import_classnames43.default)(
          hashId,
          cssVarCls,
          prefixCls,
          empty2?.className,
          {
            [`${prefixCls}-normal`]: image === simpleEmptyImg,
            [`${prefixCls}-rtl`]: direction === "rtl"
          },
          className,
          rootClassName
        ),
        style: { ...empty2?.style, ...style2 },
        ...restProps
      },
      /* @__PURE__ */ React158.createElement("div", { className: `${prefixCls}-image`, style: imageStyle }, imageNode),
      des && /* @__PURE__ */ React158.createElement("div", { className: `${prefixCls}-description` }, des),
      children && /* @__PURE__ */ React158.createElement("div", { className: `${prefixCls}-footer` }, children)
    )
  );
}, "Empty");
Empty3.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty3.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
if (true) {
  Empty3.displayName = "Empty";
}
var empty_default2 = Empty3;

// packages/ant-design/components/config-provider/defaultRenderEmpty.tsx
var DefaultRenderEmpty = /* @__PURE__ */ __name((props) => {
  const { componentName } = props;
  const { getPrefixCls } = useContext53(ConfigContext);
  const prefix = getPrefixCls("empty");
  switch (componentName) {
    case "Table":
    case "List":
      return /* @__PURE__ */ React159.createElement(empty_default2, { image: empty_default2.PRESENTED_IMAGE_SIMPLE });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ React159.createElement(empty_default2, { image: empty_default2.PRESENTED_IMAGE_SIMPLE, className: `${prefix}-small` });
    default:
      return /* @__PURE__ */ React159.createElement(empty_default2, null);
  }
}, "DefaultRenderEmpty");
var defaultRenderEmpty_default = DefaultRenderEmpty;

// packages/ant-design/components/form/hooks/useVariants.ts
import { useContext as useContext54 } from "react";
var Variants = ["outlined", "borderless", "filled"];
var useVariant = /* @__PURE__ */ __name((variant, legacyBordered = void 0) => {
  const ctxVariant = useContext54(VariantContext);
  let mergedVariant;
  if (typeof variant !== "undefined") {
    mergedVariant = variant;
  } else if (legacyBordered === false) {
    mergedVariant = "borderless";
  } else {
    mergedVariant = ctxVariant ?? "outlined";
  }
  const enableVariantCls = Variants.includes(mergedVariant);
  return [mergedVariant, enableVariantCls];
}, "useVariant");
var useVariants_default = useVariant;

// packages/ant-design/components/select/mergedBuiltinPlacements.ts
var getBuiltInPlacements2 = /* @__PURE__ */ __name((popupOverflow) => {
  const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
  const sharedConfig = {
    overflow: {
      adjustX: true,
      adjustY: true,
      shiftY: true
    },
    htmlRegion,
    dynamicInset: true
  };
  return {
    bottomLeft: {
      ...sharedConfig,
      points: ["tl", "bl"],
      offset: [0, 4]
    },
    bottomRight: {
      ...sharedConfig,
      points: ["tr", "br"],
      offset: [0, 4]
    },
    topLeft: {
      ...sharedConfig,
      points: ["bl", "tl"],
      offset: [0, -4]
    },
    topRight: {
      ...sharedConfig,
      points: ["br", "tr"],
      offset: [0, -4]
    }
  };
}, "getBuiltInPlacements");
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
  return buildInPlacements || getBuiltInPlacements2(popupOverflow);
}
__name(mergedBuiltinPlacements, "mergedBuiltinPlacements");
var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

// packages/ant-design/components/select/style/dropdown.ts
var genItemStyle = /* @__PURE__ */ __name((token2) => {
  const { optionHeight, optionFontSize, optionLineHeight, optionPadding } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: optionHeight,
    padding: optionPadding,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: optionFontSize,
    lineHeight: optionLineHeight,
    boxSizing: "border-box"
  };
}, "genItemStyle");
var genSingleStyle = /* @__PURE__ */ __name((token2) => {
  const { antCls, componentCls } = token2;
  const selectItemCls = `${componentCls}-item`;
  const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
  const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
  const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
  const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
  return [
    {
      [`${componentCls}-dropdown`]: {
        // ========================== Popup ==========================
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
          animationName: slideUpIn
        },
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownIn
        },
        [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
          animationName: slideUpOut
        },
        [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        [`${selectItemCls}`]: {
          ...genItemStyle(token2),
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": {
              flex: "auto",
              ...textEllipsis
            },
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.optionActiveBg
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.optionSelectedColor,
              fontWeight: token2.optionSelectedFontWeight,
              backgroundColor: token2.optionSelectedBg,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              },
              [`&:has(+ ${selectItemCls}-option-selected:not(${selectItemCls}-option-disabled))`]: {
                borderEndStartRadius: 0,
                borderEndEndRadius: 0,
                [`& + ${selectItemCls}-option-selected:not(${selectItemCls}-option-disabled)`]: {
                  borderStartStartRadius: 0,
                  borderStartEndRadius: 0
                }
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": {
            ...genItemStyle(token2),
            color: token2.colorTextDisabled
          }
        },
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
}, "genSingleStyle");
var dropdown_default = genSingleStyle;

// packages/ant-design/components/select/style/multiple.ts
var getMultipleSelectorUnit = /* @__PURE__ */ __name((token2) => {
  const { multipleSelectItemHeight, paddingXXS, lineWidth, INTERNAL_FIXED_ITEM_MARGIN } = token2;
  const basePadding = token2.max(token2.calc(paddingXXS).sub(lineWidth).equal(), 0);
  const containerPadding = token2.max(
    token2.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(),
    0
  );
  return {
    basePadding,
    containerPadding,
    itemHeight: unit(multipleSelectItemHeight),
    itemLineHeight: unit(
      token2.calc(multipleSelectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal()
    )
  };
}, "getMultipleSelectorUnit");
var getSelectItemStyle = /* @__PURE__ */ __name((token2) => {
  const { multipleSelectItemHeight, selectHeight, lineWidth } = token2;
  const selectItemDist = token2.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
  return selectItemDist;
}, "getSelectItemStyle");
var genOverflowStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    borderRadiusSM,
    motionDurationSlow,
    paddingXS,
    multipleItemColorDisabled,
    multipleItemBorderColorDisabled,
    colorIcon,
    colorIconHover,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [selectOverflowPrefixCls]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        maxWidth: "100%",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${componentCls}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
        borderRadius: borderRadiusSM,
        cursor: "default",
        transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
        marginInlineEnd: token2.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
        paddingInlineStart: paddingXS,
        paddingInlineEnd: token2.calc(paddingXS).div(2).equal(),
        [`${componentCls}-disabled&`]: {
          color: multipleItemColorDisabled,
          borderColor: multipleItemBorderColorDisabled,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token2.calc(paddingXS).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": {
          ...resetIcon(),
          display: "inline-flex",
          alignItems: "center",
          color: colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: colorIconHover
          }
        }
      }
    }
  };
}, "genOverflowStyle");
var genSelectionStyle = /* @__PURE__ */ __name((token2, suffix) => {
  const { componentCls, INTERNAL_FIXED_ITEM_MARGIN } = token2;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  const selectItemHeight = token2.multipleSelectItemHeight;
  const selectItemDist = getSelectItemStyle(token2);
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  const multipleSelectorUnit = getMultipleSelectorUnit(token2);
  return {
    [`${componentCls}-multiple${suffixCls}`]: {
      // ========================= Overflow =========================
      ...genOverflowStyle(token2),
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        height: "100%",
        // Multiple is little different that horizontal is follow the vertical
        paddingInline: multipleSelectorUnit.basePadding,
        paddingBlock: multipleSelectorUnit.containerPadding,
        borderRadius: token2.borderRadius,
        [`${componentCls}-disabled&`]: {
          background: token2.multipleSelectorBgDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${unit(INTERNAL_FIXED_ITEM_MARGIN)} 0`,
          lineHeight: unit(selectItemHeight),
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      // ======================== Selections ========================
      [`${componentCls}-selection-item`]: {
        height: multipleSelectorUnit.itemHeight,
        lineHeight: unit(multipleSelectorUnit.itemLineHeight)
      },
      // ========================== Input ==========================
      [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      // https://github.com/ant-design/ant-design/issues/44754
      [`${selectOverflowPrefixCls}-item-suffix`]: {
        height: "100%"
      },
      [`${componentCls}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
        [`
          &-input,
          &-mirror
        `]: {
          height: selectItemHeight,
          fontFamily: token2.fontFamily,
          lineHeight: unit(selectItemHeight),
          transition: `all ${token2.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          // fix whitespace wrapping caused width calculation bug
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: token2.inputPaddingHorizontalBase,
        insetInlineEnd: token2.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${token2.motionDurationSlow}`
      }
    }
  };
}, "genSelectionStyle");
function genSizeStyle(token2, suffix) {
  const { componentCls } = token2;
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  const rawStyle = {
    [`${componentCls}-multiple${suffixCls}`]: {
      fontSize: token2.fontSize,
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        [`${componentCls}-show-search&`]: {
          cursor: "text"
        }
      },
      [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
        paddingInlineEnd: token2.calc(token2.fontSizeIcon).add(token2.controlPaddingHorizontal).equal()
      }
    }
  };
  return [genSelectionStyle(token2, suffix), rawStyle];
}
__name(genSizeStyle, "genSizeStyle");
var genMultipleStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const smallToken = merge2(token2, {
    selectHeight: token2.controlHeightSM,
    multipleSelectItemHeight: token2.multipleItemHeightSM,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS
  });
  const largeToken = merge2(token2, {
    fontSize: token2.fontSizeLG,
    selectHeight: token2.controlHeightLG,
    multipleSelectItemHeight: token2.multipleItemHeightLG,
    borderRadius: token2.borderRadiusLG,
    borderRadiusSM: token2.borderRadius
  });
  return [
    genSizeStyle(token2),
    // ======================== Small ========================
    genSizeStyle(smallToken, "sm"),
    // Padding
    {
      [`${componentCls}-multiple${componentCls}-sm`]: {
        [`${componentCls}-selection-placeholder`]: {
          insetInline: token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal()
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 2
          // Magic Number
        }
      }
    },
    // ======================== Large ========================
    genSizeStyle(largeToken, "lg")
  ];
}, "genMultipleStyle");
var multiple_default = genMultipleStyle;

// packages/ant-design/components/select/style/single.ts
function genSizeStyle2(token2, suffix) {
  const { componentCls, inputPaddingHorizontalBase, borderRadius } = token2;
  const selectHeightWithoutBorder = token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal();
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-single${suffixCls}`]: {
      fontSize: token2.fontSize,
      height: token2.controlHeight,
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        ...resetComponent(token2, true),
        display: "flex",
        borderRadius,
        [`${componentCls}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: inputPaddingHorizontalBase,
          insetInlineEnd: inputPaddingHorizontalBase,
          bottom: 0,
          "&-input": {
            width: "100%",
            WebkitAppearance: "textfield"
          }
        },
        [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: unit(selectHeightWithoutBorder),
          transition: `all ${token2.motionDurationSlow}, visibility 0s`,
          alignSelf: "center"
        },
        [`${componentCls}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${componentCls}-selection-item:empty:after`,
          /* For undefined value baseline align */
          `${componentCls}-selection-placeholder:empty:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
        paddingInlineEnd: token2.showArrowPaddingInlineEnd
      },
      // Opacity selection if open
      [`&${componentCls}-open ${componentCls}-selection-item`]: {
        color: token2.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${componentCls}-customize-input)`]: {
        [`${componentCls}-selector`]: {
          width: "100%",
          height: "100%",
          padding: `0 ${unit(inputPaddingHorizontalBase)}`,
          [`${componentCls}-selection-search-input`]: {
            height: selectHeightWithoutBorder
          },
          "&:after": {
            lineHeight: unit(selectHeightWithoutBorder)
          }
        }
      },
      [`&${componentCls}-customize-input`]: {
        [`${componentCls}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${componentCls}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${unit(inputPaddingHorizontalBase)}`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
__name(genSizeStyle2, "genSizeStyle");
function genSingleStyle2(token2) {
  const { componentCls } = token2;
  const inputPaddingHorizontalSM = token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal();
  return [
    genSizeStyle2(token2),
    // ======================== Small ========================
    // Shared
    genSizeStyle2(
      merge2(token2, {
        controlHeight: token2.controlHeightSM,
        borderRadius: token2.borderRadiusSM
      }),
      "sm"
    ),
    // padding
    {
      [`${componentCls}-single${componentCls}-sm`]: {
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selection-search`]: {
            insetInlineStart: inputPaddingHorizontalSM,
            insetInlineEnd: inputPaddingHorizontalSM
          },
          [`${componentCls}-selector`]: {
            padding: `0 ${unit(inputPaddingHorizontalSM)}`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalSM).add(token2.calc(token2.fontSize).mul(1.5)).equal()
          },
          [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
            paddingInlineEnd: token2.calc(token2.fontSize).mul(1.5).equal()
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    genSizeStyle2(
      merge2(token2, {
        controlHeight: token2.singleItemHeightLG,
        fontSize: token2.fontSizeLG,
        borderRadius: token2.borderRadiusLG
      }),
      "lg"
    )
  ];
}
__name(genSingleStyle2, "genSingleStyle");

// packages/ant-design/components/select/style/token.ts
var prepareComponentToken9 = /* @__PURE__ */ __name((token2) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    controlPaddingHorizontal,
    zIndexPopupBase,
    colorText,
    fontWeightStrong,
    controlItemBgActive,
    controlItemBgHover,
    colorBgContainer,
    colorFillSecondary,
    colorBgContainerDisabled,
    colorTextDisabled
  } = token2;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(
    controlHeightSM - dblPaddingXXS,
    controlHeightSM - dblLineWidth
  );
  const multipleItemHeightLG = Math.min(
    controlHeightLG - dblPaddingXXS,
    controlHeightLG - dblLineWidth
  );
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  return {
    INTERNAL_FIXED_ITEM_MARGIN,
    zIndexPopup: zIndexPopupBase + 50,
    optionSelectedColor: colorText,
    optionSelectedFontWeight: fontWeightStrong,
    optionSelectedBg: controlItemBgActive,
    optionActiveBg: controlItemBgHover,
    optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    optionFontSize: fontSize,
    optionLineHeight: lineHeight,
    optionHeight: controlHeight,
    selectorBg: colorBgContainer,
    clearBg: colorBgContainer,
    singleItemHeightLG: controlHeightLG,
    multipleItemBg: colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25)
  };
}, "prepareComponentToken");

// packages/ant-design/components/select/style/variants.ts
var genBaseOutlinedStyle = /* @__PURE__ */ __name((token2, options) => {
  const { componentCls, antCls, controlOutlineWidth } = token2;
  return {
    [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${options.borderColor}`,
      background: token2.selectorBg
    },
    [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
      [`&:hover ${componentCls}-selector`]: {
        borderColor: options.hoverBorderHover
      },
      [`${componentCls}-focused& ${componentCls}-selector`]: {
        borderColor: options.activeBorderColor,
        boxShadow: `0 0 0 ${unit(controlOutlineWidth)} ${options.activeShadowColor}`,
        outline: 0
      }
    }
  };
}, "genBaseOutlinedStyle");
var genOutlinedStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}`]: {
    ...genBaseOutlinedStyle(token2, options)
  }
}), "genOutlinedStatusStyle");
var genOutlinedStyle = /* @__PURE__ */ __name((token2) => ({
  "&-outlined": {
    ...genBaseOutlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderHover: token2.colorPrimaryHover,
      activeBorderColor: token2.colorPrimary,
      activeShadowColor: token2.controlOutline
    }),
    ...genOutlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderHover: token2.colorErrorHover,
      activeBorderColor: token2.colorError,
      activeShadowColor: token2.colorErrorOutline
    }),
    ...genOutlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderHover: token2.colorWarningHover,
      activeBorderColor: token2.colorWarning,
      activeShadowColor: token2.colorWarningOutline
    }),
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        background: token2.colorBgContainerDisabled,
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.multipleItemBg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
    }
  }
}), "genOutlinedStyle");
var genBaseFilledStyle = /* @__PURE__ */ __name((token2, options) => {
  const { componentCls, antCls } = token2;
  return {
    [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
      background: options.bg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
      color: options.color
    },
    [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
      [`&:hover ${componentCls}-selector`]: {
        background: options.hoverBg
      },
      [`${componentCls}-focused& ${componentCls}-selector`]: {
        background: token2.selectorBg,
        borderColor: options.activeBorderColor,
        outline: 0
      }
    }
  };
}, "genBaseFilledStyle");
var genFilledStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}`]: {
    ...genBaseFilledStyle(token2, options)
  }
}), "genFilledStatusStyle");
var genFilledStyle = /* @__PURE__ */ __name((token2) => ({
  "&-filled": {
    ...genBaseFilledStyle(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.colorPrimary,
      color: token2.colorText
    }),
    ...genFilledStatusStyle(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      color: token2.colorError
    }),
    ...genFilledStatusStyle(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      color: token2.colorWarning
    }),
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        borderColor: token2.colorBorder,
        background: token2.colorBgContainerDisabled,
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.colorBgContainer,
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    }
  }
}), "genFilledStyle");
var genBorderlessStyle = /* @__PURE__ */ __name((token2) => ({
  "&-borderless": {
    [`${token2.componentCls}-selector`]: {
      background: "transparent",
      borderColor: "transparent"
    },
    [`&${token2.componentCls}-disabled`]: {
      [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
        color: token2.colorTextDisabled
      }
    },
    [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
      background: token2.multipleItemBg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
    }
  }
}), "genBorderlessStyle");
var genVariantsStyle = /* @__PURE__ */ __name((token2) => ({
  [token2.componentCls]: {
    ...genOutlinedStyle(token2),
    ...genFilledStyle(token2),
    ...genBorderlessStyle(token2)
  }
}), "genVariantsStyle");
var variants_default = genVariantsStyle;

// packages/ant-design/components/select/style/index.ts
var genSelectorStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    position: "relative",
    transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${componentCls}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit",
        height: "100%"
      }
    },
    [`${componentCls}-disabled&`]: {
      cursor: "not-allowed",
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, "genSelectorStyle");
var getSearchInputWithoutBorderStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      fontFamily: "inherit",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, "getSearchInputWithoutBorderStyle");
var genBaseStyle3 = /* @__PURE__ */ __name((token2) => {
  const { antCls, componentCls, inputPaddingHorizontalBase, iconCls } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
        ...genSelectorStyle(token2),
        ...getSearchInputWithoutBorderStyle(token2)
      },
      // ======================== Selection ========================
      [`${componentCls}-selection-item`]: {
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none",
        ...textEllipsis,
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${antCls}-typography`]: {
          display: "inline"
        }
      },
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder`]: {
        ...textEllipsis,
        flex: 1,
        color: token2.colorTextPlaceholder,
        pointerEvents: "none"
      },
      // ========================== Arrow ==========================
      [`${componentCls}-arrow`]: {
        ...resetIcon(),
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        transition: `opacity ${token2.motionDurationSlow} ease`,
        [iconCls]: {
          verticalAlign: "top",
          transition: `transform ${token2.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${componentCls}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${componentCls}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      },
      // ========================== Clear ==========================
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorTextTertiary
        }
      },
      "&:hover": {
        [`${componentCls}-clear`]: {
          opacity: 1
        },
        // Should use the following selector, but since `:has` has poor compatibility,
        // we use `:not(:last-child)` instead, which may cause some problems in some cases.
        // [`${componentCls}-arrow:has(+ ${componentCls}-clear)`]: {
        [`${componentCls}-arrow:not(:last-child)`]: {
          opacity: 0
        }
      }
    },
    // ========================= Feedback ==========================
    [`${componentCls}-has-feedback`]: {
      [`${componentCls}-clear`]: {
        insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
      }
    }
  };
}, "genBaseStyle");
var genSelectStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return [
    {
      [componentCls]: {
        // ==================== In Form ====================
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    genBaseStyle3(token2),
    // Single
    genSingleStyle2(token2),
    // Multiple
    multiple_default(token2),
    // Dropdown
    dropdown_default(token2),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      borderElCls: `${componentCls}-selector`,
      focusElCls: `${componentCls}-focused`
    })
  ];
}, "genSelectStyle");
var style_default12 = genStyleHooks(
  "Select",
  (token2, { rootPrefixCls }) => {
    const selectToken = merge2(token2, {
      rootPrefixCls,
      inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
      multipleSelectItemHeight: token2.multipleItemHeight,
      selectHeight: token2.controlHeight
    });
    return [genSelectStyle(selectToken), variants_default(selectToken)];
  },
  prepareComponentToken9,
  {
    unitless: {
      optionLineHeight: true,
      optionSelectedFontWeight: true
    }
  }
);

// packages/ant-design/components/select/useIcons.tsx
var import_CheckOutlined = __toESM(require_CheckOutlined3());
var import_CloseCircleFilled5 = __toESM(require_CloseCircleFilled3());
var import_CloseOutlined7 = __toESM(require_CloseOutlined3());
var import_DownOutlined = __toESM(require_DownOutlined3());
var import_LoadingOutlined3 = __toESM(require_LoadingOutlined3());
var import_SearchOutlined = __toESM(require_SearchOutlined3());
import * as React160 from "react";
function useIcons({
  suffixIcon,
  clearIcon,
  menuItemSelectedIcon,
  removeIcon,
  loading,
  multiple,
  hasFeedback,
  prefixCls,
  showSuffixIcon,
  feedbackIcon,
  showArrow,
  componentName
}) {
  if (true) {
    const warning5 = devUseWarning(componentName);
    warning5.deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  }
  const mergedClearIcon = clearIcon ?? /* @__PURE__ */ React160.createElement(import_CloseCircleFilled5.default, null);
  const getSuffixIconNode = /* @__PURE__ */ __name((arrowIcon) => {
    if (suffixIcon === null && !hasFeedback && !showArrow) {
      return null;
    }
    return /* @__PURE__ */ React160.createElement(React160.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
  }, "getSuffixIconNode");
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ React160.createElement(import_LoadingOutlined3.default, { spin: true }));
  } else {
    const iconCls = `${prefixCls}-suffix`;
    mergedSuffixIcon = /* @__PURE__ */ __name(({ open: open3, showSearch }) => {
      if (open3 && showSearch) {
        return getSuffixIconNode(/* @__PURE__ */ React160.createElement(import_SearchOutlined.default, { className: iconCls }));
      }
      return getSuffixIconNode(/* @__PURE__ */ React160.createElement(import_DownOutlined.default, { className: iconCls }));
    }, "mergedSuffixIcon");
  }
  let mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = /* @__PURE__ */ React160.createElement(import_CheckOutlined.default, null);
  } else {
    mergedItemIcon = null;
  }
  let mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = /* @__PURE__ */ React160.createElement(import_CloseOutlined7.default, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
__name(useIcons, "useIcons");

// packages/ant-design/components/select/useShowArrow.ts
function useShowArrow(suffixIcon, showArrow) {
  return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}
__name(useShowArrow, "useShowArrow");

// packages/ant-design/components/select/index.tsx
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered,
    className,
    rootClassName,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    listHeight = 256,
    placement,
    listItemHeight: customListItemHeight,
    size: customizeSize,
    disabled: customDisabled,
    notFoundContent,
    status: customStatus,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    direction: propDirection,
    style: style2,
    allowClear,
    variant: customizeVariant,
    dropdownStyle,
    transitionName,
    tagRender,
    maxCount,
    ...rest
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction: contextDirection,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow,
    select
  } = React161.useContext(ConfigContext);
  const [, token2] = useToken();
  const listItemHeight = customListItemHeight ?? token2?.controlHeight;
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const direction = propDirection ?? contextDirection;
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default(customizeVariant, bordered);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default12(prefixCls, rootCls);
  const mode = React161.useMemo(() => {
    const { mode: m } = props;
    if (m === "combobox") {
      return void 0;
    }
    if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m;
  }, [props.mode]);
  const isMultiple2 = mode === "multiple" || mode === "tags";
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React161.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = renderEmpty?.("Select") || /* @__PURE__ */ React161.createElement(defaultRenderEmpty_default, { componentName: "Select" });
  }
  const { suffixIcon, itemIcon, removeIcon, clearIcon } = useIcons({
    ...rest,
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    prefixCls,
    componentName: "Select"
  });
  const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
  const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
  const mergedPopupClassName = (0, import_classnames44.default)(
    popupClassName || dropdownClassName,
    {
      [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
    },
    rootClassName,
    cssVarCls,
    rootCls,
    hashId
  );
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React161.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedClassName = (0, import_classnames44.default)(
    {
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    },
    getStatusClassNames(prefixCls, mergedStatus, hasFeedback),
    compactItemClassnames,
    select?.className,
    className,
    rootClassName,
    cssVarCls,
    rootCls,
    hashId
  );
  const memoPlacement = React161.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  if (true) {
    const warning5 = devUseWarning("Select");
    warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
    warning5.deprecated(
      dropdownMatchSelectWidth === void 0,
      "dropdownMatchSelectWidth",
      "popupMatchSelectWidth"
    );
    warning5(
      !("showArrow" in props),
      "deprecated",
      "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."
    );
    warning5.deprecated(!("bordered" in props), "bordered", "variant");
    warning5(
      !(typeof maxCount !== "undefined" && !isMultiple2),
      "usage",
      "`maxCount` only works with mode `multiple` or `tags`"
    );
  }
  const [zIndex] = useZIndex("SelectLike", dropdownStyle?.zIndex);
  return wrapCSSVar(
    /* @__PURE__ */ React161.createElement(
      src_default6,
      {
        ref,
        virtual,
        showSearch: select?.showSearch,
        ...selectProps,
        style: { ...select?.style, ...style2 },
        dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
        transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
        builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
        listHeight,
        listItemHeight,
        mode,
        prefixCls,
        placement: memoPlacement,
        direction,
        suffixIcon,
        menuItemSelectedIcon: itemIcon,
        removeIcon,
        allowClear: mergedAllowClear,
        notFoundContent: mergedNotFound,
        className: mergedClassName,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        dropdownClassName: mergedPopupClassName,
        disabled: mergedDisabled,
        dropdownStyle: { ...dropdownStyle, zIndex },
        maxCount: isMultiple2 ? maxCount : void 0,
        tagRender: isMultiple2 ? tagRender : void 0
      }
    )
  );
}, "InternalSelect");
if (true) {
  InternalSelect.displayName = "Select";
}
var Select2 = React161.forwardRef(InternalSelect);
var PurePanel3 = PurePanel_default3(Select2);
Select2.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select2.Option = Option_default;
Select2.OptGroup = OptGroup_default;
Select2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel3;
if (true) {
  Select2.displayName = "Select";
}
var select_default = Select2;

// packages/ant-design/components/auto-complete/index.tsx
var { Option: Option2 } = select_default;
function isSelectOptionOrSelectOptGroup(child) {
  return child && child.type && (child.type.isSelectOption || child.type.isSelectOptGroup);
}
__name(isSelectOptionOrSelectOptGroup, "isSelectOptionOrSelectOptGroup");
var AutoComplete = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    popupClassName,
    dropdownClassName,
    children,
    dataSource
  } = props;
  const childNodes = toArray(children);
  let customizeInput;
  if (childNodes.length === 1 && React162.isValidElement(childNodes[0]) && !isSelectOptionOrSelectOptGroup(childNodes[0])) {
    [customizeInput] = childNodes;
  }
  const getInputElement = customizeInput ? () => customizeInput : void 0;
  let optionChildren;
  if (childNodes.length && isSelectOptionOrSelectOptGroup(childNodes[0])) {
    optionChildren = children;
  } else {
    optionChildren = dataSource ? dataSource.map((item) => {
      if (React162.isValidElement(item)) {
        return item;
      }
      switch (typeof item) {
        case "string":
          return /* @__PURE__ */ React162.createElement(Option2, { key: item, value: item }, item);
        case "object": {
          const { value: optionValue } = item;
          return /* @__PURE__ */ React162.createElement(Option2, { key: optionValue, value: optionValue }, item.text);
        }
        default:
          return void 0;
      }
    }) : [];
  }
  if (true) {
    const warning5 = devUseWarning("AutoComplete");
    warning5.deprecated(!("dataSource" in props), "dataSource", "options");
    warning5(
      !customizeInput || !("size" in props),
      "usage",
      "You need to control style self instead of setting `size` when using customize input."
    );
    warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
  }
  const { getPrefixCls } = React162.useContext(ConfigContext);
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const [zIndex] = useZIndex("SelectLike", props.dropdownStyle?.zIndex);
  return /* @__PURE__ */ React162.createElement(
    select_default,
    {
      ref,
      suffixIcon: null,
      ...omit(props, ["dataSource", "dropdownClassName"]),
      prefixCls,
      popupClassName: popupClassName || dropdownClassName,
      dropdownStyle: {
        ...props.dropdownStyle,
        zIndex
      },
      className: (0, import_classnames45.default)(`${prefixCls}-auto-complete`, className),
      mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
      ...{
        // Internal api
        getInputElement
      }
    },
    optionChildren
  );
}, "AutoComplete");
var RefAutoComplete = React162.forwardRef(
  AutoComplete
);
var PurePanel4 = PurePanel_default3(RefAutoComplete);
RefAutoComplete.Option = Option2;
RefAutoComplete._InternalPanelDoNotUseOrYouWillBeFired = PurePanel4;
if (true) {
  RefAutoComplete.displayName = "AutoComplete";
}
var auto_complete_default = RefAutoComplete;

// packages/ant-design/components/avatar/avatar.tsx
var import_classnames46 = __toESM(require_classnames());
import * as React166 from "react";

// packages/ant-design/components/_util/responsiveObserver.ts
import React163 from "react";
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var getResponsiveMap = /* @__PURE__ */ __name((token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`
}), "getResponsiveMap");
var validateBreakpoints = /* @__PURE__ */ __name((token2) => {
  const indexableToken = token2;
  const revBreakpoints = [...responsiveArray].reverse();
  revBreakpoints.forEach((breakpoint, i) => {
    const breakpointUpper = breakpoint.toUpperCase();
    const screenMin = `screen${breakpointUpper}Min`;
    const screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen])) {
      throw new Error(
        `${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`
      );
    }
    if (i < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax])) {
        throw new Error(
          `${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`
        );
      }
      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
        throw new Error(
          `${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`
        );
      }
    }
  });
  return token2;
}, "validateBreakpoints");
function useResponsiveObserver() {
  const [, token2] = useToken();
  const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
  return React163.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size)
          this.register();
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size)
          this.unregister();
      },
      unregister() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const handler = this.matchHandlers[matchMediaQuery];
          handler?.mql.removeListener(handler?.listener);
        });
        subscribers.clear();
      },
      register() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const listener = /* @__PURE__ */ __name(({ matches }) => {
            this.dispatch({
              ...screens,
              [screen]: matches
            });
          }, "listener");
          const mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener);
          this.matchHandlers[matchMediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      responsiveMap
    };
  }, [token2]);
}
__name(useResponsiveObserver, "useResponsiveObserver");
var matchScreen = /* @__PURE__ */ __name((screens, screenSizes) => {
  if (screenSizes && typeof screenSizes === "object") {
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint] && screenSizes[breakpoint] !== void 0) {
        return screenSizes[breakpoint];
      }
    }
  }
}, "matchScreen");

// packages/ant-design/components/grid/hooks/useBreakpoint.tsx
import { useRef as useRef59 } from "react";

// packages/ant-design/components/_util/hooks/useForceUpdate.ts
import * as React164 from "react";
function useForceUpdate() {
  const [, forceUpdate] = React164.useReducer((x) => x + 1, 0);
  return forceUpdate;
}
__name(useForceUpdate, "useForceUpdate");

// packages/ant-design/components/grid/hooks/useBreakpoint.tsx
function useBreakpoint(refreshOnChange = true) {
  const screensRef = useRef59({});
  const forceUpdate = useForceUpdate();
  const responsiveObserver = useResponsiveObserver();
  useLayoutEffect_default(() => {
    const token2 = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  return screensRef.current;
}
__name(useBreakpoint, "useBreakpoint");
var useBreakpoint_default = useBreakpoint;

// packages/ant-design/components/avatar/AvatarContext.ts
import * as React165 from "react";
var AvatarContext = React165.createContext({});
var AvatarContext_default = AvatarContext;

// packages/ant-design/components/avatar/style/index.ts
var genBaseStyle4 = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token2;
  const avatarSizeStyle = /* @__PURE__ */ __name((size, fontSize, radius) => ({
    width: size,
    height: size,
    borderRadius: "50%",
    [`&${componentCls}-square`]: {
      borderRadius: radius
    },
    [`&${componentCls}-icon`]: {
      fontSize,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  }), "avatarSizeStyle");
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${unit(lineWidth)} ${lineType} transparent`,
      [`&-image`]: {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      },
      ...avatarSizeStyle(containerSize, textFontSize, borderRadius),
      [`&-lg`]: {
        ...avatarSizeStyle(containerSizeLG, textFontSizeLG, borderRadiusLG)
      },
      [`&-sm`]: {
        ...avatarSizeStyle(containerSizeSM, textFontSizeSM, borderRadiusSM)
      },
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    }
  };
}, "genBaseStyle");
var genGroupStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, groupBorderColor, groupOverlapping, groupSpace } = token2;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [`${componentCls}`]: {
        borderColor: groupBorderColor
      },
      [`> *:not(:first-child)`]: {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
}, "genGroupStyle");
var prepareComponentToken10 = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token2;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    textFontSizeLG: fontSizeHeading3,
    textFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
}, "prepareComponentToken");
var style_default13 = genStyleHooks(
  "Avatar",
  (token2) => {
    const { colorTextLightSolid, colorTextPlaceholder } = token2;
    const avatarToken = merge2(token2, {
      avatarBg: colorTextPlaceholder,
      avatarColor: colorTextLightSolid
    });
    return [genBaseStyle4(avatarToken), genGroupStyle2(avatarToken)];
  },
  prepareComponentToken10
);

// packages/ant-design/components/avatar/avatar.tsx
var InternalAvatar = /* @__PURE__ */ __name((props, ref) => {
  const [scale, setScale] = React166.useState(1);
  const [mounted, setMounted] = React166.useState(false);
  const [isImgExist, setIsImgExist] = React166.useState(true);
  const avatarNodeRef = React166.useRef(null);
  const avatarChildrenRef = React166.useRef(null);
  const avatarNodeMergedRef = composeRef(ref, avatarNodeRef);
  const { getPrefixCls, avatar } = React166.useContext(ConfigContext);
  const avatarCtx = React166.useContext(AvatarContext_default);
  const setScaleParam = /* @__PURE__ */ __name(() => {
    if (!avatarChildrenRef.current || !avatarNodeRef.current) {
      return;
    }
    const childrenWidth = avatarChildrenRef.current.offsetWidth;
    const nodeWidth = avatarNodeRef.current.offsetWidth;
    if (childrenWidth !== 0 && nodeWidth !== 0) {
      const { gap = 4 } = props;
      if (gap * 2 < nodeWidth) {
        setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
      }
    }
  }, "setScaleParam");
  React166.useEffect(() => {
    setMounted(true);
  }, []);
  React166.useEffect(() => {
    setIsImgExist(true);
    setScale(1);
  }, [props.src]);
  React166.useEffect(setScaleParam, [props.gap]);
  const handleImgLoadError = /* @__PURE__ */ __name(() => {
    const { onError } = props;
    const errorFlag = onError?.();
    if (errorFlag !== false) {
      setIsImgExist(false);
    }
  }, "handleImgLoadError");
  const {
    prefixCls: customizePrefixCls,
    shape,
    size: customSize,
    src,
    srcSet,
    icon,
    className,
    rootClassName,
    alt,
    draggable,
    children,
    crossOrigin,
    ...others
  } = props;
  const size = useSize_default((ctxSize) => customSize ?? avatarCtx?.size ?? ctxSize ?? "default");
  const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some(
    (key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key)
  );
  const screens = useBreakpoint_default(needResponsive);
  const responsiveSizeStyle = React166.useMemo(() => {
    if (typeof size !== "object") {
      return {};
    }
    const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
    const currentSize = size[currentBreakpoint];
    return currentSize ? {
      width: currentSize,
      height: currentSize,
      fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
    } : {};
  }, [screens, size]);
  if (true) {
    const warning5 = devUseWarning("Avatar");
    warning5(
      !(typeof icon === "string" && icon.length > 2),
      "breaking",
      `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`
    );
  }
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const sizeCls = (0, import_classnames46.default)({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const hasImageElement = React166.isValidElement(src);
  const mergedShape = shape || avatarCtx?.shape || "circle";
  const classString = (0, import_classnames46.default)(
    prefixCls,
    sizeCls,
    avatar?.className,
    `${prefixCls}-${mergedShape}`,
    {
      [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
      [`${prefixCls}-icon`]: !!icon
    },
    cssVarCls,
    rootCls,
    className,
    rootClassName,
    hashId
  );
  const sizeStyle = typeof size === "number" ? {
    width: size,
    height: size,
    fontSize: icon ? size / 2 : 18
  } : {};
  let childrenToRender;
  if (typeof src === "string" && isImgExist) {
    childrenToRender = /* @__PURE__ */ React166.createElement(
      "img",
      {
        src,
        draggable,
        srcSet,
        onError: handleImgLoadError,
        alt,
        crossOrigin
      }
    );
  } else if (hasImageElement) {
    childrenToRender = src;
  } else if (icon) {
    childrenToRender = icon;
  } else if (mounted || scale !== 1) {
    const transformString = `scale(${scale})`;
    const childrenStyle = {
      msTransform: transformString,
      WebkitTransform: transformString,
      transform: transformString
    };
    childrenToRender = /* @__PURE__ */ React166.createElement(src_default, { onResize: setScaleParam }, /* @__PURE__ */ React166.createElement(
      "span",
      {
        className: `${prefixCls}-string`,
        ref: avatarChildrenRef,
        style: { ...childrenStyle }
      },
      children
    ));
  } else {
    childrenToRender = /* @__PURE__ */ React166.createElement("span", { className: `${prefixCls}-string`, style: { opacity: 0 }, ref: avatarChildrenRef }, children);
  }
  delete others.onError;
  delete others.gap;
  return wrapCSSVar(
    /* @__PURE__ */ React166.createElement(
      "span",
      {
        ...others,
        style: { ...sizeStyle, ...responsiveSizeStyle, ...avatar?.style, ...others.style },
        className: classString,
        ref: avatarNodeMergedRef
      },
      childrenToRender
    )
  );
}, "InternalAvatar");
var Avatar = React166.forwardRef(InternalAvatar);
if (true) {
  Avatar.displayName = "Avatar";
}
var avatar_default = Avatar;

// packages/ant-design/components/avatar/group.tsx
var import_classnames53 = __toESM(require_classnames());
import * as React173 from "react";

// packages/ant-design/components/popover/index.tsx
var import_classnames52 = __toESM(require_classnames());
import * as React172 from "react";

// packages/ant-design/components/_util/getRenderPropValue.ts
var getRenderPropValue = /* @__PURE__ */ __name((propValue) => {
  if (!propValue) {
    return null;
  }
  return typeof propValue === "function" ? propValue() : propValue;
}, "getRenderPropValue");

// packages/ant-design/components/tooltip/index.tsx
var import_classnames50 = __toESM(require_classnames());
import * as React170 from "react";

// packages/tooltip/src/Popup.tsx
var import_classnames47 = __toESM(require_classnames());
import * as React167 from "react";
function Popup2(props) {
  const { children, prefixCls, id, overlayInnerStyle, className, style: style2 } = props;
  return /* @__PURE__ */ React167.createElement("div", { className: (0, import_classnames47.default)(`${prefixCls}-content`, className), style: style2 }, /* @__PURE__ */ React167.createElement("div", { className: `${prefixCls}-inner`, id, role: "tooltip", style: overlayInnerStyle }, typeof children === "function" ? children() : children));
}
__name(Popup2, "Popup");

// packages/tooltip/src/Tooltip.tsx
import * as React168 from "react";
import { forwardRef as forwardRef33, useImperativeHandle as useImperativeHandle14, useRef as useRef61 } from "react";

// packages/tooltip/src/placements.tsx
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
};
var autoAdjustOverflowLeftRight = { adjustX: 1, shiftY: true };
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  }
};

// packages/tooltip/src/Tooltip.tsx
var Tooltip = /* @__PURE__ */ __name((props, ref) => {
  const {
    overlayClassName,
    trigger = ["hover"],
    mouseEnterDelay = 0,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    prefixCls = "rc-tooltip",
    children,
    onVisibleChange,
    afterVisibleChange,
    transitionName,
    animation,
    motion: motion2,
    placement = "right",
    align = {},
    destroyTooltipOnHide = false,
    defaultVisible,
    getTooltipContainer,
    overlayInnerStyle,
    arrowContent,
    overlay,
    id,
    showArrow = true,
    ...restProps
  } = props;
  const triggerRef = useRef61(null);
  useImperativeHandle14(ref, () => triggerRef.current);
  const extraProps = { ...restProps };
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  const getPopupElement = /* @__PURE__ */ __name(() => /* @__PURE__ */ React168.createElement(Popup2, { key: "content", prefixCls, id, overlayInnerStyle }, overlay), "getPopupElement");
  return /* @__PURE__ */ React168.createElement(
    src_default5,
    {
      popupClassName: overlayClassName,
      prefixCls,
      popup: getPopupElement,
      action: trigger,
      builtinPlacements: placements,
      popupPlacement: placement,
      ref: triggerRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onPopupVisibleChange: onVisibleChange,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupMotion: motion2,
      defaultPopupVisible: defaultVisible,
      autoDestroy: destroyTooltipOnHide,
      mouseLeaveDelay,
      popupStyle: overlayStyle,
      mouseEnterDelay,
      arrow: showArrow,
      ...extraProps
    },
    children
  );
}, "Tooltip");
var Tooltip_default = forwardRef33(Tooltip);

// packages/tooltip/src/index.tsx
var src_default7 = Tooltip_default;

// packages/ant-design/components/style/roundedArrow.ts
function getArrowToken(token2) {
  const { sizePopupArrow, borderRadiusXS, borderRadiusOuter } = token2;
  const unitWidth = sizePopupArrow / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = borderRadiusOuter * 1 / Math.sqrt(2);
  const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
  const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
  const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
  const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
  const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
  return {
    arrowShadowWidth: shadowWidth,
    arrowPath,
    arrowPolygon
  };
}
__name(getArrowToken, "getArrowToken");
var genRoundedArrow = /* @__PURE__ */ __name((token2, bgColor, boxShadow) => {
  const { sizePopupArrow, arrowPolygon, arrowPath, arrowShadowWidth, borderRadiusXS, calc } = token2;
  return {
    pointerEvents: "none",
    width: sizePopupArrow,
    height: sizePopupArrow,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: sizePopupArrow,
      height: calc(sizePopupArrow).div(2).equal(),
      background: bgColor,
      clipPath: {
        _multi_value_: true,
        value: [arrowPolygon, arrowPath]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: arrowShadowWidth,
      height: arrowShadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${unit(borderRadiusXS)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
}, "genRoundedArrow");

// packages/ant-design/components/style/placementArrow.ts
var MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
  const { contentRadius, limitVerticalRadius } = options;
  const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
  return { arrowOffsetHorizontal: arrowOffset, arrowOffsetVertical };
}
__name(getArrowOffsetToken, "getArrowOffsetToken");
function isInject(valid, code) {
  if (!valid) {
    return {};
  }
  return code;
}
__name(isInject, "isInject");
function getArrowStyle(token2, colorBg, options) {
  const { componentCls, boxShadowPopoverArrow, arrowOffsetVertical, arrowOffsetHorizontal } = token2;
  const {
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options || {};
  return {
    [componentCls]: {
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [
        {
          position: "absolute",
          zIndex: 1,
          // lift it up so the menu wouldn't cask shadow on it
          display: "block",
          ...genRoundedArrow(token2, colorBg, boxShadowPopoverArrow),
          "&:before": {
            background: colorBg
          }
        }
      ],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      ...isInject(!!arrowPlacement.top, {
        [[
          `&-placement-top > ${componentCls}-arrow`,
          `&-placement-topLeft > ${componentCls}-arrow`,
          `&-placement-topRight > ${componentCls}-arrow`
        ].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: arrowOffsetHorizontal
          }
        },
        [`&-placement-topRight > ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: arrowOffsetHorizontal
          }
        }
      }),
      // >>>>> Bottom
      ...isInject(!!arrowPlacement.bottom, {
        [[
          `&-placement-bottom > ${componentCls}-arrow`,
          `&-placement-bottomLeft > ${componentCls}-arrow`,
          `&-placement-bottomRight > ${componentCls}-arrow`
        ].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        [`&-placement-bottomLeft > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: arrowOffsetHorizontal
          }
        },
        [`&-placement-bottomRight > ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: arrowOffsetHorizontal
          }
        }
      }),
      // >>>>> Left
      ...isInject(!!arrowPlacement.left, {
        [[
          `&-placement-left > ${componentCls}-arrow`,
          `&-placement-leftTop > ${componentCls}-arrow`,
          `&-placement-leftBottom > ${componentCls}-arrow`
        ].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-leftBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      }),
      // >>>>> Right
      ...isInject(!!arrowPlacement.right, {
        [[
          `&-placement-right > ${componentCls}-arrow`,
          `&-placement-rightTop > ${componentCls}-arrow`,
          `&-placement-rightBottom > ${componentCls}-arrow`
        ].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-rightBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      })
    }
  };
}
__name(getArrowStyle, "getArrowStyle");

// packages/ant-design/components/_util/placements.ts
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow3) {
  if (autoAdjustOverflow3 === false) {
    return {
      adjustX: false,
      adjustY: false
    };
  }
  const overflow = autoAdjustOverflow3 && typeof autoAdjustOverflow3 === "object" ? autoAdjustOverflow3 : {};
  const baseOverflow = {};
  switch (placement) {
    case "top":
    case "bottom":
      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
      baseOverflow.shiftY = true;
      baseOverflow.adjustY = true;
      break;
    case "left":
    case "right":
      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
      baseOverflow.shiftX = true;
      baseOverflow.adjustX = true;
      break;
  }
  const mergedOverflow = {
    ...baseOverflow,
    ...overflow
  };
  if (!mergedOverflow.shiftX) {
    mergedOverflow.adjustX = true;
  }
  if (!mergedOverflow.shiftY) {
    mergedOverflow.adjustY = true;
  }
  return mergedOverflow;
}
__name(getOverflowOptions, "getOverflowOptions");
var PlacementAlignMap = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
};
var ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
};
var DisableAutoArrowList = /* @__PURE__ */ new Set([
  "topLeft",
  "topRight",
  "bottomLeft",
  "bottomRight",
  "leftTop",
  "leftBottom",
  "rightTop",
  "rightBottom"
]);
function getPlacements(config) {
  const { arrowWidth, autoAdjustOverflow: autoAdjustOverflow3, arrowPointAtCenter, offset: offset3, borderRadius, visibleFirst } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {};
  Object.keys(PlacementAlignMap).forEach((key) => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
    const placementInfo = {
      ...template,
      offset: [0, 0],
      dynamicInset: true
    };
    placementMap[key] = placementInfo;
    if (DisableAutoArrowList.has(key)) {
      placementInfo.autoArrow = false;
    }
    switch (key) {
      case "top":
      case "topLeft":
      case "topRight":
        placementInfo.offset[1] = -halfArrowWidth - offset3;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        placementInfo.offset[1] = halfArrowWidth + offset3;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        placementInfo.offset[0] = -halfArrowWidth - offset3;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        placementInfo.offset[0] = halfArrowWidth + offset3;
        break;
    }
    const arrowOffset = getArrowOffsetToken({
      contentRadius: borderRadius,
      limitVerticalRadius: true
    });
    if (arrowPointAtCenter) {
      switch (key) {
        case "topLeft":
        case "bottomLeft":
          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case "topRight":
        case "bottomRight":
          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
        case "leftTop":
        case "rightTop":
          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case "leftBottom":
        case "rightBottom":
          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
      }
    }
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow3);
    if (visibleFirst) {
      placementInfo.htmlRegion = "visibleFirst";
    }
  });
  return placementMap;
}
__name(getPlacements, "getPlacements");

// packages/ant-design/components/tooltip/PurePanel.tsx
var import_classnames49 = __toESM(require_classnames());
import * as React169 from "react";

// packages/ant-design/components/tooltip/style/index.ts
var genTooltipStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        width: "max-content",
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        // Wrapper for the tooltip content
        [`${componentCls}-inner`]: {
          minWidth: controlHeight,
          minHeight: controlHeight,
          padding: `${unit(token2.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
          color: tooltipColor,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: tooltipBg,
          borderRadius: tooltipBorderRadius,
          boxShadow: boxShadowSecondary,
          boxSizing: "border-box"
        },
        // Limit left and right placement radius
        [[
          `&-placement-left`,
          `&-placement-leftTop`,
          `&-placement-leftBottom`,
          `&-placement-right`,
          `&-placement-rightTop`,
          `&-placement-rightBottom`
        ].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        // generator for preset color
        ...genPresetColor(token2, (colorKey, { darkColor }) => ({
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        })),
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow
      }
    }
  ];
}, "genTooltipStyle");
var prepareComponentToken11 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 70,
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadius,
    limitVerticalRadius: true
  }),
  ...getArrowToken(
    merge2(token2, {
      borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
    })
  )
}), "prepareComponentToken");
var style_default14 = /* @__PURE__ */ __name((prefixCls, injectStyle = true) => {
  const useStyle = genStyleHooks(
    "Tooltip",
    (token2) => {
      const { borderRadius, colorTextLightSolid, colorBgSpotlight } = token2;
      const TooltipToken = merge2(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgSpotlight
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    },
    prepareComponentToken11,
    {
      resetStyle: false,
      // Popover use Tooltip as internal component. We do not need to handle this.
      injectStyle
    }
  );
  return useStyle(prefixCls);
}, "default");

// packages/ant-design/components/tooltip/util.ts
var import_classnames48 = __toESM(require_classnames());

// packages/ant-design/components/_util/colors.ts
var inverseColors = PresetColors.map((color) => `${color}-inverse`);
var PresetStatusColorTypes = [
  "success",
  "processing",
  "error",
  "default",
  "warning"
];
function isPresetColor(color, includeInverse = true) {
  if (includeInverse) {
    return [...inverseColors, ...PresetColors].includes(color);
  }
  return PresetColors.includes(color);
}
__name(isPresetColor, "isPresetColor");
function isPresetStatusColor(color) {
  return PresetStatusColorTypes.includes(color);
}
__name(isPresetStatusColor, "isPresetStatusColor");

// packages/ant-design/components/tooltip/util.ts
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = (0, import_classnames48.default)({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    arrowStyle["--antd-arrow-background-color"] = color;
  }
  return { className, overlayStyle, arrowStyle };
}
__name(parseColor, "parseColor");

// packages/ant-design/components/tooltip/PurePanel.tsx
var PurePanel5 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title,
    color,
    overlayInnerStyle
  } = props;
  const { getPrefixCls } = React169.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default14(prefixCls);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const formattedOverlayInnerStyle = {
    ...overlayInnerStyle,
    ...colorInfo.overlayStyle
  };
  const cls5 = (0, import_classnames49.default)(
    hashId,
    cssVarCls,
    prefixCls,
    `${prefixCls}-pure`,
    `${prefixCls}-placement-${placement}`,
    className,
    colorInfo.className
  );
  return wrapCSSVar(
    /* @__PURE__ */ React169.createElement("div", { className: cls5, style: arrowContentStyle }, /* @__PURE__ */ React169.createElement("div", { className: `${prefixCls}-arrow` }), /* @__PURE__ */ React169.createElement(
      Popup2,
      {
        ...props,
        className: hashId,
        prefixCls,
        overlayInnerStyle: formattedOverlayInnerStyle
      },
      title
    ))
  );
}, "PurePanel");
var PurePanel_default4 = PurePanel5;

// packages/ant-design/components/tooltip/index.tsx
var InternalTooltip = React170.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    overlayClassName,
    color,
    overlayInnerStyle,
    children,
    afterOpenChange,
    afterVisibleChange,
    destroyTooltipOnHide,
    arrow = true,
    title,
    overlay,
    builtinPlacements,
    arrowPointAtCenter = false,
    autoAdjustOverflow: autoAdjustOverflow3 = true
  } = props;
  const mergedShowArrow = !!arrow;
  const [, token2] = useToken();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React170.useContext(ConfigContext);
  const warning5 = devUseWarning("Tooltip");
  const tooltipRef = React170.useRef(null);
  const forceAlign = /* @__PURE__ */ __name(() => {
    tooltipRef.current?.forceAlign();
  }, "forceAlign");
  React170.useImperativeHandle(ref, () => ({
    forceAlign,
    forcePopupAlign: () => {
      warning5.deprecated(false, "forcePopupAlign", "forceAlign");
      forceAlign();
    }
  }));
  if (true) {
    [
      ["visible", "open"],
      ["defaultVisible", "defaultOpen"],
      ["onVisibleChange", "onOpenChange"],
      ["afterVisibleChange", "afterOpenChange"],
      ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    warning5(
      !destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean",
      "usage",
      "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."
    );
    warning5(
      !arrow || typeof arrow === "boolean" || !("arrowPointAtCenter" in arrow),
      "deprecated",
      "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."
    );
  }
  const [open3, setOpen] = useMergedState(false, {
    value: props.open ?? props.visible,
    defaultValue: props.defaultOpen ?? props.defaultVisible
  });
  const noTitle = !title && !overlay && title !== 0;
  const onOpenChange = /* @__PURE__ */ __name((vis) => {
    setOpen(noTitle ? false : vis);
    if (!noTitle) {
      props.onOpenChange?.(vis);
      props.onVisibleChange?.(vis);
    }
  }, "onOpenChange");
  const tooltipPlacements = React170.useMemo(() => {
    let mergedArrowPointAtCenter = arrowPointAtCenter;
    if (typeof arrow === "object") {
      mergedArrowPointAtCenter = arrow.pointAtCenter ?? arrow.arrowPointAtCenter ?? arrowPointAtCenter;
    }
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow3,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius,
      offset: token2.marginXXS,
      visibleFirst: true
    });
  }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
  const memoOverlay = React170.useMemo(() => {
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  }, [overlay, title]);
  const memoOverlayWrapper = /* @__PURE__ */ React170.createElement(NoCompactStyle, null, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
  const {
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    rootClassName,
    ...otherProps
  } = props;
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props["data-popover-inject"];
  let tempOpen = open3;
  if (!("open" in props) && !("visible" in props) && noTitle) {
    tempOpen = false;
  }
  const child = React170.isValidElement(children) && !isFragment3(children) ? children : /* @__PURE__ */ React170.createElement("span", null, children);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === "string" ? (0, import_classnames50.default)(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
  const [wrapCSSVar, hashId, cssVarCls] = style_default14(prefixCls, !injectFromPopover);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const formattedOverlayInnerStyle = {
    ...overlayInnerStyle,
    ...colorInfo.overlayStyle
  };
  const customOverlayClassName = (0, import_classnames50.default)(
    overlayClassName,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    colorInfo.className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const [zIndex, contextZIndex] = useZIndex("Tooltip", otherProps.zIndex);
  const content = /* @__PURE__ */ React170.createElement(
    src_default7,
    {
      ...otherProps,
      zIndex,
      showArrow: mergedShowArrow,
      placement,
      mouseEnterDelay,
      mouseLeaveDelay,
      prefixCls,
      overlayClassName: customOverlayClassName,
      overlayStyle: { ...arrowContentStyle, ...overlayStyle },
      getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
      ref: tooltipRef,
      builtinPlacements: tooltipPlacements,
      overlay: memoOverlayWrapper,
      visible: tempOpen,
      onVisibleChange: onOpenChange,
      afterVisibleChange: afterOpenChange ?? afterVisibleChange,
      overlayInnerStyle: formattedOverlayInnerStyle,
      arrowContent: /* @__PURE__ */ React170.createElement("span", { className: `${prefixCls}-arrow-content` }),
      motion: {
        motionName: getTransitionName2(rootPrefixCls, "zoom-big-fast", props.transitionName),
        motionDeadline: 1e3
      },
      destroyTooltipOnHide: !!destroyTooltipOnHide
    },
    tempOpen ? cloneElement3(child, { className: childCls }) : child
  );
  return wrapCSSVar(
    /* @__PURE__ */ React170.createElement(zindexContext_default.Provider, { value: contextZIndex }, content)
  );
});
var Tooltip2 = InternalTooltip;
if (true) {
  Tooltip2.displayName = "Tooltip";
}
Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default4;
var tooltip_default = Tooltip2;

// packages/ant-design/components/popover/PurePanel.tsx
var import_classnames51 = __toESM(require_classnames());
import * as React171 from "react";

// packages/ant-design/components/popover/style/index.ts
var genBaseStyle5 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    popoverColor,
    titleMinWidth,
    fontWeightStrong,
    innerPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG,
    zIndexPopup,
    titleMarginBottom,
    colorBgElevated,
    popoverBg,
    titleBorderBottom,
    innerContentPadding,
    titlePadding
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
        "--antd-arrow-background-color": colorBgElevated,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          padding: innerPadding
        },
        [`${componentCls}-title`]: {
          minWidth: titleMinWidth,
          marginBottom: titleMarginBottom,
          color: colorTextHeading,
          fontWeight: fontWeightStrong,
          borderBottom: titleBorderBottom,
          padding: titlePadding
        },
        [`${componentCls}-inner-content`]: {
          color: popoverColor,
          padding: innerContentPadding
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow,
        display: "inline-block",
        [`${componentCls}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, "genBaseStyle");
var genColorStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, "genColorStyle");
var prepareComponentToken12 = /* @__PURE__ */ __name((token2) => {
  const {
    lineWidth,
    controlHeight,
    fontHeight,
    padding,
    wireframe,
    zIndexPopupBase,
    borderRadiusLG,
    marginXS,
    lineType,
    colorSplit,
    paddingSM
  } = token2;
  const titlePaddingBlockDist = controlHeight - fontHeight;
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    titleMinWidth: 177,
    zIndexPopup: zIndexPopupBase + 30,
    ...getArrowToken(token2),
    ...getArrowOffsetToken({
      contentRadius: borderRadiusLG,
      limitVerticalRadius: true
    }),
    // internal
    innerPadding: wireframe ? 0 : 12,
    titleMarginBottom: wireframe ? 0 : marginXS,
    titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
    titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
    innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
  };
}, "prepareComponentToken");
var style_default15 = genStyleHooks(
  "Popover",
  (token2) => {
    const { colorBgElevated, colorText } = token2;
    const popoverToken = merge2(token2, {
      popoverBg: colorBgElevated,
      popoverColor: colorText
    });
    return [
      genBaseStyle5(popoverToken),
      genColorStyle(popoverToken),
      initZoomMotion(popoverToken, "zoom-big")
    ];
  },
  prepareComponentToken12,
  {
    resetStyle: false,
    deprecatedTokens: [
      ["width", "titleMinWidth"],
      ["minWidth", "titleMinWidth"]
    ]
  }
);

// packages/ant-design/components/popover/PurePanel.tsx
var getOverlay = /* @__PURE__ */ __name((prefixCls, title, content) => {
  if (!title && !content) {
    return null;
  }
  return /* @__PURE__ */ React171.createElement(React171.Fragment, null, title && /* @__PURE__ */ React171.createElement("div", { className: `${prefixCls}-title` }, getRenderPropValue(title)), /* @__PURE__ */ React171.createElement("div", { className: `${prefixCls}-inner-content` }, getRenderPropValue(content)));
}, "getOverlay");
var RawPurePanel = /* @__PURE__ */ __name((props) => {
  const {
    hashId,
    prefixCls,
    className,
    style: style2,
    placement = "top",
    title,
    content,
    children
  } = props;
  return /* @__PURE__ */ React171.createElement(
    "div",
    {
      className: (0, import_classnames51.default)(
        hashId,
        prefixCls,
        `${prefixCls}-pure`,
        `${prefixCls}-placement-${placement}`,
        className
      ),
      style: style2
    },
    /* @__PURE__ */ React171.createElement("div", { className: `${prefixCls}-arrow` }),
    /* @__PURE__ */ React171.createElement(Popup2, { ...props, className: hashId, prefixCls }, children || getOverlay(prefixCls, title, content))
  );
}, "RawPurePanel");
var PurePanel6 = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, className, ...restProps } = props;
  const { getPrefixCls } = React171.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default15(prefixCls);
  return wrapCSSVar(
    /* @__PURE__ */ React171.createElement(
      RawPurePanel,
      {
        ...restProps,
        prefixCls,
        hashId,
        className: (0, import_classnames51.default)(className, cssVarCls)
      }
    )
  );
}, "PurePanel");
var PurePanel_default5 = PurePanel6;

// packages/ant-design/components/popover/index.tsx
var Overlay = /* @__PURE__ */ __name(({ title, content, prefixCls }) => /* @__PURE__ */ React172.createElement(React172.Fragment, null, title && /* @__PURE__ */ React172.createElement("div", { className: `${prefixCls}-title` }, getRenderPropValue(title)), /* @__PURE__ */ React172.createElement("div", { className: `${prefixCls}-inner-content` }, getRenderPropValue(content))), "Overlay");
var InternalPopover = React172.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    content,
    overlayClassName,
    placement = "top",
    trigger = "hover",
    children,
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    onOpenChange,
    overlayStyle = {},
    ...otherProps
  } = props;
  const { getPrefixCls } = React172.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default15(prefixCls);
  const rootPrefixCls = getPrefixCls();
  const overlayCls = (0, import_classnames52.default)(overlayClassName, hashId, cssVarCls);
  const [open3, setOpen] = useMergedState(false, {
    value: props.open ?? props.visible,
    defaultValue: props.defaultOpen ?? props.defaultVisible
  });
  const settingOpen = /* @__PURE__ */ __name((value, e3) => {
    setOpen(value, true);
    onOpenChange?.(value, e3);
  }, "settingOpen");
  const onKeyDown2 = /* @__PURE__ */ __name((e3) => {
    if (e3.keyCode === KeyCode_default.ESC) {
      settingOpen(false, e3);
    }
  }, "onKeyDown");
  const onInternalOpenChange = /* @__PURE__ */ __name((value) => {
    settingOpen(value);
  }, "onInternalOpenChange");
  return wrapCSSVar(
    /* @__PURE__ */ React172.createElement(
      tooltip_default,
      {
        placement,
        trigger,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayStyle,
        ...otherProps,
        prefixCls,
        overlayClassName: overlayCls,
        ref,
        open: open3,
        onOpenChange: onInternalOpenChange,
        overlay: title || content ? /* @__PURE__ */ React172.createElement(Overlay, { prefixCls, title, content }) : null,
        transitionName: getTransitionName2(rootPrefixCls, "zoom-big", otherProps.transitionName),
        "data-popover-inject": true
      },
      cloneElement3(children, {
        onKeyDown: (e3) => {
          if (React172.isValidElement(children)) {
            children?.props.onKeyDown?.(e3);
          }
          onKeyDown2(e3);
        }
      })
    )
  );
});
var Popover = InternalPopover;
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default5;
if (true) {
  Popover.displayName = "Popover";
}
var popover_default = Popover;

// packages/ant-design/components/avatar/group.tsx
var AvatarContextProvider = /* @__PURE__ */ __name((props) => {
  const { size, shape } = React173.useContext(AvatarContext_default);
  const avatarContextValue = React173.useMemo(
    () => ({ size: props.size || size, shape: props.shape || shape }),
    [props.size, props.shape, size, shape]
  );
  return /* @__PURE__ */ React173.createElement(AvatarContext_default.Provider, { value: avatarContextValue }, props.children);
}, "AvatarContextProvider");
var Group = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction } = React173.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    maxCount,
    maxStyle,
    size,
    shape,
    maxPopoverPlacement = "top",
    maxPopoverTrigger = "hover",
    children
  } = props;
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const cls5 = (0, import_classnames53.default)(
    groupPrefixCls,
    {
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    },
    cssVarCls,
    rootCls,
    className,
    rootClassName,
    hashId
  );
  const childrenWithProps = toArray(children).map(
    (child, index3) => cloneElement3(child, { key: `avatar-key-${index3}` })
  );
  const numOfChildren = childrenWithProps.length;
  if (maxCount && maxCount < numOfChildren) {
    const childrenShow = childrenWithProps.slice(0, maxCount);
    const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren);
    childrenShow.push(
      /* @__PURE__ */ React173.createElement(
        popover_default,
        {
          key: "avatar-popover-key",
          content: childrenHidden,
          trigger: maxPopoverTrigger,
          placement: maxPopoverPlacement,
          overlayClassName: `${groupPrefixCls}-popover`,
          destroyTooltipOnHide: true
        },
        /* @__PURE__ */ React173.createElement(avatar_default, { style: maxStyle }, `+${numOfChildren - maxCount}`)
      )
    );
    return wrapCSSVar(
      /* @__PURE__ */ React173.createElement(AvatarContextProvider, { shape, size }, /* @__PURE__ */ React173.createElement("div", { className: cls5, style: style2 }, childrenShow))
    );
  }
  return wrapCSSVar(
    /* @__PURE__ */ React173.createElement(AvatarContextProvider, { shape, size }, /* @__PURE__ */ React173.createElement("div", { className: cls5, style: style2 }, childrenWithProps))
  );
}, "Group");
var group_default2 = Group;

// packages/ant-design/components/avatar/index.ts
var Avatar2 = avatar_default;
Avatar2.Group = group_default2;
var avatar_default2 = Avatar2;

// packages/ant-design/components/back-top/index.tsx
var import_VerticalAlignTopOutlined = __toESM(require_VerticalAlignTopOutlined3());
var import_classnames54 = __toESM(require_classnames());
import * as React174 from "react";

// packages/ant-design/components/back-top/style/index.ts
var genSharedBackTopStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, backTopFontSize, backTopSize, zIndexPopup } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "fixed",
      insetInlineEnd: token2.backTopInlineEnd,
      insetBlockEnd: token2.backTopBlockEnd,
      zIndex: zIndexPopup,
      width: 40,
      height: 40,
      cursor: "pointer",
      "&:empty": {
        display: "none"
      },
      [`${componentCls}-content`]: {
        width: backTopSize,
        height: backTopSize,
        overflow: "hidden",
        color: token2.backTopColor,
        textAlign: "center",
        backgroundColor: token2.backTopBackground,
        borderRadius: backTopSize,
        transition: `all ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.backTopHoverBackground,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      // change to .backtop .backtop-icon
      [`${componentCls}-icon`]: {
        fontSize: backTopFontSize,
        lineHeight: unit(backTopSize)
      }
    }
  };
}, "genSharedBackTopStyle");
var genMediaBackTopStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, screenMD, screenXS, backTopInlineEndMD, backTopInlineEndXS } = token2;
  return {
    [`@media (max-width: ${unit(screenMD)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndMD
      }
    },
    [`@media (max-width: ${unit(screenXS)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndXS
      }
    }
  };
}, "genMediaBackTopStyle");
var prepareComponentToken13 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexBase + 10
}), "prepareComponentToken");
var style_default16 = genStyleHooks(
  "BackTop",
  (token2) => {
    const {
      fontSizeHeading3,
      colorTextDescription,
      colorTextLightSolid,
      colorText,
      controlHeightLG,
      calc
    } = token2;
    const backTopToken = merge2(token2, {
      backTopBackground: colorTextDescription,
      backTopColor: colorTextLightSolid,
      backTopHoverBackground: colorText,
      backTopFontSize: fontSizeHeading3,
      backTopSize: controlHeightLG,
      backTopBlockEnd: calc(controlHeightLG).mul(1.25).equal(),
      backTopInlineEnd: calc(controlHeightLG).mul(2.5).equal(),
      backTopInlineEndMD: calc(controlHeightLG).mul(1.5).equal(),
      backTopInlineEndXS: calc(controlHeightLG).mul(0.5).equal()
    });
    return [genSharedBackTopStyle(backTopToken), genMediaBackTopStyle(backTopToken)];
  },
  prepareComponentToken13
);

// packages/ant-design/components/back-top/index.tsx
var BackTop = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    visibilityHeight = 400,
    target,
    onClick,
    duration = 450
  } = props;
  const [visible, setVisible] = React174.useState(visibilityHeight === 0);
  const ref = React174.useRef(null);
  const getDefaultTarget2 = /* @__PURE__ */ __name(() => ref.current && ref.current.ownerDocument ? ref.current.ownerDocument : window, "getDefaultTarget");
  const handleScroll = throttleByAnimationFrame_default(
    (e3) => {
      const scrollTop = getScroll(e3.target, true);
      setVisible(scrollTop >= visibilityHeight);
    }
  );
  if (true) {
    const warning5 = devUseWarning("BackTop");
    warning5.deprecated(false, "BackTop", "FloatButton.BackTop");
  }
  React174.useEffect(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({ target: container });
    container?.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container?.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = /* @__PURE__ */ __name((e3) => {
    scrollTo(0, { getContainer: target || getDefaultTarget2, duration });
    onClick?.(e3);
  }, "scrollToTop");
  const { getPrefixCls, direction } = React174.useContext(ConfigContext);
  const prefixCls = getPrefixCls("back-top", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [wrapCSSVar, hashId, cssVarCls] = style_default16(prefixCls);
  const classString = (0, import_classnames54.default)(
    hashId,
    cssVarCls,
    prefixCls,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName
  );
  const divProps = omit(props, [
    "prefixCls",
    "className",
    "rootClassName",
    "children",
    "visibilityHeight",
    "target"
  ]);
  const defaultElement = /* @__PURE__ */ React174.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ React174.createElement("div", { className: `${prefixCls}-icon` }, /* @__PURE__ */ React174.createElement(import_VerticalAlignTopOutlined.default, null)));
  return wrapCSSVar(
    /* @__PURE__ */ React174.createElement("div", { ...divProps, className: classString, onClick: scrollToTop, ref }, /* @__PURE__ */ React174.createElement(src_default2, { visible, motionName: `${rootPrefixCls}-fade` }, ({ className: motionClassName }) => cloneElement3(props.children || defaultElement, ({ className: cloneCls }) => ({
      className: (0, import_classnames54.default)(motionClassName, cloneCls)
    }))))
  );
}, "BackTop");
if (true) {
  BackTop.displayName = "BackTop";
}
var back_top_default = BackTop;

// packages/ant-design/components/badge/index.tsx
var import_classnames58 = __toESM(require_classnames());
import * as React178 from "react";
import { useMemo as useMemo44, useRef as useRef64 } from "react";

// packages/ant-design/components/badge/Ribbon.tsx
var import_classnames55 = __toESM(require_classnames());
import * as React175 from "react";

// packages/ant-design/components/badge/style/index.ts
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
  "0%": { transform: "scale(0.8)", opacity: 0.5 },
  "100%": { transform: "scale(2.4)", opacity: 0 }
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
  "0%": { transform: "scale(0) translate(50%, -50%)", opacity: 0 },
  "100%": { transform: "scale(1) translate(50%, -50%)" }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
  "0%": { transform: "scale(1) translate(50%, -50%)" },
  "100%": { transform: "scale(0) translate(50%, -50%)", opacity: 0 }
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
  "0%": { transform: "scale(0)", opacity: 0 },
  "100%": { transform: "scale(1)" }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
  "0%": { transform: "scale(1)" },
  "100%": { transform: "scale(0)", opacity: 0 }
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
  "0%": { transformOrigin: "50%" },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
});
var genSharedBadgeStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeShadowSize,
    motionDurationSlow,
    textFontSize,
    textFontSizeSM,
    statusSize,
    dotSize,
    textFontWeight,
    indicatorHeight,
    indicatorHeightSM,
    marginXS,
    calc
  } = token2;
  const numberPrefixCls = `${antCls}-scroll-number`;
  const colorPreset = genPresetColor(token2, (colorKey, { darkColor }) => ({
    [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
      background: darkColor,
      [`&:not(${componentCls}-count)`]: {
        color: darkColor
      },
      "a:hover &": {
        background: darkColor
      }
    }
  }));
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        zIndex: token2.indicatorZIndex,
        minWidth: indicatorHeight,
        height: indicatorHeight,
        color: token2.badgeTextColor,
        fontWeight: textFontWeight,
        fontSize: textFontSize,
        lineHeight: unit(indicatorHeight),
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token2.badgeColor,
        borderRadius: calc(indicatorHeight).div(2).equal(),
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token2.badgeShadowColor}`,
        transition: `background ${token2.motionDurationMid}`,
        a: {
          color: token2.badgeTextColor
        },
        "a:hover": {
          color: token2.badgeTextColor
        },
        "a:hover &": {
          background: token2.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: indicatorHeightSM,
        height: indicatorHeightSM,
        fontSize: textFontSizeSM,
        lineHeight: unit(indicatorHeightSM),
        borderRadius: calc(indicatorHeightSM).div(2).equal()
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${unit(token2.paddingXS)}`,
        bdi: {
          unicodeBidi: "plaintext"
        }
      },
      [`${componentCls}-dot`]: {
        zIndex: token2.indicatorZIndex,
        width: dotSize,
        minWidth: dotSize,
        height: dotSize,
        background: token2.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token2.badgeShadowColor}`
      },
      [`${componentCls}-dot${numberPrefixCls}`]: {
        transition: `background ${motionDurationSlow}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          // Magic number, but seems better experience
          display: "inline-block",
          width: statusSize,
          height: statusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token2.colorInfo,
          backgroundColor: token2.colorInfo,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token2.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token2.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token2.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token2.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token2.colorText,
          fontSize: token2.fontSize
        }
      },
      ...colorPreset,
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [`${numberPrefixCls}`]: {
        overflow: "hidden",
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: indicatorHeight,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: indicatorHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }
  };
}, "genSharedBadgeStyle");
var prepareToken3 = /* @__PURE__ */ __name((token2) => {
  const { fontHeight, lineWidth, marginXS, colorBorderBg } = token2;
  const badgeFontHeight = fontHeight;
  const badgeShadowSize = lineWidth;
  const badgeTextColor = token2.colorBgContainer;
  const badgeColor = token2.colorError;
  const badgeColorHover = token2.colorErrorHover;
  const badgeToken = merge2(token2, {
    badgeFontHeight,
    badgeShadowSize,
    badgeTextColor,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: `brightness(75%)`
  });
  return badgeToken;
}, "prepareToken");
var prepareComponentToken14 = /* @__PURE__ */ __name((token2) => {
  const { fontSize, lineHeight, fontSizeSM, lineWidth } = token2;
  return {
    indicatorZIndex: "auto",
    indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
    indicatorHeightSM: fontSize,
    dotSize: fontSizeSM / 2,
    textFontSize: fontSizeSM,
    textFontSizeSM: fontSizeSM,
    textFontWeight: "normal",
    statusSize: fontSizeSM / 2
  };
}, "prepareComponentToken");
var style_default17 = genStyleHooks(
  "Badge",
  (token2) => {
    const badgeToken = prepareToken3(token2);
    return genSharedBadgeStyle(badgeToken);
  },
  prepareComponentToken14
);

// packages/ant-design/components/badge/style/ribbon.ts
var genRibbonStyle = /* @__PURE__ */ __name((token2) => {
  const { antCls, badgeFontHeight, marginXS, badgeRibbonOffset, calc } = token2;
  const ribbonPrefixCls = `${antCls}-ribbon`;
  const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
  const statusRibbonPreset = genPresetColor(token2, (colorKey, { darkColor }) => ({
    [`&${ribbonPrefixCls}-color-${colorKey}`]: {
      background: darkColor,
      color: darkColor
    }
  }));
  return {
    [`${ribbonWrapperPrefixCls}`]: {
      position: "relative"
    },
    [`${ribbonPrefixCls}`]: {
      ...resetComponent(token2),
      position: "absolute",
      top: marginXS,
      padding: `0 ${unit(token2.paddingXS)}`,
      color: token2.colorPrimary,
      lineHeight: unit(badgeFontHeight),
      whiteSpace: "nowrap",
      backgroundColor: token2.colorPrimary,
      borderRadius: token2.borderRadiusSM,
      [`${ribbonPrefixCls}-text`]: {
        color: token2.colorTextLightSolid
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${unit(calc(badgeRibbonOffset).div(2).equal())} solid`,
        transform: token2.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token2.badgeRibbonCornerFilter
      },
      ...statusRibbonPreset,
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, "genRibbonStyle");
var ribbon_default = genStyleHooks(
  ["Badge", "Ribbon"],
  (token2) => {
    const badgeToken = prepareToken3(token2);
    return genRibbonStyle(badgeToken);
  },
  prepareComponentToken14
);

// packages/ant-design/components/badge/Ribbon.tsx
var Ribbon = /* @__PURE__ */ __name((props) => {
  const {
    className,
    prefixCls: customizePrefixCls,
    style: style2,
    color,
    children,
    text,
    placement = "end",
    rootClassName
  } = props;
  const { getPrefixCls, direction } = React175.useContext(ConfigContext);
  const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
  const wrapperCls = `${prefixCls}-wrapper`;
  const [wrapCSSVar, hashId, cssVarCls] = ribbon_default(prefixCls, wrapperCls);
  const colorInPreset = isPresetColor(color, false);
  const ribbonCls = (0, import_classnames55.default)(
    prefixCls,
    `${prefixCls}-placement-${placement}`,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-color-${color}`]: colorInPreset
    },
    className
  );
  const colorStyle = {};
  const cornerColorStyle = {};
  if (color && !colorInPreset) {
    colorStyle.background = color;
    cornerColorStyle.color = color;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React175.createElement("div", { className: (0, import_classnames55.default)(wrapperCls, rootClassName, hashId, cssVarCls) }, children, /* @__PURE__ */ React175.createElement("div", { className: (0, import_classnames55.default)(ribbonCls, hashId), style: { ...colorStyle, ...style2 } }, /* @__PURE__ */ React175.createElement("span", { className: `${prefixCls}-text` }, text), /* @__PURE__ */ React175.createElement("div", { className: `${prefixCls}-corner`, style: cornerColorStyle })))
  );
}, "Ribbon");
if (true) {
  Ribbon.displayName = "Ribbon";
}
var Ribbon_default = Ribbon;

// packages/ant-design/components/badge/ScrollNumber.tsx
var import_classnames57 = __toESM(require_classnames());
import * as React177 from "react";

// packages/ant-design/components/badge/SingleNumber.tsx
var import_classnames56 = __toESM(require_classnames());
import * as React176 from "react";
function UnitNumber({ prefixCls, value, current, offset: offset3 = 0 }) {
  let style2;
  if (offset3) {
    style2 = {
      position: "absolute",
      top: `${offset3}00%`,
      left: 0
    };
  }
  return /* @__PURE__ */ React176.createElement(
    "span",
    {
      style: style2,
      className: (0, import_classnames56.default)(`${prefixCls}-only-unit`, {
        current
      })
    },
    value
  );
}
__name(UnitNumber, "UnitNumber");
function getOffset(start, end, unit3) {
  let index3 = start;
  let offset3 = 0;
  while ((index3 + 10) % 10 !== end) {
    index3 += unit3;
    offset3 += unit3;
  }
  return offset3;
}
__name(getOffset, "getOffset");
function SingleNumber(props) {
  const { prefixCls, count: originCount, value: originValue } = props;
  const value = Number(originValue);
  const count = Math.abs(originCount);
  const [prevValue, setPrevValue] = React176.useState(value);
  const [prevCount, setPrevCount] = React176.useState(count);
  const onTransitionEnd = /* @__PURE__ */ __name(() => {
    setPrevValue(value);
    setPrevCount(count);
  }, "onTransitionEnd");
  React176.useEffect(() => {
    const timeout = setTimeout(() => {
      onTransitionEnd();
    }, 1e3);
    return () => {
      clearTimeout(timeout);
    };
  }, [value]);
  let unitNodes;
  let offsetStyle;
  if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
    unitNodes = [/* @__PURE__ */ React176.createElement(UnitNumber, { ...props, key: value, current: true })];
    offsetStyle = {
      transition: "none"
    };
  } else {
    unitNodes = [];
    const end = value + 10;
    const unitNumberList = [];
    for (let index3 = value; index3 <= end; index3 += 1) {
      unitNumberList.push(index3);
    }
    const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
    unitNodes = unitNumberList.map((n2, index3) => {
      const singleUnit = n2 % 10;
      return /* @__PURE__ */ React176.createElement(
        UnitNumber,
        {
          ...props,
          key: n2,
          value: singleUnit,
          offset: index3 - prevIndex,
          current: index3 === prevIndex
        }
      );
    });
    const unit3 = prevCount < count ? 1 : -1;
    offsetStyle = {
      transform: `translateY(${-getOffset(prevValue, value, unit3)}00%)`
    };
  }
  return /* @__PURE__ */ React176.createElement("span", { className: `${prefixCls}-only`, style: offsetStyle, onTransitionEnd }, unitNodes);
}
__name(SingleNumber, "SingleNumber");

// packages/ant-design/components/badge/ScrollNumber.tsx
var ScrollNumber = React177.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    count,
    className,
    motionClassName,
    style: style2,
    title,
    show,
    component: Component11 = "sup",
    children,
    ...restProps
  } = props;
  const { getPrefixCls } = React177.useContext(ConfigContext);
  const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
  const newProps = {
    ...restProps,
    "data-show": show,
    style: style2,
    className: (0, import_classnames57.default)(prefixCls, className, motionClassName),
    title
  };
  let numberNodes = count;
  if (count && Number(count) % 1 === 0) {
    const numberList = String(count).split("");
    numberNodes = /* @__PURE__ */ React177.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ React177.createElement(
      SingleNumber,
      {
        prefixCls,
        count: Number(count),
        value: num,
        key: numberList.length - i
      }
    )));
  }
  if (style2 && style2.borderColor) {
    newProps.style = {
      ...style2,
      boxShadow: `0 0 0 1px ${style2.borderColor} inset`
    };
  }
  if (children) {
    return cloneElement3(children, (oriProps) => ({
      className: (0, import_classnames57.default)(`${prefixCls}-custom-component`, oriProps?.className, motionClassName)
    }));
  }
  return /* @__PURE__ */ React177.createElement(Component11, { ...newProps, ref }, numberNodes);
});
var ScrollNumber_default = ScrollNumber;

// packages/ant-design/components/badge/index.tsx
var InternalBadge = React178.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
    children,
    status,
    text,
    color,
    count = null,
    overflowCount = 99,
    dot = false,
    size = "default",
    title,
    offset: offset3,
    style: style2,
    className,
    rootClassName,
    classNames: classNames253,
    styles,
    showZero = false,
    ...restProps
  } = props;
  const { getPrefixCls, direction, badge } = React178.useContext(ConfigContext);
  const prefixCls = getPrefixCls("badge", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default17(prefixCls);
  const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
  const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0;
  const ignoreCount = count === null || isZero && !showZero;
  const hasStatus = (status !== null && status !== void 0 || color !== null && color !== void 0) && ignoreCount;
  const showAsDot = dot && !isZero;
  const mergedCount = showAsDot ? "" : numberedDisplayCount;
  const isHidden = useMemo44(() => {
    const isEmpty2 = mergedCount === null || mergedCount === void 0 || mergedCount === "";
    return (isEmpty2 || isZero && !showZero) && !showAsDot;
  }, [mergedCount, isZero, showZero, showAsDot]);
  const countRef = useRef64(count);
  if (!isHidden) {
    countRef.current = count;
  }
  const livingCount = countRef.current;
  const displayCountRef = useRef64(mergedCount);
  if (!isHidden) {
    displayCountRef.current = mergedCount;
  }
  const displayCount = displayCountRef.current;
  const isDotRef = useRef64(showAsDot);
  if (!isHidden) {
    isDotRef.current = showAsDot;
  }
  const mergedStyle = useMemo44(() => {
    if (!offset3) {
      return { ...badge?.style, ...style2 };
    }
    const offsetStyle = { marginTop: offset3[1] };
    if (direction === "rtl") {
      offsetStyle.left = parseInt(offset3[0], 10);
    } else {
      offsetStyle.right = -parseInt(offset3[0], 10);
    }
    return { ...offsetStyle, ...badge?.style, ...style2 };
  }, [direction, offset3, style2, badge?.style]);
  const titleNode = title ?? (typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0);
  const statusTextNode = isHidden || !text ? null : /* @__PURE__ */ React178.createElement("span", { className: `${prefixCls}-status-text` }, text);
  const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement3(livingCount, (oriProps) => ({
    style: { ...mergedStyle, ...oriProps.style }
  }));
  const isInternalColor = isPresetColor(color, false);
  const statusCls = (0, import_classnames58.default)(classNames253?.indicator, badge?.classNames?.indicator, {
    [`${prefixCls}-status-dot`]: hasStatus,
    [`${prefixCls}-status-${status}`]: !!status,
    [`${prefixCls}-color-${color}`]: isInternalColor
  });
  const statusStyle = {};
  if (color && !isInternalColor) {
    statusStyle.color = color;
    statusStyle.background = color;
  }
  const badgeClassName = (0, import_classnames58.default)(
    prefixCls,
    {
      [`${prefixCls}-status`]: hasStatus,
      [`${prefixCls}-not-a-wrapper`]: !children,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    badge?.className,
    badge?.classNames?.root,
    classNames253?.root,
    hashId,
    cssVarCls
  );
  if (!children && hasStatus) {
    const statusTextColor = mergedStyle.color;
    return wrapCSSVar(
      /* @__PURE__ */ React178.createElement(
        "span",
        {
          ...restProps,
          className: badgeClassName,
          style: { ...styles?.root, ...badge?.styles?.root, ...mergedStyle }
        },
        /* @__PURE__ */ React178.createElement(
          "span",
          {
            className: statusCls,
            style: { ...styles?.indicator, ...badge?.styles?.indicator, ...statusStyle }
          }
        ),
        text && /* @__PURE__ */ React178.createElement("span", { style: { color: statusTextColor }, className: `${prefixCls}-status-text` }, text)
      )
    );
  }
  return wrapCSSVar(
    /* @__PURE__ */ React178.createElement(
      "span",
      {
        ref,
        ...restProps,
        className: badgeClassName,
        style: { ...badge?.styles?.root, ...styles?.root }
      },
      children,
      /* @__PURE__ */ React178.createElement(
        src_default2,
        {
          visible: !isHidden,
          motionName: `${prefixCls}-zoom`,
          motionAppear: false,
          motionDeadline: 1e3
        },
        ({ className: motionClassName, ref: scrollNumberRef }) => {
          const scrollNumberPrefixCls = getPrefixCls(
            "scroll-number",
            customizeScrollNumberPrefixCls
          );
          const isDot = isDotRef.current;
          const scrollNumberCls = (0, import_classnames58.default)(classNames253?.indicator, badge?.classNames?.indicator, {
            [`${prefixCls}-dot`]: isDot,
            [`${prefixCls}-count`]: !isDot,
            [`${prefixCls}-count-sm`]: size === "small",
            [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
            [`${prefixCls}-status-${status}`]: !!status,
            [`${prefixCls}-color-${color}`]: isInternalColor
          });
          let scrollNumberStyle = {
            ...styles?.indicator,
            ...badge?.styles?.indicator,
            ...mergedStyle
          };
          if (color && !isInternalColor) {
            scrollNumberStyle = scrollNumberStyle || {};
            scrollNumberStyle.background = color;
          }
          return /* @__PURE__ */ React178.createElement(
            ScrollNumber_default,
            {
              prefixCls: scrollNumberPrefixCls,
              show: !isHidden,
              motionClassName,
              className: scrollNumberCls,
              count: displayCount,
              title: titleNode,
              style: scrollNumberStyle,
              key: "scrollNumber",
              ref: scrollNumberRef
            },
            displayNode
          );
        }
      ),
      statusTextNode
    )
  );
});
var Badge = InternalBadge;
Badge.Ribbon = Ribbon_default;
if (true) {
  Badge.displayName = "Badge";
}
var badge_default = Badge;

// packages/ant-design/components/breadcrumb/Breadcrumb.tsx
var import_classnames74 = __toESM(require_classnames());
import * as React216 from "react";

// packages/ant-design/components/breadcrumb/BreadcrumbItem.tsx
var import_DownOutlined2 = __toESM(require_DownOutlined3());
import * as React215 from "react";

// packages/ant-design/components/dropdown/dropdown.tsx
var import_RightOutlined2 = __toESM(require_RightOutlined3());
var import_classnames72 = __toESM(require_classnames());
import * as React212 from "react";

// packages/dropdown/src/Dropdown.tsx
var import_classnames59 = __toESM(require_classnames());
import React181 from "react";

// packages/dropdown/src/hooks/useAccessibility.ts
import * as React179 from "react";
var { ESC, TAB } = KeyCode_default;
function useAccessibility({
  visible,
  triggerRef,
  onVisibleChange,
  autoFocus,
  overlayRef
}) {
  const focusMenuRef = React179.useRef(false);
  const handleCloseMenuAndReturnFocus = /* @__PURE__ */ __name(() => {
    if (visible) {
      triggerRef.current?.focus?.();
      onVisibleChange?.(false);
    }
  }, "handleCloseMenuAndReturnFocus");
  const focusMenu = /* @__PURE__ */ __name(() => {
    if (overlayRef.current?.focus) {
      overlayRef.current.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  }, "focusMenu");
  const handleKeyDown = /* @__PURE__ */ __name((event) => {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        let focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  }, "handleKeyDown");
  React179.useEffect(() => {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        raf_default(focusMenu, 3);
      }
      return () => {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return () => {
      focusMenuRef.current = false;
    };
  }, [visible]);
}
__name(useAccessibility, "useAccessibility");

// packages/dropdown/src/Overlay.tsx
import React180, { forwardRef as forwardRef38, useMemo as useMemo45 } from "react";
var Overlay2 = forwardRef38((props, ref) => {
  const { overlay, arrow, prefixCls } = props;
  const overlayNode = useMemo45(() => {
    let overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  }, [overlay]);
  const composedRef = composeRef(ref, overlayNode?.ref);
  return /* @__PURE__ */ React180.createElement(React180.Fragment, null, arrow && /* @__PURE__ */ React180.createElement("div", { className: `${prefixCls}-arrow` }), React180.cloneElement(overlayNode, { ref: supportRef(overlayNode) ? composedRef : void 0 }));
});
var Overlay_default = Overlay2;

// packages/dropdown/src/placements.ts
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset2 = [0, 0];
var placements2 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  }
};
var placements_default = placements2;

// packages/dropdown/src/Dropdown.tsx
function Dropdown(props, ref) {
  const {
    arrow = false,
    prefixCls = "rc-dropdown",
    transitionName,
    animation,
    align,
    placement = "bottomLeft",
    placements: placements5 = placements_default,
    getPopupContainer,
    showAction,
    hideAction,
    overlayClassName,
    overlayStyle,
    visible,
    trigger = ["hover"],
    autoFocus,
    overlay,
    children,
    onVisibleChange,
    ...otherProps
  } = props;
  const [triggerVisible, setTriggerVisible] = React181.useState();
  const mergedVisible = "visible" in props ? visible : triggerVisible;
  const triggerRef = React181.useRef(null);
  const overlayRef = React181.useRef(null);
  const childRef = React181.useRef(null);
  React181.useImperativeHandle(ref, () => triggerRef.current);
  const handleVisibleChange = /* @__PURE__ */ __name((newVisible) => {
    setTriggerVisible(newVisible);
    onVisibleChange?.(newVisible);
  }, "handleVisibleChange");
  useAccessibility({
    visible: mergedVisible,
    triggerRef: childRef,
    onVisibleChange: handleVisibleChange,
    autoFocus,
    overlayRef
  });
  const onClick = /* @__PURE__ */ __name((e3) => {
    const { onOverlayClick } = props;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e3);
    }
  }, "onClick");
  const getMenuElement = /* @__PURE__ */ __name(() => /* @__PURE__ */ React181.createElement(
    Overlay_default,
    {
      ref: overlayRef,
      overlay,
      prefixCls,
      arrow
    }
  ), "getMenuElement");
  const getMenuElementOrLambda = /* @__PURE__ */ __name(() => {
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  }, "getMenuElementOrLambda");
  const getMinOverlayWidthMatchTrigger = /* @__PURE__ */ __name(() => {
    const { minOverlayWidthMatchTrigger, alignPoint } = props;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint;
  }, "getMinOverlayWidthMatchTrigger");
  const getOpenClassName = /* @__PURE__ */ __name(() => {
    const { openClassName } = props;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return `${prefixCls}-open`;
  }, "getOpenClassName");
  const childrenNode = React181.cloneElement(children, {
    className: (0, import_classnames59.default)(
      children.props?.className,
      mergedVisible && getOpenClassName()
    ),
    ref: supportRef(children) ? composeRef(
      childRef,
      children.ref
    ) : void 0
  });
  let triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return /* @__PURE__ */ React181.createElement(
    src_default5,
    {
      builtinPlacements: placements5,
      ...otherProps,
      prefixCls,
      ref: triggerRef,
      popupClassName: (0, import_classnames59.default)(overlayClassName, {
        [`${prefixCls}-show-arrow`]: arrow
      }),
      popupStyle: overlayStyle,
      action: trigger,
      showAction,
      hideAction: triggerHideAction,
      popupPlacement: placement,
      popupAlign: align,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupVisible: mergedVisible,
      stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
      popup: getMenuElementOrLambda(),
      onPopupVisibleChange: handleVisibleChange,
      onPopupClick: onClick,
      getPopupContainer
    },
    childrenNode
  );
}
__name(Dropdown, "Dropdown");
var Dropdown_default = React181.forwardRef(Dropdown);

// packages/dropdown/src/index.tsx
var src_default8 = Dropdown_default;

// packages/ant-design/components/menu/index.tsx
import * as React211 from "react";
import { forwardRef as forwardRef47, useImperativeHandle as useImperativeHandle17, useRef as useRef75 } from "react";

// packages/menu/src/Menu.tsx
var import_classnames66 = __toESM(require_classnames());
init_warning();
import * as React202 from "react";
import { useImperativeHandle as useImperativeHandle16 } from "react";
import { flushSync as flushSync2 } from "react-dom";

// packages/menu/src/context/IdContext.ts
import * as React182 from "react";
var IdContext = React182.createContext(null);
function getMenuId(uuid9, eventKey) {
  if (uuid9 === void 0) {
    return null;
  }
  return `${uuid9}-${eventKey}`;
}
__name(getMenuId, "getMenuId");
function useMenuId(eventKey) {
  const id = React182.useContext(IdContext);
  return getMenuId(id, eventKey);
}
__name(useMenuId, "useMenuId");

// packages/menu/src/context/MenuContext.tsx
import * as React183 from "react";
var MenuContext = React183.createContext(null);
function mergeProps(origin, target) {
  const clone = { ...origin };
  Object.keys(target).forEach((key) => {
    const value = target[key];
    if (value !== void 0) {
      clone[key] = value;
    }
  });
  return clone;
}
__name(mergeProps, "mergeProps");
function InheritableContextProvider({
  children,
  locked,
  ...restProps
}) {
  const context = React183.useContext(MenuContext);
  const inheritableContext = useMemo(
    () => mergeProps(context, restProps),
    [context, restProps],
    (prev2, next2) => !locked && (prev2[0] !== next2[0] || !isEqual_default(prev2[1], next2[1], true))
  );
  return /* @__PURE__ */ React183.createElement(MenuContext.Provider, { value: inheritableContext }, children);
}
__name(InheritableContextProvider, "InheritableContextProvider");

// packages/menu/src/context/PathContext.tsx
import * as React184 from "react";
var EmptyList = [];
var PathRegisterContext = React184.createContext(
  null
);
function useMeasure() {
  return React184.useContext(PathRegisterContext);
}
__name(useMeasure, "useMeasure");
var PathTrackerContext = React184.createContext(EmptyList);
function useFullPath(eventKey) {
  const parentKeyPath = React184.useContext(PathTrackerContext);
  return React184.useMemo(
    () => eventKey !== void 0 ? [...parentKeyPath, eventKey] : parentKeyPath,
    [parentKeyPath, eventKey]
  );
}
__name(useFullPath, "useFullPath");
var PathUserContext = React184.createContext(null);

// packages/menu/src/context/PrivateContext.ts
import * as React185 from "react";
var PrivateContext = React185.createContext({});
var PrivateContext_default = PrivateContext;

// packages/util/src/Dom/focus.ts
function focusable(node2, includePositive = false) {
  if (isVisible_default(node2)) {
    const nodeName = node2.nodeName.toLowerCase();
    const isFocusableElement = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
      node2.isContentEditable || // Anchor with href element
      nodeName === "a" && !!node2.getAttribute("href")
    );
    const tabIndexAttr = node2.getAttribute("tabindex");
    const tabIndexNum = Number(tabIndexAttr);
    let tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
__name(focusable, "focusable");
function getFocusNodeList(node2, includePositive = false) {
  const res = [...node2.querySelectorAll("*")].filter((child) => {
    return focusable(child, includePositive);
  });
  if (focusable(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
__name(getFocusNodeList, "getFocusNodeList");

// packages/menu/src/hooks/useAccessibility.ts
import * as React186 from "react";
var { LEFT, RIGHT, UP, DOWN, ENTER, ESC: ESC2, HOME, END } = KeyCode_default;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset2(mode, isRootLevel, isRtl, which) {
  const prev2 = "prev";
  const next2 = "next";
  const children = "children";
  const parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  const inline3 = {
    [UP]: prev2,
    [DOWN]: next2
  };
  const horizontal = {
    [LEFT]: isRtl ? next2 : prev2,
    [RIGHT]: isRtl ? prev2 : next2,
    [DOWN]: children,
    [ENTER]: children
  };
  const vertical = {
    [UP]: prev2,
    [DOWN]: next2,
    [ENTER]: children,
    [ESC2]: parent,
    [LEFT]: isRtl ? children : parent,
    [RIGHT]: isRtl ? parent : children
  };
  const offsets = {
    inline: inline3,
    horizontal,
    vertical,
    inlineSub: inline3,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  const type5 = offsets[`${mode}${isRootLevel ? "" : "Sub"}`]?.[which];
  switch (type5) {
    case prev2:
      return {
        offset: -1,
        sibling: true
      };
    case next2:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
__name(getOffset2, "getOffset");
function findContainerUL(element) {
  let current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
__name(findContainerUL, "findContainerUL");
function getFocusElement(activeElement, elements) {
  let current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
__name(getFocusElement, "getFocusElement");
function getFocusableElements(container, elements) {
  const list = getFocusNodeList(container, true);
  return list.filter((ele) => elements.has(ele));
}
__name(getFocusableElements, "getFocusableElements");
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset3 = 1) {
  if (!parentQueryContainer) {
    return null;
  }
  const sameLevelFocusableMenuElementList = getFocusableElements(
    parentQueryContainer,
    elements
  );
  const count = sameLevelFocusableMenuElementList.length;
  let focusIndex = sameLevelFocusableMenuElementList.findIndex(
    (ele) => focusMenuElement === ele
  );
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
__name(getNextFocusElement, "getNextFocusElement");
var refreshElements = /* @__PURE__ */ __name((keys2, id) => {
  const elements = /* @__PURE__ */ new Set();
  const key2element = /* @__PURE__ */ new Map();
  const element2key = /* @__PURE__ */ new Map();
  keys2.forEach((key) => {
    const element = document.querySelector(
      `[data-menu-id='${getMenuId(id, key)}']`
    );
    if (element) {
      elements.add(element);
      element2key.set(element, key);
      key2element.set(key, element);
    }
  });
  return { elements, key2element, element2key };
}, "refreshElements");
function useAccessibility2(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  const rafRef = React186.useRef();
  const activeRef = React186.useRef();
  activeRef.current = activeKey;
  const cleanRaf = /* @__PURE__ */ __name(() => {
    raf_default.cancel(rafRef.current);
  }, "cleanRaf");
  React186.useEffect(
    () => () => {
      cleanRaf();
    },
    []
  );
  return (e3) => {
    const { which } = e3;
    if ([...ArrowKeys, ENTER, ESC2, HOME, END].includes(which)) {
      const keys2 = getKeys();
      let refreshedElements = refreshElements(keys2, id);
      const { elements, key2element, element2key } = refreshedElements;
      const activeElement = key2element.get(activeKey);
      const focusMenuElement = getFocusElement(activeElement, elements);
      const focusMenuKey = element2key.get(focusMenuElement);
      const offsetObj = getOffset2(
        mode,
        getKeyPath(focusMenuKey, true).length === 1,
        isRtl,
        which
      );
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e3.preventDefault();
      }
      const tryFocus = /* @__PURE__ */ __name((menuElement) => {
        if (menuElement) {
          let focusTargetElement = menuElement;
          const link = menuElement.querySelector("a");
          if (link?.getAttribute("href")) {
            focusTargetElement = link;
          }
          const targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = raf_default(() => {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      }, "tryFocus");
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        let parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        let targetElement;
        const focusableElements = getFocusableElements(
          parentQueryContainer,
          elements
        );
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(
            parentQueryContainer,
            elements,
            focusMenuElement,
            offsetObj.offset
          );
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = raf_default(() => {
          refreshedElements = refreshElements(keys2, id);
          const controlId = focusMenuElement.getAttribute("aria-controls");
          const subQueryContainer = document.getElementById(controlId);
          const targetElement = getNextFocusElement(
            subQueryContainer,
            refreshedElements.elements
          );
          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        const keyPath = getKeyPath(focusMenuKey, true);
        const parentKey = keyPath[keyPath.length - 2];
        const parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown?.(e3);
  };
}
__name(useAccessibility2, "useAccessibility");

// packages/menu/src/hooks/useKeyRecords.ts
init_warning();
import * as React187 from "react";
import { useRef as useRef67, useCallback as useCallback19 } from "react";

// packages/menu/src/utils/timeUtil.ts
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
__name(nextSlice, "nextSlice");

// packages/menu/src/hooks/useKeyRecords.ts
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = /* @__PURE__ */ __name((keyPath) => keyPath.join(PATH_SPLIT), "getPathStr");
var getPathKeys = /* @__PURE__ */ __name((keyPathStr) => keyPathStr.split(PATH_SPLIT), "getPathKeys");
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  const [, internalForceUpdate] = React187.useState({});
  const key2pathRef = useRef67(/* @__PURE__ */ new Map());
  const path2keyRef = useRef67(/* @__PURE__ */ new Map());
  const [overflowKeys, setOverflowKeys] = React187.useState([]);
  const updateRef = useRef67(0);
  const destroyRef = useRef67(false);
  const forceUpdate = /* @__PURE__ */ __name(() => {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  }, "forceUpdate");
  const registerPath = useCallback19((key, keyPath) => {
    if (true) {
      warning_default(
        !key2pathRef.current.has(key),
        `Duplicated key '${key}' used in Menu by path [${keyPath.join(" > ")}]`
      );
    }
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    const id = updateRef.current;
    nextSlice(() => {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  const unregisterPath = useCallback19((key, keyPath) => {
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  const refreshOverflowKeys = useCallback19((keys2) => {
    setOverflowKeys(keys2);
  }, []);
  const getKeyPath = useCallback19(
    (eventKey, includeOverflow) => {
      const fullPath = key2pathRef.current.get(eventKey) || "";
      const keys2 = getPathKeys(fullPath);
      if (includeOverflow && overflowKeys.includes(keys2[0])) {
        keys2.unshift(OVERFLOW_KEY);
      }
      return keys2;
    },
    [overflowKeys]
  );
  const isSubPathKey = useCallback19(
    (pathKeys, eventKey) => pathKeys.some((pathKey2) => {
      const pathKeyList = getKeyPath(pathKey2, true);
      return pathKeyList.includes(eventKey);
    }),
    [getKeyPath]
  );
  const getKeys = /* @__PURE__ */ __name(() => {
    const keys2 = [...key2pathRef.current.keys()];
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  }, "getKeys");
  const getSubPathKeys = useCallback19((key) => {
    const connectedPath = `${key2pathRef.current.get(key)}${PATH_SPLIT}`;
    const pathKeys = /* @__PURE__ */ new Set();
    [...path2keyRef.current.keys()].forEach((pathKey2) => {
      if (pathKey2.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey2));
      }
    });
    return pathKeys;
  }, []);
  React187.useEffect(
    () => () => {
      destroyRef.current = true;
    },
    []
  );
  return {
    // Register
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    // Util
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
__name(useKeyRecords, "useKeyRecords");

// packages/menu/src/hooks/useMemoCallback.ts
import * as React188 from "react";
function useMemoCallback(func) {
  const funRef = React188.useRef(func);
  funRef.current = func;
  const callback = React188.useCallback(
    (...args) => funRef.current?.(...args),
    []
  );
  return func ? callback : void 0;
}
__name(useMemoCallback, "useMemoCallback");

// packages/menu/src/hooks/useUUID.ts
import * as React189 from "react";
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
  const [uuid9, setUUID] = useMergedState(id, {
    value: id
  });
  React189.useEffect(() => {
    internalId += 1;
    const newId = false ? "test" : `${uniquePrefix}-${internalId}`;
    setUUID(`rc-menu-uuid-${newId}`);
  }, []);
  return uuid9;
}
__name(useUUID, "useUUID");

// packages/menu/src/MenuItem.tsx
var import_classnames60 = __toESM(require_classnames());
init_warning();
import * as React193 from "react";

// packages/menu/src/hooks/useActive.ts
import * as React190 from "react";
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  const {
    // Active
    activeKey,
    onActive,
    onInactive
  } = React190.useContext(MenuContext);
  const ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = (domEvent) => {
      onMouseEnter?.({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = (domEvent) => {
      onMouseLeave?.({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
__name(useActive, "useActive");

// packages/menu/src/hooks/useDirectionStyle.ts
import * as React191 from "react";
function useDirectionStyle(level) {
  const { mode, rtl, inlineIndent } = React191.useContext(MenuContext);
  if (mode !== "inline") {
    return null;
  }
  const len = level;
  return rtl ? { paddingRight: len * inlineIndent } : { paddingLeft: len * inlineIndent };
}
__name(useDirectionStyle, "useDirectionStyle");

// packages/menu/src/Icon.tsx
import * as React192 from "react";
function Icon({ icon, props, children }) {
  let iconNode;
  if (icon === null || icon === false) {
    return null;
  }
  if (typeof icon === "function") {
    iconNode = React192.createElement(icon, {
      ...props
    });
  } else if (typeof icon !== "boolean") {
    iconNode = icon;
  }
  return iconNode || children || null;
}
__name(Icon, "Icon");

// packages/menu/src/utils/warnUtil.ts
init_warning();
function warnItemProp({
  item,
  ...restInfo
}) {
  Object.defineProperty(restInfo, "item", {
    get: () => {
      warning_default(
        false,
        "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."
      );
      return item;
    }
  });
  return restInfo;
}
__name(warnItemProp, "warnItemProp");

// packages/menu/src/MenuItem.tsx
var LegacyMenuItem = class extends React193.Component {
  static {
    __name(this, "LegacyMenuItem");
  }
  render() {
    const { title, attribute, elementRef, ...restProps } = this.props;
    const passedProps = omit(restProps, [
      "eventKey",
      "popupClassName",
      "popupOffset",
      "onTitleClick"
    ]);
    warning_default(
      !attribute,
      "`attribute` of Menu.Item is deprecated. Please pass attribute directly."
    );
    return /* @__PURE__ */ React193.createElement(
      es_default3.Item,
      {
        ...attribute,
        title: typeof title === "string" ? title : void 0,
        ...passedProps,
        ref: elementRef
      }
    );
  }
};
var InternalMenuItem = React193.forwardRef(
  (props, ref) => {
    const {
      style: style2,
      className,
      eventKey,
      warnKey,
      disabled,
      itemIcon,
      children,
      // Aria
      role,
      // Active
      onMouseEnter,
      onMouseLeave,
      onClick,
      onKeyDown: onKeyDown2,
      onFocus,
      ...restProps
    } = props;
    const domDataId = useMenuId(eventKey);
    const {
      prefixCls,
      onItemClick,
      disabled: contextDisabled,
      overflowDisabled,
      // Icon
      itemIcon: contextItemIcon,
      // Select
      selectedKeys,
      // Active
      onActive
    } = React193.useContext(MenuContext);
    const { _internalRenderMenuItem } = React193.useContext(PrivateContext_default);
    const itemCls = `${prefixCls}-item`;
    const legacyMenuItemRef = React193.useRef();
    const elementRef = React193.useRef();
    const mergedDisabled = contextDisabled || disabled;
    const mergedEleRef = useComposeRef(ref, elementRef);
    const connectedKeys = useFullPath(eventKey);
    if (warnKey) {
      warning_default(false, "MenuItem should not leave undefined `key`.");
    }
    const getEventInfo = /* @__PURE__ */ __name((e3) => {
      return {
        key: eventKey,
        // Note: For legacy code is reversed which not like other antd component
        keyPath: [...connectedKeys].reverse(),
        item: legacyMenuItemRef.current,
        domEvent: e3
      };
    }, "getEventInfo");
    const mergedItemIcon = itemIcon || contextItemIcon;
    const { active, ...activeProps } = useActive(
      eventKey,
      mergedDisabled,
      onMouseEnter,
      onMouseLeave
    );
    const selected = selectedKeys.includes(eventKey);
    const directionStyle = useDirectionStyle(connectedKeys.length);
    const onInternalClick = /* @__PURE__ */ __name((e3) => {
      if (mergedDisabled) {
        return;
      }
      const info = getEventInfo(e3);
      onClick?.(warnItemProp(info));
      onItemClick(info);
    }, "onInternalClick");
    const onInternalKeyDown = /* @__PURE__ */ __name((e3) => {
      onKeyDown2?.(e3);
      if (e3.which === KeyCode_default.ENTER) {
        const info = getEventInfo(e3);
        onClick?.(warnItemProp(info));
        onItemClick(info);
      }
    }, "onInternalKeyDown");
    const onInternalFocus = /* @__PURE__ */ __name((e3) => {
      onActive(eventKey);
      onFocus?.(e3);
    }, "onInternalFocus");
    const optionRoleProps = {};
    if (props.role === "option") {
      optionRoleProps["aria-selected"] = selected;
    }
    let renderNode = /* @__PURE__ */ React193.createElement(
      LegacyMenuItem,
      {
        ref: legacyMenuItemRef,
        elementRef: mergedEleRef,
        role: role === null ? "none" : role || "menuitem",
        tabIndex: disabled ? null : -1,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
        ...restProps,
        ...activeProps,
        ...optionRoleProps,
        component: "li",
        "aria-disabled": disabled,
        style: {
          ...directionStyle,
          ...style2
        },
        className: (0, import_classnames60.default)(
          itemCls,
          {
            [`${itemCls}-active`]: active,
            [`${itemCls}-selected`]: selected,
            [`${itemCls}-disabled`]: mergedDisabled
          },
          className
        ),
        onClick: onInternalClick,
        onKeyDown: onInternalKeyDown,
        onFocus: onInternalFocus
      },
      children,
      /* @__PURE__ */ React193.createElement(
        Icon,
        {
          props: {
            ...props,
            isSelected: selected
          },
          icon: mergedItemIcon
        }
      )
    );
    if (_internalRenderMenuItem) {
      renderNode = _internalRenderMenuItem(renderNode, props, { selected });
    }
    return renderNode;
  }
);
function MenuItem(props, ref) {
  const { eventKey } = props;
  const measure = useMeasure();
  const connectedKeyPath = useFullPath(eventKey);
  React193.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React193.createElement(InternalMenuItem, { ...props, ref });
}
__name(MenuItem, "MenuItem");
var MenuItem_default = React193.forwardRef(MenuItem);

// packages/menu/src/SubMenu/index.tsx
var import_classnames63 = __toESM(require_classnames());
import * as React198 from "react";
init_warning();

// packages/menu/src/SubMenu/SubMenuList.tsx
var import_classnames61 = __toESM(require_classnames());
import * as React194 from "react";
var InternalSubMenuList = /* @__PURE__ */ __name(({ className, children, ...restProps }, ref) => {
  const { prefixCls, mode, rtl } = React194.useContext(MenuContext);
  return /* @__PURE__ */ React194.createElement(
    "ul",
    {
      className: (0, import_classnames61.default)(
        prefixCls,
        rtl && `${prefixCls}-rtl`,
        `${prefixCls}-sub`,
        `${prefixCls}-${mode === "inline" ? "inline" : "vertical"}`,
        className
      ),
      role: "menu",
      ...restProps,
      "data-menu-list": true,
      ref
    },
    children
  );
}, "InternalSubMenuList");
var SubMenuList = React194.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
var SubMenuList_default = SubMenuList;

// packages/menu/src/utils/commonUtil.ts
import * as React195 from "react";
function parseChildren(children, keyPath) {
  return toArray(children).map((child, index3) => {
    if (React195.isValidElement(child)) {
      const { key } = child;
      let eventKey = child.props?.eventKey ?? key;
      const emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = `tmp_key-${[...keyPath, index3].join("-")}`;
      }
      const cloneProps = {
        key: eventKey,
        eventKey
      };
      if (emptyKey) {
        cloneProps.warnKey = true;
      }
      return React195.cloneElement(child, cloneProps);
    }
    return child;
  });
}
__name(parseChildren, "parseChildren");

// packages/menu/src/SubMenu/PopupTrigger.tsx
import * as React196 from "react";
var import_classnames62 = __toESM(require_classnames());

// packages/menu/src/placements.ts
var autoAdjustOverflow2 = {
  adjustX: 1,
  adjustY: 1
};
var placements3 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};

// packages/menu/src/utils/motionUtil.ts
function getMotion4(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
__name(getMotion4, "getMotion");

// packages/menu/src/SubMenu/PopupTrigger.tsx
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger({
  prefixCls,
  visible,
  children,
  popup,
  popupStyle,
  popupClassName,
  popupOffset,
  disabled,
  mode,
  onVisibleChange
}) {
  const {
    getPopupContainer,
    rtl,
    subMenuOpenDelay,
    subMenuCloseDelay,
    builtinPlacements,
    triggerSubMenuAction,
    forceSubMenuRender,
    rootClassName,
    // Motion
    motion: motion2,
    defaultMotions
  } = React196.useContext(MenuContext);
  const [innerVisible, setInnerVisible] = React196.useState(false);
  const placement = rtl ? { ...placementsRtl, ...builtinPlacements } : { ...placements3, ...builtinPlacements };
  const popupPlacement = popupPlacementMap[mode];
  const targetMotion = getMotion4(mode, motion2, defaultMotions);
  const targetMotionRef = React196.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  const mergedMotion = {
    ...targetMotionRef.current,
    leavedClassName: `${prefixCls}-hidden`,
    removeOnLeave: false,
    motionAppear: true
  };
  const visibleRef = React196.useRef();
  React196.useEffect(() => {
    visibleRef.current = raf_default(() => {
      setInnerVisible(visible);
    });
    return () => {
      raf_default.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ React196.createElement(
    src_default5,
    {
      prefixCls,
      popupClassName: (0, import_classnames62.default)(
        `${prefixCls}-popup`,
        {
          [`${prefixCls}-rtl`]: rtl
        },
        popupClassName,
        rootClassName
      ),
      stretch: mode === "horizontal" ? "minWidth" : null,
      getPopupContainer,
      builtinPlacements: placement,
      popupPlacement,
      popupVisible: innerVisible,
      popup,
      popupStyle,
      popupAlign: popupOffset && { offset: popupOffset },
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: onVisibleChange,
      forceRender: forceSubMenuRender,
      popupMotion: mergedMotion,
      fresh: true
    },
    children
  );
}
__name(PopupTrigger, "PopupTrigger");

// packages/menu/src/SubMenu/InlineSubMenuList.tsx
import * as React197 from "react";
function InlineSubMenuList({
  id,
  open: open3,
  keyPath,
  children
}) {
  const fixedMode = "inline";
  const {
    prefixCls,
    forceSubMenuRender,
    motion: motion2,
    defaultMotions,
    mode
  } = React197.useContext(MenuContext);
  const sameModeRef = React197.useRef(false);
  sameModeRef.current = mode === fixedMode;
  const [destroy3, setDestroy] = React197.useState(!sameModeRef.current);
  const mergedOpen = sameModeRef.current ? open3 : false;
  React197.useEffect(() => {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  const mergedMotion = { ...getMotion4(fixedMode, motion2, defaultMotions) };
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  const originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = (newVisible) => {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged?.(newVisible);
  };
  if (destroy3) {
    return null;
  }
  return /* @__PURE__ */ React197.createElement(InheritableContextProvider, { mode: fixedMode, locked: !sameModeRef.current }, /* @__PURE__ */ React197.createElement(
    src_default2,
    {
      visible: mergedOpen,
      ...mergedMotion,
      forceRender: forceSubMenuRender,
      removeOnLeave: false,
      leavedClassName: `${prefixCls}-hidden`
    },
    ({ className: motionClassName, style: motionStyle }) => {
      return /* @__PURE__ */ React197.createElement(
        SubMenuList_default,
        {
          id,
          className: motionClassName,
          style: motionStyle
        },
        children
      );
    }
  ));
}
__name(InlineSubMenuList, "InlineSubMenuList");

// packages/menu/src/SubMenu/index.tsx
var InternalSubMenu = React198.forwardRef(
  (props, ref) => {
    const {
      style: style2,
      className,
      title,
      eventKey,
      warnKey,
      disabled,
      internalPopupClose,
      children,
      // Icons
      itemIcon,
      expandIcon,
      // Popup
      popupClassName,
      popupOffset,
      popupStyle,
      // Events
      onClick,
      onMouseEnter,
      onMouseLeave,
      onTitleClick,
      onTitleMouseEnter,
      onTitleMouseLeave,
      ...restProps
    } = props;
    const domDataId = useMenuId(eventKey);
    const {
      prefixCls,
      mode,
      openKeys,
      // Disabled
      disabled: contextDisabled,
      overflowDisabled,
      // ActiveKey
      activeKey,
      // SelectKey
      selectedKeys,
      // Icon
      itemIcon: contextItemIcon,
      expandIcon: contextExpandIcon,
      // Events
      onItemClick,
      onOpenChange,
      onActive
    } = React198.useContext(MenuContext);
    const { _internalRenderSubMenuItem } = React198.useContext(PrivateContext_default);
    const { isSubPathKey } = React198.useContext(PathUserContext);
    const connectedPath = useFullPath();
    const subMenuPrefixCls = `${prefixCls}-submenu`;
    const mergedDisabled = contextDisabled || disabled;
    const elementRef = React198.useRef();
    const popupRef = React198.useRef();
    if (warnKey) {
      warning_default(false, "SubMenu should not leave undefined `key`.");
    }
    const mergedItemIcon = itemIcon ?? contextItemIcon;
    const mergedExpandIcon = expandIcon ?? contextExpandIcon;
    const originOpen = openKeys.includes(eventKey);
    const open3 = !overflowDisabled && originOpen;
    const childrenSelected = isSubPathKey(selectedKeys, eventKey);
    const { active, ...activeProps } = useActive(
      eventKey,
      mergedDisabled,
      onTitleMouseEnter,
      onTitleMouseLeave
    );
    const [childrenActive, setChildrenActive] = React198.useState(false);
    const triggerChildrenActive = /* @__PURE__ */ __name((newActive) => {
      if (!mergedDisabled) {
        setChildrenActive(newActive);
      }
    }, "triggerChildrenActive");
    const onInternalMouseEnter = /* @__PURE__ */ __name((domEvent) => {
      triggerChildrenActive(true);
      onMouseEnter?.({
        key: eventKey,
        domEvent
      });
    }, "onInternalMouseEnter");
    const onInternalMouseLeave = /* @__PURE__ */ __name((domEvent) => {
      triggerChildrenActive(false);
      onMouseLeave?.({
        key: eventKey,
        domEvent
      });
    }, "onInternalMouseLeave");
    const mergedActive = React198.useMemo(() => {
      if (active) {
        return active;
      }
      if (mode !== "inline") {
        return childrenActive || isSubPathKey([activeKey], eventKey);
      }
      return false;
    }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
    const directionStyle = useDirectionStyle(connectedPath.length);
    const onInternalTitleClick = /* @__PURE__ */ __name((e3) => {
      if (mergedDisabled) {
        return;
      }
      onTitleClick?.({
        key: eventKey,
        domEvent: e3
      });
      if (mode === "inline") {
        onOpenChange(eventKey, !originOpen);
      }
    }, "onInternalTitleClick");
    const onMergedItemClick = useMemoCallback((info) => {
      onClick?.(warnItemProp(info));
      onItemClick(info);
    });
    const onPopupVisibleChange = /* @__PURE__ */ __name((newVisible) => {
      if (mode !== "inline") {
        onOpenChange(eventKey, newVisible);
      }
    }, "onPopupVisibleChange");
    const onInternalFocus = /* @__PURE__ */ __name(() => {
      onActive(eventKey);
    }, "onInternalFocus");
    const popupId = domDataId && `${domDataId}-popup`;
    let titleNode = /* @__PURE__ */ React198.createElement(
      "div",
      {
        role: "menuitem",
        style: directionStyle,
        className: `${subMenuPrefixCls}-title`,
        tabIndex: mergedDisabled ? null : -1,
        ref: elementRef,
        title: typeof title === "string" ? title : null,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
        "aria-expanded": open3,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled,
        onClick: onInternalTitleClick,
        onFocus: onInternalFocus,
        ...activeProps
      },
      title,
      /* @__PURE__ */ React198.createElement(
        Icon,
        {
          icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
          props: {
            ...props,
            isOpen: open3,
            // [Legacy] Not sure why need this mark
            isSubMenu: true
          }
        },
        /* @__PURE__ */ React198.createElement("i", { className: `${subMenuPrefixCls}-arrow` })
      )
    );
    const triggerModeRef = React198.useRef(mode);
    if (mode !== "inline" && connectedPath.length > 1) {
      triggerModeRef.current = "vertical";
    } else {
      triggerModeRef.current = mode;
    }
    if (!overflowDisabled) {
      const triggerMode = triggerModeRef.current;
      titleNode = /* @__PURE__ */ React198.createElement(
        PopupTrigger,
        {
          mode: triggerMode,
          prefixCls: subMenuPrefixCls,
          visible: !internalPopupClose && open3 && mode !== "inline",
          popupClassName,
          popupOffset,
          popupStyle,
          popup: /* @__PURE__ */ React198.createElement(
            InheritableContextProvider,
            {
              mode: triggerMode === "horizontal" ? "vertical" : triggerMode
            },
            /* @__PURE__ */ React198.createElement(SubMenuList_default, { id: popupId, ref: popupRef }, children)
          ),
          disabled: mergedDisabled,
          onVisibleChange: onPopupVisibleChange
        },
        titleNode
      );
    }
    let listNode = /* @__PURE__ */ React198.createElement(
      es_default3.Item,
      {
        ref,
        role: "none",
        ...restProps,
        component: "li",
        style: style2,
        className: (0, import_classnames63.default)(
          subMenuPrefixCls,
          `${subMenuPrefixCls}-${mode}`,
          className,
          {
            [`${subMenuPrefixCls}-open`]: open3,
            [`${subMenuPrefixCls}-active`]: mergedActive,
            [`${subMenuPrefixCls}-selected`]: childrenSelected,
            [`${subMenuPrefixCls}-disabled`]: mergedDisabled
          }
        ),
        onMouseEnter: onInternalMouseEnter,
        onMouseLeave: onInternalMouseLeave
      },
      titleNode,
      !overflowDisabled && /* @__PURE__ */ React198.createElement(InlineSubMenuList, { id: popupId, open: open3, keyPath: connectedPath }, children)
    );
    if (_internalRenderSubMenuItem) {
      listNode = _internalRenderSubMenuItem(listNode, props, {
        selected: childrenSelected,
        active: mergedActive,
        open: open3,
        disabled: mergedDisabled
      });
    }
    return /* @__PURE__ */ React198.createElement(
      InheritableContextProvider,
      {
        onItemClick: onMergedItemClick,
        mode: mode === "horizontal" ? "vertical" : mode,
        itemIcon: mergedItemIcon,
        expandIcon: mergedExpandIcon
      },
      listNode
    );
  }
);
var SubMenu = React198.forwardRef((props, ref) => {
  const { eventKey, children } = props;
  const connectedKeyPath = useFullPath(eventKey);
  const childList = parseChildren(
    children,
    connectedKeyPath
  );
  const measure = useMeasure();
  React198.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  let renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ React198.createElement(InternalSubMenu, { ref, ...props }, childList);
  }
  return /* @__PURE__ */ React198.createElement(PathTrackerContext.Provider, { value: connectedKeyPath }, renderNode);
});
if (true) {
  SubMenu.displayName = "SubMenu";
}
var SubMenu_default = SubMenu;

// packages/menu/src/utils/nodeUtil.tsx
import * as React201 from "react";

// packages/menu/src/MenuItemGroup.tsx
var import_classnames64 = __toESM(require_classnames());
import * as React199 from "react";
var InternalMenuItemGroup = React199.forwardRef((props, ref) => {
  const { className, title, eventKey, children, ...restProps } = props;
  const { prefixCls } = React199.useContext(MenuContext);
  const groupPrefixCls = `${prefixCls}-item-group`;
  return /* @__PURE__ */ React199.createElement(
    "li",
    {
      ref,
      role: "presentation",
      ...restProps,
      onClick: (e3) => e3.stopPropagation(),
      className: (0, import_classnames64.default)(groupPrefixCls, className)
    },
    /* @__PURE__ */ React199.createElement(
      "div",
      {
        role: "presentation",
        className: `${groupPrefixCls}-title`,
        title: typeof title === "string" ? title : void 0
      },
      title
    ),
    /* @__PURE__ */ React199.createElement("ul", { role: "group", className: `${groupPrefixCls}-list` }, children)
  );
});
var MenuItemGroup = React199.forwardRef(
  (props, ref) => {
    const { eventKey, children } = props;
    const connectedKeyPath = useFullPath(eventKey);
    const childList = parseChildren(
      children,
      connectedKeyPath
    );
    const measure = useMeasure();
    if (measure) {
      return childList;
    }
    return /* @__PURE__ */ React199.createElement(InternalMenuItemGroup, { ref, ...omit(props, ["warnKey"]) }, childList);
  }
);
if (true) {
  MenuItemGroup.displayName = "MenuItemGroup";
}
var MenuItemGroup_default = MenuItemGroup;

// packages/menu/src/Divider.tsx
var import_classnames65 = __toESM(require_classnames());
import * as React200 from "react";
function Divider({ className, style: style2 }) {
  const { prefixCls } = React200.useContext(MenuContext);
  const measure = useMeasure();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ React200.createElement(
    "li",
    {
      role: "separator",
      className: (0, import_classnames65.default)(`${prefixCls}-item-divider`, className),
      style: style2
    }
  );
}
__name(Divider, "Divider");

// packages/menu/src/utils/nodeUtil.tsx
function convertItemsToNodes(list) {
  return (list || []).map((opt, index3) => {
    if (opt && typeof opt === "object") {
      const { label, children, key, type: type5, ...restProps } = opt;
      const mergedKey = key ?? `tmp-${index3}`;
      if (children || type5 === "group") {
        if (type5 === "group") {
          return /* @__PURE__ */ React201.createElement(MenuItemGroup_default, { key: mergedKey, ...restProps, title: label }, convertItemsToNodes(children));
        }
        return /* @__PURE__ */ React201.createElement(SubMenu_default, { key: mergedKey, ...restProps, title: label }, convertItemsToNodes(children));
      }
      if (type5 === "divider") {
        return /* @__PURE__ */ React201.createElement(Divider, { key: mergedKey, ...restProps });
      }
      return /* @__PURE__ */ React201.createElement(MenuItem_default, { key: mergedKey, ...restProps }, label);
    }
    return null;
  }).filter((opt) => opt);
}
__name(convertItemsToNodes, "convertItemsToNodes");
function parseItems(children, items, keyPath) {
  let childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes(items);
  }
  return parseChildren(childNodes, keyPath);
}
__name(parseItems, "parseItems");

// packages/menu/src/Menu.tsx
var EMPTY_LIST3 = [];
var Menu = React202.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-menu",
    rootClassName,
    style: style2,
    className,
    tabIndex = 0,
    items,
    children,
    direction,
    id,
    // Mode
    mode = "vertical",
    inlineCollapsed,
    // Disabled
    disabled,
    disabledOverflow,
    // Open
    subMenuOpenDelay = 0.1,
    subMenuCloseDelay = 0.1,
    forceSubMenuRender,
    defaultOpenKeys,
    openKeys,
    // Active
    activeKey,
    defaultActiveFirst,
    // Selection
    selectable = true,
    multiple = false,
    defaultSelectedKeys,
    selectedKeys,
    onSelect,
    onDeselect,
    // Level
    inlineIndent = 24,
    // Motion
    motion: motion2,
    defaultMotions,
    // Popup
    triggerSubMenuAction = "hover",
    builtinPlacements,
    // Icon
    itemIcon,
    expandIcon,
    overflowedIndicator = "...",
    overflowedIndicatorPopupClassName,
    // Function
    getPopupContainer,
    // Events
    onClick,
    onOpenChange,
    onKeyDown: onKeyDown2,
    // Deprecated
    openAnimation,
    openTransitionName,
    // Internal
    _internalRenderMenuItem,
    _internalRenderSubMenuItem,
    ...restProps
  } = props;
  const childList = React202.useMemo(
    () => parseItems(children, items, EMPTY_LIST3),
    [children, items]
  );
  const [mounted, setMounted] = React202.useState(false);
  const containerRef = React202.useRef();
  const uuid9 = useUUID(id);
  const isRtl = direction === "rtl";
  if (true) {
    warning_default(
      !openAnimation && !openTransitionName,
      "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead."
    );
  }
  const [mergedOpenKeys, setMergedOpenKeys] = useMergedState(defaultOpenKeys, {
    value: openKeys,
    postState: (keys2) => keys2 || EMPTY_LIST3
  });
  const triggerOpenKeys = /* @__PURE__ */ __name((keys2, forceFlush = false) => {
    function doUpdate() {
      setMergedOpenKeys(keys2);
      onOpenChange?.(keys2);
    }
    __name(doUpdate, "doUpdate");
    if (forceFlush) {
      flushSync2(doUpdate);
    } else {
      doUpdate();
    }
  }, "triggerOpenKeys");
  const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = React202.useState(
    mergedOpenKeys
  );
  const mountRef = React202.useRef(false);
  const [mergedMode, mergedInlineCollapsed] = React202.useMemo(() => {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]);
  const isInlineMode = mergedMode === "inline";
  const [internalMode, setInternalMode] = React202.useState(mergedMode);
  const [internalInlineCollapsed, setInternalInlineCollapsed] = React202.useState(
    mergedInlineCollapsed
  );
  React202.useEffect(() => {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST3);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  const [lastVisibleIndex, setLastVisibleIndex] = React202.useState(0);
  const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React202.useEffect(() => {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  React202.useEffect(() => {
    mountRef.current = true;
    return () => {
      mountRef.current = false;
    };
  }, []);
  const {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  } = useKeyRecords();
  const registerPathContext = React202.useMemo(
    () => ({ registerPath, unregisterPath }),
    [registerPath, unregisterPath]
  );
  const pathUserContext = React202.useMemo(() => ({ isSubPathKey }), [
    isSubPathKey
  ]);
  React202.useEffect(() => {
    refreshOverflowKeys(
      allVisible ? EMPTY_LIST3 : childList.slice(lastVisibleIndex + 1).map((child) => child.key)
    );
  }, [lastVisibleIndex, allVisible]);
  const [mergedActiveKey, setMergedActiveKey] = useMergedState(
    activeKey || defaultActiveFirst && childList[0]?.key,
    {
      value: activeKey
    }
  );
  const onActive = useMemoCallback((key) => {
    setMergedActiveKey(key);
  });
  const onInactive = useMemoCallback(() => {
    setMergedActiveKey(void 0);
  });
  useImperativeHandle16(ref, () => {
    return {
      list: containerRef.current,
      focus: (options) => {
        const keys2 = getKeys();
        const { elements, key2element, element2key } = refreshElements(
          keys2,
          uuid9
        );
        const focusableElements = getFocusableElements(
          containerRef.current,
          elements
        );
        const shouldFocusKey = mergedActiveKey ?? (focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find((node2) => !node2.props.disabled)?.key);
        const elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          elementToFocus?.focus?.(options);
        }
      }
    };
  });
  const [mergedSelectKeys, setMergedSelectKeys] = useMergedState(
    defaultSelectedKeys || [],
    {
      value: selectedKeys,
      // Legacy convert key to array
      postState: (keys2) => {
        if (Array.isArray(keys2)) {
          return keys2;
        }
        if (keys2 === null || keys2 === void 0) {
          return EMPTY_LIST3;
        }
        return [keys2];
      }
    }
  );
  const triggerSelection = /* @__PURE__ */ __name((info) => {
    if (selectable) {
      const { key: targetKey } = info;
      const exist = mergedSelectKeys.includes(targetKey);
      let newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter((key) => key !== targetKey);
        } else {
          newSelectKeys = [...mergedSelectKeys, targetKey];
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      const selectInfo = {
        ...info,
        selectedKeys: newSelectKeys
      };
      if (exist) {
        onDeselect?.(selectInfo);
      } else {
        onSelect?.(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST3);
    }
  }, "triggerSelection");
  const onInternalClick = useMemoCallback((info) => {
    onClick?.(warnItemProp(info));
    triggerSelection(info);
  });
  const onInternalOpenChange = useMemoCallback((key, open3) => {
    let newOpenKeys = mergedOpenKeys.filter((k) => k !== key);
    if (open3) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      const subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter((k) => !subPathKeys.has(k));
    }
    if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  const triggerAccessibilityOpen = /* @__PURE__ */ __name((key, open3) => {
    const nextOpen = open3 ?? !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  }, "triggerAccessibilityOpen");
  const onInternalKeyDown = useAccessibility2(
    internalMode,
    mergedActiveKey,
    isRtl,
    uuid9,
    containerRef,
    getKeys,
    getKeyPath,
    setMergedActiveKey,
    triggerAccessibilityOpen,
    onKeyDown2
  );
  React202.useEffect(() => {
    setMounted(true);
  }, []);
  const privateContext = React202.useMemo(
    () => ({
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    }),
    [_internalRenderMenuItem, _internalRenderSubMenuItem]
  );
  const wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
    // Need wrap for overflow dropdown that do not response for open
    childList.map((child, index3) => (
      // Always wrap provider to avoid sub node re-mount
      /* @__PURE__ */ React202.createElement(
        InheritableContextProvider,
        {
          key: child.key,
          overflowDisabled: index3 > lastVisibleIndex
        },
        child
      )
    ))
  );
  const container = /* @__PURE__ */ React202.createElement(
    es_default3,
    {
      id,
      ref: containerRef,
      prefixCls: `${prefixCls}-overflow`,
      component: "ul",
      itemComponent: MenuItem_default,
      className: (0, import_classnames66.default)(
        prefixCls,
        `${prefixCls}-root`,
        `${prefixCls}-${internalMode}`,
        className,
        {
          [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,
          [`${prefixCls}-rtl`]: isRtl
        },
        rootClassName
      ),
      dir: direction,
      style: style2,
      role: "menu",
      tabIndex,
      data: wrappedChildList,
      renderRawItem: (node2) => node2,
      renderRawRest: (omitItems) => {
        const len = omitItems.length;
        const originOmitItems = len ? childList.slice(-len) : null;
        return /* @__PURE__ */ React202.createElement(
          SubMenu_default,
          {
            eventKey: OVERFLOW_KEY,
            title: overflowedIndicator,
            disabled: allVisible,
            internalPopupClose: len === 0,
            popupClassName: overflowedIndicatorPopupClassName
          },
          originOmitItems
        );
      },
      maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default3.INVALIDATE : es_default3.RESPONSIVE,
      ssr: "full",
      "data-menu-list": true,
      onVisibleChange: (newLastIndex) => {
        setLastVisibleIndex(newLastIndex);
      },
      onKeyDown: onInternalKeyDown,
      ...restProps
    }
  );
  return /* @__PURE__ */ React202.createElement(PrivateContext_default.Provider, { value: privateContext }, /* @__PURE__ */ React202.createElement(IdContext.Provider, { value: uuid9 }, /* @__PURE__ */ React202.createElement(
    InheritableContextProvider,
    {
      prefixCls,
      rootClassName,
      mode: internalMode,
      openKeys: mergedOpenKeys,
      rtl: isRtl,
      disabled,
      motion: mounted ? motion2 : null,
      defaultMotions: mounted ? defaultMotions : null,
      activeKey: mergedActiveKey,
      onActive,
      onInactive,
      selectedKeys: mergedSelectKeys,
      inlineIndent,
      subMenuOpenDelay,
      subMenuCloseDelay,
      forceSubMenuRender,
      builtinPlacements,
      triggerSubMenuAction,
      getPopupContainer,
      itemIcon,
      expandIcon,
      onItemClick: onInternalClick,
      onOpenChange: onInternalOpenChange
    },
    /* @__PURE__ */ React202.createElement(PathUserContext.Provider, { value: pathUserContext }, container),
    /* @__PURE__ */ React202.createElement("div", { style: { display: "none" }, "aria-hidden": true }, /* @__PURE__ */ React202.createElement(PathRegisterContext.Provider, { value: registerPathContext }, childList))
  )));
});
var Menu_default = Menu;

// packages/menu/src/index.ts
var ExportMenu = Menu_default;
ExportMenu.Item = MenuItem_default;
ExportMenu.SubMenu = SubMenu_default;
ExportMenu.ItemGroup = MenuItemGroup_default;
ExportMenu.Divider = Divider;
var src_default9 = ExportMenu;

// packages/ant-design/components/layout/Sider.tsx
var import_BarsOutlined = __toESM(require_BarsOutlined3());
var import_LeftOutlined = __toESM(require_LeftOutlined3());
var import_RightOutlined = __toESM(require_RightOutlined3());
var import_classnames67 = __toESM(require_classnames());
import * as React204 from "react";
import { useContext as useContext79, useEffect as useEffect56, useRef as useRef74, useState as useState52 } from "react";

// packages/ant-design/components/_util/isNumeric.ts
var isNumeric = /* @__PURE__ */ __name((value) => !isNaN(parseFloat(value)) && isFinite(value), "isNumeric");
var isNumeric_default = isNumeric;

// packages/ant-design/components/layout/context.ts
import * as React203 from "react";
var LayoutContext = React203.createContext({
  siderHook: {
    addSider: () => null,
    removeSider: () => null
  }
});

// packages/ant-design/components/layout/Sider.tsx
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
};
var SiderContext = React204.createContext({});
var generateId = /* @__PURE__ */ (() => {
  let i = 0;
  return (prefix = "") => {
    i += 1;
    return `${prefix}${i}`;
  };
})();
var Sider = React204.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    trigger,
    children,
    defaultCollapsed = false,
    theme = "dark",
    style: style2 = {},
    collapsible = false,
    reverseArrow = false,
    width = 200,
    collapsedWidth = 80,
    zeroWidthTriggerStyle,
    breakpoint,
    onCollapse,
    onBreakpoint,
    ...otherProps
  } = props;
  const { siderHook } = useContext79(LayoutContext);
  const [collapsed, setCollapsed] = useState52(
    "collapsed" in props ? props.collapsed : defaultCollapsed
  );
  const [below, setBelow] = useState52(false);
  useEffect56(() => {
    if ("collapsed" in props) {
      setCollapsed(props.collapsed);
    }
  }, [props.collapsed]);
  const handleSetCollapsed = /* @__PURE__ */ __name((value, type5) => {
    if (!("collapsed" in props)) {
      setCollapsed(value);
    }
    onCollapse?.(value, type5);
  }, "handleSetCollapsed");
  const responsiveHandlerRef = useRef74();
  responsiveHandlerRef.current = (mql) => {
    setBelow(mql.matches);
    onBreakpoint?.(mql.matches);
    if (collapsed !== mql.matches) {
      handleSetCollapsed(mql.matches, "responsive");
    }
  };
  useEffect56(() => {
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.current(mql2);
    }
    __name(responsiveHandler, "responsiveHandler");
    let mql;
    if (typeof window !== "undefined") {
      const { matchMedia } = window;
      if (matchMedia && breakpoint && breakpoint in dimensionMaxMap) {
        mql = matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
        try {
          mql.addEventListener("change", responsiveHandler);
        } catch (error) {
          mql.addListener(responsiveHandler);
        }
        responsiveHandler(mql);
      }
    }
    return () => {
      try {
        mql?.removeEventListener("change", responsiveHandler);
      } catch (error) {
        mql?.removeListener(responsiveHandler);
      }
    };
  }, [breakpoint]);
  useEffect56(() => {
    const uniqueId = generateId("ant-sider-");
    siderHook.addSider(uniqueId);
    return () => siderHook.removeSider(uniqueId);
  }, []);
  const toggle = /* @__PURE__ */ __name(() => {
    handleSetCollapsed(!collapsed, "clickTrigger");
  }, "toggle");
  const { getPrefixCls } = useContext79(ConfigContext);
  const renderSider = /* @__PURE__ */ __name(() => {
    const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
    const divProps = omit(otherProps, ["collapsed"]);
    const rawWidth = collapsed ? collapsedWidth : width;
    const siderWidth = isNumeric_default(rawWidth) ? `${rawWidth}px` : String(rawWidth);
    const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ React204.createElement(
      "span",
      {
        onClick: toggle,
        className: (0, import_classnames67.default)(
          `${prefixCls}-zero-width-trigger`,
          `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`
        ),
        style: zeroWidthTriggerStyle
      },
      trigger || /* @__PURE__ */ React204.createElement(import_BarsOutlined.default, null)
    ) : null;
    const iconObj = {
      expanded: reverseArrow ? /* @__PURE__ */ React204.createElement(import_RightOutlined.default, null) : /* @__PURE__ */ React204.createElement(import_LeftOutlined.default, null),
      collapsed: reverseArrow ? /* @__PURE__ */ React204.createElement(import_LeftOutlined.default, null) : /* @__PURE__ */ React204.createElement(import_RightOutlined.default, null)
    };
    const status = collapsed ? "collapsed" : "expanded";
    const defaultTrigger = iconObj[status];
    const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ React204.createElement("div", { className: `${prefixCls}-trigger`, onClick: toggle, style: { width: siderWidth } }, trigger || defaultTrigger) : null;
    const divStyle = {
      ...style2,
      flex: `0 0 ${siderWidth}`,
      maxWidth: siderWidth,
      // Fix width transition bug in IE11
      minWidth: siderWidth,
      // https://github.com/ant-design/ant-design/issues/6349
      width: siderWidth
    };
    const siderCls = (0, import_classnames67.default)(
      prefixCls,
      `${prefixCls}-${theme}`,
      {
        [`${prefixCls}-collapsed`]: !!collapsed,
        [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
        [`${prefixCls}-below`]: !!below,
        [`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
      },
      className
    );
    return /* @__PURE__ */ React204.createElement("aside", { className: siderCls, ...divProps, style: divStyle, ref }, /* @__PURE__ */ React204.createElement("div", { className: `${prefixCls}-children` }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null);
  }, "renderSider");
  const contextValue = React204.useMemo(() => ({ siderCollapsed: collapsed }), [collapsed]);
  return /* @__PURE__ */ React204.createElement(SiderContext.Provider, { value: contextValue }, renderSider());
});
if (true) {
  Sider.displayName = "Sider";
}
var Sider_default = Sider;

// packages/ant-design/components/menu/menu.tsx
var import_EllipsisOutlined = __toESM(require_EllipsisOutlined3());
var import_classnames71 = __toESM(require_classnames());
import * as React210 from "react";
import { forwardRef as forwardRef46 } from "react";

// packages/ant-design/components/menu/hooks/useItems.tsx
import * as React208 from "react";

// packages/ant-design/components/menu/MenuDivider.tsx
var import_classnames68 = __toESM(require_classnames());
import * as React205 from "react";
var MenuDivider = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, className, dashed, ...restProps } = props;
  const { getPrefixCls } = React205.useContext(ConfigContext);
  const prefixCls = getPrefixCls("menu", customizePrefixCls);
  const classString = (0, import_classnames68.default)(
    {
      [`${prefixCls}-item-divider-dashed`]: !!dashed
    },
    className
  );
  return /* @__PURE__ */ React205.createElement(Divider, { className: classString, ...restProps });
}, "MenuDivider");
var MenuDivider_default = MenuDivider;

// packages/ant-design/components/menu/MenuItem.tsx
var import_classnames69 = __toESM(require_classnames());
import * as React206 from "react";

// packages/ant-design/components/menu/MenuContext.tsx
import { createContext as createContext32 } from "react";
var MenuContext2 = createContext32({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false
});
var MenuContext_default = MenuContext2;

// packages/ant-design/components/menu/MenuItem.tsx
var MenuItem2 = /* @__PURE__ */ __name((props) => {
  const { className, children, icon, title, danger } = props;
  const {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed
  } = React206.useContext(MenuContext_default);
  const renderItemChildren = /* @__PURE__ */ __name((inlineCollapsed) => {
    const wrapNode = /* @__PURE__ */ React206.createElement("span", { className: `${prefixCls}-title-content` }, children);
    if (!icon || React206.isValidElement(children) && children.type === "span") {
      if (children && inlineCollapsed && firstLevel && typeof children === "string") {
        return /* @__PURE__ */ React206.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, children.charAt(0));
      }
    }
    return wrapNode;
  }, "renderItemChildren");
  const { siderCollapsed } = React206.useContext(SiderContext);
  let tooltipTitle = title;
  if (typeof title === "undefined") {
    tooltipTitle = firstLevel ? children : "";
  } else if (title === false) {
    tooltipTitle = "";
  }
  const tooltipProps = { title: tooltipTitle };
  if (!siderCollapsed && !isInlineCollapsed) {
    tooltipProps.title = null;
    tooltipProps.open = false;
  }
  const childrenLength = toArray(children).length;
  let returnNode = /* @__PURE__ */ React206.createElement(
    MenuItem_default,
    {
      ...omit(props, ["title", "icon", "danger"]),
      className: (0, import_classnames69.default)(
        {
          [`${prefixCls}-item-danger`]: danger,
          [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
        },
        className
      ),
      title: typeof title === "string" ? title : void 0
    },
    cloneElement3(icon, {
      className: (0, import_classnames69.default)(
        React206.isValidElement(icon) ? icon.props?.className : "",
        `${prefixCls}-item-icon`
      )
    }),
    renderItemChildren(isInlineCollapsed)
  );
  if (!disableMenuItemTitleTooltip) {
    returnNode = /* @__PURE__ */ React206.createElement(
      tooltip_default,
      {
        ...tooltipProps,
        placement: direction === "rtl" ? "left" : "right",
        overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
      },
      returnNode
    );
  }
  return returnNode;
}, "MenuItem");
var MenuItem_default2 = MenuItem2;

// packages/ant-design/components/menu/SubMenu.tsx
var import_classnames70 = __toESM(require_classnames());
import * as React207 from "react";
var SubMenu2 = /* @__PURE__ */ __name((props) => {
  const { popupClassName, icon, title, theme: customTheme } = props;
  const context = React207.useContext(MenuContext_default);
  const { prefixCls, inlineCollapsed, theme: contextTheme } = context;
  const parentPath = useFullPath();
  let titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ React207.createElement("div", { className: `${prefixCls}-inline-collapsed-noicon` }, title.charAt(0)) : /* @__PURE__ */ React207.createElement("span", { className: `${prefixCls}-title-content` }, title);
  } else {
    const titleIsSpan = React207.isValidElement(title) && title.type === "span";
    titleNode = /* @__PURE__ */ React207.createElement(React207.Fragment, null, cloneElement3(icon, {
      className: (0, import_classnames70.default)(
        React207.isValidElement(icon) ? icon.props?.className : "",
        `${prefixCls}-item-icon`
      )
    }), titleIsSpan ? title : /* @__PURE__ */ React207.createElement("span", { className: `${prefixCls}-title-content` }, title));
  }
  const contextValue = React207.useMemo(
    () => ({ ...context, firstLevel: false }),
    [context]
  );
  const [zIndex] = useZIndex("Menu");
  return /* @__PURE__ */ React207.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ React207.createElement(
    SubMenu_default,
    {
      ...omit(props, ["icon"]),
      title: titleNode,
      popupClassName: (0, import_classnames70.default)(
        prefixCls,
        popupClassName,
        `${prefixCls}-${customTheme || contextTheme}`
      ),
      popupStyle: {
        zIndex
      }
    }
  ));
}, "SubMenu");
var SubMenu_default2 = SubMenu2;

// packages/ant-design/components/menu/hooks/useItems.tsx
function convertItemsToNodes2(list) {
  return (list || []).map((opt, index3) => {
    if (opt && typeof opt === "object") {
      const { label, children, key, type: type5, ...restProps } = opt;
      const mergedKey = key ?? `tmp-${index3}`;
      if (children || type5 === "group") {
        if (type5 === "group") {
          return /* @__PURE__ */ React208.createElement(MenuItemGroup_default, { key: mergedKey, ...restProps, title: label }, convertItemsToNodes2(children));
        }
        return /* @__PURE__ */ React208.createElement(SubMenu_default2, { key: mergedKey, ...restProps, title: label }, convertItemsToNodes2(children));
      }
      if (type5 === "divider") {
        return /* @__PURE__ */ React208.createElement(MenuDivider_default, { key: mergedKey, ...restProps });
      }
      return /* @__PURE__ */ React208.createElement(MenuItem_default2, { key: mergedKey, ...restProps }, label);
    }
    return null;
  }).filter((opt) => opt);
}
__name(convertItemsToNodes2, "convertItemsToNodes");
function useItems(items) {
  return React208.useMemo(() => {
    if (!items) {
      return items;
    }
    return convertItemsToNodes2(items);
  }, [items]);
}
__name(useItems, "useItems");

// packages/ant-design/components/menu/OverrideContext.tsx
import * as React209 from "react";
var OverrideContext = React209.createContext(null);
var OverrideProvider = React209.forwardRef((props, ref) => {
  const { children, ...restProps } = props;
  const override = React209.useContext(OverrideContext);
  const context = React209.useMemo(
    () => ({ ...override, ...restProps }),
    [
      override,
      restProps.prefixCls,
      // restProps.expandIcon, Not mark as deps since this is a ReactNode
      restProps.mode,
      restProps.selectable,
      restProps.rootClassName
      // restProps.validator, Not mark as deps since this is a function
    ]
  );
  const canRef = supportNodeRef(children);
  const mergedRef = useComposeRef(ref, canRef ? children.ref : null);
  return /* @__PURE__ */ React209.createElement(OverrideContext.Provider, { value: context }, /* @__PURE__ */ React209.createElement(NoCompactStyle, null, canRef ? React209.cloneElement(children, { ref: mergedRef }) : children));
});
var OverrideContext_default = OverrideContext;

// packages/ant-design/components/menu/style/index.ts
init_public_api();

// packages/ant-design/components/menu/style/horizontal.ts
var getHorizontalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    horizontalLineHeight,
    colorSplit,
    lineWidth,
    lineType,
    itemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: horizontalLineHeight,
      border: 0,
      borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: itemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(
          ","
        )
      },
      // ===================== Sub Menu =====================
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, "getHorizontalStyle");
var horizontal_default = getHorizontalStyle;

// packages/ant-design/components/menu/style/rtl.ts
var getRTLStyle = /* @__PURE__ */ __name(({
  componentCls,
  menuArrowOffset,
  calc
}) => ({
  [`${componentCls}-rtl`]: {
    direction: "rtl"
  },
  [`${componentCls}-submenu-rtl`]: {
    transformOrigin: "100% 0"
  },
  // Vertical Arrow
  [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
    [`${componentCls}-submenu-arrow`]: {
      "&::before": {
        transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})`
      },
      "&::after": {
        transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})`
      }
    }
  }
}), "getRTLStyle");
var rtl_default = getRTLStyle;

// packages/ant-design/components/menu/style/theme.ts
var accessibilityFocus = /* @__PURE__ */ __name((token2) => ({
  ...genFocusOutline(token2)
}), "accessibilityFocus");
var getThemeStyle = /* @__PURE__ */ __name((token2, themeSuffix) => {
  const {
    componentCls,
    itemColor,
    itemSelectedColor,
    groupTitleColor,
    itemBg,
    subMenuItemBg,
    itemSelectedBg,
    activeBarHeight,
    activeBarWidth,
    activeBarBorderWidth,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    itemPaddingInline,
    motionDurationMid,
    itemHoverColor,
    lineType,
    colorSplit,
    // Disabled
    itemDisabledColor,
    // Danger
    dangerItemColor,
    dangerItemHoverColor,
    dangerItemSelectedColor,
    dangerItemActiveBg,
    dangerItemSelectedBg,
    // Bg
    popupBg,
    itemHoverBg,
    itemActiveBg,
    menuSubMenuBg,
    // Horizontal
    horizontalItemSelectedColor,
    horizontalItemSelectedBg,
    horizontalItemBorderRadius,
    horizontalItemHoverBg
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
      color: itemColor,
      background: itemBg,
      [`&${componentCls}-root:focus-visible`]: {
        ...accessibilityFocus(token2)
      },
      // ======================== Item ========================
      [`${componentCls}-item-group-title`]: {
        color: groupTitleColor
      },
      [`${componentCls}-submenu-selected`]: {
        [`> ${componentCls}-submenu-title`]: {
          color: itemSelectedColor
        }
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        color: itemColor,
        [`&:not(${componentCls}-item-disabled):focus-visible`]: {
          ...accessibilityFocus(token2)
        }
      },
      // Disabled
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${itemDisabledColor} !important`
      },
      // Hover
      [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
        [`&:hover, > ${componentCls}-submenu-title:hover`]: {
          color: itemHoverColor
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        }
      },
      // Danger - only Item has
      [`${componentCls}-item-danger`]: {
        color: dangerItemColor,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: dangerItemHoverColor
          }
        },
        [`&${componentCls}-item:active`]: {
          background: dangerItemActiveBg
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: itemSelectedColor,
        // Danger
        [`&${componentCls}-item-danger`]: {
          color: dangerItemSelectedColor
        },
        [`a, a:hover`]: {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: itemSelectedBg,
        // Danger
        [`&${componentCls}-item-danger`]: {
          backgroundColor: dangerItemSelectedBg
        }
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      // ===== 设置浮层的颜色 =======
      // ！dark 模式会被popupBg 会被rest 为 darkPopupBg
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      [`&${componentCls}-submenu-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      // ===== 设置浮层的颜色 end =======
      // ====================== Horizontal ======================
      [`&${componentCls}-horizontal`]: {
        ...themeSuffix === "dark" ? {
          borderBottom: 0
        } : {},
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: activeBarBorderWidth,
          marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
          marginBottom: 0,
          borderRadius: horizontalItemBorderRadius,
          "&::after": {
            position: "absolute",
            insetInline: itemPaddingInline,
            bottom: 0,
            borderBottom: `${unit(activeBarHeight)} solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          [`&:hover, &-active, &-open`]: {
            background: horizontalItemHoverBg,
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          },
          [`&-selected`]: {
            color: horizontalItemSelectedColor,
            backgroundColor: horizontalItemSelectedBg,
            "&:hover": {
              backgroundColor: horizontalItemSelectedBg
            },
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          }
        }
      },
      // ================== Inline & Vertical ===================
      //
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}`
        }
      },
      // ======================== Inline ========================
      [`&${componentCls}-inline`]: {
        // Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: subMenuItemBg
        },
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [
              `transform ${motionDurationMid} ${motionEaseOut}`,
              `opacity ${motionDurationMid} ${motionEaseOut}`
            ].join(","),
            content: '""'
          },
          // Danger
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: dangerItemSelectedColor
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [
              `transform ${motionDurationMid} ${motionEaseInOut}`,
              `opacity ${motionDurationMid} ${motionEaseInOut}`
            ].join(",")
          }
        }
      }
    }
  };
}, "getThemeStyle");
var theme_default = getThemeStyle;

// packages/ant-design/components/menu/style/vertical.ts
var getVerticalInlineStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    itemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    itemMarginBlock,
    itemWidth
  } = token2;
  const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
  return {
    [`${componentCls}-item`]: {
      position: "relative",
      overflow: "hidden"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight),
      paddingInline: padding,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: itemMarginBlock,
      width: itemWidth
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight)
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
}, "getVerticalInlineStyle");
var getVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    itemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionDurationMid,
    motionEaseOut,
    paddingXL,
    itemMarginInline,
    fontSizeLG,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary,
    collapsedWidth,
    collapsedIconSize
  } = token2;
  const inlineItemStyle = {
    height: itemHeight,
    lineHeight: unit(itemHeight),
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        [`&-inline, &-vertical`]: {
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          },
          ...getVerticalInlineStyle(token2)
        }
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: {
          ...getVerticalInlineStyle(token2),
          boxShadow: boxShadowSecondary
        }
      }
    },
    // Vertical only
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${unit(token2.calc(controlHeightLG).mul(2.5).equal())})`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [
              `border-color ${motionDurationSlow}`,
              `background ${motionDurationSlow}`,
              `padding ${motionDurationMid} ${motionEaseOut}`,
              `padding-inline calc(50% - ${unit(token2.calc(fontSizeLG).div(2).equal())} - ${unit(itemMarginInline)})`
            ].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        // >>>>> Item
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    // Inline Collapse Only
    {
      [`${componentCls}-inline-collapsed`]: {
        width: collapsedWidth,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${unit(token2.calc(fontSizeLG).div(2).equal())} - ${unit(
            itemMarginInline
          )})`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: collapsedIconSize,
            lineHeight: unit(itemHeight),
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: {
          ...textEllipsis,
          paddingInline: paddingXS
        }
      }
    }
  ];
}, "getVerticalStyle");
var vertical_default = getVerticalStyle;

// packages/ant-design/components/menu/style/index.ts
var genMenuItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    iconSize,
    iconMarginInlineEnd
  } = token2;
  return {
    // >>>>> Item
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [
        `border-color ${motionDurationSlow}`,
        `background ${motionDurationSlow}`,
        `padding ${motionDurationSlow} ${motionEaseInOut}`
      ].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: iconSize,
        fontSize: iconSize,
        transition: [
          `font-size ${motionDurationMid} ${motionEaseOut}`,
          `margin ${motionDurationSlow} ${motionEaseInOut}`,
          `color ${motionDurationSlow}`
        ].join(","),
        "+ span": {
          marginInlineStart: iconMarginInlineEnd,
          opacity: 1,
          transition: [
            `opacity ${motionDurationSlow} ${motionEaseInOut}`,
            `margin ${motionDurationSlow}`,
            `color ${motionDurationSlow}`
          ].join(",")
        }
      },
      [`${componentCls}-item-icon`]: {
        ...resetIcon()
      },
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, "genMenuItemStyle");
var genSubMenuArrowStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      [`&-expand-icon, &-arrow`]: {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        // →
        "&::before, &::after": {
          position: "absolute",
          width: token2.calc(menuArrowSize).mul(0.6).equal(),
          height: token2.calc(menuArrowSize).mul(0.15).equal(),
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [
            `background ${motionDurationSlow} ${motionEaseInOut}`,
            `transform ${motionDurationSlow} ${motionEaseInOut}`,
            `top ${motionDurationSlow} ${motionEaseInOut}`,
            `color ${motionDurationSlow} ${motionEaseInOut}`
          ].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(${unit(
            token2.calc(menuArrowOffset).mul(-1).equal()
          )})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})`
        }
      }
    }
  };
}, "genSubMenuArrowStyle");
var getBaseStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    subMenuItemBorderRadius,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    groupTitleLineHeight,
    groupTitleFontSize
  } = token2;
  return [
    // Misc
    {
      "": {
        [`${componentCls}`]: {
          ...clearFix(),
          // Hidden
          [`&-hidden`]: {
            display: "none"
          }
        }
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...clearFix(),
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize,
        lineHeight: 0,
        // Fix display inline-block gap
        listStyle: "none",
        outline: "none",
        // Magic cubic here but smooth transition
        transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
        [`ul, ol`]: {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        [`&-overflow`]: {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.itemBorderRadius
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${unit(paddingXS)} ${unit(padding)}`,
          fontSize: groupTitleFontSize,
          lineHeight: groupTitleLineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [
            `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            `background ${motionDurationSlow} ${motionEaseInOut}`
          ].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [
            `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            `background ${motionDurationSlow} ${motionEaseInOut}`,
            `padding ${motionDurationMid} ${motionEaseInOut}`
          ].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [
            `background ${motionDurationSlow} ${motionEaseInOut}`,
            `padding ${motionDurationSlow} ${motionEaseInOut}`
          ].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`,
          // https://github.com/ant-design/ant-design/issues/41143
          [`> ${antCls}-typography-ellipsis-single-line`]: {
            display: "inline",
            verticalAlign: "unset"
          }
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        },
        // Item
        ...genMenuItemStyle(token2),
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${unit(token2.calc(fontSize).mul(2).equal())} ${unit(padding)}`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            [`&${componentCls}-submenu`]: {
              background: "transparent"
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: 0,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            },
            [`> ${componentCls}`]: {
              borderRadius: borderRadiusLG,
              ...genMenuItemStyle(token2),
              ...genSubMenuArrowStyle(token2),
              [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                borderRadius: subMenuItemBorderRadius
              },
              [`${componentCls}-submenu-title::after`]: {
                transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
              }
            }
          },
          [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
            transformOrigin: "100% 0"
          },
          [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
            transformOrigin: "100% 100%"
          },
          [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
            transformOrigin: "0 100%"
          },
          [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
            transformOrigin: "0 0"
          },
          [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
            paddingInlineEnd: token2.paddingXS
          },
          [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
            paddingInlineStart: token2.paddingXS
          },
          [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
            paddingBottom: token2.paddingXS
          },
          [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
            paddingTop: token2.paddingXS
          }
        },
        ...genSubMenuArrowStyle(token2),
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          // ↓
          "&::before": {
            transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(${unit(
              token2.calc(menuArrowOffset).mul(-1).equal()
            )})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          // ↑
          transform: `translateY(${unit(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
          "&::after": {
            transform: `rotate(-45deg) translateX(${unit(
              token2.calc(menuArrowOffset).mul(-1).equal()
            )})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})`
          }
        }
      }
    },
    // Integration with header element so menu items have the same height
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, "getBaseStyle");
var prepareComponentToken15 = /* @__PURE__ */ __name((token2) => {
  const {
    colorPrimary,
    colorError,
    colorTextDisabled,
    colorErrorBg,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorFillAlter,
    colorFillContent,
    lineWidth,
    lineWidthBold,
    controlItemBgActive,
    colorBgTextHover,
    controlHeightLG,
    lineHeight,
    colorBgElevated,
    marginXXS,
    padding,
    fontSize,
    controlHeightSM,
    fontSizeLG,
    colorTextLightSolid,
    colorErrorHover
  } = token2;
  const activeBarWidth = token2.activeBarWidth ?? 0;
  const activeBarBorderWidth = token2.activeBarBorderWidth ?? lineWidth;
  const itemMarginInline = token2.itemMarginInline ?? token2.marginXXS;
  const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
  return {
    dropdownWidth: 160,
    zIndexPopup: token2.zIndexPopupBase + 50,
    radiusItem: token2.borderRadiusLG,
    itemBorderRadius: token2.borderRadiusLG,
    radiusSubMenuItem: token2.borderRadiusSM,
    subMenuItemBorderRadius: token2.borderRadiusSM,
    colorItemText: colorText,
    itemColor: colorText,
    colorItemTextHover: colorText,
    itemHoverColor: colorText,
    colorItemTextHoverHorizontal: colorPrimary,
    horizontalItemHoverColor: colorPrimary,
    colorGroupTitle: colorTextDescription,
    groupTitleColor: colorTextDescription,
    colorItemTextSelected: colorPrimary,
    itemSelectedColor: colorPrimary,
    colorItemTextSelectedHorizontal: colorPrimary,
    horizontalItemSelectedColor: colorPrimary,
    colorItemBg: colorBgContainer,
    itemBg: colorBgContainer,
    colorItemBgHover: colorBgTextHover,
    itemHoverBg: colorBgTextHover,
    colorItemBgActive: colorFillContent,
    itemActiveBg: controlItemBgActive,
    colorSubItemBg: colorFillAlter,
    subMenuItemBg: colorFillAlter,
    colorItemBgSelected: controlItemBgActive,
    itemSelectedBg: controlItemBgActive,
    colorItemBgSelectedHorizontal: "transparent",
    horizontalItemSelectedBg: "transparent",
    colorActiveBarWidth: 0,
    activeBarWidth,
    colorActiveBarHeight: lineWidthBold,
    activeBarHeight: lineWidthBold,
    colorActiveBarBorderSize: lineWidth,
    activeBarBorderWidth,
    // Disabled
    colorItemTextDisabled: colorTextDisabled,
    itemDisabledColor: colorTextDisabled,
    // Danger
    colorDangerItemText: colorError,
    dangerItemColor: colorError,
    colorDangerItemTextHover: colorError,
    dangerItemHoverColor: colorError,
    colorDangerItemTextSelected: colorError,
    dangerItemSelectedColor: colorError,
    colorDangerItemBgActive: colorErrorBg,
    dangerItemActiveBg: colorErrorBg,
    colorDangerItemBgSelected: colorErrorBg,
    dangerItemSelectedBg: colorErrorBg,
    itemMarginInline,
    horizontalItemBorderRadius: 0,
    horizontalItemHoverBg: "transparent",
    itemHeight: controlHeightLG,
    groupTitleLineHeight: lineHeight,
    collapsedWidth: controlHeightLG * 2,
    popupBg: colorBgElevated,
    itemMarginBlock: marginXXS,
    itemPaddingInline: padding,
    horizontalLineHeight: `${controlHeightLG * 1.15}px`,
    iconSize: fontSize,
    iconMarginInlineEnd: controlHeightSM - fontSize,
    collapsedIconSize: fontSizeLG,
    groupTitleFontSize: fontSize,
    // Disabled
    darkItemDisabledColor: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
    // Dark
    darkItemColor: colorTextDark,
    darkDangerItemColor: colorError,
    darkItemBg: "#001529",
    darkPopupBg: "#001529",
    darkSubMenuItemBg: "#000c17",
    darkItemSelectedColor: colorTextLightSolid,
    darkItemSelectedBg: colorPrimary,
    darkDangerItemSelectedBg: colorError,
    darkItemHoverBg: "transparent",
    darkGroupTitleColor: colorTextDark,
    darkItemHoverColor: colorTextLightSolid,
    darkDangerItemHoverColor: colorErrorHover,
    darkDangerItemSelectedColor: colorTextLightSolid,
    darkDangerItemActiveBg: colorError,
    // internal
    itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
  };
}, "prepareComponentToken");
var style_default18 = /* @__PURE__ */ __name((prefixCls, rootCls = prefixCls, injectStyle = true) => {
  const useStyle = genStyleHooks(
    "Menu",
    (token2) => {
      const {
        colorBgElevated,
        controlHeightLG,
        fontSize,
        darkItemColor,
        darkDangerItemColor,
        darkItemBg,
        darkSubMenuItemBg,
        darkItemSelectedColor,
        darkItemSelectedBg,
        darkDangerItemSelectedBg,
        darkItemHoverBg,
        darkGroupTitleColor,
        darkItemHoverColor,
        darkItemDisabledColor,
        darkDangerItemHoverColor,
        darkDangerItemSelectedColor,
        darkDangerItemActiveBg,
        popupBg,
        darkPopupBg
      } = token2;
      const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
      const menuToken = merge2(token2, {
        menuArrowSize,
        menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
        menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
        menuSubMenuBg: colorBgElevated,
        calc: token2.calc,
        popupBg
      });
      const menuDarkToken = merge2(menuToken, {
        itemColor: darkItemColor,
        itemHoverColor: darkItemHoverColor,
        groupTitleColor: darkGroupTitleColor,
        itemSelectedColor: darkItemSelectedColor,
        itemBg: darkItemBg,
        popupBg: darkPopupBg,
        subMenuItemBg: darkSubMenuItemBg,
        itemActiveBg: "transparent",
        itemSelectedBg: darkItemSelectedBg,
        activeBarHeight: 0,
        activeBarBorderWidth: 0,
        itemHoverBg: darkItemHoverBg,
        // Disabled
        itemDisabledColor: darkItemDisabledColor,
        // Danger
        dangerItemColor: darkDangerItemColor,
        dangerItemHoverColor: darkDangerItemHoverColor,
        dangerItemSelectedColor: darkDangerItemSelectedColor,
        dangerItemActiveBg: darkDangerItemActiveBg,
        dangerItemSelectedBg: darkDangerItemSelectedBg,
        menuSubMenuBg: darkSubMenuItemBg,
        // Horizontal
        horizontalItemSelectedColor: darkItemSelectedColor,
        horizontalItemSelectedBg: darkItemSelectedBg
      });
      return [
        // Basic
        getBaseStyle(menuToken),
        // Horizontal
        horizontal_default(menuToken),
        // Hard code for some light style
        // Vertical
        vertical_default(menuToken),
        // Hard code for some light style
        // Theme
        theme_default(menuToken, "light"),
        theme_default(menuDarkToken, "dark"),
        // RTL
        rtl_default(menuToken),
        // Motion
        collapse_default(menuToken),
        initSlideMotion(menuToken, "slide-up"),
        initSlideMotion(menuToken, "slide-down"),
        initZoomMotion(menuToken, "zoom-big")
      ];
    },
    prepareComponentToken15,
    {
      deprecatedTokens: [
        ["colorGroupTitle", "groupTitleColor"],
        ["radiusItem", "itemBorderRadius"],
        ["radiusSubMenuItem", "subMenuItemBorderRadius"],
        ["colorItemText", "itemColor"],
        ["colorItemTextHover", "itemHoverColor"],
        ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"],
        ["colorItemTextSelected", "itemSelectedColor"],
        ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"],
        ["colorItemTextDisabled", "itemDisabledColor"],
        ["colorDangerItemText", "dangerItemColor"],
        ["colorDangerItemTextHover", "dangerItemHoverColor"],
        ["colorDangerItemTextSelected", "dangerItemSelectedColor"],
        ["colorDangerItemBgActive", "dangerItemActiveBg"],
        ["colorDangerItemBgSelected", "dangerItemSelectedBg"],
        ["colorItemBg", "itemBg"],
        ["colorItemBgHover", "itemHoverBg"],
        ["colorSubItemBg", "subMenuItemBg"],
        ["colorItemBgActive", "itemActiveBg"],
        ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"],
        ["colorActiveBarWidth", "activeBarWidth"],
        ["colorActiveBarHeight", "activeBarHeight"],
        ["colorActiveBarBorderSize", "activeBarBorderWidth"],
        ["colorItemBgSelected", "itemSelectedBg"]
      ],
      // Dropdown will handle menu style self. We do not need to handle this.
      injectStyle,
      unitless: {
        groupTitleLineHeight: true
      }
    }
  );
  return useStyle(prefixCls, rootCls);
}, "default");

// packages/ant-design/components/menu/menu.tsx
function isEmptyIcon(icon) {
  return icon === null || icon === false;
}
__name(isEmptyIcon, "isEmptyIcon");
var InternalMenu = forwardRef46((props, ref) => {
  const override = React210.useContext(OverrideContext_default);
  const overrideObj = override || {};
  const { getPrefixCls, getPopupContainer, direction, menu } = React210.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    theme = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    items,
    children,
    rootClassName,
    mode,
    selectable,
    onClick,
    overflowedIndicatorPopupClassName,
    ...restProps
  } = props;
  const passedProps = omit(restProps, ["collapsedWidth"]);
  const mergedChildren = useItems(items) || children;
  if (true) {
    const warning5 = devUseWarning("Menu");
    warning5(
      !("inlineCollapsed" in props && mode !== "inline"),
      "usage",
      "`inlineCollapsed` should only be used when `mode` is inline."
    );
    warning5(
      !(props.siderCollapsed !== void 0 && "inlineCollapsed" in props),
      "usage",
      "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead."
    );
    warning5.deprecated("items" in props && !children, "children", "items");
  }
  overrideObj.validator?.({ mode });
  const onItemClick = useEvent((...args) => {
    onClick?.(...args);
    overrideObj.onClick?.();
  });
  const mergedMode = overrideObj.mode || mode;
  const mergedSelectable = selectable ?? overrideObj.selectable;
  const mergedInlineCollapsed = React210.useMemo(() => {
    if (siderCollapsed !== void 0) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  const defaultMotions = {
    horizontal: { motionName: `${rootPrefixCls}-slide-up` },
    inline: motion_default(rootPrefixCls),
    other: { motionName: `${rootPrefixCls}-zoom-big` }
  };
  const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default18(prefixCls, rootCls, !override);
  const menuClassName = (0, import_classnames71.default)(`${prefixCls}-${theme}`, menu?.className, className);
  const mergedExpandIcon = React210.useMemo(() => {
    if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
      return expandIcon || null;
    }
    if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
      return overrideObj.expandIcon || null;
    }
    if (typeof menu?.expandIcon === "function" || isEmptyIcon(menu?.expandIcon)) {
      return menu?.expandIcon || null;
    }
    const mergedIcon = expandIcon ?? overrideObj?.expandIcon ?? menu?.expandIcon;
    return cloneElement3(mergedIcon, {
      className: (0, import_classnames71.default)(
        `${prefixCls}-submenu-expand-icon`,
        React210.isValidElement(mergedIcon) ? mergedIcon.props?.className : void 0
      )
    });
  }, [expandIcon, overrideObj?.expandIcon, menu?.expandIcon, prefixCls]);
  const contextValue = React210.useMemo(
    () => ({
      prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      direction,
      firstLevel: true,
      theme,
      mode: mergedMode,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
    }),
    [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme]
  );
  return wrapCSSVar(
    /* @__PURE__ */ React210.createElement(OverrideContext_default.Provider, { value: null }, /* @__PURE__ */ React210.createElement(MenuContext_default.Provider, { value: contextValue }, /* @__PURE__ */ React210.createElement(
      src_default9,
      {
        getPopupContainer,
        overflowedIndicator: /* @__PURE__ */ React210.createElement(import_EllipsisOutlined.default, null),
        overflowedIndicatorPopupClassName: (0, import_classnames71.default)(
          prefixCls,
          `${prefixCls}-${theme}`,
          overflowedIndicatorPopupClassName
        ),
        mode: mergedMode,
        selectable: mergedSelectable,
        onClick: onItemClick,
        ...passedProps,
        inlineCollapsed: mergedInlineCollapsed,
        style: { ...menu?.style, ...style2 },
        className: menuClassName,
        prefixCls,
        direction,
        defaultMotions,
        expandIcon: mergedExpandIcon,
        ref,
        rootClassName: (0, import_classnames71.default)(
          rootClassName,
          hashId,
          overrideObj.rootClassName,
          cssVarCls,
          rootCls
        )
      },
      mergedChildren
    )))
  );
});
var menu_default = InternalMenu;

// packages/ant-design/components/menu/index.tsx
var Menu2 = forwardRef47((props, ref) => {
  const menuRef = useRef75(null);
  const context = React211.useContext(SiderContext);
  useImperativeHandle17(ref, () => ({
    menu: menuRef.current,
    focus: (options) => {
      menuRef.current?.focus(options);
    }
  }));
  return /* @__PURE__ */ React211.createElement(menu_default, { ref: menuRef, ...props, ...context });
});
Menu2.Item = MenuItem_default2;
Menu2.SubMenu = SubMenu_default2;
Menu2.Divider = MenuDivider_default;
Menu2.ItemGroup = MenuItemGroup_default;
if (true) {
  Menu2.displayName = "Menu";
}
var menu_default2 = Menu2;

// packages/ant-design/components/dropdown/style/status.ts
var genStatusStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, menuCls, colorError, colorTextLightSolid } = token2;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
}, "genStatusStyle");
var status_default = genStatusStyle;

// packages/ant-design/components/dropdown/style/index.ts
var genBaseStyle6 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    paddingBlock,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`&-trigger${antCls}-btn`]: {
          [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          }
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      }
    },
    // =============================================================
    // ==                        Arrow style                      ==
    // =============================================================
    getArrowStyle(token2, colorBgElevated, {
      arrowPlacement: { top: true, bottom: true }
    }),
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [menuCls]: {
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          ...genFocusStyle(token2),
          "&:empty": {
            padding: 0,
            boxShadow: "none"
          },
          [`${menuCls}-item-group-title`]: {
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          // ======================= Item Content =======================
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          // =========================== Item ===========================
          [`${menuCls}-item, ${menuCls}-submenu-title`]: {
            clear: "both",
            margin: 0,
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            [`&:hover, &-active`]: {
              backgroundColor: token2.controlItemBgHover
            },
            ...genFocusStyle(token2),
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              // By design
              margin: `${unit(token2.marginXXS)} 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorTextDescription,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          },
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${unit(token2.marginXS)}`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        }
      }
    },
    // Follow code may reuse in other components
    [
      initSlideMotion(token2, "slide-up"),
      initSlideMotion(token2, "slide-down"),
      initMoveMotion(token2, "move-up"),
      initMoveMotion(token2, "move-down"),
      initZoomMotion(token2, "zoom-big")
    ]
  ];
}, "genBaseStyle");
var prepareComponentToken16 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50,
  paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2,
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token2)
}), "prepareComponentToken");
var style_default19 = genStyleHooks(
  "Dropdown",
  (token2) => {
    const { marginXXS, sizePopupArrow, paddingXXS, componentCls } = token2;
    const dropdownToken = merge2(token2, {
      menuCls: `${componentCls}-menu`,
      dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
      dropdownEdgeChildPadding: paddingXXS
    });
    return [genBaseStyle6(dropdownToken), status_default(dropdownToken)];
  },
  prepareComponentToken16
);

// packages/ant-design/components/dropdown/dropdown.tsx
var Dropdown2 = /* @__PURE__ */ __name((props) => {
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    overlayStyle,
    open: open3,
    onOpenChange,
    // Deprecated
    visible,
    onVisibleChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    placement = "",
    overlay,
    transitionName
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    dropdown
  } = React212.useContext(ConfigContext);
  const warning5 = devUseWarning("Dropdown");
  if (true) {
    [
      ["visible", "open"],
      ["onVisibleChange", "onOpenChange"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    warning5.deprecated(!("overlay" in props), "overlay", "menu");
  }
  const memoTransitionName = React212.useMemo(() => {
    const rootPrefixCls = getPrefixCls();
    if (transitionName !== void 0) {
      return transitionName;
    }
    if (placement.includes("top")) {
      return `${rootPrefixCls}-slide-down`;
    }
    return `${rootPrefixCls}-slide-up`;
  }, [getPrefixCls, placement, transitionName]);
  const memoPlacement = React212.useMemo(() => {
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      return placement.slice(0, placement.indexOf("Center"));
    }
    return placement;
  }, [placement, direction]);
  if (true) {
    if (placement.includes("Center")) {
      const newPlacement = placement.slice(0, placement.indexOf("Center"));
      warning5(
        !placement.includes("Center"),
        "deprecated",
        `You are using '${placement}' placement in Dropdown, which is deprecated. Try to use '${newPlacement}' instead.`
      );
    }
    [
      ["visible", "open"],
      ["onVisibleChange", "onOpenChange"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default19(prefixCls, rootCls);
  const [, token2] = useToken();
  const child = React212.Children.only(children);
  const dropdownTrigger = cloneElement3(child, {
    className: (0, import_classnames72.default)(
      `${prefixCls}-trigger`,
      {
        [`${prefixCls}-rtl`]: direction === "rtl"
      },
      child.props.className
    ),
    disabled
  });
  const triggerActions = disabled ? [] : trigger;
  let alignPoint;
  if (triggerActions && triggerActions.includes("contextMenu")) {
    alignPoint = true;
  }
  const [mergedOpen, setOpen] = useMergedState(false, {
    value: open3 ?? visible
  });
  const onInnerOpenChange = useEvent((nextOpen) => {
    onOpenChange?.(nextOpen, { source: "trigger" });
    onVisibleChange?.(nextOpen);
    setOpen(nextOpen);
  });
  const overlayClassNameCustomized = (0, import_classnames72.default)(
    overlayClassName,
    rootClassName,
    hashId,
    cssVarCls,
    rootCls,
    dropdown?.className,
    { [`${prefixCls}-rtl`]: direction === "rtl" }
  );
  const builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow3,
    offset: token2.marginXXS,
    arrowWidth: arrow ? token2.sizePopupArrow : 0,
    borderRadius: token2.borderRadius
  });
  const onMenuClick = React212.useCallback(() => {
    if (menu?.selectable && menu?.multiple) {
      return;
    }
    onOpenChange?.(false, { source: "menu" });
    setOpen(false);
  }, [menu?.selectable, menu?.multiple]);
  const renderOverlay = /* @__PURE__ */ __name(() => {
    let overlayNode;
    if (menu?.items) {
      overlayNode = /* @__PURE__ */ React212.createElement(menu_default2, { ...menu });
    } else if (typeof overlay === "function") {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    if (dropdownRender) {
      overlayNode = dropdownRender(overlayNode);
    }
    overlayNode = React212.Children.only(
      typeof overlayNode === "string" ? /* @__PURE__ */ React212.createElement("span", null, overlayNode) : overlayNode
    );
    return /* @__PURE__ */ React212.createElement(
      OverrideProvider,
      {
        prefixCls: `${prefixCls}-menu`,
        rootClassName: (0, import_classnames72.default)(cssVarCls, rootCls),
        expandIcon: /* @__PURE__ */ React212.createElement("span", { className: `${prefixCls}-menu-submenu-arrow` }, /* @__PURE__ */ React212.createElement(import_RightOutlined2.default, { className: `${prefixCls}-menu-submenu-arrow-icon` })),
        mode: "vertical",
        selectable: false,
        onClick: onMenuClick,
        validator: ({ mode }) => {
          warning5(
            !mode || mode === "vertical",
            "usage",
            `mode="${mode}" is not supported for Dropdown's Menu.`
          );
        }
      },
      overlayNode
    );
  }, "renderOverlay");
  const [zIndex, contextZIndex] = useZIndex("Dropdown", overlayStyle?.zIndex);
  let renderNode = /* @__PURE__ */ React212.createElement(
    src_default8,
    {
      alignPoint,
      ...omit(props, ["rootClassName"]),
      mouseEnterDelay,
      mouseLeaveDelay,
      visible: mergedOpen,
      builtinPlacements,
      arrow: !!arrow,
      overlayClassName: overlayClassNameCustomized,
      prefixCls,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      transitionName: memoTransitionName,
      trigger: triggerActions,
      overlay: renderOverlay,
      placement: memoPlacement,
      onVisibleChange: onInnerOpenChange,
      overlayStyle: { ...dropdown?.style, ...overlayStyle, zIndex }
    },
    dropdownTrigger
  );
  if (zIndex) {
    renderNode = /* @__PURE__ */ React212.createElement(zindexContext_default.Provider, { value: contextZIndex }, renderNode);
  }
  return wrapCSSVar(renderNode);
}, "Dropdown");
function postPureProps(props) {
  return {
    ...props,
    align: {
      overflow: {
        adjustX: false,
        adjustY: false
      }
    }
  };
}
__name(postPureProps, "postPureProps");
var PurePanel7 = PurePanel_default3(Dropdown2, "dropdown", (prefixCls) => prefixCls, postPureProps);
var WrapPurePanel = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React212.createElement(PurePanel7, { ...props }, /* @__PURE__ */ React212.createElement("span", null)), "WrapPurePanel");
Dropdown2._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
if (true) {
  Dropdown2.displayName = "Dropdown";
}
var dropdown_default2 = Dropdown2;

// packages/ant-design/components/breadcrumb/BreadcrumbSeparator.tsx
import * as React213 from "react";
var BreadcrumbSeparator = /* @__PURE__ */ __name(({ children }) => {
  const { getPrefixCls } = React213.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb");
  return /* @__PURE__ */ React213.createElement("li", { className: `${prefixCls}-separator`, "aria-hidden": "true" }, children === "" ? children : children || "/");
}, "BreadcrumbSeparator");
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator_default = BreadcrumbSeparator;

// packages/ant-design/components/breadcrumb/useItemRender.tsx
var import_classnames73 = __toESM(require_classnames());
import * as React214 from "react";
function getBreadcrumbName(route, params) {
  if (route.title === void 0 || route.title === null) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  return typeof route.title === "object" ? route.title : String(route.title).replace(
    new RegExp(`:(${paramsKeys})`, "g"),
    (replacement, key) => params[key] || replacement
  );
}
__name(getBreadcrumbName, "getBreadcrumbName");
function renderItem(prefixCls, item, children, href) {
  if (children === null || children === void 0) {
    return null;
  }
  const { className, onClick, ...restItem } = item;
  const passedProps = {
    ...pickAttrs(restItem, {
      data: true,
      aria: true
    }),
    onClick
  };
  if (href !== void 0) {
    return /* @__PURE__ */ React214.createElement("a", { ...passedProps, className: (0, import_classnames73.default)(`${prefixCls}-link`, className), href }, children);
  }
  return /* @__PURE__ */ React214.createElement("span", { ...passedProps, className: (0, import_classnames73.default)(`${prefixCls}-link`, className) }, children);
}
__name(renderItem, "renderItem");
function useItemRender(prefixCls, itemRender) {
  const mergedItemRender = /* @__PURE__ */ __name((item, params, routes, path2, href) => {
    if (itemRender) {
      return itemRender(item, params, routes, path2);
    }
    const name = getBreadcrumbName(item, params);
    return renderItem(prefixCls, item, name, href);
  }, "mergedItemRender");
  return mergedItemRender;
}
__name(useItemRender, "useItemRender");

// packages/ant-design/components/breadcrumb/BreadcrumbItem.tsx
var InternalBreadcrumbItem = /* @__PURE__ */ __name((props) => {
  const { prefixCls, separator = "/", children, menu, overlay, dropdownProps, href } = props;
  if (true) {
    const warning5 = devUseWarning("Breadcrumb.Item");
    warning5.deprecated(!("overlay" in props), "overlay", "menu");
  }
  const renderBreadcrumbNode = /* @__PURE__ */ __name((breadcrumbItem) => {
    if (menu || overlay) {
      const mergeDropDownProps = {
        ...dropdownProps
      };
      if (menu) {
        const { items, ...menuProps } = menu || {};
        mergeDropDownProps.menu = {
          ...menuProps,
          items: items?.map(({ key, title, label, path: path2, ...itemProps }, index3) => {
            let mergedLabel = label ?? title;
            if (path2) {
              mergedLabel = /* @__PURE__ */ React215.createElement("a", { href: `${href}${path2}` }, mergedLabel);
            }
            return {
              ...itemProps,
              key: key ?? index3,
              label: mergedLabel
            };
          })
        };
      } else if (overlay) {
        mergeDropDownProps.overlay = overlay;
      }
      return /* @__PURE__ */ React215.createElement(dropdown_default2, { placement: "bottom", ...mergeDropDownProps }, /* @__PURE__ */ React215.createElement("span", { className: `${prefixCls}-overlay-link` }, breadcrumbItem, /* @__PURE__ */ React215.createElement(import_DownOutlined2.default, null)));
    }
    return breadcrumbItem;
  }, "renderBreadcrumbNode");
  const link = renderBreadcrumbNode(children);
  if (link !== void 0 && link !== null) {
    return /* @__PURE__ */ React215.createElement(React215.Fragment, null, /* @__PURE__ */ React215.createElement("li", null, link), separator && /* @__PURE__ */ React215.createElement(BreadcrumbSeparator_default, null, separator));
  }
  return null;
}, "InternalBreadcrumbItem");
var BreadcrumbItem = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, children, href, ...restProps } = props;
  const { getPrefixCls } = React215.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  return /* @__PURE__ */ React215.createElement(InternalBreadcrumbItem, { ...restProps, prefixCls }, renderItem(prefixCls, restProps, children, href));
}, "BreadcrumbItem");
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem_default = BreadcrumbItem;

// packages/ant-design/components/breadcrumb/style/index.ts
var genBreadcrumbStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls, calc } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      color: token2.itemColor,
      fontSize: token2.fontSize,
      [iconCls]: {
        fontSize: token2.iconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: {
        color: token2.linkColor,
        transition: `color ${token2.motionDurationMid}`,
        padding: `0 ${unit(token2.paddingXXS)}`,
        borderRadius: token2.borderRadiusSM,
        height: token2.fontHeight,
        display: "inline-block",
        marginInline: calc(token2.marginXXS).mul(-1).equal(),
        "&:hover": {
          color: token2.linkHoverColor,
          backgroundColor: token2.colorBgTextHover
        },
        ...genFocusStyle(token2)
      },
      [`li:last-child`]: {
        color: token2.lastItemColor
      },
      [`${componentCls}-separator`]: {
        marginInline: token2.separatorMargin,
        color: token2.separatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token2.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token2.borderRadiusSM,
        height: token2.fontHeight,
        display: "inline-block",
        padding: `0 ${unit(token2.paddingXXS)}`,
        marginInline: calc(token2.marginXXS).mul(-1).equal(),
        [`> ${iconCls}`]: {
          marginInlineStart: token2.marginXXS,
          fontSize: token2.fontSizeIcon
        },
        "&:hover": {
          color: token2.linkHoverColor,
          backgroundColor: token2.colorBgTextHover,
          a: {
            color: token2.linkHoverColor
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
}, "genBreadcrumbStyle");
var prepareComponentToken17 = /* @__PURE__ */ __name((token2) => ({
  itemColor: token2.colorTextDescription,
  lastItemColor: token2.colorText,
  iconFontSize: token2.fontSize,
  linkColor: token2.colorTextDescription,
  linkHoverColor: token2.colorText,
  separatorColor: token2.colorTextDescription,
  separatorMargin: token2.marginXS
}), "prepareComponentToken");
var style_default20 = genStyleHooks(
  "Breadcrumb",
  (token2) => {
    const breadcrumbToken = merge2(token2, {});
    return genBreadcrumbStyle(breadcrumbToken);
  },
  prepareComponentToken17
);

// packages/ant-design/components/breadcrumb/useItems.ts
import { useMemo as useMemo55 } from "react";
function route2item(route) {
  const { breadcrumbName, children, ...rest } = route;
  const clone = {
    title: breadcrumbName,
    ...rest
  };
  if (children) {
    clone.menu = {
      items: children.map(({ breadcrumbName: itemBreadcrumbName, ...itemProps }) => ({
        ...itemProps,
        title: itemBreadcrumbName
      }))
    };
  }
  return clone;
}
__name(route2item, "route2item");
function useItems2(items, routes) {
  return useMemo55(() => {
    if (items) {
      return items;
    }
    if (routes) {
      return routes.map(route2item);
    }
    return null;
  }, [items, routes]);
}
__name(useItems2, "useItems");

// packages/ant-design/components/breadcrumb/Breadcrumb.tsx
var getPath = /* @__PURE__ */ __name((params, path2) => {
  if (path2 === void 0) {
    return path2;
  }
  let mergedPath = (path2 || "").replace(/^\//, "");
  Object.keys(params).forEach((key) => {
    mergedPath = mergedPath.replace(`:${key}`, params[key]);
  });
  return mergedPath;
}, "getPath");
var Breadcrumb = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    separator = "/",
    style: style2,
    className,
    rootClassName,
    routes: legacyRoutes,
    items,
    children,
    itemRender,
    params = {},
    ...restProps
  } = props;
  const { getPrefixCls, direction, breadcrumb } = React216.useContext(ConfigContext);
  let crumbs;
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default20(prefixCls);
  const mergedItems = useItems2(items, legacyRoutes);
  if (true) {
    const warning5 = devUseWarning("Breadcrumb");
    warning5.deprecated(!legacyRoutes, "routes", "items");
    if (!mergedItems || mergedItems.length === 0) {
      const childList = toArray(children);
      warning5.deprecated(
        childList.length === 0,
        "Breadcrumb.Item and Breadcrumb.Separator",
        "items"
      );
      childList.forEach((element) => {
        if (element) {
          warning5(
            element.type && (element.type.__ANT_BREADCRUMB_ITEM === true || element.type.__ANT_BREADCRUMB_SEPARATOR === true),
            "usage",
            "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children"
          );
        }
      });
    }
  }
  const mergedItemRender = useItemRender(prefixCls, itemRender);
  if (mergedItems && mergedItems.length > 0) {
    const paths = [];
    const itemRenderRoutes = items || legacyRoutes;
    crumbs = mergedItems.map((item, index3) => {
      const {
        path: path2,
        key,
        type: type5,
        menu,
        overlay,
        onClick,
        className: itemClassName,
        separator: itemSeparator,
        dropdownProps
      } = item;
      const mergedPath = getPath(params, path2);
      if (mergedPath !== void 0) {
        paths.push(mergedPath);
      }
      const mergedKey = key ?? index3;
      if (type5 === "separator") {
        return /* @__PURE__ */ React216.createElement(BreadcrumbSeparator_default, { key: mergedKey }, itemSeparator);
      }
      const itemProps = {};
      const isLastItem = index3 === mergedItems.length - 1;
      if (menu) {
        itemProps.menu = menu;
      } else if (overlay) {
        itemProps.overlay = overlay;
      }
      let { href } = item;
      if (paths.length && mergedPath !== void 0) {
        href = `#/${paths.join("/")}`;
      }
      return /* @__PURE__ */ React216.createElement(
        InternalBreadcrumbItem,
        {
          key: mergedKey,
          ...itemProps,
          ...pickAttrs(item, { data: true, aria: true }),
          className: itemClassName,
          dropdownProps,
          href,
          separator: isLastItem ? "" : separator,
          onClick,
          prefixCls
        },
        mergedItemRender(item, params, itemRenderRoutes, paths, href)
      );
    });
  } else if (children) {
    const childrenLength = toArray(children).length;
    crumbs = toArray(children).map((element, index3) => {
      if (!element) {
        return element;
      }
      const isLastItem = index3 === childrenLength - 1;
      return cloneElement3(element, {
        separator: isLastItem ? "" : separator,
        key: index3
      });
    });
  }
  const breadcrumbClassName = (0, import_classnames74.default)(
    prefixCls,
    breadcrumb?.className,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...breadcrumb?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React216.createElement("nav", { className: breadcrumbClassName, style: mergedStyle, ...restProps }, /* @__PURE__ */ React216.createElement("ol", null, crumbs))
  );
}, "Breadcrumb");
Breadcrumb.Item = BreadcrumbItem_default;
Breadcrumb.Separator = BreadcrumbSeparator_default;
if (true) {
  Breadcrumb.displayName = "Breadcrumb";
}
var Breadcrumb_default = Breadcrumb;

// packages/ant-design/components/breadcrumb/index.ts
var breadcrumb_default = Breadcrumb_default;

// packages/picker/src/generate/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min());
init_warning();
var import_weekday = __toESM(require_weekday());
var import_localeData = __toESM(require_localeData());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_weekYear = __toESM(require_weekYear());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_customParseFormat = __toESM(require_customParseFormat());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekday.default);
import_dayjs.default.extend(import_localeData.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend((o3, c) => {
  const proto = c.prototype;
  const oldFormat = proto.format;
  proto.format = /* @__PURE__ */ __name(function f(formatStr) {
    const str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  }, "f");
});
var localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  // todo: dayjs has no fr_BE locale, use fr at present
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = /* @__PURE__ */ __name((locale6) => {
  const mapLocale = localeMap[locale6];
  return mapLocale || locale6.split("_")[0];
}, "parseLocale");
var parseNoMatchNotice = /* @__PURE__ */ __name(() => {
  noteOnce(false, "Not match any format. Please help to fire a issue about this.");
}, "parseNoMatchNotice");
var generateConfig = {
  // get
  getNow: () => (0, import_dayjs.default)(),
  getFixedDate: (string3) => (0, import_dayjs.default)(string3, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (date4) => date4.endOf("month"),
  getWeekDay: (date4) => {
    const clone = date4.locale("en");
    return clone.weekday() + clone.localeData().firstDayOfWeek();
  },
  getYear: (date4) => date4.year(),
  getMonth: (date4) => date4.month(),
  getDate: (date4) => date4.date(),
  getHour: (date4) => date4.hour(),
  getMinute: (date4) => date4.minute(),
  getSecond: (date4) => date4.second(),
  getMillisecond: (date4) => date4.millisecond(),
  // set
  addYear: (date4, diff) => date4.add(diff, "year"),
  addMonth: (date4, diff) => date4.add(diff, "month"),
  addDate: (date4, diff) => date4.add(diff, "day"),
  setYear: (date4, year) => date4.year(year),
  setMonth: (date4, month) => date4.month(month),
  setDate: (date4, num) => date4.date(num),
  setHour: (date4, hour) => date4.hour(hour),
  setMinute: (date4, minute) => date4.minute(minute),
  setSecond: (date4, second) => date4.second(second),
  setMillisecond: (date4, milliseconds) => date4.millisecond(milliseconds),
  // Compare
  isAfter: (date1, date22) => date1.isAfter(date22),
  isValidate: (date4) => date4.isValid(),
  locale: {
    getWeekFirstDay: (locale6) => (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (locale6, date4) => date4.locale(parseLocale(locale6)).weekday(0),
    getWeek: (locale6, date4) => date4.locale(parseLocale(locale6)).week(),
    getShortWeekDays: (locale6) => (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().weekdaysMin(),
    getShortMonths: (locale6) => (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().monthsShort(),
    format: (locale6, date4, format2) => date4.locale(parseLocale(locale6)).format(format2),
    parse: (locale6, text, formats) => {
      const localeStr = parseLocale(locale6);
      for (let i = 0; i < formats.length; i += 1) {
        const format2 = formats[i];
        const formatText = text;
        if (format2.includes("wo") || format2.includes("Wo")) {
          const year = formatText.split("-")[0];
          const weekStr = formatText.split("-")[1];
          const firstWeek = (0, import_dayjs.default)(year, "YYYY").startOf("year").locale(localeStr);
          for (let j = 0; j <= 52; j += 1) {
            const nextWeek = firstWeek.add(j, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        const date4 = (0, import_dayjs.default)(formatText, format2, true).locale(localeStr);
        if (date4.isValid()) {
          return date4;
        }
      }
      if (text) {
        parseNoMatchNotice();
      }
      return null;
    }
  }
};
var dayjs_default = generateConfig;

// packages/ant-design/components/calendar/generateCalendar.tsx
var import_classnames92 = __toESM(require_classnames());
import * as React268 from "react";

// packages/picker/src/PickerInput/RangePicker.tsx
init_warning();
import * as React258 from "react";

// packages/picker/src/PickerTrigger/index.tsx
var import_classnames75 = __toESM(require_classnames());
import * as React218 from "react";

// packages/picker/src/PickerInput/context.tsx
import * as React217 from "react";
var PickerContext = React217.createContext(null);
var context_default6 = PickerContext;

// packages/picker/src/PickerTrigger/index.tsx
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger({
  popupElement,
  popupStyle,
  popupClassName,
  popupAlign,
  transitionName,
  getPopupContainer,
  children,
  range: range3,
  placement,
  builtinPlacements = BUILT_IN_PLACEMENTS,
  direction,
  // Visible
  visible,
  onClose
}) {
  const { prefixCls } = React218.useContext(context_default6);
  const dropdownPrefixCls = `${prefixCls}-dropdown`;
  const mergedPlacement = React218.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  return /* @__PURE__ */ React218.createElement(
    src_default5,
    {
      showAction: [],
      hideAction: ["click"],
      popupPlacement: mergedPlacement,
      builtinPlacements,
      prefixCls: dropdownPrefixCls,
      popupTransitionName: transitionName,
      popup: popupElement,
      popupAlign,
      popupVisible: visible,
      popupClassName: (0, import_classnames75.default)(popupClassName, {
        [`${dropdownPrefixCls}-range`]: range3,
        [`${dropdownPrefixCls}-rtl`]: direction === "rtl"
      }),
      popupStyle,
      stretch: "minWidth",
      getPopupContainer,
      onPopupVisibleChange: (nextVisible) => {
        if (!nextVisible) {
          onClose();
        }
      }
    },
    children
  );
}
__name(PickerTrigger, "PickerTrigger");
var PickerTrigger_default = PickerTrigger;

// packages/picker/src/utils/miscUtil.ts
function leftPad(str, length2, fill = "0") {
  let current = String(str);
  while (current.length < length2) {
    current = `${fill}${current}`;
  }
  return current;
}
__name(leftPad, "leftPad");
function toArray5(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
__name(toArray5, "toArray");
function fillIndex(ori, index3, value) {
  const clone = [...ori];
  clone[index3] = value;
  return clone;
}
__name(fillIndex, "fillIndex");
function pickProps(props, keys2) {
  const clone = {};
  const mergedKeys = keys2 || Object.keys(props);
  mergedKeys.forEach((key) => {
    if (props[key] !== void 0) {
      clone[key] = props[key];
    }
  });
  return clone;
}
__name(pickProps, "pickProps");
function getRowFormat(picker, locale6, format2) {
  if (format2) {
    return format2;
  }
  switch (picker) {
    case "time":
      return locale6.fieldTimeFormat;
    case "datetime":
      return locale6.fieldDateTimeFormat;
    case "month":
      return locale6.fieldMonthFormat;
    case "year":
      return locale6.fieldYearFormat;
    case "quarter":
      return locale6.fieldQuarterFormat;
    case "week":
      return locale6.fieldWeekFormat;
    default:
      return locale6.fieldDateFormat;
  }
}
__name(getRowFormat, "getRowFormat");

// packages/picker/src/PickerTrigger/util.ts
function pickTriggerProps(props) {
  return pickProps(props, [
    "placement",
    "builtinPlacements",
    "popupAlign",
    "getPopupContainer",
    "transitionName",
    "direction"
  ]);
}
__name(pickTriggerProps, "pickTriggerProps");

// packages/picker/src/PickerInput/hooks/useCellRender.ts
import * as React219 from "react";
function useCellRender(cellRender, dateRender, monthCellRender, range3) {
  if (true) {
    warning_default(!dateRender, `'dateRender' is deprecated. Please use 'cellRender' instead.`);
    warning_default(!monthCellRender, `'monthCellRender' is deprecated. Please use 'cellRender' instead.`);
  }
  const mergedCellRender = React219.useMemo(() => {
    if (cellRender) {
      return cellRender;
    }
    return (current, info) => {
      const date4 = current;
      if (dateRender && info.type === "date") {
        return dateRender(date4, info.today);
      }
      if (monthCellRender && info.type === "month") {
        return monthCellRender(date4, info.locale);
      }
      return info.originNode;
    };
  }, [cellRender, monthCellRender, dateRender]);
  const onInternalCellRender = React219.useCallback(
    (date4, info) => mergedCellRender(date4, {
      ...info,
      range: range3
    }),
    [mergedCellRender, range3]
  );
  return onInternalCellRender;
}
__name(useCellRender, "useCellRender");

// packages/picker/src/PickerInput/hooks/useFieldsInvalidate.ts
import * as React220 from "react";
function useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty = []) {
  const [fieldsInvalidates, setFieldsInvalidates] = React220.useState([
    false,
    false
  ]);
  const onSelectorInvalid = /* @__PURE__ */ __name((invalid, index3) => {
    setFieldsInvalidates((ori) => fillIndex(ori, index3, invalid));
  }, "onSelectorInvalid");
  const submitInvalidates = React220.useMemo(() => {
    return fieldsInvalidates.map((invalid, index3) => {
      if (invalid) {
        return true;
      }
      const current = calendarValue[index3];
      if (!current) {
        return false;
      }
      if (!allowEmpty[index3] && !current) {
        return true;
      }
      if (current && isInvalidateDate(current, { activeIndex: index3 })) {
        return true;
      }
      return false;
    });
  }, [calendarValue, fieldsInvalidates, isInvalidateDate, allowEmpty]);
  return [submitInvalidates, onSelectorInvalid];
}
__name(useFieldsInvalidate, "useFieldsInvalidate");

// packages/picker/src/PickerInput/hooks/useFilledProps.ts
import * as React224 from "react";

// packages/picker/src/hooks/useLocale.ts
import React221 from "react";
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
  let timeFormat = "";
  const cells = [];
  if (showHour) {
    cells.push(showMeridiem ? "hh" : "HH");
  }
  if (showMinute) {
    cells.push("mm");
  }
  if (showSecond) {
    cells.push("ss");
  }
  timeFormat = cells.join(":");
  if (showMillisecond) {
    timeFormat += ".SSS";
  }
  if (showMeridiem) {
    timeFormat += " A";
  }
  return timeFormat;
}
__name(fillTimeFormat, "fillTimeFormat");
function fillLocale(locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
  const {
    // Input Field
    fieldDateTimeFormat,
    fieldDateFormat,
    fieldTimeFormat,
    fieldMonthFormat,
    fieldYearFormat,
    fieldWeekFormat,
    fieldQuarterFormat,
    // Header Format
    yearFormat,
    // monthFormat,
    // Cell format
    cellYearFormat,
    cellQuarterFormat,
    dayFormat,
    cellDateFormat
    // cellMeridiemFormat,
  } = locale6;
  const timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
  return {
    ...locale6,
    fieldDateTimeFormat: fieldDateTimeFormat || `YYYY-MM-DD ${timeFormat}`,
    fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
    fieldTimeFormat: fieldTimeFormat || timeFormat,
    fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
    fieldYearFormat: fieldYearFormat || "YYYY",
    fieldWeekFormat: fieldWeekFormat || "gggg-wo",
    fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
    yearFormat: yearFormat || "YYYY",
    cellYearFormat: cellYearFormat || "YYYY",
    cellQuarterFormat: cellQuarterFormat || "[Q]Q",
    cellDateFormat: cellDateFormat || dayFormat || "D"
  };
}
__name(fillLocale, "fillLocale");
function useLocale2(locale6, showProps) {
  const { showHour, showMinute, showSecond, showMillisecond, use12Hours } = showProps;
  return React221.useMemo(
    () => fillLocale(locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours),
    [locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours]
  );
}
__name(useLocale2, "useLocale");

// packages/picker/src/hooks/useTimeConfig.ts
function checkShow(format2, keywords, show) {
  return show ?? keywords.some((keyword) => format2.includes(keyword));
}
__name(checkShow, "checkShow");
var showTimeKeys = [
  // 'format',
  "showNow",
  "showHour",
  "showMinute",
  "showSecond",
  "showMillisecond",
  "use12Hours",
  "hourStep",
  "minuteStep",
  "secondStep",
  "millisecondStep",
  "hideDisabledOptions",
  "defaultValue",
  "disabledHours",
  "disabledMinutes",
  "disabledSeconds",
  "disabledMilliseconds",
  "disabledTime",
  "changeOnScroll",
  "defaultOpenValue"
];
function pickTimeProps(props) {
  const timeProps = pickProps(props, showTimeKeys);
  const { format: format2, picker } = props;
  let propFormat = null;
  if (format2) {
    propFormat = format2;
    if (Array.isArray(propFormat)) {
      propFormat = propFormat[0];
    }
    propFormat = typeof propFormat === "object" ? propFormat.format : propFormat;
  }
  if (picker === "time") {
    timeProps.format = propFormat;
  }
  return [timeProps, propFormat];
}
__name(pickTimeProps, "pickTimeProps");
function isStringFormat(format2) {
  return format2 && typeof format2 === "string";
}
__name(isStringFormat, "isStringFormat");
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
  return [showHour, showMinute, showSecond, showMillisecond].some((show) => show !== void 0);
}
__name(existShowConfig, "existShowConfig");
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
  let parsedShowHour = showHour;
  let parsedShowMinute = showMinute;
  let parsedShowSecond = showSecond;
  if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
    parsedShowHour = true;
    parsedShowMinute = true;
    parsedShowSecond = true;
  } else if (hasShowConfig) {
    const existFalse = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(
      (show) => show === false
    );
    const existTrue = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(
      (show) => show === true
    );
    const defaultShow = existFalse ? true : !existTrue;
    parsedShowHour = parsedShowHour ?? defaultShow;
    parsedShowMinute = parsedShowMinute ?? defaultShow;
    parsedShowSecond = parsedShowSecond ?? defaultShow;
  }
  return [parsedShowHour, parsedShowMinute, parsedShowSecond, showMillisecond];
}
__name(fillShowConfig, "fillShowConfig");
function getTimeProps(componentProps) {
  const { showTime } = componentProps;
  const [pickedProps, propFormat] = pickTimeProps(componentProps);
  const showTimeConfig = showTime && typeof showTime === "object" ? showTime : {};
  const timeConfig = {
    defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue,
    ...pickedProps,
    ...showTimeConfig
  };
  const { showMillisecond } = timeConfig;
  let { showHour, showMinute, showSecond } = timeConfig;
  const hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
  [showHour, showMinute, showSecond] = fillShowConfig(
    hasShowConfig,
    showHour,
    showMinute,
    showSecond,
    showMillisecond
  );
  return [
    timeConfig,
    {
      ...timeConfig,
      showHour,
      showMinute,
      showSecond,
      showMillisecond
    },
    timeConfig.format,
    propFormat
  ];
}
__name(getTimeProps, "getTimeProps");
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale6) {
  const isTimePicker = picker === "time";
  if (picker === "datetime" || isTimePicker) {
    const pickedProps = timeConfig;
    const defaultLocaleFormat = getRowFormat(picker, locale6, null);
    let baselineFormat = defaultLocaleFormat;
    const formatList = [showTimeFormat, propFormat];
    for (let i = 0; i < formatList.length; i += 1) {
      const format2 = toArray5(formatList[i])[0];
      if (isStringFormat(format2)) {
        baselineFormat = format2;
        break;
      }
    }
    let { showHour, showMinute, showSecond, showMillisecond } = pickedProps;
    const { use12Hours } = pickedProps;
    const showMeridiem = checkShow(baselineFormat, ["a", "A", "LT", "LLL", "LTS"], use12Hours);
    const hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
    if (!hasShowConfig) {
      showHour = checkShow(baselineFormat, ["H", "h", "k", "LT", "LLL"]);
      showMinute = checkShow(baselineFormat, ["m", "LT", "LLL"]);
      showSecond = checkShow(baselineFormat, ["s", "LTS"]);
      showMillisecond = checkShow(baselineFormat, ["SSS"]);
    }
    [showHour, showMinute, showSecond] = fillShowConfig(
      hasShowConfig,
      showHour,
      showMinute,
      showSecond,
      showMillisecond
    );
    const timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
    return {
      ...pickedProps,
      // Format
      format: timeFormat,
      // Show Config
      showHour,
      showMinute,
      showSecond,
      showMillisecond,
      use12Hours: showMeridiem
    };
  }
  return null;
}
__name(fillShowTimeConfig, "fillShowTimeConfig");

// packages/picker/src/PickerInput/Selector/hooks/useClearIcon.tsx
init_warning();
import * as React222 from "react";
function fillClearIcon(prefixCls, allowClear, clearIcon) {
  if (clearIcon) {
    warning_default(false, "`clearIcon` will be removed in future. Please use `allowClear` instead.");
  }
  if (allowClear === false) {
    return null;
  }
  const config = allowClear && typeof allowClear === "object" ? allowClear : {};
  return config.clearIcon || clearIcon || /* @__PURE__ */ React222.createElement("span", { className: `${prefixCls}-clear-btn` });
}
__name(fillClearIcon, "fillClearIcon");

// packages/picker/src/utils/dateUtil.ts
var WEEK_DAY_COUNT = 7;
function nullableCompare(value1, value2, oriCompareFn) {
  if (!value1 && !value2 || value1 === value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return oriCompareFn();
}
__name(nullableCompare, "nullableCompare");
function isSameDecade(generateConfig2, decade1, decade2) {
  return nullableCompare(decade1, decade2, () => {
    const num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
    const num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
    return num1 === num2;
  });
}
__name(isSameDecade, "isSameDecade");
function isSameYear(generateConfig2, year1, year2) {
  return nullableCompare(
    year1,
    year2,
    () => generateConfig2.getYear(year1) === generateConfig2.getYear(year2)
  );
}
__name(isSameYear, "isSameYear");
function getQuarter(generateConfig2, date4) {
  const quota = Math.floor(generateConfig2.getMonth(date4) / 3);
  return quota + 1;
}
__name(getQuarter, "getQuarter");
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  return nullableCompare(
    quarter1,
    quarter2,
    () => isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2)
  );
}
__name(isSameQuarter, "isSameQuarter");
function isSameMonth(generateConfig2, month1, month2) {
  return nullableCompare(
    month1,
    month2,
    () => isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2)
  );
}
__name(isSameMonth, "isSameMonth");
function isSameDate(generateConfig2, date1, date22) {
  return nullableCompare(
    date1,
    date22,
    () => isSameYear(generateConfig2, date1, date22) && isSameMonth(generateConfig2, date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22)
  );
}
__name(isSameDate, "isSameDate");
function isSameTime(generateConfig2, time1, time2) {
  return nullableCompare(
    time1,
    time2,
    () => generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2)
  );
}
__name(isSameTime, "isSameTime");
function isSameTimestamp(generateConfig2, time1, time2) {
  return nullableCompare(
    time1,
    time2,
    () => isSameDate(generateConfig2, time1, time2) && isSameTime(generateConfig2, time1, time2) && generateConfig2.getMillisecond(time1) === generateConfig2.getMillisecond(time2)
  );
}
__name(isSameTimestamp, "isSameTimestamp");
function isSameWeek(generateConfig2, locale6, date1, date22) {
  return nullableCompare(date1, date22, () => {
    const weekStartDate1 = generateConfig2.locale.getWeekFirstDate(locale6, date1);
    const weekStartDate2 = generateConfig2.locale.getWeekFirstDate(locale6, date22);
    return isSameYear(generateConfig2, weekStartDate1, weekStartDate2) && generateConfig2.locale.getWeek(locale6, date1) === generateConfig2.locale.getWeek(locale6, date22);
  });
}
__name(isSameWeek, "isSameWeek");
function isSame(generateConfig2, locale6, source, target, type5) {
  switch (type5) {
    case "date":
      return isSameDate(generateConfig2, source, target);
    case "week":
      return isSameWeek(generateConfig2, locale6.locale, source, target);
    case "month":
      return isSameMonth(generateConfig2, source, target);
    case "quarter":
      return isSameQuarter(generateConfig2, source, target);
    case "year":
      return isSameYear(generateConfig2, source, target);
    case "decade":
      return isSameDecade(generateConfig2, source, target);
    case "time":
      return isSameTime(generateConfig2, source, target);
    default:
      return isSameTimestamp(generateConfig2, source, target);
  }
}
__name(isSame, "isSame");
function isInRange(generateConfig2, startDate, endDate, current) {
  if (!startDate || !endDate || !current) {
    return false;
  }
  return generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
__name(isInRange, "isInRange");
function isSameOrAfter(generateConfig2, locale6, date1, date22, type5) {
  if (isSame(generateConfig2, locale6, date1, date22, type5)) {
    return true;
  }
  return generateConfig2.isAfter(date1, date22);
}
__name(isSameOrAfter, "isSameOrAfter");
function getWeekStartDate(locale6, generateConfig2, value) {
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale6);
  const monthStartDate = generateConfig2.setDate(value, 1);
  const startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  let alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
__name(getWeekStartDate, "getWeekStartDate");
function formatValue(value, {
  generateConfig: generateConfig2,
  locale: locale6,
  format: format2
}) {
  if (!value) {
    return "";
  }
  return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale6.locale, value, format2);
}
__name(formatValue, "formatValue");
function fillTime(generateConfig2, date4, time) {
  let tmpDate = date4;
  const getFn = ["getHour", "getMinute", "getSecond", "getMillisecond"];
  const setFn = ["setHour", "setMinute", "setSecond", "setMillisecond"];
  setFn.forEach((fn, index3) => {
    if (time) {
      tmpDate = generateConfig2[fn](tmpDate, generateConfig2[getFn[index3]](time));
    } else {
      tmpDate = generateConfig2[fn](tmpDate, 0);
    }
  });
  return tmpDate;
}
__name(fillTime, "fillTime");

// packages/picker/src/PickerInput/hooks/useDisabledBoundary.ts
function useDisabledBoundary(generateConfig2, locale6, disabledDate, minDate, maxDate) {
  const mergedDisabledDate = useEvent((date4, info) => {
    if (disabledDate && disabledDate(date4, info)) {
      return true;
    }
    if (minDate && generateConfig2.isAfter(minDate, date4) && !isSame(generateConfig2, locale6, minDate, date4, info.type)) {
      return true;
    }
    if (maxDate && generateConfig2.isAfter(date4, maxDate) && !isSame(generateConfig2, locale6, maxDate, date4, info.type)) {
      return true;
    }
    return false;
  });
  return mergedDisabledDate;
}
__name(useDisabledBoundary, "useDisabledBoundary");

// packages/picker/src/PickerInput/hooks/useFieldFormat.ts
import * as React223 from "react";
function useFieldFormat(picker, locale6, format2) {
  return React223.useMemo(() => {
    const rawFormat = getRowFormat(picker, locale6, format2);
    const formatList = toArray5(rawFormat);
    const firstFormat = formatList[0];
    const maskFormat = typeof firstFormat === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
    return [
      // Format list
      formatList.map(
        (config) => typeof config === "string" || typeof config === "function" ? config : config.format
      ),
      // Mask Format
      maskFormat
    ];
  }, [picker, locale6, format2]);
}
__name(useFieldFormat, "useFieldFormat");

// packages/picker/src/PickerInput/hooks/useInputReadOnly.ts
function useInputReadOnly(formatList, inputReadOnly, multiple) {
  if (typeof formatList[0] === "function" || multiple) {
    return true;
  }
  return inputReadOnly;
}
__name(useInputReadOnly, "useInputReadOnly");

// packages/picker/src/PickerInput/hooks/useInvalidate.ts
function useInvalidate(generateConfig2, picker, disabledDate, showTime) {
  const isInvalidate = useEvent(
    (date4, info) => {
      const outsideInfo = {
        type: picker,
        ...info
      };
      delete outsideInfo.activeIndex;
      if (
        // Date object is invalid
        !generateConfig2.isValidate(date4) || // Date is disabled by `disabledDate`
        disabledDate && disabledDate(date4, outsideInfo)
      ) {
        return true;
      }
      if ((picker === "date" || picker === "time") && showTime) {
        const { disabledHours, disabledMinutes, disabledSeconds, disabledMilliseconds } = showTime.disabledTime?.(date4, info && info.activeIndex === 1 ? "end" : "start") || {};
        const {
          disabledHours: legacyDisabledHours,
          disabledMinutes: legacyDisabledMinutes,
          disabledSeconds: legacyDisabledSeconds
        } = showTime;
        const mergedDisabledHours = disabledHours || legacyDisabledHours;
        const mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
        const mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
        const hour = generateConfig2.getHour(date4);
        const minute = generateConfig2.getMinute(date4);
        const second = generateConfig2.getSecond(date4);
        const millisecond = generateConfig2.getMillisecond(date4);
        if (mergedDisabledHours && mergedDisabledHours().includes(hour)) {
          return true;
        }
        if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) {
          return true;
        }
        if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) {
          return true;
        }
        if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) {
          return true;
        }
      }
      return false;
    }
  );
  return isInvalidate;
}
__name(useInvalidate, "useInvalidate");

// packages/picker/src/PickerInput/hooks/useFilledProps.ts
function useList(value, fillMode = false) {
  const values = React224.useMemo(() => {
    const list = value ? toArray5(value) : value;
    if (fillMode && list) {
      list[1] = list[1] || list[0];
    }
    return list;
  }, [value, fillMode]);
  return values;
}
__name(useList, "useList");
function useFilledProps(props, updater) {
  const {
    generateConfig: generateConfig2,
    locale: locale6,
    picker = "date",
    prefixCls = "rc-picker",
    styles = {},
    classNames: classNames253 = {},
    order = true,
    components = {},
    inputRender,
    allowClear,
    clearIcon,
    needConfirm,
    multiple,
    format: format2,
    inputReadOnly,
    disabledDate,
    minDate,
    maxDate,
    showTime,
    value,
    defaultValue,
    pickerValue,
    defaultPickerValue
  } = props;
  const values = useList(value);
  const defaultValues = useList(defaultValue);
  const pickerValues = useList(pickerValue);
  const defaultPickerValues = useList(defaultPickerValue);
  const internalPicker = picker === "date" && showTime ? "datetime" : picker;
  const multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
  const complexPicker = multipleInteractivePicker || multiple;
  const mergedNeedConfirm = needConfirm ?? multipleInteractivePicker;
  const [timeProps, localeTimeProps, showTimeFormat, propFormat] = getTimeProps(props);
  const mergedLocale = useLocale2(locale6, localeTimeProps);
  const mergedShowTime = React224.useMemo(
    () => fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale),
    [internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale]
  );
  if (picker === "time") {
    if (["disabledHours", "disabledMinutes", "disabledSeconds"].some((key) => props[key])) {
      warning_default(
        false,
        `'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.`
      );
    }
  }
  const filledProps = React224.useMemo(
    () => ({
      ...props,
      prefixCls,
      locale: mergedLocale,
      picker,
      styles,
      classNames: classNames253,
      order,
      components: {
        input: inputRender,
        ...components
      },
      clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
      showTime: mergedShowTime,
      value: values,
      defaultValue: defaultValues,
      pickerValue: pickerValues,
      defaultPickerValue: defaultPickerValues,
      ...updater?.()
    }),
    [props]
  );
  const [formatList, maskFormat] = useFieldFormat(internalPicker, mergedLocale, format2);
  const mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
  const disabledBoundaryDate = useDisabledBoundary(
    generateConfig2,
    locale6,
    disabledDate,
    minDate,
    maxDate
  );
  const isInvalidateDate = useInvalidate(
    generateConfig2,
    picker,
    disabledBoundaryDate,
    mergedShowTime
  );
  const mergedProps = React224.useMemo(
    () => ({
      ...filledProps,
      needConfirm: mergedNeedConfirm,
      inputReadOnly: mergedInputReadOnly,
      disabledDate: disabledBoundaryDate
    }),
    [filledProps, mergedNeedConfirm, mergedInputReadOnly, disabledBoundaryDate]
  );
  return [mergedProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate];
}
__name(useFilledProps, "useFilledProps");

// packages/picker/src/PickerInput/hooks/useDelayState.ts
import React225 from "react";
function useDelayState(value, defaultValue, onChange) {
  const [state, setState] = useMergedState(defaultValue, {
    value
  });
  const nextValueRef = React225.useRef(value);
  const rafRef = React225.useRef();
  const cancelRaf = /* @__PURE__ */ __name(() => {
    raf_default.cancel(rafRef.current);
  }, "cancelRaf");
  const doUpdate = useEvent(() => {
    setState(nextValueRef.current);
    if (onChange && state !== nextValueRef.current) {
      onChange(nextValueRef.current);
    }
  });
  const updateValue = useEvent((next2, immediately) => {
    cancelRaf();
    nextValueRef.current = next2;
    if (next2 || immediately) {
      doUpdate();
    } else {
      rafRef.current = raf_default(doUpdate);
    }
  });
  React225.useEffect(() => cancelRaf, []);
  return [state, updateValue];
}
__name(useDelayState, "useDelayState");

// packages/picker/src/PickerInput/hooks/useOpen.ts
function useOpen(open3, defaultOpen, disabledList = [], onOpenChange) {
  const mergedOpen = disabledList.every((disabled) => disabled) ? false : open3;
  const [rafOpen, setRafOpen] = useDelayState(mergedOpen, defaultOpen || false, onOpenChange);
  function setOpen(next2, config = {}) {
    if (!config.inherit || rafOpen) {
      setRafOpen(next2, config.force);
    }
  }
  __name(setOpen, "setOpen");
  return [rafOpen, setOpen];
}
__name(useOpen, "useOpen");

// packages/picker/src/PickerInput/hooks/usePickerRef.ts
import * as React226 from "react";
function usePickerRef(ref) {
  const selectorRef = React226.useRef();
  React226.useImperativeHandle(ref, () => ({
    nativeElement: selectorRef.current?.nativeElement,
    focus: (options) => {
      selectorRef.current?.focus(options);
    },
    blur: () => {
      selectorRef.current?.blur();
    }
  }));
  return selectorRef;
}
__name(usePickerRef, "usePickerRef");

// packages/picker/src/PickerInput/hooks/usePresets.ts
init_warning();
import * as React227 from "react";
function usePresets(presets, legacyRanges) {
  return React227.useMemo(() => {
    if (presets) {
      return presets;
    }
    if (legacyRanges) {
      warning_default(false, "`ranges` is deprecated. Please use `presets` instead.");
      return Object.entries(legacyRanges).map(([label, value]) => ({
        label,
        value
      }));
    }
    return [];
  }, [presets, legacyRanges]);
}
__name(usePresets, "usePresets");

// packages/picker/src/PickerInput/hooks/useRangeActive.ts
import * as React229 from "react";

// packages/picker/src/PickerInput/hooks/useLockEffect.ts
import * as React228 from "react";
function useLockEffect(condition, callback, delayFrames = 1) {
  const callbackRef = React228.useRef(callback);
  callbackRef.current = callback;
  useLayoutUpdateEffect(() => {
    if (condition) {
      callbackRef.current(condition);
    } else {
      const id = raf_default(() => {
        callbackRef.current(condition);
      }, delayFrames);
      return () => {
        raf_default.cancel(id);
      };
    }
  }, [condition]);
}
__name(useLockEffect, "useLockEffect");

// packages/picker/src/PickerInput/hooks/useRangeActive.ts
function useRangeActive(disabled, empty2 = []) {
  const [activeIndex, setActiveIndex] = React229.useState(0);
  const [focused, setFocused] = React229.useState(false);
  const activeListRef = React229.useRef([]);
  const lastOperationRef = React229.useRef(null);
  const triggerFocus3 = /* @__PURE__ */ __name((nextFocus) => {
    setFocused(nextFocus);
  }, "triggerFocus");
  const lastOperation = /* @__PURE__ */ __name((type5) => {
    if (type5) {
      lastOperationRef.current = type5;
    }
    return lastOperationRef.current;
  }, "lastOperation");
  const nextActiveIndex = /* @__PURE__ */ __name((nextValue) => {
    const list = activeListRef.current;
    const filledActiveSet = new Set(list.filter((index3) => nextValue[index3] || empty2[index3]));
    const nextIndex = list[list.length - 1] === 0 ? 1 : 0;
    if (filledActiveSet.size >= 2 || disabled[nextIndex]) {
      return null;
    }
    return nextIndex;
  }, "nextActiveIndex");
  useLockEffect(focused, () => {
    if (!focused) {
      activeListRef.current = [];
    }
  });
  React229.useEffect(() => {
    if (focused) {
      activeListRef.current.push(activeIndex);
    }
  }, [focused, activeIndex]);
  return [
    focused,
    triggerFocus3,
    lastOperation,
    activeIndex,
    setActiveIndex,
    nextActiveIndex,
    activeListRef.current
  ];
}
__name(useRangeActive, "useRangeActive");

// packages/picker/src/PickerInput/hooks/useRangeDisabledDate.ts
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig2, locale6, disabledDate) {
  const activeIndex = activeIndexList[activeIndexList.length - 1];
  const firstValuedIndex = activeIndexList.find((index3) => values[index3]);
  const rangeDisabledDate = /* @__PURE__ */ __name((date4, info) => {
    const [start, end] = values;
    const mergedInfo = {
      ...info,
      from: activeIndex !== firstValuedIndex ? values[firstValuedIndex] : void 0
    };
    if (activeIndex === 1 && disabled[0] && start && // Same date isOK
    !isSame(generateConfig2, locale6, start, date4, mergedInfo.type) && // Before start date
    generateConfig2.isAfter(start, date4)) {
      return true;
    }
    if (activeIndex === 0 && disabled[1] && end && // Same date isOK
    !isSame(generateConfig2, locale6, end, date4, mergedInfo.type) && // After end date
    generateConfig2.isAfter(date4, end)) {
      return true;
    }
    return disabledDate?.(date4, mergedInfo);
  }, "rangeDisabledDate");
  return rangeDisabledDate;
}
__name(useRangeDisabledDate, "useRangeDisabledDate");

// packages/picker/src/PickerInput/hooks/useRangePickerValue.ts
import * as React230 from "react";
function offsetPanelDate(generateConfig2, picker, date4, offset3) {
  switch (picker) {
    case "date":
    case "week":
      return generateConfig2.addMonth(date4, offset3);
    case "month":
    case "quarter":
      return generateConfig2.addYear(date4, offset3);
    case "year":
      return generateConfig2.addYear(date4, offset3 * 10);
    case "decade":
      return generateConfig2.addYear(date4, offset3 * 100);
    default:
      return date4;
  }
}
__name(offsetPanelDate, "offsetPanelDate");
var EMPTY_LIST4 = [];
function useRangePickerValue(generateConfig2, locale6, calendarValue, modes, open3, activeIndex, pickerMode, multiplePanel, defaultPickerValue = EMPTY_LIST4, pickerValue = EMPTY_LIST4, timeDefaultValue = EMPTY_LIST4, onPickerValueChange, minDate, maxDate) {
  const isTimePicker = pickerMode === "time";
  const mergedActiveIndex = activeIndex || 0;
  const getDefaultPickerValue = /* @__PURE__ */ __name((index3) => {
    let now2 = generateConfig2.getNow();
    if (isTimePicker) {
      now2 = fillTime(generateConfig2, now2);
    }
    return defaultPickerValue[index3] || calendarValue[index3] || now2;
  }, "getDefaultPickerValue");
  const [startPickerValue, endPickerValue] = pickerValue;
  const [mergedStartPickerValue, setStartPickerValue] = useMergedState(
    () => getDefaultPickerValue(0),
    {
      value: startPickerValue
    }
  );
  const [mergedEndPickerValue, setEndPickerValue] = useMergedState(() => getDefaultPickerValue(1), {
    value: endPickerValue
  });
  const currentPickerValue = React230.useMemo(() => {
    const current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
    return isTimePicker ? current : fillTime(generateConfig2, current, timeDefaultValue[mergedActiveIndex]);
  }, [
    isTimePicker,
    mergedStartPickerValue,
    mergedEndPickerValue,
    mergedActiveIndex,
    generateConfig2,
    timeDefaultValue
  ]);
  const setCurrentPickerValue = /* @__PURE__ */ __name((nextPickerValue, source = "panel") => {
    const updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
    updater(nextPickerValue);
    const clone = [mergedStartPickerValue, mergedEndPickerValue];
    clone[mergedActiveIndex] = nextPickerValue;
    if (onPickerValueChange && (!isSame(generateConfig2, locale6, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig2, locale6, mergedEndPickerValue, clone[1], pickerMode))) {
      onPickerValueChange(clone, {
        source,
        range: mergedActiveIndex === 1 ? "end" : "start",
        mode: modes
      });
    }
  }, "setCurrentPickerValue");
  const getEndDatePickerValue = /* @__PURE__ */ __name((startDate, endDate) => {
    if (multiplePanel) {
      const SAME_CHECKER = {
        date: "month",
        week: "month",
        month: "year",
        quarter: "year"
      };
      const mode = SAME_CHECKER[pickerMode];
      if (mode && !isSame(generateConfig2, locale6, startDate, endDate, mode)) {
        return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
      }
      if (pickerMode === "year") {
        const srcYear = Math.floor(generateConfig2.getYear(startDate) / 10);
        const tgtYear = Math.floor(generateConfig2.getYear(endDate) / 10);
        if (srcYear !== tgtYear) {
          return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
        }
      }
    }
    return endDate;
  }, "getEndDatePickerValue");
  const prevActiveIndexRef = React230.useRef(null);
  useLayoutEffect_default(() => {
    if (open3) {
      if (!defaultPickerValue[mergedActiveIndex]) {
        let nextPickerValue = isTimePicker ? null : generateConfig2.getNow();
        if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) {
          nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
        } else if (calendarValue[mergedActiveIndex]) {
          nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
        } else if (calendarValue[mergedActiveIndex ^ 1]) {
          nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
        }
        if (nextPickerValue) {
          if (minDate && generateConfig2.isAfter(minDate, nextPickerValue)) {
            nextPickerValue = minDate;
          }
          const offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, nextPickerValue, 1) : nextPickerValue;
          if (maxDate && generateConfig2.isAfter(offsetPickerValue, maxDate)) {
            nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, maxDate, -1) : maxDate;
          }
          setCurrentPickerValue(nextPickerValue, "reset");
        }
      }
    }
  }, [open3, mergedActiveIndex, calendarValue[mergedActiveIndex]]);
  React230.useEffect(() => {
    if (open3) {
      prevActiveIndexRef.current = mergedActiveIndex;
    } else {
      prevActiveIndexRef.current = null;
    }
  }, [open3, mergedActiveIndex]);
  useLayoutEffect_default(() => {
    if (open3 && defaultPickerValue) {
      if (defaultPickerValue[mergedActiveIndex]) {
        setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
      }
    }
  }, [open3, mergedActiveIndex]);
  return [currentPickerValue, setCurrentPickerValue];
}
__name(useRangePickerValue, "useRangePickerValue");

// packages/picker/src/PickerInput/hooks/useRangeValue.ts
import * as React232 from "react";

// packages/picker/src/hooks/useSyncState.ts
import * as React231 from "react";
function useSyncState(defaultValue, controlledValue) {
  const valueRef = React231.useRef(defaultValue);
  const [, forceUpdate] = React231.useState({});
  const getter = /* @__PURE__ */ __name((useControlledValueFirst) => useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current, "getter");
  const setter = /* @__PURE__ */ __name((nextValue) => {
    valueRef.current = nextValue;
    forceUpdate({});
  }, "setter");
  return [getter, setter, getter(true)];
}
__name(useSyncState, "useSyncState");

// packages/picker/src/PickerInput/hooks/useRangeValue.ts
var EMPTY_VALUE = [];
function useUtil(generateConfig2, locale6, formatList) {
  const getDateTexts = /* @__PURE__ */ __name((dates) => {
    return dates.map(
      (date4) => formatValue(date4, { generateConfig: generateConfig2, locale: locale6, format: formatList[0] })
    );
  }, "getDateTexts");
  const isSameDates = /* @__PURE__ */ __name((source, target) => {
    const maxLen = Math.max(source.length, target.length);
    let diffIndex = -1;
    for (let i = 0; i < maxLen; i += 1) {
      const prev2 = source[i] || null;
      const next2 = target[i] || null;
      if (prev2 !== next2 && !isSameTimestamp(generateConfig2, prev2, next2)) {
        diffIndex = i;
        break;
      }
    }
    return [diffIndex < 0, diffIndex !== 0];
  }, "isSameDates");
  return [getDateTexts, isSameDates];
}
__name(useUtil, "useUtil");
function orderDates(dates, generateConfig2) {
  return [...dates].sort((a, b) => generateConfig2.isAfter(a, b) ? 1 : -1);
}
__name(orderDates, "orderDates");
function useCalendarValue(mergedValue) {
  const [calendarValue, setCalendarValue] = useSyncState(mergedValue);
  const syncWithValue = useEvent(() => {
    setCalendarValue(mergedValue);
  });
  React232.useEffect(() => {
    syncWithValue();
  }, [mergedValue]);
  return [calendarValue, setCalendarValue];
}
__name(useCalendarValue, "useCalendarValue");
function useInnerValue(generateConfig2, locale6, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
  const [innerValue, setInnerValue] = useMergedState(defaultValue, {
    value
  });
  const mergedValue = innerValue || EMPTY_VALUE;
  const [calendarValue, setCalendarValue] = useCalendarValue(mergedValue);
  const [getDateTexts, isSameDates] = useUtil(generateConfig2, locale6, formatList);
  const triggerCalendarChange = useEvent(
    (nextCalendarValues) => {
      let clone = [...nextCalendarValues];
      if (rangeValue) {
        for (let i = 0; i < 2; i += 1) {
          clone[i] = clone[i] || null;
        }
      } else if (order) {
        clone = orderDates(clone.filter((date4) => date4), generateConfig2);
      }
      const [isSameMergedDates, isSameStart] = isSameDates(calendarValue(), clone);
      if (!isSameMergedDates) {
        setCalendarValue(clone);
        if (onCalendarChange) {
          const cellTexts = getDateTexts(clone);
          onCalendarChange(clone, cellTexts, {
            range: isSameStart ? "end" : "start"
          });
        }
      }
    }
  );
  const triggerOk = /* @__PURE__ */ __name(() => {
    if (onOk) {
      onOk(calendarValue());
    }
  }, "triggerOk");
  return [mergedValue, setInnerValue, calendarValue, triggerCalendarChange, triggerOk];
}
__name(useInnerValue, "useInnerValue");
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open3, isInvalidateDate) {
  const {
    // MISC
    generateConfig: generateConfig2,
    locale: locale6,
    picker,
    onChange,
    // Checker
    allowEmpty,
    order
  } = info;
  const orderOnChange = disabled.some((d) => d) ? false : order;
  const [getDateTexts, isSameDates] = useUtil(generateConfig2, locale6, formatList);
  const [submitValue, setSubmitValue] = useSyncState(mergedValue);
  const syncWithValue = useEvent(() => {
    setSubmitValue(mergedValue);
  });
  React232.useEffect(() => {
    syncWithValue();
  }, [mergedValue]);
  const triggerSubmit = useEvent((nextValue) => {
    const isNullValue = nextValue === null;
    let clone = [...nextValue || submitValue()];
    if (isNullValue) {
      const maxLen = Math.max(disabled.length, clone.length);
      for (let i = 0; i < maxLen; i += 1) {
        if (!disabled[i]) {
          clone[i] = null;
        }
      }
    }
    if (orderOnChange && clone[0] && clone[1]) {
      clone = orderDates(clone, generateConfig2);
    }
    triggerCalendarChange(clone);
    const [start, end] = clone;
    const startEmpty = !start;
    const endEmpty = !end;
    const validateEmptyDateRange = allowEmpty ? (
      // Validate empty start
      (!startEmpty || allowEmpty[0]) && // Validate empty end
      (!endEmpty || allowEmpty[1])
    ) : true;
    const validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig2, locale6, start, end, picker) || generateConfig2.isAfter(end, start);
    const validateDates = (
      // Validate start
      (!start || !isInvalidateDate(start, { activeIndex: 0 })) && // Validate end
      (!end || !isInvalidateDate(end, { from: start, activeIndex: 1 }))
    );
    const allPassed = (
      // Null value is from clear button
      isNullValue || // Normal check
      validateEmptyDateRange && validateOrder && validateDates
    );
    if (allPassed) {
      setInnerValue(clone);
      const [isSameMergedDates] = isSameDates(clone, mergedValue);
      if (onChange && !isSameMergedDates) {
        onChange(
          // Return null directly if all date are empty
          isNullValue && clone.every((val) => !val) ? null : clone,
          getDateTexts(clone)
        );
      }
    }
    return allPassed;
  });
  const flushSubmit = useEvent((index3, needTriggerChange) => {
    const nextSubmitValue = fillIndex(submitValue(), index3, getCalendarValue()[index3]);
    setSubmitValue(nextSubmitValue);
    if (needTriggerChange) {
      triggerSubmit();
    }
  });
  const interactiveFinished = !focused && !open3;
  useLockEffect(
    !interactiveFinished,
    () => {
      if (interactiveFinished) {
        triggerSubmit();
        triggerCalendarChange(mergedValue);
        syncWithValue();
      }
    },
    2
  );
  return [flushSubmit, triggerSubmit];
}
__name(useRangeValue, "useRangeValue");

// packages/picker/src/PickerInput/hooks/useShowNow.ts
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
  if (mode !== "date" && mode !== "time") {
    return false;
  }
  if (showNow !== void 0) {
    return showNow;
  }
  if (showToday !== void 0) {
    return showToday;
  }
  return !rangePicker && (picker === "date" || picker === "time");
}
__name(useShowNow, "useShowNow");

// packages/picker/src/PickerInput/Popup/index.tsx
var import_classnames84 = __toESM(require_classnames());
import * as React252 from "react";

// packages/picker/src/PickerInput/Popup/Footer.tsx
var import_classnames76 = __toESM(require_classnames());
import * as React234 from "react";

// packages/picker/src/hooks/useTimeInfo.ts
import * as React233 from "react";

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/util.ts
function findValidateTime(date4, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig2) {
  let nextDate = date4;
  function alignValidate(getUnitValue2, setUnitValue, units) {
    let nextValue = generateConfig2[getUnitValue2](nextDate);
    const nextUnit = units.find((unit3) => unit3.value === nextValue);
    if (!nextUnit || nextUnit.disabled) {
      const validateUnits = units.filter((unit3) => !unit3.disabled);
      const reverseEnabledUnits = [...validateUnits].reverse();
      const validateUnit = reverseEnabledUnits.find((unit3) => unit3.value <= nextValue) || validateUnits[0];
      if (validateUnit) {
        nextValue = validateUnit.value;
        nextDate = generateConfig2[setUnitValue](nextDate, nextValue);
      }
    }
    return nextValue;
  }
  __name(alignValidate, "alignValidate");
  const nextHour = alignValidate("getHour", "setHour", getHourUnits());
  const nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
  const nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
  alignValidate(
    "getMillisecond",
    "setMillisecond",
    getMillisecondUnits(nextHour, nextMinute, nextSecond)
  );
  return nextDate;
}
__name(findValidateTime, "findValidateTime");

// packages/picker/src/hooks/useTimeInfo.ts
function emptyDisabled() {
  return [];
}
__name(emptyDisabled, "emptyDisabled");
function generateUnits(start, end, step = 1, hideDisabledOptions = false, disabledUnits = [], pad = 2) {
  const units = [];
  const integerStep = step >= 1 ? step | 0 : 1;
  for (let i = start; i <= end; i += integerStep) {
    const disabled = disabledUnits.includes(i);
    if (!disabled || !hideDisabledOptions) {
      units.push({
        label: leftPad(i, pad),
        value: i,
        disabled
      });
    }
  }
  return units;
}
__name(generateUnits, "generateUnits");
function useTimeInfo(generateConfig2, props = {}, date4) {
  const {
    // Show
    use12Hours,
    // Steps
    hourStep = 1,
    minuteStep = 1,
    secondStep = 1,
    millisecondStep = 100,
    // Disabled
    hideDisabledOptions,
    disabledTime,
    disabledHours,
    disabledMinutes,
    disabledSeconds
  } = props || {};
  const mergedDate = React233.useMemo(() => date4 || generateConfig2.getNow(), [date4, generateConfig2]);
  if (true) {
    const isHourStepValid = 24 % hourStep === 0;
    const isMinuteStepValid = 60 % minuteStep === 0;
    const isSecondStepValid = 60 % secondStep === 0;
    warning_default(isHourStepValid, `\`hourStep\` ${hourStep} is invalid. It should be a factor of 24.`);
    warning_default(
      isMinuteStepValid,
      `\`minuteStep\` ${minuteStep} is invalid. It should be a factor of 60.`
    );
    warning_default(
      isSecondStepValid,
      `\`secondStep\` ${secondStep} is invalid. It should be a factor of 60.`
    );
  }
  const getDisabledTimes = React233.useCallback(
    (targetDate) => {
      const disabledConfig = disabledTime?.(targetDate) || {};
      return [
        disabledConfig.disabledHours || disabledHours || emptyDisabled,
        disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled,
        disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled,
        disabledConfig.disabledMilliseconds || emptyDisabled
      ];
    },
    [disabledTime, disabledHours, disabledMinutes, disabledSeconds]
  );
  const [
    mergedDisabledHours,
    mergedDisabledMinutes,
    mergedDisabledSeconds,
    mergedDisabledMilliseconds
  ] = React233.useMemo(() => getDisabledTimes(mergedDate), [mergedDate, getDisabledTimes]);
  const getAllUnits = React233.useCallback(
    (getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) => {
      const hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
      const rowHourUnits2 = use12Hours ? hours.map((unit3) => ({
        ...unit3,
        label: leftPad(unit3.value % 12 || 12, 2)
      })) : hours;
      const getMinuteUnits2 = /* @__PURE__ */ __name((nextHour) => generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour)), "getMinuteUnits");
      const getSecondUnits2 = /* @__PURE__ */ __name((nextHour, nextMinute) => generateUnits(
        0,
        59,
        secondStep,
        hideDisabledOptions,
        getDisabledSeconds(nextHour, nextMinute)
      ), "getSecondUnits");
      const getMillisecondUnits2 = /* @__PURE__ */ __name((nextHour, nextMinute, nextSecond) => generateUnits(
        0,
        999,
        millisecondStep,
        hideDisabledOptions,
        getDisabledMilliseconds(nextHour, nextMinute, nextSecond),
        3
      ), "getMillisecondUnits");
      return [rowHourUnits2, getMinuteUnits2, getSecondUnits2, getMillisecondUnits2];
    },
    [hideDisabledOptions, hourStep, use12Hours, millisecondStep, minuteStep, secondStep]
  );
  const [rowHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits] = React233.useMemo(
    () => getAllUnits(
      mergedDisabledHours,
      mergedDisabledMinutes,
      mergedDisabledSeconds,
      mergedDisabledMilliseconds
    ),
    [
      getAllUnits,
      mergedDisabledHours,
      mergedDisabledMinutes,
      mergedDisabledSeconds,
      mergedDisabledMilliseconds
    ]
  );
  const getValidTime = /* @__PURE__ */ __name((nextTime, certainDate) => {
    let getCheckHourUnits = /* @__PURE__ */ __name(() => rowHourUnits, "getCheckHourUnits");
    let getCheckMinuteUnits = getMinuteUnits;
    let getCheckSecondUnits = getSecondUnits;
    let getCheckMillisecondUnits = getMillisecondUnits;
    if (certainDate) {
      const [
        targetDisabledHours,
        targetDisabledMinutes,
        targetDisabledSeconds,
        targetDisabledMilliseconds
      ] = getDisabledTimes(certainDate);
      const [
        targetRowHourUnits,
        targetGetMinuteUnits,
        targetGetSecondUnits,
        targetGetMillisecondUnits
      ] = getAllUnits(
        targetDisabledHours,
        targetDisabledMinutes,
        targetDisabledSeconds,
        targetDisabledMilliseconds
      );
      getCheckHourUnits = /* @__PURE__ */ __name(() => targetRowHourUnits, "getCheckHourUnits");
      getCheckMinuteUnits = targetGetMinuteUnits;
      getCheckSecondUnits = targetGetSecondUnits;
      getCheckMillisecondUnits = targetGetMillisecondUnits;
    }
    const validateDate = findValidateTime(
      nextTime,
      getCheckHourUnits,
      getCheckMinuteUnits,
      getCheckSecondUnits,
      getCheckMillisecondUnits,
      generateConfig2
    );
    return validateDate;
  }, "getValidTime");
  return [
    // getValidTime
    getValidTime,
    // Units
    rowHourUnits,
    getMinuteUnits,
    getSecondUnits,
    getMillisecondUnits
  ];
}
__name(useTimeInfo, "useTimeInfo");

// packages/picker/src/PickerInput/Popup/Footer.tsx
function Footer2(props) {
  const {
    mode,
    internalMode,
    renderExtraFooter,
    showNow,
    showTime,
    onSubmit,
    onNow,
    invalid,
    needConfirm,
    generateConfig: generateConfig2,
    disabledDate
  } = props;
  const { prefixCls, locale: locale6, button: Button2 = "button" } = React234.useContext(context_default6);
  const now2 = generateConfig2.getNow();
  const [getValidTime] = useTimeInfo(generateConfig2, showTime, now2);
  const extraNode = renderExtraFooter?.(mode);
  const nowDisabled = disabledDate(now2, {
    type: mode
  });
  const onInternalNow = /* @__PURE__ */ __name(() => {
    if (!nowDisabled) {
      const validateNow = getValidTime(now2);
      onNow(validateNow);
    }
  }, "onInternalNow");
  const nowPrefixCls = `${prefixCls}-now`;
  const nowBtnPrefixCls = `${nowPrefixCls}-btn`;
  const presetNode = showNow && /* @__PURE__ */ React234.createElement("li", { className: nowPrefixCls }, /* @__PURE__ */ React234.createElement(
    "a",
    {
      className: (0, import_classnames76.default)(nowBtnPrefixCls, nowDisabled && `${nowBtnPrefixCls}-disabled`),
      "aria-disabled": nowDisabled,
      onClick: onInternalNow
    },
    internalMode === "date" ? locale6.today : locale6.now
  ));
  const okNode = needConfirm && /* @__PURE__ */ React234.createElement("li", { className: `${prefixCls}-ok` }, /* @__PURE__ */ React234.createElement(Button2, { disabled: invalid, onClick: onSubmit }, locale6.ok));
  const rangeNode = (presetNode || okNode) && /* @__PURE__ */ React234.createElement("ul", { className: `${prefixCls}-ranges` }, presetNode, okNode);
  if (!extraNode && !rangeNode) {
    return null;
  }
  return /* @__PURE__ */ React234.createElement("div", { className: `${prefixCls}-footer` }, extraNode && /* @__PURE__ */ React234.createElement("div", { className: `${prefixCls}-footer-extra` }, extraNode), rangeNode);
}
__name(Footer2, "Footer");

// packages/picker/src/PickerInput/Popup/PopupPanel.tsx
import * as React250 from "react";

// packages/picker/src/PickerPanel/index.tsx
var import_classnames83 = __toESM(require_classnames());
import * as React249 from "react";

// packages/picker/src/hooks/useToggleDates.ts
function useToggleDates(generateConfig2, locale6, panelMode) {
  function toggleDates(list, target) {
    const index3 = list.findIndex((date4) => isSame(generateConfig2, locale6, date4, target, panelMode));
    if (index3 === -1) {
      return [...list, target];
    }
    const sliceList = [...list];
    sliceList.splice(index3, 1);
    return sliceList;
  }
  __name(toggleDates, "toggleDates");
  return toggleDates;
}
__name(useToggleDates, "useToggleDates");

// packages/picker/src/PickerPanel/context.ts
import * as React235 from "react";
var PanelContext = React235.createContext(null);
function usePanelContext() {
  return React235.useContext(PanelContext);
}
__name(usePanelContext, "usePanelContext");
function useInfo(props, panelType) {
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale6,
    disabledDate,
    minDate,
    maxDate,
    cellRender,
    hoverValue,
    hoverRangeValue,
    onHover,
    values,
    pickerValue,
    onSelect,
    // Icons
    prevIcon,
    nextIcon,
    superPrevIcon,
    superNextIcon
  } = props;
  const now2 = generateConfig2.getNow();
  const info = {
    now: now2,
    values,
    pickerValue,
    prefixCls,
    disabledDate,
    minDate,
    maxDate,
    cellRender,
    hoverValue,
    hoverRangeValue,
    onHover,
    locale: locale6,
    generateConfig: generateConfig2,
    onSelect,
    panelType,
    // Icons
    prevIcon,
    nextIcon,
    superPrevIcon,
    superNextIcon
  };
  return [info, now2];
}
__name(useInfo, "useInfo");
var PickerHackContext = React235.createContext({});
if (true) {
  PickerHackContext.displayName = "PickerHackContext";
}

// packages/picker/src/PickerPanel/DatePanel/index.tsx
var import_classnames79 = __toESM(require_classnames());
import * as React238 from "react";

// packages/picker/src/PickerPanel/PanelBody.tsx
var import_classnames77 = __toESM(require_classnames());
import * as React236 from "react";
function PanelBody(props) {
  const {
    rowNum,
    colNum,
    baseDate,
    getCellDate,
    prefixColumn,
    rowClassName,
    titleFormat,
    getCellText,
    getCellClassName,
    headerCells,
    cellSelection = true,
    disabledDate
  } = props;
  const {
    prefixCls,
    panelType: type5,
    now: now2,
    disabledDate: contextDisabledDate,
    cellRender,
    onHover,
    hoverValue,
    hoverRangeValue,
    generateConfig: generateConfig2,
    values,
    locale: locale6,
    onSelect
  } = usePanelContext();
  const mergedDisabledDate = disabledDate || contextDisabledDate;
  const cellPrefixCls = `${prefixCls}-cell`;
  const { onCellDblClick } = React236.useContext(PickerHackContext);
  const matchValues = /* @__PURE__ */ __name((date4) => values.some(
    (singleValue) => singleValue && isSame(generateConfig2, locale6, date4, singleValue, type5)
  ), "matchValues");
  const rows = [];
  for (let row = 0; row < rowNum; row += 1) {
    const rowNode = [];
    let rowStartDate;
    for (let col = 0; col < colNum; col += 1) {
      const offset3 = row * colNum + col;
      const currentDate = getCellDate(baseDate, offset3);
      const disabled = mergedDisabledDate?.(currentDate, {
        type: type5
      });
      if (col === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          rowNode.push(prefixColumn(rowStartDate));
        }
      }
      let inRange = false;
      let rangeStart = false;
      let rangeEnd = false;
      if (cellSelection && hoverRangeValue) {
        const [hoverStart, hoverEnd] = hoverRangeValue;
        inRange = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
        rangeStart = isSame(generateConfig2, locale6, currentDate, hoverStart, type5);
        rangeEnd = isSame(generateConfig2, locale6, currentDate, hoverEnd, type5);
      }
      const title = titleFormat ? formatValue(currentDate, {
        locale: locale6,
        format: titleFormat,
        generateConfig: generateConfig2
      }) : void 0;
      const inner = /* @__PURE__ */ React236.createElement("div", { className: `${cellPrefixCls}-inner` }, getCellText(currentDate));
      rowNode.push(
        /* @__PURE__ */ React236.createElement(
          "td",
          {
            key: col,
            title,
            className: (0, import_classnames77.default)(cellPrefixCls, {
              [`${cellPrefixCls}-disabled`]: disabled,
              [`${cellPrefixCls}-hover`]: (hoverValue || []).some(
                (date4) => isSame(generateConfig2, locale6, currentDate, date4, type5)
              ),
              [`${cellPrefixCls}-in-range`]: inRange && !rangeStart && !rangeEnd,
              [`${cellPrefixCls}-range-start`]: rangeStart,
              [`${cellPrefixCls}-range-end`]: rangeEnd,
              [`${prefixCls}-cell-selected`]: !hoverRangeValue && // WeekPicker use row instead
              type5 !== "week" && matchValues(currentDate),
              ...getCellClassName(currentDate)
            }),
            onClick: () => {
              if (!disabled) {
                onSelect(currentDate);
              }
            },
            onDoubleClick: () => {
              if (!disabled && onCellDblClick) {
                onCellDblClick();
              }
            },
            onMouseEnter: () => {
              if (!disabled) {
                onHover?.(currentDate);
              }
            },
            onMouseLeave: () => {
              if (!disabled) {
                onHover?.(null);
              }
            }
          },
          cellRender ? cellRender(currentDate, {
            prefixCls,
            originNode: inner,
            today: now2,
            type: type5,
            locale: locale6
          }) : inner
        )
      );
    }
    rows.push(
      /* @__PURE__ */ React236.createElement("tr", { key: row, className: rowClassName?.(rowStartDate) }, rowNode)
    );
  }
  return /* @__PURE__ */ React236.createElement("div", { className: `${prefixCls}-body` }, /* @__PURE__ */ React236.createElement("table", { className: `${prefixCls}-content` }, headerCells && /* @__PURE__ */ React236.createElement("thead", null, /* @__PURE__ */ React236.createElement("tr", null, headerCells)), /* @__PURE__ */ React236.createElement("tbody", null, rows)));
}
__name(PanelBody, "PanelBody");

// packages/picker/src/PickerPanel/PanelHeader.tsx
var import_classnames78 = __toESM(require_classnames());
import * as React237 from "react";
var HIDDEN_STYLE = {
  visibility: "hidden"
};
function PanelHeader(props) {
  const {
    offset: offset3,
    superOffset,
    onChange,
    getStart,
    getEnd,
    children
  } = props;
  const {
    prefixCls,
    // Icons
    prevIcon = "\u2039",
    nextIcon = "\u203A",
    superPrevIcon = "\xAB",
    superNextIcon = "\xBB",
    // Limitation
    minDate,
    maxDate,
    generateConfig: generateConfig2,
    locale: locale6,
    pickerValue,
    panelType: type5
  } = usePanelContext();
  const headerPrefixCls = `${prefixCls}-header`;
  const { hidePrev, hideNext, hideHeader } = React237.useContext(PickerHackContext);
  const disabledOffsetPrev = React237.useMemo(() => {
    if (!minDate || !offset3 || !getEnd) {
      return false;
    }
    const prevPanelLimitDate = getEnd(offset3(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, prevPanelLimitDate, minDate, type5);
  }, [minDate, offset3, pickerValue, getEnd, generateConfig2, locale6, type5]);
  const disabledSuperOffsetPrev = React237.useMemo(() => {
    if (!minDate || !superOffset || !getEnd) {
      return false;
    }
    const prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, prevPanelLimitDate, minDate, type5);
  }, [minDate, superOffset, pickerValue, getEnd, generateConfig2, locale6, type5]);
  const disabledOffsetNext = React237.useMemo(() => {
    if (!maxDate || !offset3 || !getStart) {
      return false;
    }
    const nextPanelLimitDate = getStart(offset3(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, maxDate, nextPanelLimitDate, type5);
  }, [maxDate, offset3, pickerValue, getStart, generateConfig2, locale6, type5]);
  const disabledSuperOffsetNext = React237.useMemo(() => {
    if (!maxDate || !superOffset || !getStart) {
      return false;
    }
    const nextPanelLimitDate = getStart(superOffset(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, maxDate, nextPanelLimitDate, type5);
  }, [maxDate, superOffset, pickerValue, getStart, generateConfig2, locale6, type5]);
  const onOffset = /* @__PURE__ */ __name((distance) => {
    if (offset3) {
      onChange(offset3(distance, pickerValue));
    }
  }, "onOffset");
  const onSuperOffset = /* @__PURE__ */ __name((distance) => {
    if (superOffset) {
      onChange(superOffset(distance, pickerValue));
    }
  }, "onSuperOffset");
  if (hideHeader) {
    return null;
  }
  const prevBtnCls = `${headerPrefixCls}-prev-btn`;
  const nextBtnCls = `${headerPrefixCls}-next-btn`;
  const superPrevBtnCls = `${headerPrefixCls}-super-prev-btn`;
  const superNextBtnCls = `${headerPrefixCls}-super-next-btn`;
  return /* @__PURE__ */ React237.createElement("div", { className: headerPrefixCls }, superOffset && /* @__PURE__ */ React237.createElement(
    "button",
    {
      type: "button",
      onClick: () => onSuperOffset(-1),
      tabIndex: -1,
      className: (0, import_classnames78.default)(
        superPrevBtnCls,
        disabledSuperOffsetPrev && `${superPrevBtnCls}-disabled`
      ),
      disabled: disabledSuperOffsetPrev,
      style: hidePrev ? HIDDEN_STYLE : {}
    },
    superPrevIcon
  ), offset3 && /* @__PURE__ */ React237.createElement(
    "button",
    {
      type: "button",
      onClick: () => onOffset(-1),
      tabIndex: -1,
      className: (0, import_classnames78.default)(prevBtnCls, disabledOffsetPrev && `${prevBtnCls}-disabled`),
      disabled: disabledOffsetPrev,
      style: hidePrev ? HIDDEN_STYLE : {}
    },
    prevIcon
  ), /* @__PURE__ */ React237.createElement("div", { className: `${headerPrefixCls}-view` }, children), offset3 && /* @__PURE__ */ React237.createElement(
    "button",
    {
      type: "button",
      onClick: () => onOffset(1),
      tabIndex: -1,
      className: (0, import_classnames78.default)(nextBtnCls, disabledOffsetNext && `${nextBtnCls}-disabled`),
      disabled: disabledOffsetNext,
      style: hideNext ? HIDDEN_STYLE : {}
    },
    nextIcon
  ), superOffset && /* @__PURE__ */ React237.createElement(
    "button",
    {
      type: "button",
      onClick: () => onSuperOffset(1),
      tabIndex: -1,
      className: (0, import_classnames78.default)(
        superNextBtnCls,
        disabledSuperOffsetNext && `${superNextBtnCls}-disabled`
      ),
      disabled: disabledSuperOffsetNext,
      style: hideNext ? HIDDEN_STYLE : {}
    },
    superNextIcon
  ));
}
__name(PanelHeader, "PanelHeader");
var PanelHeader_default = PanelHeader;

// packages/picker/src/PickerPanel/DatePanel/index.tsx
function DatePanel(props) {
  const {
    prefixCls,
    panelName = "date",
    locale: locale6,
    generateConfig: generateConfig2,
    pickerValue,
    onPickerValueChange,
    onModeChange,
    mode = "date",
    disabledDate,
    onSelect,
    onHover,
    showWeek
  } = props;
  const panelPrefixCls = `${prefixCls}-${panelName}-panel`;
  const cellPrefixCls = `${prefixCls}-cell`;
  const isWeek = mode === "week";
  const [info, now2] = useInfo(props, mode);
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale6.locale);
  const monthStartDate = generateConfig2.setDate(pickerValue, 1);
  const baseDate = getWeekStartDate(locale6.locale, generateConfig2, monthStartDate);
  const month = generateConfig2.getMonth(pickerValue);
  const prefixColumn = isWeek || showWeek ? (date4) => {
    const disabled = disabledDate?.(date4, { type: "week" });
    return /* @__PURE__ */ React238.createElement(
      "td",
      {
        key: "week",
        className: (0, import_classnames79.default)(cellPrefixCls, `${cellPrefixCls}-week`, {
          [`${cellPrefixCls}-disabled`]: disabled
        }),
        onClick: () => {
          if (!disabled) {
            onSelect(date4);
          }
        },
        onMouseEnter: () => {
          if (!disabled) {
            onHover?.(date4);
          }
        },
        onMouseLeave: () => {
          if (!disabled) {
            onHover?.(null);
          }
        }
      },
      /* @__PURE__ */ React238.createElement("div", { className: `${cellPrefixCls}-inner` }, generateConfig2.locale.getWeek(locale6.locale, date4))
    );
  } : null;
  const headerCells = [];
  const weekDaysLocale = locale6.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale6.locale) : []);
  if (prefixColumn) {
    headerCells.push(/* @__PURE__ */ React238.createElement("th", { key: "empty", "aria-label": "empty cell" }));
  }
  for (let i = 0; i < WEEK_DAY_COUNT; i += 1) {
    headerCells.push(/* @__PURE__ */ React238.createElement("th", { key: i }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
  }
  const getCellDate = /* @__PURE__ */ __name((date4, offset3) => {
    return generateConfig2.addDate(date4, offset3);
  }, "getCellDate");
  const getCellText = /* @__PURE__ */ __name((date4) => {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellDateFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText");
  const getCellClassName = /* @__PURE__ */ __name((date4) => {
    const classObj = {
      [`${prefixCls}-cell-in-view`]: isSameMonth(generateConfig2, date4, pickerValue),
      [`${prefixCls}-cell-today`]: isSameDate(generateConfig2, date4, now2)
    };
    return classObj;
  }, "getCellClassName");
  const monthsLocale = locale6.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale6.locale) : []);
  const yearNode = /* @__PURE__ */ React238.createElement(
    "button",
    {
      type: "button",
      key: "year",
      onClick: () => {
        onModeChange("year", pickerValue);
      },
      tabIndex: -1,
      className: `${prefixCls}-year-btn`
    },
    formatValue(pickerValue, {
      locale: locale6,
      format: locale6.yearFormat,
      generateConfig: generateConfig2
    })
  );
  const monthNode = /* @__PURE__ */ React238.createElement(
    "button",
    {
      type: "button",
      key: "month",
      onClick: () => {
        onModeChange("month", pickerValue);
      },
      tabIndex: -1,
      className: `${prefixCls}-month-btn`
    },
    locale6.monthFormat ? formatValue(pickerValue, {
      locale: locale6,
      format: locale6.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[month]
  );
  const monthYearNodes = locale6.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return /* @__PURE__ */ React238.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React238.createElement("div", { className: (0, import_classnames79.default)(panelPrefixCls, showWeek && `${panelPrefixCls}-show-week`) }, /* @__PURE__ */ React238.createElement(
    PanelHeader_default,
    {
      offset: (distance) => generateConfig2.addMonth(pickerValue, distance),
      superOffset: (distance) => generateConfig2.addYear(pickerValue, distance),
      onChange: onPickerValueChange,
      getStart: (date4) => generateConfig2.setDate(date4, 1),
      getEnd: (date4) => {
        let clone = generateConfig2.setDate(date4, 1);
        clone = generateConfig2.addMonth(clone, 1);
        return generateConfig2.addDate(clone, -1);
      }
    },
    monthYearNodes
  ), /* @__PURE__ */ React238.createElement(
    PanelBody,
    {
      titleFormat: locale6.fieldDateFormat,
      ...props,
      colNum: WEEK_DAY_COUNT,
      rowNum: 6,
      baseDate,
      headerCells,
      getCellDate,
      getCellText,
      getCellClassName,
      prefixColumn,
      cellSelection: !isWeek
    }
  )));
}
__name(DatePanel, "DatePanel");

// packages/picker/src/PickerPanel/DateTimePanel/index.tsx
import * as React243 from "react";

// packages/picker/src/PickerPanel/TimePanel/index.tsx
var import_classnames81 = __toESM(require_classnames());
import * as React242 from "react";

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/index.tsx
import * as React241 from "react";

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/TimeColumn.tsx
var import_classnames80 = __toESM(require_classnames());
import * as React240 from "react";

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/useScrollTo.ts
import * as React239 from "react";
var SPEED_PTG = 1 / 3;
function useScrollTo2(ulRef, value) {
  const scrollingRef = React239.useRef(false);
  const scrollRafRef = React239.useRef(null);
  const scrollDistRef = React239.useRef(null);
  const isScrolling = /* @__PURE__ */ __name(() => scrollingRef.current, "isScrolling");
  const stopScroll = /* @__PURE__ */ __name(() => {
    raf_default.cancel(scrollRafRef.current);
    scrollingRef.current = false;
  }, "stopScroll");
  const scrollRafTimesRef = React239.useRef();
  const startScroll = /* @__PURE__ */ __name(() => {
    const ul = ulRef.current;
    scrollDistRef.current = null;
    scrollRafTimesRef.current = 0;
    if (ul) {
      const targetLi = ul.querySelector(`[data-value="${value}"]`);
      const firstLi = ul.querySelector(`li`);
      const doScroll = /* @__PURE__ */ __name(() => {
        stopScroll();
        scrollingRef.current = true;
        scrollRafTimesRef.current += 1;
        const { scrollTop: currentTop } = ul;
        const firstLiTop = firstLi.offsetTop;
        const targetLiTop = targetLi.offsetTop;
        const targetTop = targetLiTop - firstLiTop;
        if (targetLiTop === 0 && targetLi !== firstLi || !isVisible_default(ul)) {
          if (scrollRafTimesRef.current <= 5) {
            scrollRafRef.current = raf_default(doScroll);
          }
          return;
        }
        const nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
        const dist = Math.abs(targetTop - nextTop);
        if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
          stopScroll();
          return;
        }
        scrollDistRef.current = dist;
        if (dist <= 1) {
          ul.scrollTop = targetTop;
          stopScroll();
          return;
        }
        ul.scrollTop = nextTop;
        scrollRafRef.current = raf_default(doScroll);
      }, "doScroll");
      if (targetLi && firstLi) {
        doScroll();
      }
    }
  }, "startScroll");
  const syncScroll = useEvent(startScroll);
  return [syncScroll, stopScroll, isScrolling];
}
__name(useScrollTo2, "useScrollTo");

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/TimeColumn.tsx
var SCROLL_DELAY = 300;
function TimeColumn(props) {
  const { units, value, optionalValue, type: type5, onChange, onDblClick, changeOnScroll } = props;
  const { prefixCls, cellRender, now: now2, locale: locale6 } = usePanelContext();
  const panelPrefixCls = `${prefixCls}-time-panel`;
  const cellPrefixCls = `${prefixCls}-time-panel-cell`;
  const ulRef = React240.useRef(null);
  const checkDelayRef = React240.useRef();
  const clearDelayCheck = /* @__PURE__ */ __name(() => {
    clearTimeout(checkDelayRef.current);
  }, "clearDelayCheck");
  const [syncScroll, stopScroll, isScrolling] = useScrollTo2(ulRef, value ?? optionalValue);
  useLayoutEffect_default(() => {
    syncScroll();
    clearDelayCheck();
    return () => {
      stopScroll();
      clearDelayCheck();
    };
  }, [value, optionalValue, units]);
  const onInternalScroll = /* @__PURE__ */ __name((event) => {
    clearDelayCheck();
    const target = event.target;
    if (!isScrolling() && changeOnScroll) {
      checkDelayRef.current = setTimeout(() => {
        const ul = ulRef.current;
        const firstLiTop = ul.querySelector(`li`).offsetTop;
        const liList = Array.from(ul.querySelectorAll(`li`));
        const liTopList = liList.map((li) => li.offsetTop - firstLiTop);
        const liDistList = liTopList.map((top, index3) => {
          if (units[index3].disabled) {
            return Number.MAX_SAFE_INTEGER;
          }
          return Math.abs(top - target.scrollTop);
        });
        const minDist = Math.min(...liDistList);
        const minDistIndex = liDistList.findIndex((dist) => dist === minDist);
        const targetUnit = units[minDistIndex];
        if (targetUnit && !targetUnit.disabled) {
          onChange(targetUnit.value);
        }
      }, SCROLL_DELAY);
    }
  }, "onInternalScroll");
  const columnPrefixCls = `${panelPrefixCls}-column`;
  return /* @__PURE__ */ React240.createElement("ul", { className: columnPrefixCls, ref: ulRef, "data-type": type5, onScroll: onInternalScroll }, units.map(({ label, value: unitValue, disabled }) => {
    const inner = /* @__PURE__ */ React240.createElement("div", { className: `${cellPrefixCls}-inner` }, label);
    return /* @__PURE__ */ React240.createElement(
      "li",
      {
        key: unitValue,
        className: (0, import_classnames80.default)(cellPrefixCls, {
          [`${cellPrefixCls}-selected`]: value === unitValue,
          [`${cellPrefixCls}-disabled`]: disabled
        }),
        onClick: () => {
          if (!disabled) {
            onChange(unitValue);
          }
        },
        onDoubleClick: () => {
          if (!disabled && onDblClick) {
            onDblClick();
          }
        },
        "data-value": unitValue
      },
      cellRender ? cellRender(unitValue, {
        prefixCls,
        originNode: inner,
        today: now2,
        type: "time",
        subType: type5,
        locale: locale6
      }) : inner
    );
  }));
}
__name(TimeColumn, "TimeColumn");

// packages/picker/src/PickerPanel/TimePanel/TimePanelBody/index.tsx
function isAM(hour) {
  return hour < 12;
}
__name(isAM, "isAM");
function TimePanelBody(props) {
  const {
    // Show Config
    showHour,
    showMinute,
    showSecond,
    showMillisecond,
    use12Hours: showMeridiem,
    // MISC
    changeOnScroll
  } = props;
  const { prefixCls, values, generateConfig: generateConfig2, locale: locale6, onSelect, pickerValue } = usePanelContext();
  const value = values?.[0] || null;
  const { onCellDblClick } = React241.useContext(PickerHackContext);
  const [getValidTime, rowHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits] = useTimeInfo(generateConfig2, props, value);
  const getUnitValue2 = /* @__PURE__ */ __name((func) => {
    const valueUnitVal = value && generateConfig2[func](value);
    const pickerUnitValue = pickerValue && generateConfig2[func](pickerValue);
    return [valueUnitVal, pickerUnitValue];
  }, "getUnitValue");
  const [hour, pickerHour] = getUnitValue2("getHour");
  const [minute, pickerMinute] = getUnitValue2("getMinute");
  const [second, pickerSecond] = getUnitValue2("getSecond");
  const [millisecond, pickerMillisecond] = getUnitValue2("getMillisecond");
  const meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
  const hourUnits = React241.useMemo(() => {
    if (!showMeridiem) {
      return rowHourUnits;
    }
    return isAM(hour) ? rowHourUnits.filter((h) => isAM(h.value)) : rowHourUnits.filter((h) => !isAM(h.value));
  }, [hour, rowHourUnits, showMeridiem]);
  const getEnabled = /* @__PURE__ */ __name((units, val) => {
    const enabledUnits = units.filter((unit3) => !unit3.disabled);
    return val ?? // Fallback to enabled value
    enabledUnits?.[0]?.value;
  }, "getEnabled");
  const validHour = getEnabled(rowHourUnits, hour);
  const minuteUnits = React241.useMemo(() => getMinuteUnits(validHour), [getMinuteUnits, validHour]);
  const validMinute = getEnabled(minuteUnits, minute);
  const secondUnits = React241.useMemo(
    () => getSecondUnits(validHour, validMinute),
    [getSecondUnits, validHour, validMinute]
  );
  const validSecond = getEnabled(secondUnits, second);
  const millisecondUnits = React241.useMemo(
    () => getMillisecondUnits(validHour, validMinute, validSecond),
    [getMillisecondUnits, validHour, validMinute, validSecond]
  );
  const validMillisecond = getEnabled(millisecondUnits, millisecond);
  const meridiemUnits = React241.useMemo(() => {
    if (!showMeridiem) {
      return [];
    }
    const base = generateConfig2.getNow();
    const amDate = generateConfig2.setHour(base, 6);
    const pmDate = generateConfig2.setHour(base, 18);
    const formatMeridiem = /* @__PURE__ */ __name((date4, defaultLabel) => {
      const { cellMeridiemFormat } = locale6;
      return cellMeridiemFormat ? formatValue(date4, {
        generateConfig: generateConfig2,
        locale: locale6,
        format: cellMeridiemFormat
      }) : defaultLabel;
    }, "formatMeridiem");
    return [
      {
        label: formatMeridiem(amDate, "AM"),
        value: "am",
        disabled: rowHourUnits.every((h) => h.disabled || !isAM(h.value))
      },
      {
        label: formatMeridiem(pmDate, "PM"),
        value: "pm",
        disabled: rowHourUnits.every((h) => h.disabled || isAM(h.value))
      }
    ];
  }, [rowHourUnits, showMeridiem, generateConfig2, locale6]);
  const triggerChange = /* @__PURE__ */ __name((nextDate) => {
    const validateDate = getValidTime(nextDate);
    onSelect(validateDate);
  }, "triggerChange");
  const triggerDateTmpl = React241.useMemo(() => {
    let tmpl = value || pickerValue || generateConfig2.getNow();
    const isNotNull = /* @__PURE__ */ __name((num) => num !== null && num !== void 0, "isNotNull");
    if (isNotNull(hour)) {
      tmpl = generateConfig2.setHour(tmpl, hour);
      tmpl = generateConfig2.setMinute(tmpl, minute);
      tmpl = generateConfig2.setSecond(tmpl, second);
      tmpl = generateConfig2.setMillisecond(tmpl, millisecond);
    } else if (isNotNull(pickerHour)) {
      tmpl = generateConfig2.setHour(tmpl, pickerHour);
      tmpl = generateConfig2.setMinute(tmpl, pickerMinute);
      tmpl = generateConfig2.setSecond(tmpl, pickerSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, pickerMillisecond);
    } else if (isNotNull(validHour)) {
      tmpl = generateConfig2.setHour(tmpl, validHour);
      tmpl = generateConfig2.setMinute(tmpl, validMinute);
      tmpl = generateConfig2.setSecond(tmpl, validSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, validMillisecond);
    }
    return tmpl;
  }, [
    value,
    pickerValue,
    hour,
    minute,
    second,
    millisecond,
    validHour,
    validMinute,
    validSecond,
    validMillisecond,
    pickerHour,
    pickerMinute,
    pickerSecond,
    pickerMillisecond,
    generateConfig2
  ]);
  const onHourChange = /* @__PURE__ */ __name((val) => {
    triggerChange(generateConfig2.setHour(triggerDateTmpl, val));
  }, "onHourChange");
  const onMinuteChange = /* @__PURE__ */ __name((val) => {
    triggerChange(generateConfig2.setMinute(triggerDateTmpl, val));
  }, "onMinuteChange");
  const onSecondChange = /* @__PURE__ */ __name((val) => {
    triggerChange(generateConfig2.setSecond(triggerDateTmpl, val));
  }, "onSecondChange");
  const onMillisecondChange = /* @__PURE__ */ __name((val) => {
    triggerChange(generateConfig2.setMillisecond(triggerDateTmpl, val));
  }, "onMillisecondChange");
  const onMeridiemChange = /* @__PURE__ */ __name((val) => {
    if (val === "am" && !isAM(hour)) {
      triggerChange(generateConfig2.setHour(triggerDateTmpl, hour - 12));
    } else if (val === "pm" && isAM(hour)) {
      triggerChange(generateConfig2.setHour(triggerDateTmpl, hour + 12));
    }
  }, "onMeridiemChange");
  const sharedColumnProps = {
    onDblClick: onCellDblClick,
    changeOnScroll
  };
  return /* @__PURE__ */ React241.createElement("div", { className: `${prefixCls}-content` }, showHour && /* @__PURE__ */ React241.createElement(
    TimeColumn,
    {
      units: hourUnits,
      value: hour,
      optionalValue: pickerHour,
      type: "hour",
      onChange: onHourChange,
      ...sharedColumnProps
    }
  ), showMinute && /* @__PURE__ */ React241.createElement(
    TimeColumn,
    {
      units: minuteUnits,
      value: minute,
      optionalValue: pickerMinute,
      type: "minute",
      onChange: onMinuteChange,
      ...sharedColumnProps
    }
  ), showSecond && /* @__PURE__ */ React241.createElement(
    TimeColumn,
    {
      units: secondUnits,
      value: second,
      optionalValue: pickerSecond,
      type: "second",
      onChange: onSecondChange,
      ...sharedColumnProps
    }
  ), showMillisecond && /* @__PURE__ */ React241.createElement(
    TimeColumn,
    {
      units: millisecondUnits,
      value: millisecond,
      optionalValue: pickerMillisecond,
      type: "millisecond",
      onChange: onMillisecondChange,
      ...sharedColumnProps
    }
  ), showMeridiem && /* @__PURE__ */ React241.createElement(
    TimeColumn,
    {
      units: meridiemUnits,
      value: meridiem,
      type: "meridiem",
      onChange: onMeridiemChange,
      ...sharedColumnProps
    }
  ));
}
__name(TimePanelBody, "TimePanelBody");

// packages/picker/src/PickerPanel/TimePanel/index.tsx
function TimePanel(props) {
  const {
    prefixCls,
    value,
    locale: locale6,
    generateConfig: generateConfig2,
    // Format
    showTime
  } = props;
  const { format: format2 } = showTime || {};
  const panelPrefixCls = `${prefixCls}-time-panel`;
  const [info] = useInfo(props, "time");
  return /* @__PURE__ */ React242.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React242.createElement("div", { className: (0, import_classnames81.default)(panelPrefixCls) }, /* @__PURE__ */ React242.createElement(PanelHeader_default, null, value ? formatValue(value, {
    locale: locale6,
    format: format2,
    generateConfig: generateConfig2
  }) : "\xA0"), /* @__PURE__ */ React242.createElement(TimePanelBody, { ...showTime })));
}
__name(TimePanel, "TimePanel");

// packages/picker/src/PickerPanel/DateTimePanel/index.tsx
function DateTimePanel(props) {
  const { prefixCls, generateConfig: generateConfig2, showTime, onSelect, value, pickerValue, onHover } = props;
  const panelPrefixCls = `${prefixCls}-datetime-panel`;
  const [getValidTime] = useTimeInfo(generateConfig2, showTime);
  const mergeTime = /* @__PURE__ */ __name((date4) => {
    if (value) {
      return fillTime(generateConfig2, date4, value);
    }
    return fillTime(generateConfig2, date4, pickerValue);
  }, "mergeTime");
  const onDateHover = /* @__PURE__ */ __name((date4) => {
    onHover(date4 ? mergeTime(date4) : date4);
  }, "onDateHover");
  const onDateSelect = /* @__PURE__ */ __name((date4) => {
    const cloneDate = mergeTime(date4);
    onSelect(getValidTime(cloneDate, cloneDate));
  }, "onDateSelect");
  return /* @__PURE__ */ React243.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ React243.createElement(DatePanel, { ...props, onSelect: onDateSelect, onHover: onDateHover }), /* @__PURE__ */ React243.createElement(TimePanel, { ...props }));
}
__name(DateTimePanel, "DateTimePanel");

// packages/picker/src/PickerPanel/DecadePanel/index.tsx
import * as React244 from "react";
function DecadePanel(props) {
  const { prefixCls, locale: locale6, generateConfig: generateConfig2, pickerValue, disabledDate, onPickerValueChange } = props;
  const panelPrefixCls = `${prefixCls}-decade-panel`;
  const [info] = useInfo(props, "decade");
  const getStartYear = /* @__PURE__ */ __name((date4) => {
    const startYear = Math.floor(generateConfig2.getYear(pickerValue) / 100) * 100;
    return generateConfig2.setYear(date4, startYear);
  }, "getStartYear");
  const getEndYear = /* @__PURE__ */ __name((date4) => {
    const startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 99);
  }, "getEndYear");
  const startYearDate = getStartYear(pickerValue);
  const endYearDate = getEndYear(pickerValue);
  const baseDate = generateConfig2.addYear(startYearDate, -10);
  const getCellDate = /* @__PURE__ */ __name((date4, offset3) => {
    return generateConfig2.addYear(date4, offset3 * 10);
  }, "getCellDate");
  const getCellText = /* @__PURE__ */ __name((date4) => {
    const cellYearFormat = locale6.cellYearFormat;
    const startYearStr = formatValue(date4, {
      locale: locale6,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    const endYearStr = formatValue(generateConfig2.addYear(date4, 9), {
      locale: locale6,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    return `${startYearStr}-${endYearStr}`;
  }, "getCellText");
  const getCellClassName = /* @__PURE__ */ __name((date4) => {
    return {
      [`${prefixCls}-cell-in-view`]: isSameDecade(generateConfig2, date4, startYearDate) || isSameDecade(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4)
    };
  }, "getCellClassName");
  const mergedDisabledDate = disabledDate ? (currentDate, disabledInfo) => {
    const baseStartDate = generateConfig2.setDate(currentDate, 1);
    const baseStartMonth = generateConfig2.setMonth(baseStartDate, 0);
    const baseStartYear = generateConfig2.setYear(
      baseStartMonth,
      Math.floor(generateConfig2.getYear(baseStartMonth) / 10) * 10
    );
    const baseEndYear = generateConfig2.addYear(baseStartYear, 10);
    const baseEndDate = generateConfig2.addDate(baseEndYear, -1);
    return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
  } : null;
  const yearNode = `${formatValue(startYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  })}-${formatValue(endYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  })}`;
  return /* @__PURE__ */ React244.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React244.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ React244.createElement(
    PanelHeader_default,
    {
      superOffset: (distance) => generateConfig2.addYear(pickerValue, distance * 100),
      onChange: onPickerValueChange,
      getStart: getStartYear,
      getEnd: getEndYear
    },
    yearNode
  ), /* @__PURE__ */ React244.createElement(
    PanelBody,
    {
      ...props,
      disabledDate: mergedDisabledDate,
      colNum: 3,
      rowNum: 4,
      baseDate,
      getCellDate,
      getCellText,
      getCellClassName
    }
  )));
}
__name(DecadePanel, "DecadePanel");

// packages/picker/src/PickerPanel/MonthPanel/index.tsx
import * as React245 from "react";
function MonthPanel(props) {
  const {
    prefixCls,
    locale: locale6,
    generateConfig: generateConfig2,
    pickerValue,
    disabledDate,
    onPickerValueChange,
    onModeChange
  } = props;
  const panelPrefixCls = `${prefixCls}-month-panel`;
  const [info] = useInfo(props, "month");
  const baseDate = generateConfig2.setMonth(pickerValue, 0);
  const monthsLocale = locale6.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale6.locale) : []);
  const getCellDate = /* @__PURE__ */ __name((date4, offset3) => {
    return generateConfig2.addMonth(date4, offset3);
  }, "getCellDate");
  const getCellText = /* @__PURE__ */ __name((date4) => {
    const month = generateConfig2.getMonth(date4);
    return locale6.monthFormat ? formatValue(date4, {
      locale: locale6,
      format: locale6.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[month];
  }, "getCellText");
  const getCellClassName = /* @__PURE__ */ __name(() => ({
    [`${prefixCls}-cell-in-view`]: true
  }), "getCellClassName");
  const mergedDisabledDate = disabledDate ? (currentDate, disabledInfo) => {
    const startDate = generateConfig2.setDate(currentDate, 1);
    const nextMonthStartDate = generateConfig2.setMonth(
      startDate,
      generateConfig2.getMonth(startDate) + 1
    );
    const endDate = generateConfig2.addDate(nextMonthStartDate, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null;
  const yearNode = /* @__PURE__ */ React245.createElement(
    "button",
    {
      type: "button",
      key: "year",
      onClick: () => {
        onModeChange("year");
      },
      tabIndex: -1,
      className: `${prefixCls}-year-btn`
    },
    formatValue(pickerValue, {
      locale: locale6,
      format: locale6.yearFormat,
      generateConfig: generateConfig2
    })
  );
  return /* @__PURE__ */ React245.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React245.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ React245.createElement(
    PanelHeader_default,
    {
      superOffset: (distance) => generateConfig2.addYear(pickerValue, distance),
      onChange: onPickerValueChange,
      getStart: (date4) => generateConfig2.setMonth(date4, 0),
      getEnd: (date4) => generateConfig2.setMonth(date4, 11)
    },
    yearNode
  ), /* @__PURE__ */ React245.createElement(
    PanelBody,
    {
      ...props,
      disabledDate: mergedDisabledDate,
      titleFormat: locale6.fieldMonthFormat,
      colNum: 3,
      rowNum: 4,
      baseDate,
      getCellDate,
      getCellText,
      getCellClassName
    }
  )));
}
__name(MonthPanel, "MonthPanel");

// packages/picker/src/PickerPanel/QuarterPanel/index.tsx
import * as React246 from "react";
function QuarterPanel(props) {
  const { prefixCls, locale: locale6, generateConfig: generateConfig2, pickerValue, onPickerValueChange, onModeChange } = props;
  const panelPrefixCls = `${prefixCls}-quarter-panel`;
  const [info] = useInfo(props, "quarter");
  const baseDate = generateConfig2.setMonth(pickerValue, 0);
  const getCellDate = /* @__PURE__ */ __name((date4, offset3) => {
    return generateConfig2.addMonth(date4, offset3 * 3);
  }, "getCellDate");
  const getCellText = /* @__PURE__ */ __name((date4) => {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellQuarterFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText");
  const getCellClassName = /* @__PURE__ */ __name(() => ({
    [`${prefixCls}-cell-in-view`]: true
  }), "getCellClassName");
  const yearNode = /* @__PURE__ */ React246.createElement(
    "button",
    {
      type: "button",
      key: "year",
      onClick: () => {
        onModeChange("year");
      },
      tabIndex: -1,
      className: `${prefixCls}-year-btn`
    },
    formatValue(pickerValue, {
      locale: locale6,
      format: locale6.yearFormat,
      generateConfig: generateConfig2
    })
  );
  return /* @__PURE__ */ React246.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React246.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ React246.createElement(
    PanelHeader_default,
    {
      superOffset: (distance) => generateConfig2.addYear(pickerValue, distance),
      onChange: onPickerValueChange,
      getStart: (date4) => generateConfig2.setMonth(date4, 0),
      getEnd: (date4) => generateConfig2.setMonth(date4, 11)
    },
    yearNode
  ), /* @__PURE__ */ React246.createElement(
    PanelBody,
    {
      ...props,
      titleFormat: locale6.fieldQuarterFormat,
      colNum: 4,
      rowNum: 1,
      baseDate,
      getCellDate,
      getCellText,
      getCellClassName
    }
  )));
}
__name(QuarterPanel, "QuarterPanel");

// packages/picker/src/PickerPanel/WeekPanel/index.tsx
var import_classnames82 = __toESM(require_classnames());
import * as React247 from "react";
function WeekPanel(props) {
  const { prefixCls, generateConfig: generateConfig2, locale: locale6, value, hoverValue, hoverRangeValue } = props;
  const localeName = locale6.locale;
  const rowPrefixCls = `${prefixCls}-week-panel-row`;
  const rowClassName = /* @__PURE__ */ __name((currentDate) => {
    const rangeCls = {};
    if (hoverRangeValue) {
      const [rangeStart, rangeEnd] = hoverRangeValue;
      const isRangeStart = isSameWeek(generateConfig2, localeName, rangeStart, currentDate);
      const isRangeEnd = isSameWeek(generateConfig2, localeName, rangeEnd, currentDate);
      rangeCls[`${rowPrefixCls}-range-start`] = isRangeStart;
      rangeCls[`${rowPrefixCls}-range-end`] = isRangeEnd;
      rangeCls[`${rowPrefixCls}-range-hover`] = !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, currentDate);
    }
    if (hoverValue) {
      rangeCls[`${rowPrefixCls}-hover`] = hoverValue.some(
        (date4) => isSameWeek(generateConfig2, localeName, currentDate, date4)
      );
    }
    return (0, import_classnames82.default)(
      rowPrefixCls,
      {
        [`${rowPrefixCls}-selected`]: !hoverRangeValue && isSameWeek(generateConfig2, localeName, value, currentDate)
      },
      // Patch for hover range
      rangeCls
    );
  }, "rowClassName");
  return /* @__PURE__ */ React247.createElement(DatePanel, { ...props, mode: "week", panelName: "week", rowClassName });
}
__name(WeekPanel, "WeekPanel");

// packages/picker/src/PickerPanel/YearPanel/index.tsx
import * as React248 from "react";
function YearPanel(props) {
  const {
    prefixCls,
    locale: locale6,
    generateConfig: generateConfig2,
    pickerValue,
    disabledDate,
    onPickerValueChange,
    onModeChange
  } = props;
  const panelPrefixCls = `${prefixCls}-year-panel`;
  const [info] = useInfo(props, "year");
  const getStartYear = /* @__PURE__ */ __name((date4) => {
    const startYear = Math.floor(generateConfig2.getYear(pickerValue) / 10) * 10;
    return generateConfig2.setYear(date4, startYear);
  }, "getStartYear");
  const getEndYear = /* @__PURE__ */ __name((date4) => {
    const startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 9);
  }, "getEndYear");
  const startYearDate = getStartYear(pickerValue);
  const endYearDate = getEndYear(pickerValue);
  const baseDate = generateConfig2.addYear(startYearDate, -1);
  const getCellDate = /* @__PURE__ */ __name((date4, offset3) => {
    return generateConfig2.addYear(date4, offset3);
  }, "getCellDate");
  const getCellText = /* @__PURE__ */ __name((date4) => {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellYearFormat,
      generateConfig: generateConfig2
    });
  }, "getCellText");
  const getCellClassName = /* @__PURE__ */ __name((date4) => {
    return {
      [`${prefixCls}-cell-in-view`]: isSameYear(generateConfig2, date4, startYearDate) || isSameYear(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4)
    };
  }, "getCellClassName");
  const mergedDisabledDate = disabledDate ? (currentDate, disabledInfo) => {
    const startMonth = generateConfig2.setMonth(currentDate, 0);
    const startDate = generateConfig2.setDate(startMonth, 1);
    const endMonth = generateConfig2.setMonth(
      currentDate,
      generateConfig2.getMonth(currentDate) + 1
    );
    const enDate = generateConfig2.addDate(endMonth, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(enDate, disabledInfo);
  } : null;
  const yearNode = /* @__PURE__ */ React248.createElement(
    "button",
    {
      type: "button",
      key: "year",
      onClick: () => {
        onModeChange("decade");
      },
      tabIndex: -1,
      className: `${prefixCls}-decade-btn`
    },
    formatValue(startYearDate, {
      locale: locale6,
      format: locale6.yearFormat,
      generateConfig: generateConfig2
    }),
    "-",
    formatValue(endYearDate, {
      locale: locale6,
      format: locale6.yearFormat,
      generateConfig: generateConfig2
    })
  );
  return /* @__PURE__ */ React248.createElement(PanelContext.Provider, { value: info }, /* @__PURE__ */ React248.createElement("div", { className: panelPrefixCls }, /* @__PURE__ */ React248.createElement(
    PanelHeader_default,
    {
      superOffset: (distance) => generateConfig2.addYear(pickerValue, distance * 10),
      onChange: onPickerValueChange,
      getStart: getStartYear,
      getEnd: getEndYear
    },
    yearNode
  ), /* @__PURE__ */ React248.createElement(
    PanelBody,
    {
      ...props,
      disabledDate: mergedDisabledDate,
      titleFormat: locale6.fieldYearFormat,
      colNum: 3,
      rowNum: 4,
      baseDate,
      getCellDate,
      getCellText,
      getCellClassName
    }
  )));
}
__name(YearPanel, "YearPanel");

// packages/picker/src/PickerPanel/index.tsx
var DefaultComponents = {
  date: DatePanel,
  datetime: DateTimePanel,
  week: WeekPanel,
  month: MonthPanel,
  quarter: QuarterPanel,
  year: YearPanel,
  decade: DecadePanel,
  time: TimePanel
};
function PickerPanel(props, ref) {
  const {
    locale: locale6,
    generateConfig: generateConfig2,
    direction,
    // Style
    prefixCls,
    tabIndex = 0,
    // Value
    multiple,
    defaultValue,
    value,
    onChange,
    onSelect,
    // Picker control
    defaultPickerValue,
    pickerValue,
    onPickerValueChange,
    // Mode
    mode,
    onPanelChange,
    picker = "date",
    showTime,
    // Hover
    hoverValue,
    hoverRangeValue,
    // Cell
    cellRender,
    dateRender,
    monthCellRender,
    // Components
    components = {},
    hideHeader
  } = props;
  const mergedPrefixCls = React249.useContext(context_default6)?.prefixCls || prefixCls || "rc-picker";
  const rootRef = React249.useRef();
  React249.useImperativeHandle(ref, () => ({
    nativeElement: rootRef.current
  }));
  const [timeProps, localeTimeProps, showTimeFormat, propFormat] = getTimeProps(props);
  const filledLocale = useLocale2(locale6, localeTimeProps);
  const internalPicker = picker === "date" && showTime ? "datetime" : picker;
  const mergedShowTime = React249.useMemo(
    () => fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale),
    [internalPicker, showTimeFormat, propFormat, timeProps, filledLocale]
  );
  const now2 = generateConfig2.getNow();
  const [mergedMode, setMergedMode] = useMergedState(picker, {
    value: mode,
    postState: (val) => val || "date"
  });
  const internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  const toggleDates = useToggleDates(generateConfig2, locale6, internalPicker);
  const [innerValue, setMergedValue] = useMergedState(defaultValue, {
    value
  });
  const mergedValue = React249.useMemo(() => {
    const values = toArray5(innerValue).filter((val) => val);
    return multiple ? values : values.slice(0, 1);
  }, [innerValue, multiple]);
  const triggerChange = useEvent((nextValue) => {
    setMergedValue(nextValue);
    if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(
      (ori, index3) => !isSame(generateConfig2, locale6, ori, nextValue[index3], internalPicker)
    ))) {
      onChange?.(multiple ? nextValue : nextValue[0]);
    }
  });
  const onInternalSelect = useEvent((newDate) => {
    onSelect?.(newDate);
    if (mergedMode === picker) {
      const nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
      triggerChange(nextValues);
    }
  });
  const [mergedPickerValue, setInternalPickerValue] = useMergedState(
    defaultPickerValue || mergedValue[0] || now2,
    {
      value: pickerValue
    }
  );
  React249.useEffect(() => {
    if (mergedValue[0] && !pickerValue) {
      setInternalPickerValue(mergedValue[0]);
    }
  }, [mergedValue[0]]);
  const triggerPanelChange = /* @__PURE__ */ __name((viewDate, nextMode) => {
    onPanelChange?.(viewDate || pickerValue, nextMode || mergedMode);
  }, "triggerPanelChange");
  const setPickerValue = /* @__PURE__ */ __name((nextPickerValue, triggerPanelEvent = false) => {
    setInternalPickerValue(nextPickerValue);
    onPickerValueChange?.(nextPickerValue);
    if (triggerPanelEvent) {
      triggerPanelChange(nextPickerValue);
    }
  }, "setPickerValue");
  const triggerModeChange = /* @__PURE__ */ __name((nextMode, viewDate) => {
    setMergedMode(nextMode);
    if (viewDate) {
      setPickerValue(viewDate);
    }
    triggerPanelChange(viewDate, nextMode);
  }, "triggerModeChange");
  const onPanelValueSelect = /* @__PURE__ */ __name((nextValue) => {
    onInternalSelect(nextValue);
    setPickerValue(nextValue);
    if (mergedMode !== picker) {
      const decadeYearQueue = ["decade", "year"];
      const decadeYearMonthQueue = [...decadeYearQueue, "month"];
      const pickerQueue = {
        quarter: [...decadeYearQueue, "quarter"],
        week: [...decadeYearMonthQueue, "week"],
        date: [...decadeYearMonthQueue, "date"]
      };
      const queue = pickerQueue[picker] || decadeYearMonthQueue;
      const index3 = queue.indexOf(mergedMode);
      const nextMode = queue[index3 + 1];
      if (nextMode) {
        triggerModeChange(nextMode, nextValue);
      }
    }
  }, "onPanelValueSelect");
  const hoverRangeDate = React249.useMemo(() => {
    let start;
    let end;
    if (Array.isArray(hoverRangeValue)) {
      [start, end] = hoverRangeValue;
    } else {
      start = hoverRangeValue;
    }
    if (!start && !end) {
      return null;
    }
    start = start || end;
    end = end || start;
    return generateConfig2.isAfter(start, end) ? [end, start] : [start, end];
  }, [hoverRangeValue, generateConfig2]);
  const onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  const PanelComponent = components[internalMode] || DefaultComponents[internalMode] || DatePanel;
  const parentHackContext = React249.useContext(PickerHackContext);
  const pickerPanelContext = React249.useMemo(
    () => ({ ...parentHackContext, hideHeader }),
    [parentHackContext, hideHeader]
  );
  if (true) {
    warning_default(
      !mergedValue || mergedValue.every((val) => generateConfig2.isValidate(val)),
      "Invalidate date pass to `value` or `defaultValue`."
    );
  }
  const panelCls = `${mergedPrefixCls}-panel`;
  const panelProps = pickProps(props, [
    // Week
    "showWeek",
    // Icons
    "prevIcon",
    "nextIcon",
    "superPrevIcon",
    "superNextIcon",
    // Disabled
    "disabledDate",
    "minDate",
    "maxDate",
    // Hover
    "onHover"
  ]);
  return /* @__PURE__ */ React249.createElement(PickerHackContext.Provider, { value: pickerPanelContext }, /* @__PURE__ */ React249.createElement(
    "div",
    {
      ref: rootRef,
      tabIndex,
      className: (0, import_classnames83.default)(panelCls, {
        [`${panelCls}-rtl`]: direction === "rtl"
      })
    },
    /* @__PURE__ */ React249.createElement(
      PanelComponent,
      {
        ...panelProps,
        showTime: mergedShowTime,
        prefixCls: mergedPrefixCls,
        locale: filledLocale,
        generateConfig: generateConfig2,
        onModeChange: triggerModeChange,
        pickerValue: mergedPickerValue,
        onPickerValueChange: (nextPickerValue) => {
          setPickerValue(nextPickerValue, true);
        },
        value: mergedValue[0],
        onSelect: onPanelValueSelect,
        values: mergedValue,
        cellRender: onInternalCellRender,
        hoverRangeValue: hoverRangeDate,
        hoverValue
      }
    )
  ));
}
__name(PickerPanel, "PickerPanel");
var RefPanelPicker = React249.memo(React249.forwardRef(PickerPanel));
if (true) {
  RefPanelPicker.displayName = "PanelPicker";
}
var PickerPanel_default = RefPanelPicker;

// packages/picker/src/PickerInput/Popup/PopupPanel.tsx
function PopupPanel(props) {
  const {
    picker,
    multiplePanel,
    pickerValue,
    onPickerValueChange,
    needConfirm,
    onSubmit,
    range: range3,
    hoverValue
  } = props;
  const { prefixCls, generateConfig: generateConfig2 } = React250.useContext(context_default6);
  const internalOffsetDate = React250.useCallback(
    (date4, offset3) => {
      return offsetPanelDate(generateConfig2, picker, date4, offset3);
    },
    [generateConfig2, picker]
  );
  const nextPickerValue = React250.useMemo(
    () => internalOffsetDate(pickerValue, 1),
    [pickerValue, internalOffsetDate]
  );
  const onSecondPickerValueChange = /* @__PURE__ */ __name((nextDate) => {
    onPickerValueChange(internalOffsetDate(nextDate, -1));
  }, "onSecondPickerValueChange");
  const sharedContext = {
    onCellDblClick: () => {
      if (needConfirm) {
        onSubmit();
      }
    }
  };
  const hideHeader = picker === "time";
  const pickerProps = {
    ...props,
    hoverValue: null,
    hoverRangeValue: null,
    hideHeader
  };
  if (range3) {
    pickerProps.hoverRangeValue = hoverValue;
  } else {
    pickerProps.hoverValue = hoverValue;
  }
  if (multiplePanel) {
    return /* @__PURE__ */ React250.createElement("div", { className: `${prefixCls}-panels` }, /* @__PURE__ */ React250.createElement(
      PickerHackContext.Provider,
      {
        value: {
          ...sharedContext,
          hideNext: true
        }
      },
      /* @__PURE__ */ React250.createElement(PickerPanel_default, { ...pickerProps })
    ), /* @__PURE__ */ React250.createElement(
      PickerHackContext.Provider,
      {
        value: {
          ...sharedContext,
          hidePrev: true
        }
      },
      /* @__PURE__ */ React250.createElement(
        PickerPanel_default,
        {
          ...pickerProps,
          pickerValue: nextPickerValue,
          onPickerValueChange: onSecondPickerValueChange
        }
      )
    ));
  }
  return /* @__PURE__ */ React250.createElement(
    PickerHackContext.Provider,
    {
      value: {
        ...sharedContext
      }
    },
    /* @__PURE__ */ React250.createElement(PickerPanel_default, { ...pickerProps })
  );
}
__name(PopupPanel, "PopupPanel");

// packages/picker/src/PickerInput/Popup/PresetPanel.tsx
import * as React251 from "react";
function executeValue(value) {
  return typeof value === "function" ? value() : value;
}
__name(executeValue, "executeValue");
function PresetPanel(props) {
  const { prefixCls, presets, onClick, onHover } = props;
  if (!presets.length) {
    return null;
  }
  return /* @__PURE__ */ React251.createElement("div", { className: `${prefixCls}-presets` }, /* @__PURE__ */ React251.createElement("ul", null, presets.map(({ label, value }, index3) => /* @__PURE__ */ React251.createElement(
    "li",
    {
      key: index3,
      onClick: () => {
        onClick(executeValue(value));
      },
      onMouseEnter: () => {
        onHover(executeValue(value));
      },
      onMouseLeave: () => {
        onHover(null);
      }
    },
    label
  ))));
}
__name(PresetPanel, "PresetPanel");

// packages/picker/src/PickerInput/Popup/index.tsx
function Popup3(props) {
  const {
    panelRender,
    internalMode,
    picker,
    showNow,
    // Range
    range: range3,
    multiple,
    activeOffset = 0,
    // Presets
    presets,
    onPresetHover,
    onPresetSubmit,
    // Focus
    onFocus,
    onBlur,
    // Direction
    direction,
    // Change
    value,
    onSelect,
    isInvalid,
    defaultOpenValue,
    onOk,
    onSubmit
  } = props;
  const { prefixCls } = React252.useContext(context_default6);
  const panelPrefixCls = `${prefixCls}-panel`;
  const rtl = direction === "rtl";
  const arrowRef = React252.useRef(null);
  const wrapperRef = React252.useRef(null);
  const [containerWidth, setContainerWidth] = React252.useState(0);
  const [containerOffset, setContainerOffset] = React252.useState(0);
  const onResize2 = /* @__PURE__ */ __name((info) => {
    if (info.offsetWidth) {
      setContainerWidth(info.offsetWidth);
    }
  }, "onResize");
  React252.useEffect(() => {
    if (range3) {
      const arrowWidth = arrowRef.current?.offsetWidth || 0;
      const maxOffset = containerWidth - arrowWidth;
      if (activeOffset <= maxOffset) {
        setContainerOffset(0);
      } else {
        setContainerOffset(activeOffset + arrowWidth - containerWidth);
      }
    }
  }, [containerWidth, activeOffset, range3]);
  function filterEmpty(list) {
    return list.filter((item) => item);
  }
  __name(filterEmpty, "filterEmpty");
  const valueList = React252.useMemo(() => filterEmpty(toArray5(value)), [value]);
  const isTimePickerEmptyValue = picker === "time" && !valueList.length;
  const footerSubmitValue = React252.useMemo(() => {
    if (isTimePickerEmptyValue) {
      return filterEmpty([defaultOpenValue]);
    }
    return valueList;
  }, [isTimePickerEmptyValue, valueList, defaultOpenValue]);
  const popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
  const disableSubmit = React252.useMemo(() => {
    if (!footerSubmitValue.length) {
      return true;
    }
    return footerSubmitValue.some((val) => isInvalid(val));
  }, [footerSubmitValue, isInvalid]);
  const onFooterSubmit = /* @__PURE__ */ __name(() => {
    if (isTimePickerEmptyValue) {
      onSelect(defaultOpenValue);
    }
    onOk();
    onSubmit();
  }, "onFooterSubmit");
  let mergedNodes = /* @__PURE__ */ React252.createElement("div", { className: `${prefixCls}-panel-layout` }, /* @__PURE__ */ React252.createElement(
    PresetPanel,
    {
      prefixCls,
      presets,
      onClick: onPresetSubmit,
      onHover: onPresetHover
    }
  ), /* @__PURE__ */ React252.createElement("div", null, /* @__PURE__ */ React252.createElement(PopupPanel, { ...props, value: popupPanelValue }), /* @__PURE__ */ React252.createElement(
    Footer2,
    {
      ...props,
      showNow: multiple ? false : showNow,
      invalid: disableSubmit,
      onSubmit: onFooterSubmit
    }
  )));
  if (panelRender) {
    mergedNodes = panelRender(mergedNodes);
  }
  const containerPrefixCls = `${panelPrefixCls}-container`;
  const marginLeft = "marginLeft";
  const marginRight = "marginRight";
  let renderNode = /* @__PURE__ */ React252.createElement(
    "div",
    {
      tabIndex: -1,
      className: (0, import_classnames84.default)(
        containerPrefixCls,
        // Used for Today Button style, safe to remove if no need
        `${prefixCls}-${internalMode}-panel-container`
      ),
      style: {
        [rtl ? marginRight : marginLeft]: containerOffset,
        [rtl ? marginLeft : marginRight]: "auto"
      },
      onFocus,
      onBlur
    },
    mergedNodes
  );
  if (range3) {
    renderNode = /* @__PURE__ */ React252.createElement(
      "div",
      {
        ref: wrapperRef,
        className: (0, import_classnames84.default)(`${prefixCls}-range-wrapper`, `${prefixCls}-${picker}-range-wrapper`)
      },
      /* @__PURE__ */ React252.createElement(
        "div",
        {
          ref: arrowRef,
          className: `${prefixCls}-range-arrow`,
          style: { [rtl ? "right" : "left"]: activeOffset }
        }
      ),
      /* @__PURE__ */ React252.createElement(src_default, { onResize: onResize2 }, renderNode)
    );
  }
  return renderNode;
}
__name(Popup3, "Popup");

// packages/picker/src/PickerInput/Selector/RangeSelector.tsx
var import_classnames86 = __toESM(require_classnames());
import * as React257 from "react";

// packages/picker/src/PickerInput/Selector/hooks/useInputProps.ts
import * as React253 from "react";
function useInputProps(props, postProps) {
  const {
    format: format2,
    maskFormat,
    generateConfig: generateConfig2,
    locale: locale6,
    preserveInvalidOnBlur,
    inputReadOnly,
    required: required5,
    "aria-required": ariaRequired,
    onSubmit,
    onFocus,
    onBlur,
    onInputChange,
    onInvalid,
    open: open3,
    onOpenChange,
    onKeyDown: onKeyDown2,
    onChange,
    activeHelp,
    name,
    autoComplete,
    id,
    value,
    invalid,
    placeholder,
    disabled,
    activeIndex,
    allHelp,
    picker
  } = props;
  const parseDate = /* @__PURE__ */ __name((str, formatStr) => {
    const parsed = generateConfig2.locale.parse(locale6.locale, str, [formatStr]);
    return parsed && generateConfig2.isValidate(parsed) ? parsed : null;
  }, "parseDate");
  const firstFormat = format2[0];
  const getText = React253.useCallback(
    (date4) => formatValue(date4, {
      locale: locale6,
      format: firstFormat,
      generateConfig: generateConfig2
    }),
    [locale6, generateConfig2, firstFormat]
  );
  const valueTexts = React253.useMemo(() => value.map(getText), [value, getText]);
  const size = React253.useMemo(() => {
    const defaultSize = picker === "time" ? 8 : 10;
    const length2 = typeof firstFormat === "function" ? firstFormat(generateConfig2.getNow()).length : firstFormat.length;
    return Math.max(defaultSize, length2) + 2;
  }, [firstFormat, picker, generateConfig2]);
  const validateFormat = /* @__PURE__ */ __name((text) => {
    for (let i = 0; i < format2.length; i += 1) {
      const singleFormat = format2[i];
      if (typeof singleFormat === "string") {
        const parsed = parseDate(text, singleFormat);
        if (parsed) {
          return parsed;
        }
      }
    }
    return false;
  }, "validateFormat");
  const getInputProps = /* @__PURE__ */ __name((index3) => {
    function getProp(propValue) {
      return index3 !== void 0 ? propValue[index3] : propValue;
    }
    __name(getProp, "getProp");
    const pickedAttrs = pickAttrs(props, {
      aria: true,
      data: true
    });
    const inputProps = {
      ...pickedAttrs,
      // ============== Shared ==============
      format: maskFormat,
      validateFormat: (text) => !!validateFormat(text),
      preserveInvalidOnBlur,
      readOnly: inputReadOnly,
      required: required5,
      "aria-required": ariaRequired,
      name,
      autoComplete,
      size,
      // ============= By Index =============
      id: getProp(id),
      value: getProp(valueTexts) || "",
      invalid: getProp(invalid),
      placeholder: getProp(placeholder),
      active: activeIndex === index3,
      helped: allHelp || activeHelp && activeIndex === index3,
      disabled: getProp(disabled),
      onFocus: (event) => {
        onFocus(event, index3);
      },
      onBlur: (event) => {
        onBlur(event, index3);
      },
      onSubmit,
      // Get validate text value
      onChange: (text) => {
        onInputChange();
        const parsed = validateFormat(text);
        if (parsed) {
          onInvalid(false, index3);
          onChange(parsed, index3);
          return;
        }
        onInvalid(!!text, index3);
      },
      onHelp: () => {
        onOpenChange(true, {
          index: index3
        });
      },
      onKeyDown: (event) => {
        let prevented = false;
        onKeyDown2?.(event, () => {
          if (true) {
            warning_default(
              false,
              "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly."
            );
          }
          prevented = true;
        });
        if (!event.defaultPrevented && !prevented) {
          switch (event.key) {
            case "Escape":
              onOpenChange(false, {
                index: index3
              });
              break;
            case "Enter":
              if (!open3) {
                onOpenChange(true);
              }
              break;
          }
        }
      },
      // ============ Post Props ============
      ...postProps?.({
        valueTexts
      })
    };
    Object.keys(inputProps).forEach((key) => {
      if (inputProps[key] === void 0) {
        delete inputProps[key];
      }
    });
    return inputProps;
  }, "getInputProps");
  return [getInputProps, getText];
}
__name(useInputProps, "useInputProps");

// packages/picker/src/PickerInput/Selector/hooks/useRootProps.ts
import * as React254 from "react";
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
  return React254.useMemo(() => pickProps(props, propNames), [props]);
}
__name(useRootProps, "useRootProps");

// packages/picker/src/PickerInput/Selector/Icon.tsx
import * as React255 from "react";
function Icon2(props) {
  const { icon, type: type5, ...restProps } = props;
  const { prefixCls } = React255.useContext(context_default6);
  return icon ? /* @__PURE__ */ React255.createElement("span", { className: `${prefixCls}-${type5}`, ...restProps }, icon) : null;
}
__name(Icon2, "Icon");
function ClearIcon({ onClear, ...restProps }) {
  return /* @__PURE__ */ React255.createElement(
    Icon2,
    {
      ...restProps,
      type: "clear",
      role: "button",
      onMouseDown: (e3) => {
        e3.preventDefault();
      },
      onClick: (e3) => {
        e3.stopPropagation();
        onClear();
      }
    }
  );
}
__name(ClearIcon, "ClearIcon");

// packages/picker/src/PickerInput/Selector/Input.tsx
var import_classnames85 = __toESM(require_classnames());
import * as React256 from "react";

// packages/picker/src/PickerInput/Selector/MaskFormat.ts
var FORMAT_KEYS = ["YYYY", "MM", "DD", "HH", "mm", "ss", "SSS"];
var REPLACE_KEY = "\u9867";
var MaskFormat = class {
  static {
    __name(this, "MaskFormat");
  }
  format;
  maskFormat;
  cells;
  maskCells;
  constructor(format2) {
    this.format = format2;
    const replaceKeys = FORMAT_KEYS.map((key) => `(${key})`).join("|");
    const replaceReg = new RegExp(replaceKeys, "g");
    this.maskFormat = format2.replace(
      replaceReg,
      // Use Chinese character to avoid user use it in format
      (key) => REPLACE_KEY.repeat(key.length)
    );
    const cellReg = new RegExp(`(${FORMAT_KEYS.join("|")})`);
    const strCells = (format2.split(cellReg) || []).filter((str) => str);
    let offset3 = 0;
    this.cells = strCells.map((text) => {
      const mask = FORMAT_KEYS.includes(text);
      const start = offset3;
      const end = offset3 + text.length;
      offset3 = end;
      return {
        text,
        mask,
        start,
        end
      };
    });
    this.maskCells = this.cells.filter((cell) => cell.mask);
  }
  getSelection(maskCellIndex) {
    const { start, end } = this.maskCells[maskCellIndex] || {};
    return [start || 0, end || 0];
  }
  /** Check given text match format */
  match(text) {
    for (let i = 0; i < this.maskFormat.length; i += 1) {
      const maskChar = this.maskFormat[i];
      const textChar = text[i];
      if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {
        return false;
      }
    }
    return true;
  }
  /** Get mask cell count */
  size() {
    return this.maskCells.length;
  }
  getMaskCellIndex(anchorIndex) {
    let closetDist = Number.MAX_SAFE_INTEGER;
    let closetIndex = 0;
    for (let i = 0; i < this.maskCells.length; i += 1) {
      const { start, end } = this.maskCells[i];
      if (anchorIndex >= start && anchorIndex <= end) {
        return i;
      }
      const dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
      if (dist < closetDist) {
        closetDist = dist;
        closetIndex = i;
      }
    }
    return closetIndex;
  }
};

// packages/picker/src/PickerInput/Selector/util.ts
function getMaskRange(key) {
  const PresetRange = {
    YYYY: [0, 9999, (/* @__PURE__ */ new Date()).getFullYear()],
    MM: [1, 12],
    DD: [1, 31],
    HH: [0, 23],
    mm: [0, 59],
    ss: [0, 59],
    SSS: [0, 999]
  };
  return PresetRange[key];
}
__name(getMaskRange, "getMaskRange");

// packages/picker/src/PickerInput/Selector/Input.tsx
var Input2 = React256.forwardRef((props, ref) => {
  const {
    active,
    showActiveCls = true,
    suffixIcon,
    format: format2,
    validateFormat,
    onChange,
    onInput,
    helped,
    onHelp,
    onSubmit,
    onKeyDown: onKeyDown2,
    preserveInvalidOnBlur = false,
    invalid,
    clearIcon,
    // Pass to input
    ...restProps
  } = props;
  const { value, onFocus, onBlur, onMouseUp } = props;
  const { prefixCls, input: Component11 = "input" } = React256.useContext(context_default6);
  const inputPrefixCls = `${prefixCls}-input`;
  const [focused, setFocused] = React256.useState(false);
  const [internalInputValue, setInputValue] = React256.useState(value);
  const [focusCellText, setFocusCellText] = React256.useState("");
  const [focusCellIndex, setFocusCellIndex] = React256.useState(null);
  const [forceSelectionSyncMark, forceSelectionSync] = React256.useState(null);
  const inputValue = internalInputValue || "";
  React256.useEffect(() => {
    setInputValue(value);
  }, [value]);
  const holderRef = React256.useRef();
  const inputRef = React256.useRef();
  React256.useImperativeHandle(ref, () => ({
    nativeElement: holderRef.current,
    inputElement: inputRef.current,
    focus: (options) => {
      inputRef.current.focus(options);
    },
    blur: () => {
      inputRef.current.blur();
    }
  }));
  const maskFormat = React256.useMemo(() => new MaskFormat(format2 || ""), [format2]);
  const [selectionStart, selectionEnd] = React256.useMemo(() => {
    if (helped) {
      return [0, 0];
    }
    return maskFormat.getSelection(focusCellIndex);
  }, [maskFormat, focusCellIndex, helped]);
  const onModify = /* @__PURE__ */ __name((text) => {
    if (text && text !== format2 && text !== value) {
      onHelp();
    }
  }, "onModify");
  const triggerInputChange = useEvent((text) => {
    if (validateFormat(text)) {
      onChange(text);
    }
    setInputValue(text);
    onModify(text);
  });
  const onInternalChange = /* @__PURE__ */ __name((event) => {
    if (!format2) {
      const text = event.target.value;
      onModify(text);
      setInputValue(text);
      onChange(text);
    }
  }, "onInternalChange");
  const onFormatPaste = /* @__PURE__ */ __name((event) => {
    const pasteText = event.clipboardData.getData("text");
    if (validateFormat(pasteText)) {
      triggerInputChange(pasteText);
    }
  }, "onFormatPaste");
  const mouseDownRef = React256.useRef(false);
  const onFormatMouseDown = /* @__PURE__ */ __name(() => {
    mouseDownRef.current = true;
  }, "onFormatMouseDown");
  const onFormatMouseUp = /* @__PURE__ */ __name((event) => {
    const { selectionStart: start } = event.target;
    const closeMaskIndex = maskFormat.getMaskCellIndex(start);
    setFocusCellIndex(closeMaskIndex);
    forceSelectionSync({});
    onMouseUp?.(event);
    mouseDownRef.current = false;
  }, "onFormatMouseUp");
  const onFormatFocus = /* @__PURE__ */ __name((event) => {
    setFocused(true);
    setFocusCellIndex(0);
    setFocusCellText("");
    onFocus(event);
  }, "onFormatFocus");
  const onSharedBlur = /* @__PURE__ */ __name((event) => {
    onBlur(event);
  }, "onSharedBlur");
  const onFormatBlur = /* @__PURE__ */ __name((event) => {
    setFocused(false);
    onSharedBlur(event);
  }, "onFormatBlur");
  useLockEffect(active, () => {
    if (!active && !preserveInvalidOnBlur) {
      setInputValue(value);
    }
  });
  const onSharedKeyDown = /* @__PURE__ */ __name((event) => {
    if (event.key === "Enter" && validateFormat(inputValue)) {
      onSubmit();
    }
    onKeyDown2?.(event);
  }, "onSharedKeyDown");
  const onFormatKeyDown = /* @__PURE__ */ __name((event) => {
    onSharedKeyDown(event);
    const { key } = event;
    let nextCellText = null;
    let nextFillText = null;
    const maskCellLen = selectionEnd - selectionStart;
    const cellFormat = format2.slice(selectionStart, selectionEnd);
    const offsetCellIndex = /* @__PURE__ */ __name((offset3) => {
      setFocusCellIndex((idx) => {
        let nextIndex = idx + offset3;
        nextIndex = Math.max(nextIndex, 0);
        nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
        return nextIndex;
      });
    }, "offsetCellIndex");
    const offsetCellValue = /* @__PURE__ */ __name((offset3) => {
      const [rangeStart, rangeEnd, rangeDefault] = getMaskRange(cellFormat);
      const currentText = inputValue.slice(selectionStart, selectionEnd);
      const currentTextNum = Number(currentText);
      if (isNaN(currentTextNum)) {
        return String(rangeDefault ? rangeDefault : offset3 > 0 ? rangeStart : rangeEnd);
      }
      const num = currentTextNum + offset3;
      const range3 = rangeEnd - rangeStart + 1;
      return String(rangeStart + (range3 + num - rangeStart) % range3);
    }, "offsetCellValue");
    switch (key) {
      case "Backspace":
      case "Delete":
        nextCellText = "";
        nextFillText = cellFormat;
        break;
      case "ArrowLeft":
        nextCellText = "";
        offsetCellIndex(-1);
        break;
      case "ArrowRight":
        nextCellText = "";
        offsetCellIndex(1);
        break;
      case "ArrowUp":
        nextCellText = "";
        nextFillText = offsetCellValue(1);
        break;
      case "ArrowDown":
        nextCellText = "";
        nextFillText = offsetCellValue(-1);
        break;
      default:
        if (!isNaN(Number(key))) {
          nextCellText = focusCellText + key;
          nextFillText = nextCellText;
        }
        break;
    }
    if (nextCellText !== null) {
      setFocusCellText(nextCellText);
      if (nextCellText.length >= maskCellLen) {
        offsetCellIndex(1);
        setFocusCellText("");
      }
    }
    if (nextFillText !== null) {
      const nextFocusValue = (
        // before
        inputValue.slice(0, selectionStart) + // replace
        leftPad(nextFillText, maskCellLen) + // after
        inputValue.slice(selectionEnd)
      );
      triggerInputChange(nextFocusValue.slice(0, format2.length));
    }
    forceSelectionSync({});
  }, "onFormatKeyDown");
  const rafRef = React256.useRef();
  useLayoutEffect_default(() => {
    if (!focused || !format2 || mouseDownRef.current) {
      return;
    }
    if (!maskFormat.match(inputValue)) {
      triggerInputChange(format2);
      return;
    }
    inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    rafRef.current = raf_default(() => {
      inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    });
    return () => {
      raf_default.cancel(rafRef.current);
    };
  }, [
    maskFormat,
    format2,
    focused,
    inputValue,
    focusCellIndex,
    selectionStart,
    selectionEnd,
    forceSelectionSyncMark,
    triggerInputChange
  ]);
  const inputProps = format2 ? {
    onFocus: onFormatFocus,
    onBlur: onFormatBlur,
    onKeyDown: onFormatKeyDown,
    onMouseDown: onFormatMouseDown,
    onMouseUp: onFormatMouseUp,
    onPaste: onFormatPaste
  } : {};
  return /* @__PURE__ */ React256.createElement(
    "div",
    {
      ref: holderRef,
      className: (0, import_classnames85.default)(inputPrefixCls, {
        [`${inputPrefixCls}-active`]: active && showActiveCls,
        [`${inputPrefixCls}-placeholder`]: helped
      })
    },
    /* @__PURE__ */ React256.createElement(
      Component11,
      {
        ref: inputRef,
        "aria-invalid": invalid,
        autoComplete: "off",
        ...restProps,
        onKeyDown: onSharedKeyDown,
        onBlur: onSharedBlur,
        ...inputProps,
        value: inputValue,
        onChange: onInternalChange
      }
    ),
    /* @__PURE__ */ React256.createElement(Icon2, { type: "suffix", icon: suffixIcon }),
    clearIcon
  );
});
if (true) {
  Input2.displayName = "Input";
}
var Input_default2 = Input2;

// packages/picker/src/PickerInput/Selector/RangeSelector.tsx
function RangeSelector(props, ref) {
  const {
    id,
    clearIcon,
    suffixIcon,
    separator = "~",
    activeIndex,
    activeHelp,
    allHelp,
    focused,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    locale: locale6,
    generateConfig: generateConfig2,
    // Placeholder
    placeholder,
    // Style
    className,
    style: style2,
    // Click
    onClick,
    onClear,
    // Change
    value,
    onChange,
    onSubmit,
    onInputChange,
    // Valid
    format: format2,
    maskFormat,
    preserveInvalidOnBlur,
    onInvalid,
    // Disabled
    disabled,
    invalid,
    inputReadOnly,
    // Direction
    direction,
    // Open
    onOpenChange,
    // Offset
    onActiveOffset,
    // Native
    onMouseDown,
    // Input
    required: required5,
    "aria-required": ariaRequired,
    autoFocus,
    ...restProps
  } = props;
  const rtl = direction === "rtl";
  const { prefixCls } = React257.useContext(context_default6);
  const ids = React257.useMemo(() => {
    if (typeof id === "string") {
      return [id];
    }
    const mergedId = id || {};
    return [mergedId.start, mergedId.end];
  }, [id]);
  const rootRef = React257.useRef();
  const inputStartRef = React257.useRef();
  const inputEndRef = React257.useRef();
  const getInput = /* @__PURE__ */ __name((index3) => [inputStartRef, inputEndRef][index3]?.current, "getInput");
  React257.useImperativeHandle(ref, () => ({
    nativeElement: rootRef.current,
    focus: (options) => {
      if (typeof options === "object") {
        const { index: index3 = 0, ...rest } = options || {};
        getInput(index3)?.focus(rest);
      } else {
        getInput(options ?? 0)?.focus();
      }
    },
    blur: () => {
      getInput(0)?.blur();
      getInput(1)?.blur();
    }
  }));
  const rootProps = useRootProps(restProps);
  const mergedPlaceholder = React257.useMemo(
    () => Array.isArray(placeholder) ? placeholder : [placeholder, placeholder],
    [placeholder]
  );
  const [getInputProps] = useInputProps({
    ...props,
    id: ids,
    placeholder: mergedPlaceholder
  });
  const offsetUnit = rtl ? "right" : "left";
  const [activeBarStyle, setActiveBarStyle] = React257.useState({
    position: "absolute",
    width: 0,
    [offsetUnit]: 0
  });
  const syncActiveOffset = useEvent(() => {
    const input = getInput(activeIndex);
    if (input) {
      const { offsetWidth, offsetLeft, offsetParent } = input.nativeElement;
      let offset3 = offsetLeft;
      if (rtl) {
        const parentElement = offsetParent;
        const parentStyle = getComputedStyle(parentElement);
        offset3 = parentElement.offsetWidth - parseFloat(parentStyle.borderRightWidth) - parseFloat(parentStyle.borderLeftWidth) - offsetLeft - offsetWidth;
      }
      setActiveBarStyle((ori) => ({
        ...ori,
        width: offsetWidth,
        [offsetUnit]: offset3
      }));
      onActiveOffset(activeIndex === 0 ? 0 : offset3);
    }
  });
  React257.useEffect(() => {
    syncActiveOffset();
  }, [activeIndex]);
  const showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
  const startAutoFocus = autoFocus && !disabled[0];
  const endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
  return /* @__PURE__ */ React257.createElement(src_default, { onResize: syncActiveOffset }, /* @__PURE__ */ React257.createElement(
    "div",
    {
      ...rootProps,
      className: (0, import_classnames86.default)(
        prefixCls,
        `${prefixCls}-range`,
        {
          [`${prefixCls}-focused`]: focused,
          [`${prefixCls}-disabled`]: disabled.every((i) => i),
          [`${prefixCls}-invalid`]: invalid.some((i) => i),
          [`${prefixCls}-rtl`]: rtl
        },
        className
      ),
      style: style2,
      ref: rootRef,
      onClick,
      onMouseDown: (e3) => {
        const { target } = e3;
        if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) {
          e3.preventDefault();
        }
        onMouseDown?.(e3);
      }
    },
    /* @__PURE__ */ React257.createElement(
      Input_default2,
      {
        ref: inputStartRef,
        ...getInputProps(0),
        autoFocus: startAutoFocus,
        "date-range": "start"
      }
    ),
    /* @__PURE__ */ React257.createElement("div", { className: `${prefixCls}-range-separator` }, separator),
    /* @__PURE__ */ React257.createElement(Input_default2, { ref: inputEndRef, ...getInputProps(1), autoFocus: endAutoFocus, "date-range": "end" }),
    /* @__PURE__ */ React257.createElement("div", { className: `${prefixCls}-active-bar`, style: activeBarStyle }),
    /* @__PURE__ */ React257.createElement(Icon2, { type: "suffix", icon: suffixIcon }),
    showClear && /* @__PURE__ */ React257.createElement(ClearIcon, { icon: clearIcon, onClear })
  ));
}
__name(RangeSelector, "RangeSelector");
var RefRangeSelector = React257.forwardRef(RangeSelector);
if (true) {
  RefRangeSelector.displayName = "RangeSelector";
}
var RangeSelector_default = RefRangeSelector;

// packages/picker/src/PickerInput/RangePicker.tsx
function separateConfig(config, defaultConfig2) {
  const singleConfig = config ?? defaultConfig2;
  if (Array.isArray(singleConfig)) {
    return singleConfig;
  }
  return [singleConfig, singleConfig];
}
__name(separateConfig, "separateConfig");
function getActiveRange(activeIndex) {
  return activeIndex === 1 ? "end" : "start";
}
__name(getActiveRange, "getActiveRange");
function RangePicker(props, ref) {
  const [filledProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate] = useFilledProps(props, () => {
    const { disabled: disabled2, allowEmpty: allowEmpty2 } = props;
    const mergedDisabled = separateConfig(disabled2, false);
    const mergedAllowEmpty = separateConfig(allowEmpty2, false);
    return {
      disabled: mergedDisabled,
      allowEmpty: mergedAllowEmpty
    };
  });
  const {
    // Style
    prefixCls,
    styles,
    classNames: classNames253,
    // Value
    defaultValue,
    value,
    needConfirm,
    onKeyDown: onKeyDown2,
    // Disabled
    disabled,
    allowEmpty,
    disabledDate,
    minDate,
    maxDate,
    // Open
    defaultOpen,
    open: open3,
    onOpenChange,
    // Picker
    locale: locale6,
    generateConfig: generateConfig2,
    picker,
    showNow,
    showToday,
    showTime,
    // Mode
    mode,
    onPanelChange,
    onCalendarChange,
    onOk,
    // Picker Value
    defaultPickerValue,
    pickerValue,
    onPickerValueChange,
    // Format
    inputReadOnly,
    suffixIcon,
    // Focus
    onFocus,
    onBlur,
    // Presets
    presets,
    ranges,
    // Render
    components,
    cellRender,
    dateRender,
    monthCellRender,
    // Native
    onClick
  } = filledProps;
  const selectorRef = usePickerRef(ref);
  const [mergedOpen, setMergeOpen] = useOpen(open3, defaultOpen, disabled, onOpenChange);
  const triggerOpen = /* @__PURE__ */ __name((nextOpen, config) => {
    if (disabled.some((fieldDisabled) => !fieldDisabled) || !nextOpen) {
      setMergeOpen(nextOpen, config);
    }
  }, "triggerOpen");
  const [mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, triggerOk] = useInnerValue(
    generateConfig2,
    locale6,
    formatList,
    true,
    false,
    defaultValue,
    value,
    onCalendarChange,
    onOk
  );
  const calendarValue = getCalendarValue();
  const [
    focused,
    triggerFocus3,
    lastOperation,
    activeIndex,
    setActiveIndex,
    nextActiveIndex,
    activeIndexList
  ] = useRangeActive(disabled, allowEmpty);
  const onSharedFocus = /* @__PURE__ */ __name((event, index3) => {
    triggerFocus3(true);
    onFocus?.(event, {
      range: getActiveRange(index3 ?? activeIndex)
    });
  }, "onSharedFocus");
  const onSharedBlur = /* @__PURE__ */ __name((event, index3) => {
    triggerFocus3(false);
    onBlur?.(event, {
      range: getActiveRange(index3 ?? activeIndex)
    });
  }, "onSharedBlur");
  const mergedShowTime = React258.useMemo(() => {
    if (!showTime) {
      return null;
    }
    const { disabledTime } = showTime;
    const proxyDisabledTime = disabledTime ? (date4) => {
      const range3 = getActiveRange(activeIndex);
      return disabledTime(date4, range3);
    } : void 0;
    return { ...showTime, disabledTime: proxyDisabledTime };
  }, [showTime, activeIndex]);
  const [modes, setModes] = useMergedState([picker, picker], {
    value: mode
  });
  const mergedMode = modes[activeIndex] || picker;
  const internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  const multiplePanel = internalMode === picker && internalMode !== "time";
  const mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
  const [
    /** Trigger `onChange` by check `disabledDate` */
    flushSubmit,
    /** Trigger `onChange` directly without check `disabledDate` */
    triggerSubmitChange
  ] = useRangeValue(
    filledProps,
    mergedValue,
    setInnerValue,
    getCalendarValue,
    triggerCalendarChange,
    disabled,
    formatList,
    focused,
    mergedOpen,
    isInvalidateDate
  );
  const mergedDisabledDate = useRangeDisabledDate(
    calendarValue,
    disabled,
    activeIndexList,
    generateConfig2,
    locale6,
    disabledDate
  );
  const [submitInvalidates, onSelectorInvalid] = useFieldsInvalidate(
    calendarValue,
    isInvalidateDate,
    allowEmpty
  );
  const [currentPickerValue, setCurrentPickerValue] = useRangePickerValue(
    generateConfig2,
    locale6,
    calendarValue,
    modes,
    mergedOpen,
    activeIndex,
    internalPicker,
    multiplePanel,
    defaultPickerValue,
    pickerValue,
    mergedShowTime?.defaultOpenValue,
    onPickerValueChange,
    minDate,
    maxDate
  );
  const triggerModeChange = useEvent(
    (nextPickerValue, nextMode, triggerEvent) => {
      const clone = fillIndex(modes, activeIndex, nextMode);
      if (clone[0] !== modes[0] || clone[1] !== modes[1]) {
        setModes(clone);
      }
      if (onPanelChange && triggerEvent !== false) {
        const clonePickerValue = [...calendarValue];
        if (nextPickerValue) {
          clonePickerValue[activeIndex] = nextPickerValue;
        }
        onPanelChange(clonePickerValue, clone);
      }
    }
  );
  const fillCalendarValue = /* @__PURE__ */ __name((date4, index3) => (
    // Trigger change only when date changed
    fillIndex(calendarValue, index3, date4)
  ), "fillCalendarValue");
  const triggerPartConfirm = /* @__PURE__ */ __name((date4, skipFocus) => {
    let nextValue = calendarValue;
    if (date4) {
      nextValue = fillCalendarValue(date4, activeIndex);
    }
    const nextIndex = nextActiveIndex(nextValue);
    triggerCalendarChange(nextValue);
    flushSubmit(activeIndex, nextIndex === null);
    if (nextIndex === null) {
      triggerOpen(false, { force: true });
    } else if (!skipFocus) {
      selectorRef.current.focus({ index: nextIndex });
    }
  }, "triggerPartConfirm");
  const onSelectorClick = /* @__PURE__ */ __name((event) => {
    if (!selectorRef.current.nativeElement.contains(document.activeElement)) {
      const enabledIndex = disabled.findIndex((d) => !d);
      if (enabledIndex >= 0) {
        selectorRef.current.focus({ index: enabledIndex });
      }
    }
    triggerOpen(true);
    onClick?.(event);
  }, "onSelectorClick");
  const onSelectorClear = /* @__PURE__ */ __name(() => {
    triggerSubmitChange(null);
    triggerOpen(false, { force: true });
  }, "onSelectorClear");
  const [hoverSource, setHoverSource] = React258.useState(null);
  const [internalHoverValues, setInternalHoverValues] = React258.useState(null);
  const hoverValues = React258.useMemo(() => {
    return internalHoverValues || calendarValue;
  }, [calendarValue, internalHoverValues]);
  React258.useEffect(() => {
    if (!mergedOpen) {
      setInternalHoverValues(null);
    }
  }, [mergedOpen]);
  const [activeOffset, setActiveOffset] = React258.useState(0);
  const presetList = usePresets(presets, ranges);
  const onPresetHover = /* @__PURE__ */ __name((nextValues) => {
    setInternalHoverValues(nextValues);
    setHoverSource("preset");
  }, "onPresetHover");
  const onPresetSubmit = /* @__PURE__ */ __name((nextValues) => {
    const passed = triggerSubmitChange(nextValues);
    if (passed) {
      triggerOpen(false, { force: true });
    }
  }, "onPresetSubmit");
  const onNow = /* @__PURE__ */ __name((now2) => {
    triggerPartConfirm(now2);
  }, "onNow");
  const onPanelHover = /* @__PURE__ */ __name((date4) => {
    setInternalHoverValues(date4 ? fillCalendarValue(date4, activeIndex) : null);
    setHoverSource("cell");
  }, "onPanelHover");
  const onPanelFocus = /* @__PURE__ */ __name((event) => {
    triggerOpen(true);
    onSharedFocus(event);
  }, "onPanelFocus");
  const onPanelSelect = /* @__PURE__ */ __name((date4) => {
    lastOperation("panel");
    const clone = fillIndex(calendarValue, activeIndex, date4);
    triggerCalendarChange(clone);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerPartConfirm(date4);
    }
  }, "onPanelSelect");
  const onPopupClose = /* @__PURE__ */ __name(() => {
    triggerOpen(false);
  }, "onPopupClose");
  const onInternalCellRender = useCellRender(
    cellRender,
    dateRender,
    monthCellRender,
    getActiveRange(activeIndex)
  );
  const panelValue = calendarValue[activeIndex] || null;
  const isPopupInvalidateDate = useEvent((date4) => {
    return isInvalidateDate(date4, {
      activeIndex
    });
  });
  const panelProps = React258.useMemo(() => {
    const domProps = pickAttrs(filledProps, false);
    const restProps = omit(filledProps, [
      ...Object.keys(domProps),
      "onChange",
      "onCalendarChange",
      "style",
      "className",
      "onPanelChange"
    ]);
    return restProps;
  }, [filledProps]);
  const panel = /* @__PURE__ */ React258.createElement(
    Popup3,
    {
      ...panelProps,
      showNow: mergedShowNow,
      showTime: mergedShowTime,
      range: true,
      multiplePanel,
      activeOffset,
      disabledDate: mergedDisabledDate,
      onFocus: onPanelFocus,
      onBlur: onSharedBlur,
      picker,
      mode: mergedMode,
      internalMode,
      onPanelChange: triggerModeChange,
      format: maskFormat,
      value: panelValue,
      isInvalid: isPopupInvalidateDate,
      onChange: null,
      onSelect: onPanelSelect,
      pickerValue: currentPickerValue,
      defaultOpenValue: toArray5(showTime?.defaultOpenValue)[activeIndex],
      onPickerValueChange: setCurrentPickerValue,
      hoverValue: hoverValues,
      onHover: onPanelHover,
      needConfirm,
      onSubmit: triggerPartConfirm,
      onOk: triggerOk,
      presets: presetList,
      onPresetHover,
      onPresetSubmit,
      onNow,
      cellRender: onInternalCellRender
    }
  );
  const onSelectorChange = /* @__PURE__ */ __name((date4, index3) => {
    const clone = fillCalendarValue(date4, index3);
    triggerCalendarChange(clone);
  }, "onSelectorChange");
  const onSelectorInputChange = /* @__PURE__ */ __name(() => {
    lastOperation("input");
  }, "onSelectorInputChange");
  const onSelectorFocus = /* @__PURE__ */ __name((event, index3) => {
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    setActiveIndex(index3);
    onSharedFocus(event, index3);
  }, "onSelectorFocus");
  const onSelectorBlur = /* @__PURE__ */ __name((event, index3) => {
    triggerOpen(false);
    onSharedBlur(event, index3);
  }, "onSelectorBlur");
  const onSelectorKeyDown = /* @__PURE__ */ __name((event, preventDefault) => {
    if (event.key === "Tab") {
      triggerPartConfirm(null, true);
    }
    onKeyDown2?.(event, preventDefault);
  }, "onSelectorKeyDown");
  const context = React258.useMemo(
    () => ({
      prefixCls,
      locale: locale6,
      generateConfig: generateConfig2,
      button: components.button,
      input: components.input
    }),
    [prefixCls, locale6, generateConfig2, components.button, components.input]
  );
  useLayoutEffect_default(() => {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(() => {
    const lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerPartConfirm(null, true);
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerOpen(true);
      triggerPartConfirm();
    }
  }, [mergedOpen]);
  if (true) {
    const isIndexEmpty = /* @__PURE__ */ __name((index3) => {
      return (
        // Value is empty
        !value?.[index3] && // DefaultValue is empty
        !defaultValue?.[index3]
      );
    }, "isIndexEmpty");
    if (disabled.some(
      (fieldDisabled, index3) => fieldDisabled && isIndexEmpty(index3) && !allowEmpty[index3]
    )) {
      warning_default(
        false,
        "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead."
      );
    }
  }
  return /* @__PURE__ */ React258.createElement(context_default6.Provider, { value: context }, /* @__PURE__ */ React258.createElement(
    PickerTrigger_default,
    {
      ...pickTriggerProps(filledProps),
      popupElement: panel,
      popupStyle: styles.popup,
      popupClassName: classNames253.popup,
      visible: mergedOpen,
      onClose: onPopupClose,
      range: true
    },
    /* @__PURE__ */ React258.createElement(
      RangeSelector_default,
      {
        ...filledProps,
        ref: selectorRef,
        suffixIcon,
        activeIndex: focused || mergedOpen ? activeIndex : null,
        activeHelp: !!internalHoverValues,
        allHelp: !!internalHoverValues && hoverSource === "preset",
        focused,
        onFocus: onSelectorFocus,
        onBlur: onSelectorBlur,
        onKeyDown: onSelectorKeyDown,
        onSubmit: triggerPartConfirm,
        value: hoverValues,
        maskFormat,
        onChange: onSelectorChange,
        onInputChange: onSelectorInputChange,
        format: formatList,
        inputReadOnly,
        disabled,
        open: mergedOpen,
        onOpenChange: triggerOpen,
        onClick: onSelectorClick,
        onClear: onSelectorClear,
        invalid: submitInvalidates,
        onInvalid: onSelectorInvalid,
        onActiveOffset: setActiveOffset
      }
    )
  ));
}
__name(RangePicker, "RangePicker");
var RefRangePicker = React258.forwardRef(RangePicker);
if (true) {
  RefRangePicker.displayName = "RefRangePicker";
}
var RangePicker_default = RefRangePicker;

// packages/picker/src/PickerInput/SinglePicker.tsx
import * as React261 from "react";

// packages/picker/src/PickerInput/Selector/SingleSelector/index.tsx
var import_classnames88 = __toESM(require_classnames());
import * as React260 from "react";

// packages/picker/src/PickerInput/Selector/SingleSelector/MultipleDates.tsx
var import_classnames87 = __toESM(require_classnames());
import * as React259 from "react";
function MultipleDates(props) {
  const {
    prefixCls,
    value,
    onRemove,
    removeIcon = "\xD7",
    formatDate,
    disabled,
    maxTagCount,
    placeholder
  } = props;
  const selectorCls = `${prefixCls}-selector`;
  const selectionCls = `${prefixCls}-selection`;
  const overflowCls = `${selectionCls}-overflow`;
  function renderSelector(content, onClose) {
    return /* @__PURE__ */ React259.createElement(
      "span",
      {
        className: (0, import_classnames87.default)(`${selectionCls}-item`),
        title: typeof content === "string" ? content : null
      },
      /* @__PURE__ */ React259.createElement("span", { className: `${selectionCls}-item-content` }, content),
      !disabled && onClose && /* @__PURE__ */ React259.createElement(
        "span",
        {
          onMouseDown: (e3) => {
            e3.preventDefault();
          },
          onClick: onClose,
          className: `${selectionCls}-item-remove`
        },
        removeIcon
      )
    );
  }
  __name(renderSelector, "renderSelector");
  function renderItem2(date4) {
    const displayLabel = formatDate(date4);
    const onClose = /* @__PURE__ */ __name((event) => {
      if (event)
        event.stopPropagation();
      onRemove(date4);
    }, "onClose");
    return renderSelector(displayLabel, onClose);
  }
  __name(renderItem2, "renderItem");
  function renderRest(omittedValues) {
    const content = `+ ${omittedValues.length} ...`;
    return renderSelector(content);
  }
  __name(renderRest, "renderRest");
  return /* @__PURE__ */ React259.createElement("div", { className: selectorCls }, /* @__PURE__ */ React259.createElement(
    es_default3,
    {
      prefixCls: overflowCls,
      data: value,
      renderItem: renderItem2,
      renderRest,
      itemKey: (date4) => formatDate(date4),
      maxCount: maxTagCount
    }
  ), !value.length && /* @__PURE__ */ React259.createElement("span", { className: `${prefixCls}-selection-placeholder` }, placeholder));
}
__name(MultipleDates, "MultipleDates");

// packages/picker/src/PickerInput/Selector/SingleSelector/index.tsx
function SingleSelector2(props, ref) {
  const {
    id,
    open: open3,
    clearIcon,
    suffixIcon,
    activeHelp,
    allHelp,
    focused,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    locale: locale6,
    generateConfig: generateConfig2,
    // Placeholder
    placeholder,
    // Style
    className,
    style: style2,
    // Click
    onClick,
    onClear,
    // Change
    internalPicker,
    value,
    onChange,
    onSubmit,
    onInputChange,
    multiple,
    maxTagCount,
    // Valid
    format: format2,
    maskFormat,
    preserveInvalidOnBlur,
    onInvalid,
    // Disabled
    disabled,
    invalid,
    inputReadOnly,
    // Direction
    direction,
    // Open
    onOpenChange,
    // Native
    onMouseDown,
    // Input
    required: required5,
    "aria-required": ariaRequired,
    autoFocus,
    removeIcon,
    ...restProps
  } = props;
  const rtl = direction === "rtl";
  const { prefixCls } = React260.useContext(context_default6);
  const rootRef = React260.useRef();
  const inputRef = React260.useRef();
  React260.useImperativeHandle(ref, () => ({
    nativeElement: rootRef.current,
    focus: (options) => {
      inputRef.current?.focus(options);
    },
    blur: () => {
      inputRef.current?.blur();
    }
  }));
  const rootProps = useRootProps(restProps);
  const onSingleChange = /* @__PURE__ */ __name((date4) => {
    onChange([date4]);
  }, "onSingleChange");
  const onMultipleRemove = /* @__PURE__ */ __name((date4) => {
    const nextValues = value.filter(
      (oriDate) => oriDate && !isSame(generateConfig2, locale6, oriDate, date4, internalPicker)
    );
    onChange(nextValues);
    if (!open3) {
      onSubmit();
    }
  }, "onMultipleRemove");
  const [getInputProps, getText] = useInputProps(
    {
      ...props,
      onChange: onSingleChange
    },
    ({ valueTexts }) => ({
      value: valueTexts[0] || "",
      active: focused
    })
  );
  const showClear = !!(clearIcon && value.length && !disabled);
  const selectorNode = multiple ? /* @__PURE__ */ React260.createElement(React260.Fragment, null, /* @__PURE__ */ React260.createElement(
    MultipleDates,
    {
      prefixCls,
      value,
      onRemove: onMultipleRemove,
      formatDate: getText,
      maxTagCount,
      disabled,
      removeIcon,
      placeholder
    }
  ), /* @__PURE__ */ React260.createElement(
    "input",
    {
      className: `${prefixCls}-multiple-input`,
      value: value.map(getText).join(","),
      ref: inputRef,
      readOnly: true,
      autoFocus
    }
  ), /* @__PURE__ */ React260.createElement(Icon2, { type: "suffix", icon: suffixIcon }), showClear && /* @__PURE__ */ React260.createElement(ClearIcon, { icon: clearIcon, onClear })) : /* @__PURE__ */ React260.createElement(
    Input_default2,
    {
      ref: inputRef,
      ...getInputProps(),
      autoFocus,
      suffixIcon,
      clearIcon: showClear && /* @__PURE__ */ React260.createElement(ClearIcon, { icon: clearIcon, onClear }),
      showActiveCls: false
    }
  );
  return /* @__PURE__ */ React260.createElement(
    "div",
    {
      ...rootProps,
      className: (0, import_classnames88.default)(
        prefixCls,
        {
          [`${prefixCls}-multiple`]: multiple,
          [`${prefixCls}-focused`]: focused,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-invalid`]: invalid,
          [`${prefixCls}-rtl`]: rtl
        },
        className
      ),
      style: style2,
      ref: rootRef,
      onClick,
      onMouseDown: (e3) => {
        const { target } = e3;
        if (target !== inputRef.current?.inputElement) {
          e3.preventDefault();
        }
        onMouseDown?.(e3);
      }
    },
    selectorNode
  );
}
__name(SingleSelector2, "SingleSelector");
var RefSingleSelector = React260.forwardRef(SingleSelector2);
if (true) {
  RefSingleSelector.displayName = "SingleSelector";
}
var SingleSelector_default2 = RefSingleSelector;

// packages/picker/src/PickerInput/SinglePicker.tsx
function Picker(props, ref) {
  const [filledProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate] = useFilledProps(props);
  const {
    // Style
    prefixCls,
    styles,
    classNames: classNames253,
    // Value
    order,
    defaultValue,
    value,
    needConfirm,
    onChange,
    onKeyDown: onKeyDown2,
    // Disabled
    disabled,
    disabledDate,
    minDate,
    maxDate,
    // Open
    defaultOpen,
    open: open3,
    onOpenChange,
    // Picker
    locale: locale6,
    generateConfig: generateConfig2,
    picker,
    showNow,
    showToday,
    showTime,
    // Mode
    mode,
    onPanelChange,
    onCalendarChange,
    onOk,
    multiple,
    // Picker Value
    defaultPickerValue,
    pickerValue,
    onPickerValueChange,
    // Format
    inputReadOnly,
    suffixIcon,
    removeIcon,
    // Focus
    onFocus,
    onBlur,
    // Presets
    presets,
    // Render
    components,
    cellRender,
    dateRender,
    monthCellRender,
    // Native
    onClick
  } = filledProps;
  const selectorRef = usePickerRef(ref);
  function pickerParam(values) {
    if (values === null) {
      return null;
    }
    return multiple ? values : values[0];
  }
  __name(pickerParam, "pickerParam");
  const toggleDates = useToggleDates(generateConfig2, locale6, internalPicker);
  const [mergedOpen, triggerOpen] = useOpen(open3, defaultOpen, [disabled], onOpenChange);
  const onInternalCalendarChange = /* @__PURE__ */ __name((dates, dateStrings, info) => {
    if (onCalendarChange) {
      const filteredInfo = {
        ...info
      };
      delete filteredInfo.range;
      onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
    }
  }, "onInternalCalendarChange");
  const onInternalOk = /* @__PURE__ */ __name((dates) => {
    onOk?.(pickerParam(dates));
  }, "onInternalOk");
  const [mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, triggerOk] = useInnerValue(
    generateConfig2,
    locale6,
    formatList,
    false,
    order,
    defaultValue,
    value,
    onInternalCalendarChange,
    onInternalOk
  );
  const calendarValue = getCalendarValue();
  const [focused, triggerFocus3, lastOperation, activeIndex] = useRangeActive([disabled]);
  const onSharedFocus = /* @__PURE__ */ __name((event) => {
    triggerFocus3(true);
    onFocus?.(event, {});
  }, "onSharedFocus");
  const onSharedBlur = /* @__PURE__ */ __name((event) => {
    triggerFocus3(false);
    onBlur?.(event, {});
  }, "onSharedBlur");
  const [mergedMode, setMode] = useMergedState(picker, {
    value: mode
  });
  const internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
  const mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
  const onInternalChange = onChange && ((dates, dateStrings) => {
    onChange(pickerParam(dates), pickerParam(dateStrings));
  });
  const [
    ,
    /** Trigger `onChange` directly without check `disabledDate` */
    triggerSubmitChange
  ] = useRangeValue(
    {
      ...filledProps,
      onChange: onInternalChange
    },
    mergedValue,
    setInnerValue,
    getCalendarValue,
    triggerCalendarChange,
    [],
    //disabled,
    formatList,
    focused,
    mergedOpen,
    isInvalidateDate
  );
  const [submitInvalidates, onSelectorInvalid] = useFieldsInvalidate(
    calendarValue,
    isInvalidateDate
  );
  const submitInvalidate = React261.useMemo(
    () => submitInvalidates.some((invalidated) => invalidated),
    [submitInvalidates]
  );
  const onInternalPickerValueChange = /* @__PURE__ */ __name((dates, info) => {
    if (onPickerValueChange) {
      const cleanInfo = { ...info, mode: info.mode[0] };
      delete cleanInfo.range;
      onPickerValueChange(dates[0], cleanInfo);
    }
  }, "onInternalPickerValueChange");
  const [currentPickerValue, setCurrentPickerValue] = useRangePickerValue(
    generateConfig2,
    locale6,
    calendarValue,
    [mergedMode],
    mergedOpen,
    activeIndex,
    internalPicker,
    false,
    // multiplePanel,
    defaultPickerValue,
    pickerValue,
    toArray5(showTime?.defaultOpenValue),
    onInternalPickerValueChange,
    minDate,
    maxDate
  );
  const triggerModeChange = useEvent(
    (nextPickerValue, nextMode, triggerEvent) => {
      setMode(nextMode);
      if (onPanelChange && triggerEvent !== false) {
        const lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
        onPanelChange(lastPickerValue, nextMode);
      }
    }
  );
  const triggerConfirm = /* @__PURE__ */ __name(() => {
    triggerSubmitChange(getCalendarValue());
    triggerOpen(false, { force: true });
  }, "triggerConfirm");
  const onSelectorClick = /* @__PURE__ */ __name((event) => {
    if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) {
      selectorRef.current.focus();
    }
    triggerOpen(true);
    onClick?.(event);
  }, "onSelectorClick");
  const onSelectorClear = /* @__PURE__ */ __name(() => {
    triggerSubmitChange(null);
    triggerOpen(false, { force: true });
  }, "onSelectorClear");
  const [hoverSource, setHoverSource] = React261.useState(null);
  const [internalHoverValue, setInternalHoverValue] = React261.useState(null);
  const hoverValues = React261.useMemo(() => {
    const values = [internalHoverValue, ...calendarValue].filter((date4) => date4);
    return multiple ? values : values.slice(0, 1);
  }, [calendarValue, internalHoverValue, multiple]);
  const selectorValues = React261.useMemo(() => {
    if (!multiple && internalHoverValue) {
      return [internalHoverValue];
    }
    return calendarValue.filter((date4) => date4);
  }, [calendarValue, internalHoverValue, multiple]);
  React261.useEffect(() => {
    if (!mergedOpen) {
      setInternalHoverValue(null);
    }
  }, [mergedOpen]);
  const presetList = usePresets(presets);
  const onPresetHover = /* @__PURE__ */ __name((nextValue) => {
    setInternalHoverValue(nextValue);
    setHoverSource("preset");
  }, "onPresetHover");
  const onPresetSubmit = /* @__PURE__ */ __name((nextValue) => {
    const nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
    const passed = triggerSubmitChange(nextCalendarValues);
    if (passed && !multiple) {
      triggerOpen(false, { force: true });
    }
  }, "onPresetSubmit");
  const onNow = /* @__PURE__ */ __name((now2) => {
    onPresetSubmit(now2);
  }, "onNow");
  const onPanelHover = /* @__PURE__ */ __name((date4) => {
    setInternalHoverValue(date4);
    setHoverSource("cell");
  }, "onPanelHover");
  const onPanelFocus = /* @__PURE__ */ __name((event) => {
    triggerOpen(true);
    onSharedFocus(event);
  }, "onPanelFocus");
  const onPanelSelect = /* @__PURE__ */ __name((date4) => {
    lastOperation("panel");
    const nextValues = multiple ? toggleDates(getCalendarValue(), date4) : [date4];
    triggerCalendarChange(nextValues);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerConfirm();
    }
  }, "onPanelSelect");
  const onPopupClose = /* @__PURE__ */ __name(() => {
    triggerOpen(false);
  }, "onPopupClose");
  const onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  const panelProps = React261.useMemo(() => {
    const domProps = pickAttrs(filledProps, false);
    const restProps = omit(filledProps, [
      ...Object.keys(domProps),
      "onChange",
      "onCalendarChange",
      "style",
      "className",
      "onPanelChange"
    ]);
    return {
      ...restProps,
      multiple: filledProps.multiple
    };
  }, [filledProps]);
  const panel = /* @__PURE__ */ React261.createElement(
    Popup3,
    {
      ...panelProps,
      showNow: mergedShowNow,
      showTime,
      disabledDate,
      onFocus: onPanelFocus,
      onBlur: onSharedBlur,
      picker,
      mode: mergedMode,
      internalMode,
      onPanelChange: triggerModeChange,
      format: maskFormat,
      value: calendarValue,
      isInvalid: isInvalidateDate,
      onChange: null,
      onSelect: onPanelSelect,
      pickerValue: currentPickerValue,
      defaultOpenValue: showTime?.defaultOpenValue,
      onPickerValueChange: setCurrentPickerValue,
      hoverValue: hoverValues,
      onHover: onPanelHover,
      needConfirm,
      onSubmit: triggerConfirm,
      onOk: triggerOk,
      presets: presetList,
      onPresetHover,
      onPresetSubmit,
      onNow,
      cellRender: onInternalCellRender
    }
  );
  const onSelectorChange = /* @__PURE__ */ __name((date4) => {
    triggerCalendarChange(date4);
  }, "onSelectorChange");
  const onSelectorInputChange = /* @__PURE__ */ __name(() => {
    lastOperation("input");
  }, "onSelectorInputChange");
  const onSelectorFocus = /* @__PURE__ */ __name((event) => {
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    onSharedFocus(event);
  }, "onSelectorFocus");
  const onSelectorBlur = /* @__PURE__ */ __name((event) => {
    triggerOpen(false);
    onSharedBlur(event);
  }, "onSelectorBlur");
  const onSelectorKeyDown = /* @__PURE__ */ __name((event, preventDefault) => {
    if (event.key === "Tab") {
      triggerConfirm();
    }
    onKeyDown2?.(event, preventDefault);
  }, "onSelectorKeyDown");
  const context = React261.useMemo(
    () => ({
      prefixCls,
      locale: locale6,
      generateConfig: generateConfig2,
      button: components.button,
      input: components.input
    }),
    [prefixCls, locale6, generateConfig2, components.button, components.input]
  );
  useLayoutEffect_default(() => {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(() => {
    const lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerConfirm();
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerOpen(true);
      triggerConfirm();
    }
  }, [mergedOpen]);
  return /* @__PURE__ */ React261.createElement(context_default6.Provider, { value: context }, /* @__PURE__ */ React261.createElement(
    PickerTrigger_default,
    {
      ...pickTriggerProps(filledProps),
      popupElement: panel,
      popupStyle: styles.popup,
      popupClassName: classNames253.popup,
      visible: mergedOpen,
      onClose: onPopupClose
    },
    /* @__PURE__ */ React261.createElement(
      SingleSelector_default2,
      {
        ...filledProps,
        ref: selectorRef,
        suffixIcon,
        removeIcon,
        activeHelp: !!internalHoverValue,
        allHelp: !!internalHoverValue && hoverSource === "preset",
        focused,
        onFocus: onSelectorFocus,
        onBlur: onSelectorBlur,
        onKeyDown: onSelectorKeyDown,
        onSubmit: triggerConfirm,
        value: selectorValues,
        maskFormat,
        onChange: onSelectorChange,
        onInputChange: onSelectorInputChange,
        internalPicker,
        format: formatList,
        inputReadOnly,
        disabled,
        open: mergedOpen,
        onOpenChange: triggerOpen,
        onClick: onSelectorClick,
        onClear: onSelectorClear,
        invalid: submitInvalidate,
        onInvalid: (invalid) => {
          onSelectorInvalid(invalid, 0);
        }
      }
    )
  ));
}
__name(Picker, "Picker");
var RefPicker = React261.forwardRef(Picker);
if (true) {
  RefPicker.displayName = "RefPicker";
}
var SinglePicker_default = RefPicker;

// packages/picker/src/index.tsx
var src_default10 = SinglePicker_default;

// packages/ant-design/components/calendar/Header.tsx
import * as React267 from "react";
import { useContext as useContext106, useMemo as useMemo75 } from "react";

// packages/ant-design/components/radio/group.tsx
var import_classnames91 = __toESM(require_classnames());
import * as React265 from "react";

// packages/ant-design/components/radio/context.ts
import * as React262 from "react";
var RadioGroupContext = React262.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var context_default7 = RadioGroupContext;
var RadioOptionTypeContext = React262.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

// packages/ant-design/components/radio/radio.tsx
var import_classnames90 = __toESM(require_classnames());
import * as React264 from "react";

// packages/checkbox/src/index.tsx
var import_classnames89 = __toESM(require_classnames());
import * as React263 from "react";
import { forwardRef as forwardRef54, useImperativeHandle as useImperativeHandle23, useRef as useRef88 } from "react";
var Checkbox = forwardRef54((props, ref) => {
  const {
    prefixCls = "rc-checkbox",
    className,
    style: style2,
    checked,
    disabled,
    defaultChecked = false,
    type: type5 = "checkbox",
    title,
    onChange,
    ...inputProps
  } = props;
  const inputRef = useRef88(null);
  const [rawValue, setRawValue] = useMergedState(defaultChecked, {
    value: checked
  });
  useImperativeHandle23(ref, () => ({
    focus: (options) => {
      inputRef.current?.focus(options);
    },
    blur: () => {
      inputRef.current?.blur();
    },
    input: inputRef.current
  }));
  const classString = (0, import_classnames89.default)(prefixCls, className, {
    [`${prefixCls}-checked`]: rawValue,
    [`${prefixCls}-disabled`]: disabled
  });
  const handleChange = /* @__PURE__ */ __name((e3) => {
    if (disabled) {
      return;
    }
    if (!("checked" in props)) {
      setRawValue(e3.target.checked);
    }
    onChange?.({
      target: {
        ...props,
        type: type5,
        checked: e3.target.checked
      },
      stopPropagation() {
        e3.stopPropagation();
      },
      preventDefault() {
        e3.preventDefault();
      },
      nativeEvent: e3.nativeEvent
    });
  }, "handleChange");
  return /* @__PURE__ */ React263.createElement("span", { className: classString, title, style: style2 }, /* @__PURE__ */ React263.createElement(
    "input",
    {
      ...inputProps,
      className: `${prefixCls}-input`,
      ref: inputRef,
      onChange: handleChange,
      disabled,
      checked: !!rawValue,
      type: type5
    }
  ), /* @__PURE__ */ React263.createElement("span", { className: `${prefixCls}-inner` }));
});
var src_default11 = Checkbox;

// packages/ant-design/components/radio/style/index.ts
var getGroupRadioStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [`${antCls}-badge ${antCls}-badge-count`]: {
        zIndex: 1
      },
      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    }
  };
}, "getGroupRadioStyle");
var getRadioBasicStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    wrapperMarginInlineEnd,
    colorPrimary,
    radioSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOutCirc,
    colorBgContainer,
    colorBorder,
    lineWidth,
    colorBgContainerDisabled,
    colorTextDisabled,
    paddingXS,
    dotColorDisabled,
    lineType,
    radioColor,
    radioBgColor,
    calc
  } = token2;
  const radioInnerPrefixCls = `${componentCls}-inner`;
  const dotPadding = 4;
  const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
  const radioSizeCalc = calc(1).mul(radioSize).equal();
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token2),
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: wrapperMarginInlineEnd,
      cursor: "pointer",
      // RTL
      [`&${componentCls}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      // hashId 在 wrapper 上，只能铺平
      [`${componentCls}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: "50%",
        visibility: "hidden",
        opacity: 0,
        content: '""'
      },
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center",
        borderRadius: "50%"
      },
      [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
        borderColor: colorPrimary
      },
      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: {
        ...genFocusOutline(token2)
      },
      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${componentCls}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: radioSizeCalc,
          height: radioSizeCalc,
          marginBlockStart: calc(1).mul(radioSize).div(-2).equal(),
          marginInlineStart: calc(1).mul(radioSize).div(-2).equal(),
          backgroundColor: radioColor,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: radioSizeCalc,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: radioSizeCalc,
        height: radioSizeCalc,
        backgroundColor: colorBgContainer,
        borderColor: colorBorder,
        borderStyle: "solid",
        borderWidth: lineWidth,
        borderRadius: "50%",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-input`]: {
        position: "absolute",
        inset: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 选中状态
      [`${componentCls}-checked`]: {
        [radioInnerPrefixCls]: {
          borderColor: colorPrimary,
          backgroundColor: radioBgColor,
          "&::after": {
            transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
            opacity: 1,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          }
        }
      },
      [`${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [radioInnerPrefixCls]: {
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: dotColorDisabled
          }
        },
        [`${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            "&::after": {
              transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal({ unit: false })})`
            }
          }
        }
      },
      [`span${componentCls} + *`]: {
        paddingInlineStart: paddingXS,
        paddingInlineEnd: paddingXS
      }
    }
  };
}, "getRadioBasicStyle");
var getRadioButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    buttonColor,
    controlHeight,
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    motionDurationSlow,
    motionDurationMid,
    buttonPaddingInline,
    fontSize,
    buttonBg,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    paddingXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusLG,
    buttonCheckedBg,
    buttonSolidCheckedColor,
    colorTextDisabled,
    colorBgContainerDisabled,
    buttonCheckedBgDisabled,
    buttonCheckedColorDisabled,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    buttonSolidCheckedBg,
    buttonSolidCheckedHoverBg,
    buttonSolidCheckedActiveBg,
    calc
  } = token2;
  return {
    [`${componentCls}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: controlHeight,
      margin: 0,
      paddingInline: buttonPaddingInline,
      paddingBlock: 0,
      color: buttonColor,
      fontSize,
      lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
      background: buttonBg,
      border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
      borderInlineStartWidth: 0,
      borderInlineEndWidth: lineWidth,
      cursor: "pointer",
      transition: [
        `color ${motionDurationMid}`,
        `background ${motionDurationMid}`,
        `box-shadow ${motionDurationMid}`
      ].join(","),
      a: {
        color: buttonColor
      },
      [`> ${componentCls}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: calc(lineWidth).mul(-1).equal(),
          insetInlineStart: calc(lineWidth).mul(-1).equal(),
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: lineWidth,
          paddingInline: 0,
          backgroundColor: colorBorder,
          transition: `background-color ${motionDurationSlow}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
        borderStartStartRadius: borderRadius,
        borderEndStartRadius: borderRadius
      },
      "&:last-child": {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      "&:first-child:last-child": {
        borderRadius
      },
      [`${componentCls}-group-large &`]: {
        height: controlHeightLG,
        fontSize: fontSizeLG,
        lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderEndStartRadius: borderRadiusLG
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        }
      },
      [`${componentCls}-group-small &`]: {
        height: controlHeightSM,
        paddingInline: calc(paddingXS).sub(lineWidth).equal(),
        paddingBlock: 0,
        lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        }
      },
      "&:hover": {
        position: "relative",
        color: colorPrimary
      },
      "&:has(:focus-visible)": {
        ...genFocusOutline(token2)
      },
      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: colorPrimary,
        background: buttonCheckedBg,
        borderColor: colorPrimary,
        "&::before": {
          backgroundColor: colorPrimary
        },
        "&:first-child": {
          borderColor: colorPrimary
        },
        "&:hover": {
          color: colorPrimaryHover,
          borderColor: colorPrimaryHover,
          "&::before": {
            backgroundColor: colorPrimaryHover
          }
        },
        "&:active": {
          color: colorPrimaryActive,
          borderColor: colorPrimaryActive,
          "&::before": {
            backgroundColor: colorPrimaryActive
          }
        }
      },
      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        color: buttonSolidCheckedColor,
        background: buttonSolidCheckedBg,
        borderColor: buttonSolidCheckedBg,
        "&:hover": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedHoverBg,
          borderColor: buttonSolidCheckedHoverBg
        },
        "&:active": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedActiveBg,
          borderColor: buttonSolidCheckedActiveBg
        }
      },
      "&-disabled": {
        color: colorTextDisabled,
        backgroundColor: colorBgContainerDisabled,
        borderColor: colorBorder,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder
        }
      },
      [`&-disabled${componentCls}-button-wrapper-checked`]: {
        color: buttonCheckedColorDisabled,
        backgroundColor: buttonCheckedBgDisabled,
        borderColor: colorBorder,
        boxShadow: "none"
      }
    }
  };
}, "getRadioButtonStyle");
var prepareComponentToken18 = /* @__PURE__ */ __name((token2) => {
  const {
    wireframe,
    padding,
    marginXS,
    lineWidth,
    fontSizeLG,
    colorText,
    colorBgContainer,
    colorTextDisabled,
    controlItemBgActiveDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    colorWhite
  } = token2;
  const dotPadding = 4;
  const radioSize = fontSizeLG;
  const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
  return {
    // Radio
    radioSize,
    dotSize: radioDotSize,
    dotColorDisabled: colorTextDisabled,
    // Radio buttons
    buttonSolidCheckedColor: colorTextLightSolid,
    buttonSolidCheckedBg: colorPrimary,
    buttonSolidCheckedHoverBg: colorPrimaryHover,
    buttonSolidCheckedActiveBg: colorPrimaryActive,
    buttonBg: colorBgContainer,
    buttonCheckedBg: colorBgContainer,
    buttonColor: colorText,
    buttonCheckedBgDisabled: controlItemBgActiveDisabled,
    buttonCheckedColorDisabled: colorTextDisabled,
    buttonPaddingInline: padding - lineWidth,
    wrapperMarginInlineEnd: marginXS,
    // internal
    radioColor: wireframe ? colorPrimary : colorWhite,
    radioBgColor: wireframe ? colorBgContainer : colorPrimary
  };
}, "prepareComponentToken");
var style_default21 = genStyleHooks(
  "Radio",
  (token2) => {
    const { controlOutline, controlOutlineWidth } = token2;
    const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
    const radioButtonFocusShadow = radioFocusShadow;
    const radioToken = merge2(token2, {
      radioFocusShadow,
      radioButtonFocusShadow
    });
    return [
      getGroupRadioStyle(radioToken),
      getRadioBasicStyle(radioToken),
      getRadioButtonStyle(radioToken)
    ];
  },
  prepareComponentToken18,
  {
    unitless: {
      radioSize: true,
      dotSize: true
    }
  }
);

// packages/ant-design/components/radio/radio.tsx
var InternalRadio = /* @__PURE__ */ __name((props, ref) => {
  const groupContext = React264.useContext(context_default7);
  const radioOptionTypeContext = React264.useContext(RadioOptionTypeContext);
  const { getPrefixCls, direction, radio } = React264.useContext(ConfigContext);
  const innerRef = React264.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  const { isFormItemInput } = React264.useContext(FormItemInputContext);
  if (true) {
    const warning5 = devUseWarning("Radio");
    warning5(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.");
  }
  const onChange = /* @__PURE__ */ __name((e3) => {
    props.onChange?.(e3);
    groupContext?.onChange?.(e3);
  }, "onChange");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    style: style2,
    title,
    ...restProps
  } = props;
  const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
  const isButtonType = (groupContext?.optionType || radioOptionTypeContext) === "button";
  const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
  const rootCls = useCSSVarCls_default(radioPrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default21(radioPrefixCls, rootCls);
  const radioProps = { ...restProps };
  const disabled = React264.useContext(DisabledContext_default);
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled ?? groupContext.disabled;
  }
  radioProps.disabled = radioProps.disabled ?? disabled;
  const wrapperClassString = (0, import_classnames90.default)(
    `${prefixCls}-wrapper`,
    {
      [`${prefixCls}-wrapper-checked`]: radioProps.checked,
      [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
      [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
    },
    radio?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls,
    rootCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React264.createElement(wave_default, { component: "Radio", disabled: radioProps.disabled }, /* @__PURE__ */ React264.createElement(
      "label",
      {
        className: wrapperClassString,
        style: { ...radio?.style, ...style2 },
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        title
      },
      /* @__PURE__ */ React264.createElement(
        src_default11,
        {
          ...radioProps,
          className: (0, import_classnames90.default)(radioProps.className, !isButtonType && TARGET_CLS),
          type: "radio",
          prefixCls,
          ref: mergedRef
        }
      ),
      children !== void 0 ? /* @__PURE__ */ React264.createElement("span", null, children) : null
    ))
  );
}, "InternalRadio");
var Radio = React264.forwardRef(InternalRadio);
if (true) {
  Radio.displayName = "Radio";
}
var radio_default = Radio;

// packages/ant-design/components/radio/group.tsx
var RadioGroup = React265.forwardRef((props, ref) => {
  const { getPrefixCls, direction } = React265.useContext(ConfigContext);
  const [value, setValue] = useMergedState(props.defaultValue, {
    value: props.value
  });
  const onRadioChange = /* @__PURE__ */ __name((ev) => {
    const lastValue = value;
    const val = ev.target.value;
    if (!("value" in props)) {
      setValue(val);
    }
    const { onChange } = props;
    if (onChange && val !== lastValue) {
      onChange(ev);
    }
  }, "onRadioChange");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    options,
    buttonStyle = "outline",
    disabled,
    children,
    size: customizeSize,
    style: style2,
    id,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur
  } = props;
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default21(prefixCls, rootCls);
  let childrenToRender = children;
  if (options && options.length > 0) {
    childrenToRender = options.map((option) => {
      if (typeof option === "string" || typeof option === "number") {
        return /* @__PURE__ */ React265.createElement(
          radio_default,
          {
            key: option.toString(),
            prefixCls,
            disabled,
            value: option,
            checked: value === option
          },
          option
        );
      }
      return /* @__PURE__ */ React265.createElement(
        radio_default,
        {
          key: `radio-group-value-options-${option.value}`,
          prefixCls,
          disabled: option.disabled || disabled,
          value: option.value,
          checked: value === option.value,
          title: option.title,
          style: option.style,
          id: option.id,
          required: option.required
        },
        option.label
      );
    });
  }
  const mergedSize = useSize_default(customizeSize);
  const classString = (0, import_classnames91.default)(
    groupPrefixCls,
    `${groupPrefixCls}-${buttonStyle}`,
    {
      [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls,
    rootCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React265.createElement(
      "div",
      {
        ...pickAttrs(props, { aria: true, data: true }),
        className: classString,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        id,
        ref
      },
      /* @__PURE__ */ React265.createElement(
        RadioGroupContextProvider,
        {
          value: {
            onChange: onRadioChange,
            value,
            disabled: props.disabled,
            name: props.name,
            optionType: props.optionType
          }
        },
        childrenToRender
      )
    )
  );
});
var group_default3 = React265.memo(RadioGroup);

// packages/ant-design/components/radio/radioButton.tsx
import * as React266 from "react";
var RadioButton = /* @__PURE__ */ __name((props, ref) => {
  const { getPrefixCls } = React266.useContext(ConfigContext);
  const { prefixCls: customizePrefixCls, ...radioProps } = props;
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  return /* @__PURE__ */ React266.createElement(RadioOptionTypeContextProvider, { value: "button" }, /* @__PURE__ */ React266.createElement(radio_default, { prefixCls, ...radioProps, type: "radio", ref }));
}, "RadioButton");
var radioButton_default = React266.forwardRef(RadioButton);

// packages/ant-design/components/radio/index.ts
var Radio2 = radio_default;
Radio2.Button = radioButton_default;
Radio2.Group = group_default3;
Radio2.__ANT_RADIO = true;
var radio_default2 = Radio2;

// packages/ant-design/components/calendar/Header.tsx
var YearSelectOffset = 10;
var YearSelectTotal = 20;
function YearSelect(props) {
  const { fullscreen, validRange, generateConfig: generateConfig2, locale: locale6, prefixCls, value, onChange, divRef } = props;
  const year = generateConfig2.getYear(value || generateConfig2.getNow());
  let start = year - YearSelectOffset;
  let end = start + YearSelectTotal;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  const suffix = locale6 && locale6.year === "\u5E74" ? "\u5E74" : "";
  const options = [];
  for (let index3 = start; index3 < end; index3++) {
    options.push({ label: `${index3}${suffix}`, value: index3 });
  }
  return /* @__PURE__ */ React267.createElement(
    select_default,
    {
      size: fullscreen ? void 0 : "small",
      options,
      value: year,
      className: `${prefixCls}-year-select`,
      onChange: (numYear) => {
        let newDate = generateConfig2.setYear(value, numYear);
        if (validRange) {
          const [startDate, endDate] = validRange;
          const newYear = generateConfig2.getYear(newDate);
          const newMonth = generateConfig2.getMonth(newDate);
          if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
            newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
          }
          if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
            newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
          }
        }
        onChange(newDate);
      },
      getPopupContainer: () => divRef.current
    }
  );
}
__name(YearSelect, "YearSelect");
function MonthSelect(props) {
  const { prefixCls, fullscreen, validRange, value, generateConfig: generateConfig2, locale: locale6, onChange, divRef } = props;
  const month = generateConfig2.getMonth(value || generateConfig2.getNow());
  let start = 0;
  let end = 11;
  if (validRange) {
    const [rangeStart, rangeEnd] = validRange;
    const currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  const months = locale6.shortMonths || generateConfig2.locale.getShortMonths(locale6.locale);
  const options = [];
  for (let index3 = start; index3 <= end; index3 += 1) {
    options.push({
      label: months[index3],
      value: index3
    });
  }
  return /* @__PURE__ */ React267.createElement(
    select_default,
    {
      size: fullscreen ? void 0 : "small",
      className: `${prefixCls}-month-select`,
      value: month,
      options,
      onChange: (newMonth) => {
        onChange(generateConfig2.setMonth(value, newMonth));
      },
      getPopupContainer: () => divRef.current
    }
  );
}
__name(MonthSelect, "MonthSelect");
function ModeSwitch(props) {
  const { prefixCls, locale: locale6, mode, fullscreen, onModeChange } = props;
  return /* @__PURE__ */ React267.createElement(
    group_default3,
    {
      onChange: ({ target: { value } }) => {
        onModeChange(value);
      },
      value: mode,
      size: fullscreen ? void 0 : "small",
      className: `${prefixCls}-mode-switch`
    },
    /* @__PURE__ */ React267.createElement(radioButton_default, { value: "month" }, locale6.month),
    /* @__PURE__ */ React267.createElement(radioButton_default, { value: "year" }, locale6.year)
  );
}
__name(ModeSwitch, "ModeSwitch");
function CalendarHeader(props) {
  const { prefixCls, fullscreen, mode, onChange, onModeChange } = props;
  const divRef = React267.useRef(null);
  const formItemInputContext = useContext106(FormItemInputContext);
  const mergedFormItemInputContext = useMemo75(
    () => ({
      ...formItemInputContext,
      isFormItemInput: false
    }),
    [formItemInputContext]
  );
  const sharedProps = {
    ...props,
    fullscreen,
    divRef
  };
  return /* @__PURE__ */ React267.createElement("div", { className: `${prefixCls}-header`, ref: divRef }, /* @__PURE__ */ React267.createElement(FormItemInputContext.Provider, { value: mergedFormItemInputContext }, /* @__PURE__ */ React267.createElement(
    YearSelect,
    {
      ...sharedProps,
      onChange: (v) => {
        onChange(v, "year");
      }
    }
  ), mode === "month" && /* @__PURE__ */ React267.createElement(
    MonthSelect,
    {
      ...sharedProps,
      onChange: (v) => {
        onChange(v, "month");
      }
    }
  )), /* @__PURE__ */ React267.createElement(ModeSwitch, { ...sharedProps, onModeChange }));
}
__name(CalendarHeader, "CalendarHeader");
var Header_default = CalendarHeader;

// packages/ant-design/components/input/style/token.ts
function initInputToken(token2) {
  return merge2(token2, {
    inputAffixPadding: token2.paddingXXS
  });
}
__name(initInputToken, "initInputToken");
var initComponentToken = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightSM,
    controlHeightLG,
    fontSizeLG,
    lineHeightLG,
    paddingSM,
    controlPaddingHorizontalSM,
    controlPaddingHorizontal,
    colorFillAlter,
    colorPrimaryHover,
    colorPrimary,
    controlOutlineWidth,
    controlOutline,
    colorErrorOutline,
    colorWarningOutline,
    colorBgContainer
  } = token2;
  return {
    paddingBlock: Math.max(
      Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth,
      0
    ),
    paddingBlockSM: Math.max(
      Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth,
      0
    ),
    paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
    paddingInline: paddingSM - lineWidth,
    paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
    paddingInlineLG: controlPaddingHorizontal - lineWidth,
    addonBg: colorFillAlter,
    activeBorderColor: colorPrimary,
    hoverBorderColor: colorPrimaryHover,
    activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
    errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
    warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
    hoverBg: colorBgContainer,
    activeBg: colorBgContainer,
    inputFontSize: fontSize,
    inputFontSizeLG: fontSizeLG,
    inputFontSizeSM: fontSize
  };
}, "initComponentToken");

// packages/ant-design/components/input/style/variants.ts
var genHoverStyle = /* @__PURE__ */ __name((token2) => ({
  borderColor: token2.hoverBorderColor,
  backgroundColor: token2.hoverBg
}), "genHoverStyle");
var genDisabledStyle2 = /* @__PURE__ */ __name((token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  [`input[disabled], textarea[disabled]`]: {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": {
    ...genHoverStyle(
      merge2(token2, {
        hoverBorderColor: token2.colorBorder,
        hoverBg: token2.colorBgContainerDisabled
      })
    )
  }
}), "genDisabledStyle");
var genBaseOutlinedStyle2 = /* @__PURE__ */ __name((token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: options.borderColor,
  "&:hover": {
    borderColor: options.hoverBorderColor,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: options.activeBorderColor,
    boxShadow: options.activeShadow,
    outline: 0,
    backgroundColor: token2.activeBg
  }
}), "genBaseOutlinedStyle");
var genOutlinedStatusStyle2 = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseOutlinedStyle2(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  }
}), "genOutlinedStatusStyle");
var genOutlinedStyle2 = /* @__PURE__ */ __name((token2, extraStyles) => ({
  "&-outlined": {
    ...genBaseOutlinedStyle2(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle2(token2)
    },
    ...genOutlinedStatusStyle2(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    }),
    ...genOutlinedStatusStyle2(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
}), "genOutlinedStyle");
var genOutlinedGroupStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      borderColor: options.addonBorderColor,
      color: options.addonColor
    }
  }
}), "genOutlinedGroupStatusStyle");
var genOutlinedGroupStyle = /* @__PURE__ */ __name((token2) => ({
  "&-outlined": {
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.addonBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    ...genOutlinedGroupStatusStyle(token2, {
      status: "error",
      addonBorderColor: token2.colorError,
      addonColor: token2.colorErrorText
    }),
    ...genOutlinedGroupStatusStyle(token2, {
      status: "warning",
      addonBorderColor: token2.colorWarning,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group-addon`]: {
        ...genDisabledStyle2(token2)
      }
    }
  }
}), "genOutlinedGroupStyle");
var genBorderlessStyle2 = /* @__PURE__ */ __name((token2, extraStyles) => ({
  "&-borderless": {
    background: "transparent",
    border: "none",
    "&:focus, &:focus-within": {
      outline: "none"
    },
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      color: token2.colorTextDisabled
    },
    ...extraStyles
  }
}), "genBorderlessStyle");
var genBaseFilledStyle2 = /* @__PURE__ */ __name((token2, options) => ({
  background: options.bg,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: "transparent",
  [`input&, & input, textarea&, & textarea`]: {
    color: options?.inputColor
  },
  "&:hover": {
    background: options.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: options.activeBorderColor,
    backgroundColor: token2.activeBg
  }
}), "genBaseFilledStyle");
var genFilledStatusStyle2 = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseFilledStyle2(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  }
}), "genFilledStatusStyle");
var genFilledStyle2 = /* @__PURE__ */ __name((token2, extraStyles) => ({
  "&-filled": {
    ...genBaseFilledStyle2(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.colorPrimary
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle2(token2)
    },
    ...genFilledStatusStyle2(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      inputColor: token2.colorErrorText,
      affixColor: token2.colorError
    }),
    ...genFilledStatusStyle2(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      inputColor: token2.colorWarningText,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
}), "genFilledStyle");
var genFilledGroupStatusStyle = /* @__PURE__ */ __name((token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      background: options.addonBg,
      color: options.addonColor
    }
  }
}), "genFilledGroupStatusStyle");
var genFilledGroupStyle = /* @__PURE__ */ __name((token2) => ({
  "&-filled": {
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.colorFillTertiary
      },
      [`${token2.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        }
      }
    },
    ...genFilledGroupStatusStyle(token2, {
      status: "error",
      addonBg: token2.colorErrorBg,
      addonColor: token2.colorErrorText
    }),
    ...genFilledGroupStatusStyle(token2, {
      status: "warning",
      addonBg: token2.colorWarningBg,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.colorFillTertiary,
          color: token2.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        }
      }
    }
  }
}), "genFilledGroupStyle");

// packages/ant-design/components/input/style/index.ts
var genPlaceholderStyle = /* @__PURE__ */ __name((color) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), "genPlaceholderStyle");
var genInputLargeStyle = /* @__PURE__ */ __name((token2) => {
  const { paddingBlockLG, lineHeightLG, borderRadiusLG, paddingInlineLG } = token2;
  return {
    padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
    fontSize: token2.inputFontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
}, "genInputLargeStyle");
var genInputSmallStyle = /* @__PURE__ */ __name((token2) => ({
  padding: `${unit(token2.paddingBlockSM)} ${unit(token2.paddingInlineSM)}`,
  fontSize: token2.inputFontSizeSM,
  borderRadius: token2.borderRadiusSM
}), "genInputSmallStyle");
var genBasicInputStyle = /* @__PURE__ */ __name((token2) => ({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${unit(token2.paddingBlock)} ${unit(token2.paddingInline)}`,
  color: token2.colorText,
  fontSize: token2.inputFontSize,
  lineHeight: token2.lineHeight,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`,
  ...genPlaceholderStyle(token2.colorTextPlaceholder),
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": {
    ...genInputLargeStyle(token2)
  },
  "&-sm": {
    ...genInputSmallStyle(token2)
  },
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), "genBasicInputStyle");
var genInputGroupStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    [`&[class*='col-']`]: {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: {
      ...genInputLargeStyle(token2)
    },
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: {
      ...genInputSmallStyle(token2)
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      [`&-addon, &-wrap`]: {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${unit(token2.paddingInline)}`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.inputFontSize,
        textAlign: "center",
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `${unit(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit(
            token2.calc(token2.paddingInline).mul(-1).equal()
          )}`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${antCls}-select-selector`]: {
              color: token2.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [`${componentCls}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: {
      display: "block",
      ...clearFix(),
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: token2.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${componentCls}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token2.borderRadius
          }
        }
      }
    }
  };
}, "genInputGroupStyle");
var genInputStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, controlHeightSM, lineWidth, calc } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBasicInputStyle(token2),
      // Variants
      ...genOutlinedStyle2(token2),
      ...genFilledStyle2(token2),
      ...genBorderlessStyle2(token2),
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    }
  };
}, "genInputStyle");
var genAllowClearStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:hover": {
        color: token2.colorTextTertiary
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${unit(token2.inputAffixPadding)}`
      }
    }
  };
}, "genAllowClearStyle");
var genAffixStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  const affixCls = `${componentCls}-affix-wrapper`;
  return {
    [affixCls]: {
      ...genBasicInputStyle(token2),
      display: "inline-flex",
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${componentCls}`]: {
        padding: 0
      },
      [`> input${componentCls}, > textarea${componentCls}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      },
      ...genAllowClearStyle(token2),
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
}, "genAffixStyle");
var genGroupStyle3 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, borderRadiusLG, borderRadiusSM } = token2;
  return {
    [`${componentCls}-group`]: {
      // Style for input-group: input with label, with button or dropdown...
      ...resetComponent(token2),
      ...genInputGroupStyle(token2),
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design/issues/6403
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG,
            fontSize: token2.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        // Variants
        ...genOutlinedGroupStyle(token2),
        ...genFilledGroupStyle(token2),
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      }
    }
  };
}, "genGroupStyle");
var genSearchInputStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  const searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [`${componentCls}`]: {
        "&:hover, &:focus": {
          borderColor: token2.colorPrimaryHover,
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token2.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${componentCls}-lg`]: {
        lineHeight: token2.calc(token2.lineHeightLG).sub(2e-4).equal({ unit: false })
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token2.colorTextDescription,
            "&:hover": {
              color: token2.colorPrimaryHover
            },
            "&:active": {
              color: token2.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token2.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${searchPrefixCls}-button`]: {
        height: token2.controlHeightLG
      },
      [`&-small ${searchPrefixCls}-button`]: {
        height: token2.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, "genSearchInputStyle");
var genTextAreaStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, paddingLG } = token2;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${componentCls}`]: {
          height: "100%"
        },
        [`${componentCls}-data-count`]: {
          position: "absolute",
          bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      "&-allow-clear": {
        [`> ${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
        [`${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token2.paddingXS,
            insetBlockStart: token2.paddingXS
          },
          // Feedback Icon
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
}, "genTextAreaStyle");
var genRangeStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-out-of-range`]: {
      [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
        color: token2.colorError
      }
    }
  };
}, "genRangeStyle");
var style_default22 = genStyleHooks(
  "Input",
  (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [
      genInputStyle(inputToken),
      genTextAreaStyle(inputToken),
      genAffixStyle(inputToken),
      genGroupStyle3(inputToken),
      genSearchInputStyle(inputToken),
      genRangeStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)
    ];
  },
  initComponentToken,
  {
    resetFont: false
  }
);

// packages/ant-design/components/date-picker/style/multiple.ts
var genSize = /* @__PURE__ */ __name((token2, suffix) => {
  const { componentCls, controlHeight } = token2;
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  const multipleSelectorUnit = getMultipleSelectorUnit(token2);
  return [
    // genSelectionStyle(token, suffix),
    {
      [`${componentCls}-multiple${suffixCls}`]: {
        paddingBlock: multipleSelectorUnit.containerPadding,
        paddingInlineStart: multipleSelectorUnit.basePadding,
        minHeight: controlHeight,
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          height: multipleSelectorUnit.itemHeight,
          lineHeight: unit(multipleSelectorUnit.itemLineHeight)
        }
      }
    }
  ];
}, "genSize");
var genPickerMultipleStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, calc, lineWidth } = token2;
  const smallToken = merge2(token2, {
    fontHeight: token2.fontSize,
    selectHeight: token2.controlHeightSM,
    multipleSelectItemHeight: token2.multipleItemHeightSM,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS,
    controlHeight: token2.controlHeightSM
  });
  const largeToken = merge2(token2, {
    fontHeight: calc(token2.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
    fontSize: token2.fontSizeLG,
    selectHeight: token2.controlHeightLG,
    multipleSelectItemHeight: token2.multipleItemHeightLG,
    borderRadius: token2.borderRadiusLG,
    borderRadiusSM: token2.borderRadius,
    controlHeight: token2.controlHeightLG
  });
  return [
    // ======================== Size ========================
    genSize(smallToken, "small"),
    genSize(token2),
    genSize(largeToken, "large"),
    // ====================== Selection ======================
    {
      [`${componentCls}${componentCls}-multiple`]: {
        width: "100%",
        cursor: "text",
        // ==================== Selector =====================
        [`${componentCls}-selector`]: {
          flex: "auto",
          padding: 0,
          position: "relative",
          "&:after": {
            margin: 0
          },
          // ================== placeholder ==================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.inputPaddingHorizontalBase,
            insetInlineEnd: 0,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }
        },
        // ===================== Overflow ====================
        ...genOverflowStyle(token2),
        // ====================== Input ======================
        // Input is `readonly`, which is used for a11y only
        [`${componentCls}-multiple-input`]: {
          width: 0,
          height: 0,
          border: 0,
          visibility: "hidden",
          position: "absolute",
          zIndex: -1
        }
      }
    }
  ];
}, "genPickerMultipleStyle");
var multiple_default2 = genPickerMultipleStyle;

// packages/ant-design/components/date-picker/style/panel.ts
init_public_api();
var genPickerCellInnerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    pickerCellCls,
    pickerCellInnerCls,
    cellHeight,
    borderRadiusSM,
    motionDurationMid,
    cellHoverBg,
    lineWidth,
    lineType,
    colorPrimary,
    cellActiveWithRangeBg,
    colorTextLightSolid,
    colorTextDisabled,
    cellBgDisabled,
    colorFillSecondary
  } = token2;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: cellHeight,
      transform: "translateY(-50%)",
      content: '""'
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: cellHeight,
      height: cellHeight,
      lineHeight: unit(cellHeight),
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end)`]: {
      [pickerCellInnerCls]: {
        background: cellHoverBg
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      position: "relative",
      [`&:not(${pickerCellCls}-disabled):before`]: {
        background: cellActiveWithRangeBg
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      [`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
        color: colorTextLightSolid,
        background: colorPrimary
      },
      [`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: {
        background: colorFillSecondary
      }
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: {
      insetInlineEnd: "50%"
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      pointerEvents: "none",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: cellBgDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
}, "genPickerCellInnerStyle");
var genPanelStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    cellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    textHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    cellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    motionDurationSlow,
    withoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    borderRadiusSM,
    colorTextLightSolid,
    cellHoverBg,
    timeColumnHeight,
    timeColumnWidth,
    timeCellHeight,
    controlItemBgActive,
    marginXXS,
    pickerDatePanelPaddingHorizontal,
    pickerControlIconMargin
  } = token2;
  const pickerPanelWidth = token2.calc(cellWidth).mul(7).add(token2.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${unit(paddingXS)}`,
        color: colorTextHeading,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: unit(textHeight),
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          fontSize: "inherit"
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          },
          "&:disabled": {
            opacity: 0.25,
            pointerEvents: "none"
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: unit(textHeight),
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
        position: "relative",
        display: "inline-block",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: `0 solid currentcolor`,
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-super-prev-icon,
        &-super-next-icon`]: {
        "&::after": {
          position: "absolute",
          top: pickerControlIconMargin,
          insetInlineStart: pickerControlIconMargin,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-prev-icon,
        &-super-prev-icon`]: {
        transform: "rotate(-45deg)"
      },
      [`&-next-icon,
        &-super-next-icon`]: {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: cellHeight,
          fontWeight: "normal"
        },
        th: {
          height: token2.calc(cellHeight).add(token2.calc(pickerCellPaddingVertical).mul(2)).equal(),
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": {
        padding: `${unit(pickerCellPaddingVertical)} 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        },
        ...genPickerCellInnerStyle(token2)
      },
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-content`]: {
          height: token2.calc(withoutTimeCellHeight).mul(4).equal()
        },
        [pickerCellInnerCls]: {
          padding: `0 ${unit(paddingXS)}`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${unit(token2.calc(paddingXS).div(2).equal())}`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-body`]: {
          padding: `0 ${unit(paddingXS)}`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(pickerDatePanelPaddingHorizontal)}`
        },
        [`${componentCls}-content th`]: {
          boxSizing: "border-box",
          padding: 0
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        // Clear cell style
        [`${componentCls}-cell`]: {
          [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            "&:before": {
              transition: `background ${motionDurationMid}`
            },
            "&:first-child:before": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child:before": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          [`&:hover td`]: {
            "&:before": {
              background: cellHoverBg
            }
          },
          [`&-range-start td,
            &-range-end td,
            &-selected td,
            &-hover td`]: {
            // Rise priority to override hover style
            [`&${pickerCellCls}`]: {
              "&:before": {
                background: colorPrimary
              },
              [`&${componentCls}-cell-week`]: {
                color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
              },
              [pickerCellInnerCls]: {
                color: colorTextLightSolid
              }
            }
          },
          [`&-range-hover td:before`]: {
            background: controlItemBgActive
          }
        }
      },
      // >>> ShowWeek
      [`&-week-panel, &-date-panel-show-week`]: {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(paddingSM)}`
        },
        [`${componentCls}-content th`]: {
          width: "auto"
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: timeColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: timeColumnWidth,
          margin: `${unit(paddingXXS)} 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::-webkit-scrollbar": {
            width: 8,
            backgroundColor: "transparent"
          },
          "&::-webkit-scrollbar-thumb": {
            backgroundColor: token2.colorTextTertiary,
            borderRadius: token2.borderRadiusSM
          },
          // For Firefox
          "&": {
            scrollbarWidth: "thin",
            scrollbarColor: `${token2.colorTextTertiary} transparent`
          },
          "&::after": {
            display: "block",
            height: token2.calc("100%").sub(timeCellHeight).equal(),
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: token2.calc(timeColumnWidth).sub(token2.calc(marginXXS).mul(2)).equal(),
                height: timeCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: token2.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                color: colorText,
                lineHeight: unit(timeCellHeight),
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: cellHoverBg
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      }
    }
  };
}, "genPanelStyle");
var genPickerPanelStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    textHeight,
    lineWidth,
    paddingSM,
    antCls,
    colorPrimary,
    cellActiveWithRangeBg,
    colorPrimaryBorder,
    lineType,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-dropdown`]: {
      // ======================== Footer ========================
      [`${componentCls}-footer`]: {
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-extra": {
          padding: `0 ${unit(paddingSM)}`,
          lineHeight: unit(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          }
        }
      },
      // ==================== Footer > Ranges ===================
      [`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: {
        justifyContent: "space-between"
      },
      [`${componentCls}-ranges`]: {
        marginBlock: 0,
        paddingInline: unit(paddingSM),
        overflow: "hidden",
        textAlign: "start",
        listStyle: "none",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        "> li": {
          lineHeight: unit(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          display: "inline-block"
        },
        [`${componentCls}-now-btn-disabled`]: {
          pointerEvents: "none",
          color: token2.colorTextDisabled
        },
        // https://github.com/ant-design/ant-design/issues/23687
        [`${componentCls}-preset > ${antCls}-tag-blue`]: {
          color: colorPrimary,
          background: cellActiveWithRangeBg,
          borderColor: colorPrimaryBorder,
          cursor: "pointer"
        },
        [`${componentCls}-ok`]: {
          paddingBlock: token2.calc(lineWidth).mul(2).equal(),
          marginInlineStart: "auto"
        }
      }
    }
  };
}, "genPickerPanelStyle");
var panel_default = genPickerPanelStyle;

// packages/ant-design/components/date-picker/style/token.ts
init_public_api();
var initPickerPanelToken = /* @__PURE__ */ __name((token2) => {
  const { componentCls, controlHeightLG, paddingXXS, padding } = token2;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerYearMonthCellWidth: token2.calc(controlHeightLG).mul(1.5).equal(),
    pickerQuarterPanelContentHeight: token2.calc(controlHeightLG).mul(1.4).equal(),
    pickerCellPaddingVertical: token2.calc(paddingXXS).add(token2.calc(paddingXXS).div(2)).equal(),
    pickerCellBorderGap: 2,
    // Magic for gap between cells
    pickerControlIconSize: 7,
    pickerControlIconMargin: 4,
    pickerControlIconBorderWidth: 1.5,
    pickerDatePanelPaddingHorizontal: token2.calc(padding).add(token2.calc(paddingXXS).div(2)).equal()
    // 18 in normal
  };
}, "initPickerPanelToken");
var initPanelComponentToken = /* @__PURE__ */ __name((token2) => {
  const {
    colorBgContainerDisabled,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    lineWidth
  } = token2;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(
    controlHeightSM - dblPaddingXXS,
    controlHeightSM - dblLineWidth
  );
  const multipleItemHeightLG = Math.min(
    controlHeightLG - dblPaddingXXS,
    controlHeightLG - dblLineWidth
  );
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  const filledToken = {
    INTERNAL_FIXED_ITEM_MARGIN,
    cellHoverBg: token2.controlItemBgHover,
    cellActiveWithRangeBg: token2.controlItemBgActive,
    cellHoverWithRangeBg: new TinyColor(token2.colorPrimary).lighten(35).toHexString(),
    cellRangeBorderColor: new TinyColor(token2.colorPrimary).lighten(20).toHexString(),
    cellBgDisabled: colorBgContainerDisabled,
    timeColumnWidth: controlHeightLG * 1.4,
    timeColumnHeight: 28 * 8,
    timeCellHeight: 28,
    cellWidth: controlHeightSM * 1.5,
    cellHeight: controlHeightSM,
    textHeight: controlHeightLG,
    withoutTimeCellHeight: controlHeightLG * 1.65,
    multipleItemBg: token2.colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: token2.colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent"
  };
  return filledToken;
}, "initPanelComponentToken");
var prepareComponentToken19 = /* @__PURE__ */ __name((token2) => ({
  ...initComponentToken(token2),
  ...initPanelComponentToken(token2),
  ...getArrowToken(token2),
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token2.zIndexPopupBase + 50
}), "prepareComponentToken");

// packages/ant-design/components/date-picker/style/variants.ts
var genVariantsStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: [
      {
        ...genOutlinedStyle2(token2),
        ...genFilledStyle2(token2),
        ...genBorderlessStyle2(token2)
      },
      // ========================= Multiple =========================
      {
        "&-outlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        },
        "&-filled": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.colorBgContainer,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          }
        },
        "&-borderless": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        }
      }
    ]
  };
}, "genVariantsStyle");
var variants_default2 = genVariantsStyle2;

// packages/ant-design/components/date-picker/style/index.ts
var genPickerPadding = /* @__PURE__ */ __name((token2, inputHeight, fontHeight, paddingHorizontal) => {
  const height = token2.calc(fontHeight).add(2).equal();
  const paddingTop = token2.max(token2.calc(inputHeight).sub(height).div(2).equal(), 0);
  const paddingBottom = token2.max(token2.calc(inputHeight).sub(height).sub(paddingTop).equal(), 0);
  return {
    padding: `${unit(paddingTop)} ${unit(paddingHorizontal)} ${unit(paddingBottom)}`
  };
}, "genPickerPadding");
var genPickerStatusStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, colorError, colorWarning } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
      [`&${componentCls}-status-error`]: {
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
}, "genPickerStatusStyle");
var genPickerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    paddingInline,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorTextDisabled,
    colorTextPlaceholder,
    controlHeightLG,
    fontSizeLG,
    controlHeightSM,
    paddingInlineSM,
    paddingXS,
    marginXS,
    colorTextDescription,
    lineWidthBold,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    sizePopupArrow,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    cellHoverBg,
    presetsWidth,
    presetsMaxWidth,
    boxShadowPopoverArrow,
    fontHeight,
    fontHeightLG,
    lineHeightLG
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...genPickerPadding(token2, controlHeight, fontHeight, paddingInline),
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        lineHeight: 1,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": {
            position: "relative",
            display: "inline-block",
            width: "100%",
            color: "inherit",
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            transition: `all ${motionDurationMid}`,
            ...genPlaceholderStyle(colorTextPlaceholder),
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            fontFamily: "inherit",
            "&:focus": {
              boxShadow: "none",
              outline: 0
            },
            "&[disabled]": {
              background: "transparent",
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": {
          ...genPickerPadding(token2, controlHeightLG, fontHeightLG, paddingInline),
          [`${componentCls}-input > input`]: {
            fontSize: fontSizeLG,
            lineHeight: lineHeightLG
          }
        },
        "&-small": {
          ...genPickerPadding(token2, controlHeightSM, fontHeight, paddingInlineSM)
        },
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: token2.calc(paddingXS).div(2).equal(),
          color: colorTextDisabled,
          lineHeight: 1,
          pointerEvents: "none",
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextDisabled,
          lineHeight: 1,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorTextDescription
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          },
          // Should use the following selector, but since `:has` has poor compatibility,
          // we use `:not(:last-child)` instead, which may cause some problems in some cases.
          // [`${componentCls}-suffix:has(+ ${componentCls}-clear)`]: {
          [`${componentCls}-suffix:not(:last-child)`]: {
            opacity: 0
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextDisabled,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorTextDescription
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: token2.calc(lineWidth).mul(-1).equal(),
            height: lineWidthBold,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${unit(paddingXS)}`,
            lineHeight: 1
          }
        },
        // ======================== Clear =========================
        "&-range, &-multiple": {
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: paddingInline
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: paddingInlineSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": {
          ...resetComponent(token2),
          ...genPanelStyle(token2),
          pointerEvents: "none",
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: {
            position: "absolute",
            zIndex: 1,
            display: "none",
            paddingInline: token2.calc(paddingInline).mul(1.5).equal(),
            boxSizing: "content-box",
            transition: `left ${motionDurationSlow} ease-out`,
            ...genRoundedArrow(token2, colorBgElevated, boxShadowPopoverArrow),
            "&:before": {
              insetInlineStart: token2.calc(paddingInline).mul(1.5).equal()
            }
          },
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            display: "inline-block",
            pointerEvents: "auto",
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
                li: {
                  ...textEllipsis,
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: token2.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: cellHoverBg
                  }
                }
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              // [`${componentCls}-panel`]: {
              //   borderWidth: `0 0 ${unit(lineWidth)}`,
              // },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        },
        "&-dropdown-range": {
          padding: `${unit(token2.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
}, "genPickerStyle");
var style_default23 = genStyleHooks(
  "DatePicker",
  (token2) => {
    const pickerToken = merge2(
      initInputToken(token2),
      initPickerPanelToken(token2),
      {
        inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: token2.multipleItemHeight,
        selectHeight: token2.controlHeight
      }
    );
    return [
      panel_default(pickerToken),
      genPickerStyle(pickerToken),
      variants_default2(pickerToken),
      genPickerStatusStyle(pickerToken),
      multiple_default2(pickerToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(token2, {
        focusElCls: `${token2.componentCls}-focused`
      })
    ];
  },
  prepareComponentToken19
);

// packages/ant-design/components/calendar/style/index.ts
var genCalendarStyles = /* @__PURE__ */ __name((token2) => {
  const { calendarCls, componentCls, fullBg, fullPanelBg, itemActiveBg } = token2;
  return {
    [calendarCls]: {
      ...genPanelStyle(token2),
      ...resetComponent(token2),
      background: fullBg,
      "&-rtl": {
        direction: "rtl"
      },
      [`${calendarCls}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${unit(token2.paddingSM)} 0`,
        [`${calendarCls}-year-select`]: {
          minWidth: token2.yearControlWidth
        },
        [`${calendarCls}-month-select`]: {
          minWidth: token2.monthControlWidth,
          marginInlineStart: token2.marginXS
        },
        [`${calendarCls}-mode-switch`]: {
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${calendarCls} ${componentCls}-panel`]: {
      background: fullPanelBg,
      border: 0,
      borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
      borderRadius: 0,
      [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
        width: "auto"
      },
      [`${componentCls}-body`]: {
        padding: `${unit(token2.paddingXS)} 0`
      },
      [`${componentCls}-content`]: {
        width: "100%"
      }
    },
    [`${calendarCls}-mini`]: {
      borderRadius: token2.borderRadiusLG,
      [`${calendarCls}-header`]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS
      },
      [`${componentCls}-panel`]: {
        borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
      },
      [`${componentCls}-content`]: {
        height: token2.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: `${unit(token2.weekHeight)}`
        }
      },
      [`${componentCls}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${calendarCls}${calendarCls}-full`]: {
      [`${componentCls}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: fullBg,
        border: 0,
        [`${componentCls}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: token2.paddingSM,
            paddingBottom: token2.paddingXXS,
            lineHeight: `${unit(token2.weekHeight)}`
          }
        }
      },
      [`${componentCls}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${calendarCls}-date`]: {
            background: token2.controlItemBgHover
          }
        },
        [`${calendarCls}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${componentCls}-cell-selected`]: {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            background: itemActiveBg
          }
        },
        "&-selected, &-selected:hover": {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            [`${calendarCls}-date-value`]: {
              color: token2.colorPrimary
            }
          }
        }
      },
      [`${calendarCls}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${unit(token2.calc(token2.marginXS).div(2).equal())}`,
        padding: `${unit(token2.calc(token2.paddingXS).div(2).equal())} ${unit(token2.paddingXS)} 0`,
        border: 0,
        borderTop: `${unit(token2.lineWidthBold)} ${token2.lineType} ${token2.colorSplit}`,
        borderRadius: 0,
        transition: `background ${token2.motionDurationSlow}`,
        "&-value": {
          lineHeight: `${unit(token2.dateValueHeight)}`,
          transition: `color ${token2.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: token2.dateContentHeight,
          overflowY: "auto",
          color: token2.colorText,
          lineHeight: token2.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: token2.colorPrimary,
          [`${calendarCls}-date-value`]: {
            color: token2.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${unit(token2.screenXS)}) `]: {
      [`${calendarCls}`]: {
        [`${calendarCls}-header`]: {
          display: "block",
          [`${calendarCls}-year-select`]: {
            width: "50%"
          },
          [`${calendarCls}-month-select`]: {
            width: `calc(50% - ${unit(token2.paddingXS)})`
          },
          [`${calendarCls}-mode-switch`]: {
            width: "100%",
            marginTop: token2.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
}, "genCalendarStyles");
var prepareComponentToken20 = /* @__PURE__ */ __name((token2) => ({
  fullBg: token2.colorBgContainer,
  fullPanelBg: token2.colorBgContainer,
  itemActiveBg: token2.controlItemBgActive,
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256,
  ...initPanelComponentToken(token2)
}), "prepareComponentToken");
var style_default24 = genStyleHooks(
  "Calendar",
  (token2) => {
    const calendarCls = `${token2.componentCls}-calendar`;
    const calendarToken = merge2(token2, initPickerPanelToken(token2), {
      calendarCls,
      pickerCellInnerCls: `${token2.componentCls}-cell-inner`,
      dateValueHeight: token2.controlHeightSM,
      weekHeight: token2.calc(token2.controlHeightSM).mul(0.75).equal(),
      dateContentHeight: token2.calc(token2.calc(token2.fontHeightSM).add(token2.marginXS)).mul(3).add(token2.calc(token2.lineWidth).mul(2)).equal()
    });
    return [genCalendarStyles(calendarToken)];
  },
  prepareComponentToken20
);

// packages/ant-design/components/calendar/generateCalendar.tsx
function generateCalendar(generateConfig2) {
  function isSameYear2(date1, date22) {
    return date1 && date22 && generateConfig2.getYear(date1) === generateConfig2.getYear(date22);
  }
  __name(isSameYear2, "isSameYear");
  function isSameMonth2(date1, date22) {
    return isSameYear2(date1, date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22);
  }
  __name(isSameMonth2, "isSameMonth");
  function isSameDate2(date1, date22) {
    return isSameMonth2(date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
  }
  __name(isSameDate2, "isSameDate");
  const Calendar2 = /* @__PURE__ */ __name((props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      dateFullCellRender,
      dateCellRender,
      monthFullCellRender,
      monthCellRender,
      cellRender,
      fullCellRender,
      headerRender,
      value,
      defaultValue,
      disabledDate,
      mode,
      validRange,
      fullscreen = true,
      onChange,
      onPanelChange,
      onSelect
    } = props;
    const { getPrefixCls, direction, calendar } = React268.useContext(ConfigContext);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const calendarPrefixCls = `${prefixCls}-calendar`;
    const [wrapCSSVar, hashId, cssVarCls] = style_default24(prefixCls, calendarPrefixCls);
    const today = generateConfig2.getNow();
    if (true) {
      const warning5 = devUseWarning("Calendar");
      warning5.deprecated(!dateFullCellRender, "dateFullCellRender", "fullCellRender");
      warning5.deprecated(!dateCellRender, "dateCellRender", "cellRender");
      warning5.deprecated(!monthFullCellRender, "monthFullCellRender", "fullCellRender");
      warning5.deprecated(!monthCellRender, "monthCellRender", "cellRender");
    }
    const [mergedValue, setMergedValue] = useMergedState(() => value || generateConfig2.getNow(), {
      defaultValue,
      value
    });
    const [mergedMode, setMergedMode] = useMergedState("month", {
      value: mode
    });
    const panelMode = React268.useMemo(
      () => mergedMode === "year" ? "month" : "date",
      [mergedMode]
    );
    const mergedDisabledDate = React268.useCallback(
      (date4) => {
        const notInRange = validRange ? generateConfig2.isAfter(validRange[0], date4) || generateConfig2.isAfter(date4, validRange[1]) : false;
        return notInRange || !!disabledDate?.(date4);
      },
      [disabledDate, validRange]
    );
    const triggerPanelChange = /* @__PURE__ */ __name((date4, newMode) => {
      onPanelChange?.(date4, newMode);
    }, "triggerPanelChange");
    const triggerChange = /* @__PURE__ */ __name((date4) => {
      setMergedValue(date4);
      if (!isSameDate2(date4, mergedValue)) {
        if (panelMode === "date" && !isSameMonth2(date4, mergedValue) || panelMode === "month" && !isSameYear2(date4, mergedValue)) {
          triggerPanelChange(date4, mergedMode);
        }
        onChange?.(date4);
      }
    }, "triggerChange");
    const triggerModeChange = /* @__PURE__ */ __name((newMode) => {
      setMergedMode(newMode);
      triggerPanelChange(mergedValue, newMode);
    }, "triggerModeChange");
    const onInternalSelect = /* @__PURE__ */ __name((date4, source) => {
      triggerChange(date4);
      onSelect?.(date4, { source });
    }, "onInternalSelect");
    const getDefaultLocale = /* @__PURE__ */ __name(() => {
      const { locale: locale6 } = props;
      const result = {
        ...en_US_default5,
        ...locale6
      };
      result.lang = {
        ...result.lang,
        ...(locale6 || {}).lang
      };
      return result;
    }, "getDefaultLocale");
    const dateRender = React268.useCallback(
      (date4, info) => {
        if (fullCellRender) {
          return fullCellRender(date4, info);
        }
        if (dateFullCellRender) {
          return dateFullCellRender(date4);
        }
        return /* @__PURE__ */ React268.createElement(
          "div",
          {
            className: (0, import_classnames92.default)(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
              [`${calendarPrefixCls}-date-today`]: isSameDate2(today, date4)
            })
          },
          /* @__PURE__ */ React268.createElement("div", { className: `${calendarPrefixCls}-date-value` }, String(generateConfig2.getDate(date4)).padStart(2, "0")),
          /* @__PURE__ */ React268.createElement("div", { className: `${calendarPrefixCls}-date-content` }, cellRender ? cellRender(date4, info) : dateCellRender && dateCellRender(date4))
        );
      },
      [dateFullCellRender, dateCellRender, cellRender, fullCellRender]
    );
    const monthRender = React268.useCallback(
      (date4, info) => {
        if (fullCellRender) {
          return fullCellRender(date4, info);
        }
        if (monthFullCellRender) {
          return monthFullCellRender(date4);
        }
        const months = info.locale.shortMonths || generateConfig2.locale.getShortMonths(info.locale.locale);
        return /* @__PURE__ */ React268.createElement(
          "div",
          {
            className: (0, import_classnames92.default)(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
              [`${calendarPrefixCls}-date-today`]: isSameMonth2(today, date4)
            })
          },
          /* @__PURE__ */ React268.createElement("div", { className: `${calendarPrefixCls}-date-value` }, months[generateConfig2.getMonth(date4)]),
          /* @__PURE__ */ React268.createElement("div", { className: `${calendarPrefixCls}-date-content` }, cellRender ? cellRender(date4, info) : monthCellRender && monthCellRender(date4))
        );
      },
      [monthFullCellRender, monthCellRender, cellRender, fullCellRender]
    );
    const [contextLocale] = useLocale_default("Calendar", getDefaultLocale);
    const mergedCellRender = /* @__PURE__ */ __name((current, info) => {
      if (info.type === "date") {
        return dateRender(current, info);
      }
      if (info.type === "month") {
        return monthRender(current, {
          ...info,
          locale: contextLocale?.lang
        });
      }
    }, "mergedCellRender");
    return wrapCSSVar(
      /* @__PURE__ */ React268.createElement(
        "div",
        {
          className: (0, import_classnames92.default)(
            calendarPrefixCls,
            {
              [`${calendarPrefixCls}-full`]: fullscreen,
              [`${calendarPrefixCls}-mini`]: !fullscreen,
              [`${calendarPrefixCls}-rtl`]: direction === "rtl"
            },
            calendar?.className,
            className,
            rootClassName,
            hashId,
            cssVarCls
          ),
          style: { ...calendar?.style, ...style2 }
        },
        headerRender ? headerRender({
          value: mergedValue,
          type: mergedMode,
          onChange: (nextDate) => {
            onInternalSelect(nextDate, "customize");
          },
          onTypeChange: triggerModeChange
        }) : /* @__PURE__ */ React268.createElement(
          Header_default,
          {
            prefixCls: calendarPrefixCls,
            value: mergedValue,
            generateConfig: generateConfig2,
            mode: mergedMode,
            fullscreen,
            locale: contextLocale?.lang,
            validRange,
            onChange: onInternalSelect,
            onModeChange: triggerModeChange
          }
        ),
        /* @__PURE__ */ React268.createElement(
          PickerPanel_default,
          {
            value: mergedValue,
            prefixCls,
            locale: contextLocale?.lang,
            generateConfig: generateConfig2,
            cellRender: mergedCellRender,
            onSelect: (nextDate) => {
              onInternalSelect(nextDate, panelMode);
            },
            mode: panelMode,
            picker: panelMode,
            disabledDate: mergedDisabledDate,
            hideHeader: true
          }
        )
      )
    );
  }, "Calendar");
  if (true) {
    Calendar2.displayName = "Calendar";
  }
  return Calendar2;
}
__name(generateCalendar, "generateCalendar");
var generateCalendar_default = generateCalendar;

// packages/ant-design/components/calendar/index.ts
var Calendar = generateCalendar_default(dayjs_default);
Calendar.generateCalendar = generateCalendar_default;
var calendar_default = Calendar;

// packages/ant-design/components/card/Card.tsx
var import_classnames110 = __toESM(require_classnames());
import * as React293 from "react";

// packages/ant-design/components/skeleton/Skeleton.tsx
var import_classnames101 = __toESM(require_classnames());
import * as React277 from "react";

// packages/ant-design/components/skeleton/Avatar.tsx
var import_classnames94 = __toESM(require_classnames());
import * as React270 from "react";

// packages/ant-design/components/skeleton/Element.tsx
var import_classnames93 = __toESM(require_classnames());
import * as React269 from "react";
var Element2 = /* @__PURE__ */ __name((props) => {
  const { prefixCls, className, style: style2, size, shape } = props;
  const sizeCls = (0, import_classnames93.default)({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = (0, import_classnames93.default)({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = React269.useMemo(
    () => typeof size === "number" ? {
      width: size,
      height: size,
      lineHeight: `${size}px`
    } : {},
    [size]
  );
  return /* @__PURE__ */ React269.createElement(
    "span",
    {
      className: (0, import_classnames93.default)(prefixCls, sizeCls, shapeCls, className),
      style: { ...sizeStyle, ...style2 }
    }
  );
}, "Element");
var Element_default = Element2;

// packages/ant-design/components/skeleton/style/index.ts
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
});
var genSkeletonElementCommonSize = /* @__PURE__ */ __name((size) => ({
  height: size,
  lineHeight: unit(size)
}), "genSkeletonElementCommonSize");
var genSkeletonElementAvatarSize = /* @__PURE__ */ __name((size) => ({
  width: size,
  ...genSkeletonElementCommonSize(size)
}), "genSkeletonElementAvatarSize");
var genSkeletonColor = /* @__PURE__ */ __name((token2) => ({
  background: token2.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token2.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
}), "genSkeletonColor");
var genSkeletonElementInputSize = /* @__PURE__ */ __name((size, calc) => ({
  width: calc(size).mul(5).equal(),
  minWidth: calc(size).mul(5).equal(),
  ...genSkeletonElementCommonSize(size)
}), "genSkeletonElementInputSize");
var genSkeletonElementAvatar = /* @__PURE__ */ __name((token2) => {
  const { skeletonAvatarCls, gradientFromColor, controlHeight, controlHeightLG, controlHeightSM } = token2;
  return {
    [`${skeletonAvatarCls}`]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      ...genSkeletonElementAvatarSize(controlHeight)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: {
      ...genSkeletonElementAvatarSize(controlHeightLG)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: {
      ...genSkeletonElementAvatarSize(controlHeightSM)
    }
  };
}, "genSkeletonElementAvatar");
var genSkeletonElementInput = /* @__PURE__ */ __name((token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return {
    [`${skeletonInputCls}`]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      ...genSkeletonElementInputSize(controlHeight, calc)
    },
    [`${skeletonInputCls}-lg`]: {
      ...genSkeletonElementInputSize(controlHeightLG, calc)
    },
    [`${skeletonInputCls}-sm`]: {
      ...genSkeletonElementInputSize(controlHeightSM, calc)
    }
  };
}, "genSkeletonElementInput");
var genSkeletonElementImageSize = /* @__PURE__ */ __name((size) => ({
  width: size,
  ...genSkeletonElementCommonSize(size)
}), "genSkeletonElementImageSize");
var genSkeletonElementImage = /* @__PURE__ */ __name((token2) => {
  const { skeletonImageCls, imageSizeBase, gradientFromColor, borderRadiusSM, calc } = token2;
  return {
    [`${skeletonImageCls}`]: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      ...genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal()),
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: {
        ...genSkeletonElementImageSize(imageSizeBase),
        maxWidth: calc(imageSizeBase).mul(4).equal(),
        maxHeight: calc(imageSizeBase).mul(4).equal()
      },
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    },
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
}, "genSkeletonElementImage");
var genSkeletonElementButtonShape = /* @__PURE__ */ __name((token2, size, buttonCls) => {
  const { skeletonButtonCls } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
}, "genSkeletonElementButtonShape");
var genSkeletonElementButtonSize = /* @__PURE__ */ __name((size, calc) => ({
  width: calc(size).mul(2).equal(),
  minWidth: calc(size).mul(2).equal(),
  ...genSkeletonElementCommonSize(size)
}), "genSkeletonElementButtonSize");
var genSkeletonElementButton = /* @__PURE__ */ __name((token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return {
    [`${skeletonButtonCls}`]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      width: calc(controlHeight).mul(2).equal(),
      minWidth: calc(controlHeight).mul(2).equal(),
      ...genSkeletonElementButtonSize(controlHeight, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls),
    [`${skeletonButtonCls}-lg`]: {
      ...genSkeletonElementButtonSize(controlHeightLG, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`),
    [`${skeletonButtonCls}-sm`]: {
      ...genSkeletonElementButtonSize(controlHeightSM, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`)
  };
}, "genSkeletonElementButton");
var genBaseStyle7 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    padding,
    marginSM,
    borderRadius,
    titleHeight,
    blockRadius,
    paragraphLiHeight,
    controlHeightXS,
    paragraphMarginTop
  } = token2;
  return {
    [`${componentCls}`]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [`${skeletonAvatarCls}`]: {
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor,
          ...genSkeletonElementAvatarSize(controlHeight)
        },
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: {
          ...genSkeletonElementAvatarSize(controlHeightLG)
        },
        [`${skeletonAvatarCls}-sm`]: {
          ...genSkeletonElementAvatarSize(controlHeightSM)
        }
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${skeletonTitleCls}`]: {
          width: "100%",
          height: titleHeight,
          background: gradientFromColor,
          borderRadius: blockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: paragraphLiHeight,
            listStyle: "none",
            background: gradientFromColor,
            borderRadius: blockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      // Title
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: paragraphMarginTop
        }
      }
    },
    // Skeleton element
    [`${componentCls}${componentCls}-element`]: {
      display: "inline-block",
      width: "auto",
      ...genSkeletonElementButton(token2),
      ...genSkeletonElementAvatar(token2),
      ...genSkeletonElementInput(token2),
      ...genSkeletonElementImage(token2)
    },
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [`${skeletonButtonCls}`]: {
        width: "100%"
      },
      [`${skeletonInputCls}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: {
        ...genSkeletonColor(token2)
      }
    }
  };
}, "genBaseStyle");
var prepareComponentToken21 = /* @__PURE__ */ __name((token2) => {
  const { colorFillContent, colorFill } = token2;
  const gradientFromColor = colorFillContent;
  const gradientToColor = colorFill;
  return {
    color: gradientFromColor,
    colorGradientEnd: gradientToColor,
    gradientFromColor,
    gradientToColor,
    titleHeight: token2.controlHeight / 2,
    blockRadius: token2.borderRadiusSM,
    paragraphMarginTop: token2.marginLG + token2.marginXXS,
    paragraphLiHeight: token2.controlHeight / 2
  };
}, "prepareComponentToken");
var style_default25 = genStyleHooks(
  "Skeleton",
  (token2) => {
    const { componentCls, calc } = token2;
    const skeletonToken = merge2(token2, {
      skeletonAvatarCls: `${componentCls}-avatar`,
      skeletonTitleCls: `${componentCls}-title`,
      skeletonParagraphCls: `${componentCls}-paragraph`,
      skeletonButtonCls: `${componentCls}-button`,
      skeletonInputCls: `${componentCls}-input`,
      skeletonImageCls: `${componentCls}-image`,
      imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
      borderRadius: 100,
      // Large number to make capsule shape
      skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
      skeletonLoadingMotionDuration: "1.4s"
    });
    return [genBaseStyle7(skeletonToken)];
  },
  prepareComponentToken21,
  {
    deprecatedTokens: [
      ["color", "gradientFromColor"],
      ["colorGradientEnd", "gradientToColor"]
    ]
  }
);

// packages/ant-design/components/skeleton/Avatar.tsx
var SkeletonAvatar = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    shape = "circle",
    size = "default"
  } = props;
  const { getPrefixCls } = React270.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  const otherProps = omit(props, ["prefixCls", "className"]);
  const cls5 = (0, import_classnames94.default)(
    prefixCls,
    `${prefixCls}-element`,
    {
      [`${prefixCls}-active`]: active
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React270.createElement("div", { className: cls5 }, /* @__PURE__ */ React270.createElement(Element_default, { prefixCls: `${prefixCls}-avatar`, shape, size, ...otherProps }))
  );
}, "SkeletonAvatar");
var Avatar_default = SkeletonAvatar;

// packages/ant-design/components/skeleton/Button.tsx
var import_classnames95 = __toESM(require_classnames());
import * as React271 from "react";
var SkeletonButton = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block = false,
    size = "default"
  } = props;
  const { getPrefixCls } = React271.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  const otherProps = omit(props, ["prefixCls"]);
  const cls5 = (0, import_classnames95.default)(
    prefixCls,
    `${prefixCls}-element`,
    {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React271.createElement("div", { className: cls5 }, /* @__PURE__ */ React271.createElement(Element_default, { prefixCls: `${prefixCls}-button`, size, ...otherProps }))
  );
}, "SkeletonButton");
var Button_default = SkeletonButton;

// packages/ant-design/components/skeleton/Image.tsx
var import_classnames96 = __toESM(require_classnames());
import * as React272 from "react";
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, className, rootClassName, style: style2, active } = props;
  const { getPrefixCls } = React272.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  const cls5 = (0, import_classnames96.default)(
    prefixCls,
    `${prefixCls}-element`,
    {
      [`${prefixCls}-active`]: active
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React272.createElement("div", { className: cls5 }, /* @__PURE__ */ React272.createElement("div", { className: (0, import_classnames96.default)(`${prefixCls}-image`, className), style: style2 }, /* @__PURE__ */ React272.createElement(
      "svg",
      {
        viewBox: "0 0 1098 1024",
        xmlns: "http://www.w3.org/2000/svg",
        className: `${prefixCls}-image-svg`
      },
      /* @__PURE__ */ React272.createElement("path", { d: path, className: `${prefixCls}-image-path` })
    )))
  );
}, "SkeletonImage");
var Image_default = SkeletonImage;

// packages/ant-design/components/skeleton/Input.tsx
var import_classnames97 = __toESM(require_classnames());
import * as React273 from "react";
var SkeletonInput = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block,
    size = "default"
  } = props;
  const { getPrefixCls } = React273.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  const otherProps = omit(props, ["prefixCls"]);
  const cls5 = (0, import_classnames97.default)(
    prefixCls,
    `${prefixCls}-element`,
    {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React273.createElement("div", { className: cls5 }, /* @__PURE__ */ React273.createElement(Element_default, { prefixCls: `${prefixCls}-input`, size, ...otherProps }))
  );
}, "SkeletonInput");
var Input_default3 = SkeletonInput;

// packages/ant-design/components/skeleton/Node.tsx
var import_DotChartOutlined = __toESM(require_DotChartOutlined3());
var import_classnames98 = __toESM(require_classnames());
import * as React274 from "react";
var SkeletonNode = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active,
    children
  } = props;
  const { getPrefixCls } = React274.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  const cls5 = (0, import_classnames98.default)(
    prefixCls,
    `${prefixCls}-element`,
    {
      [`${prefixCls}-active`]: active
    },
    hashId,
    className,
    rootClassName,
    cssVarCls
  );
  const content = children ?? /* @__PURE__ */ React274.createElement(import_DotChartOutlined.default, null);
  return wrapCSSVar(
    /* @__PURE__ */ React274.createElement("div", { className: cls5 }, /* @__PURE__ */ React274.createElement("div", { className: (0, import_classnames98.default)(`${prefixCls}-image`, className), style: style2 }, content))
  );
}, "SkeletonNode");
var Node_default = SkeletonNode;

// packages/ant-design/components/skeleton/Paragraph.tsx
var import_classnames99 = __toESM(require_classnames());
import * as React275 from "react";
var getWidth = /* @__PURE__ */ __name((index3, props) => {
  const { width, rows = 2 } = props;
  if (Array.isArray(width)) {
    return width[index3];
  }
  if (rows - 1 === index3) {
    return width;
  }
  return void 0;
}, "getWidth");
var Paragraph = /* @__PURE__ */ __name((props) => {
  const { prefixCls, className, style: style2, rows } = props;
  const rowList = [...Array(rows)].map((_, index3) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ React275.createElement("li", { key: index3, style: { width: getWidth(index3, props) } })
  ));
  return /* @__PURE__ */ React275.createElement("ul", { className: (0, import_classnames99.default)(prefixCls, className), style: style2 }, rowList);
}, "Paragraph");
var Paragraph_default = Paragraph;

// packages/ant-design/components/skeleton/Title.tsx
var import_classnames100 = __toESM(require_classnames());
import * as React276 from "react";
var Title = /* @__PURE__ */ __name(({ prefixCls, className, width, style: style2 }) => /* @__PURE__ */ React276.createElement("h3", { className: (0, import_classnames100.default)(prefixCls, className), style: { width, ...style2 } }), "Title");
var Title_default = Title;

// packages/ant-design/components/skeleton/Skeleton.tsx
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
__name(getComponentProps, "getComponentProps");
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return { size: "large", shape: "square" };
  }
  return { size: "large", shape: "circle" };
}
__name(getAvatarBasicProps, "getAvatarBasicProps");
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return { width: "38%" };
  }
  if (hasAvatar && hasParagraph) {
    return { width: "50%" };
  }
  return {};
}
__name(getTitleBasicProps, "getTitleBasicProps");
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  if (!hasAvatar || !hasTitle) {
    basicProps.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
__name(getParagraphBasicProps, "getParagraphBasicProps");
var Skeleton = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    style: style2,
    children,
    avatar = false,
    title = true,
    paragraph = true,
    active,
    round
  } = props;
  const { getPrefixCls, direction, skeleton } = React277.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default25(prefixCls);
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = {
        prefixCls: `${prefixCls}-avatar`,
        ...getAvatarBasicProps(hasTitle, hasParagraph),
        ...getComponentProps(avatar)
      };
      avatarNode = /* @__PURE__ */ React277.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ React277.createElement(Element_default, { ...avatarProps }));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = {
          prefixCls: `${prefixCls}-title`,
          ...getTitleBasicProps(hasAvatar, hasParagraph),
          ...getComponentProps(title)
        };
        $title = /* @__PURE__ */ React277.createElement(Title_default, { ...titleProps });
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = {
          prefixCls: `${prefixCls}-paragraph`,
          ...getParagraphBasicProps(hasAvatar, hasTitle),
          ...getComponentProps(paragraph)
        };
        paragraphNode = /* @__PURE__ */ React277.createElement(Paragraph_default, { ...paragraphProps });
      }
      contentNode = /* @__PURE__ */ React277.createElement("div", { className: `${prefixCls}-content` }, $title, paragraphNode);
    }
    const cls5 = (0, import_classnames101.default)(
      prefixCls,
      {
        [`${prefixCls}-with-avatar`]: hasAvatar,
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-round`]: round
      },
      skeleton?.className,
      className,
      rootClassName,
      hashId,
      cssVarCls
    );
    return wrapCSSVar(
      /* @__PURE__ */ React277.createElement("div", { className: cls5, style: { ...skeleton?.style, ...style2 } }, avatarNode, contentNode)
    );
  }
  return children ?? null;
}, "Skeleton");
Skeleton.Button = Button_default;
Skeleton.Avatar = Avatar_default;
Skeleton.Input = Input_default3;
Skeleton.Image = Image_default;
Skeleton.Node = Node_default;
if (true) {
  Skeleton.displayName = "Skeleton";
}
var Skeleton_default = Skeleton;

// packages/ant-design/components/skeleton/index.tsx
var skeleton_default = Skeleton_default;

// packages/ant-design/components/tabs/index.tsx
var import_CloseOutlined8 = __toESM(require_CloseOutlined3());
var import_EllipsisOutlined2 = __toESM(require_EllipsisOutlined3());
var import_PlusOutlined = __toESM(require_PlusOutlined3());
var import_classnames108 = __toESM(require_classnames());
import * as React291 from "react";

// packages/tabs/src/Tabs.tsx
var import_classnames107 = __toESM(require_classnames());
import * as React289 from "react";
import { useEffect as useEffect70, useState as useState67 } from "react";

// packages/tabs/src/TabContext.ts
import { createContext as createContext37 } from "react";
var TabContext_default = createContext37(null);

// packages/tabs/src/TabNavList/Wrapper.tsx
import * as React287 from "react";

// packages/tabs/src/TabNavList/index.tsx
var import_classnames104 = __toESM(require_classnames());
import * as React285 from "react";
import { useEffect as useEffect69, useRef as useRef95, useState as useState66 } from "react";

// packages/tabs/src/hooks/useIndicator.ts
import React278, { useEffect as useEffect66, useRef as useRef91, useState as useState61 } from "react";
var useIndicator = /* @__PURE__ */ __name((options) => {
  const { activeTabOffset, horizontal, rtl, indicator = {} } = options;
  const { size, align = "center" } = indicator;
  const [inkStyle, setInkStyle] = useState61();
  const inkBarRafRef = useRef91();
  const getLength = React278.useCallback(
    (origin) => {
      if (typeof size === "function") {
        return size(origin);
      }
      if (typeof size === "number") {
        return size;
      }
      return origin;
    },
    [size]
  );
  function cleanInkBarRaf() {
    raf_default.cancel(inkBarRafRef.current);
  }
  __name(cleanInkBarRaf, "cleanInkBarRaf");
  useEffect66(() => {
    const newInkStyle = {};
    if (activeTabOffset) {
      if (horizontal) {
        newInkStyle.width = getLength(activeTabOffset.width);
        const key = rtl ? "right" : "left";
        if (align === "start") {
          newInkStyle[key] = activeTabOffset[key];
        }
        if (align === "center") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
          newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
        }
        if (align === "end") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
          newInkStyle.transform = "translateX(-100%)";
        }
      } else {
        newInkStyle.height = getLength(activeTabOffset.height);
        if (align === "start") {
          newInkStyle.top = activeTabOffset.top;
        }
        if (align === "center") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
          newInkStyle.transform = "translateY(-50%)";
        }
        if (align === "end") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
          newInkStyle.transform = "translateY(-100%)";
        }
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = raf_default(() => {
      setInkStyle(newInkStyle);
    });
    return cleanInkBarRaf;
  }, [activeTabOffset, horizontal, rtl, align, getLength]);
  return { style: inkStyle };
}, "useIndicator");
var useIndicator_default = useIndicator;

// packages/tabs/src/hooks/useOffsets.ts
import { useMemo as useMemo78 } from "react";
var DEFAULT_SIZE = { width: 0, height: 0, left: 0, top: 0 };
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return useMemo78(() => {
    const map = /* @__PURE__ */ new Map();
    const lastOffset = tabSizes.get(tabs[0]?.key) || DEFAULT_SIZE;
    const rightOffset = lastOffset.left + lastOffset.width;
    for (let i = 0; i < tabs.length; i += 1) {
      const { key } = tabs[i];
      let data = tabSizes.get(key);
      if (!data) {
        data = tabSizes.get(tabs[i - 1]?.key) || DEFAULT_SIZE;
      }
      const entity = map.get(key) || { ...data };
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    return map;
  }, [tabs.map((tab) => tab.key).join("_"), tabSizes, holderScrollWidth]);
}
__name(useOffsets, "useOffsets");

// packages/tabs/src/hooks/useSyncState.ts
import * as React279 from "react";
function useSyncState2(defaultState, onChange) {
  const stateRef = React279.useRef(defaultState);
  const [, forceUpdate] = React279.useState({});
  function setState(updater) {
    const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  __name(setState, "setState");
  return [stateRef.current, setState];
}
__name(useSyncState2, "useSyncState");

// packages/tabs/src/hooks/useTouchMove.ts
import * as React280 from "react";
import { useRef as useRef93, useState as useState63 } from "react";
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
function useTouchMove(ref, onOffset) {
  const [touchPosition, setTouchPosition] = useState63();
  const [lastTimestamp, setLastTimestamp] = useState63(0);
  const [lastTimeDiff, setLastTimeDiff] = useState63(0);
  const [lastOffset, setLastOffset] = useState63();
  const motionRef = useRef93();
  function onTouchStart(e3) {
    const { screenX, screenY } = e3.touches[0];
    setTouchPosition({ x: screenX, y: screenY });
    window.clearInterval(motionRef.current);
  }
  __name(onTouchStart, "onTouchStart");
  function onTouchMove(e3) {
    if (!touchPosition)
      return;
    e3.preventDefault();
    const { screenX, screenY } = e3.touches[0];
    setTouchPosition({ x: screenX, y: screenY });
    const offsetX = screenX - touchPosition.x;
    const offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    const now2 = Date.now();
    setLastTimestamp(now2);
    setLastTimeDiff(now2 - lastTimestamp);
    setLastOffset({ x: offsetX, y: offsetY });
  }
  __name(onTouchMove, "onTouchMove");
  function onTouchEnd() {
    if (!touchPosition)
      return;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffset) {
      const distanceX = lastOffset.x / lastTimeDiff;
      const distanceY = lastOffset.y / lastTimeDiff;
      const absX = Math.abs(distanceX);
      const absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      let currentX = distanceX;
      let currentY = distanceY;
      motionRef.current = window.setInterval(() => {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  __name(onTouchEnd, "onTouchEnd");
  const lastWheelDirectionRef = useRef93();
  function onWheel(e3) {
    const { deltaX, deltaY } = e3;
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e3.preventDefault();
    }
  }
  __name(onWheel, "onWheel");
  const touchEventsRef = useRef93(null);
  touchEventsRef.current = { onTouchStart, onTouchMove, onTouchEnd, onWheel };
  React280.useEffect(() => {
    function onProxyTouchStart(e3) {
      touchEventsRef.current.onTouchStart(e3);
    }
    __name(onProxyTouchStart, "onProxyTouchStart");
    function onProxyTouchMove(e3) {
      touchEventsRef.current.onTouchMove(e3);
    }
    __name(onProxyTouchMove, "onProxyTouchMove");
    function onProxyTouchEnd(e3) {
      touchEventsRef.current.onTouchEnd(e3);
    }
    __name(onProxyTouchEnd, "onProxyTouchEnd");
    function onProxyWheel(e3) {
      touchEventsRef.current.onWheel(e3);
    }
    __name(onProxyWheel, "onProxyWheel");
    document.addEventListener("touchmove", onProxyTouchMove, { passive: false });
    document.addEventListener("touchend", onProxyTouchEnd, { passive: false });
    ref.current.addEventListener("touchstart", onProxyTouchStart, { passive: false });
    ref.current.addEventListener("wheel", onProxyWheel);
    return () => {
      document.removeEventListener("touchmove", onProxyTouchMove);
      document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}
__name(useTouchMove, "useTouchMove");

// packages/tabs/src/hooks/useUpdate.ts
import { useRef as useRef94, useState as useState64 } from "react";
function useUpdate(callback) {
  const [count, setCount] = useState64(0);
  const effectRef = useRef94(0);
  const callbackRef = useRef94();
  callbackRef.current = callback;
  useLayoutUpdateEffect(() => {
    callbackRef.current?.();
  }, [count]);
  return () => {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
__name(useUpdate, "useUpdate");
function useUpdateState(defaultState) {
  const batchRef = useRef94([]);
  const [, forceUpdate] = useState64({});
  const state = useRef94(
    typeof defaultState === "function" ? defaultState() : defaultState
  );
  const flushUpdate = useUpdate(() => {
    let current = state.current;
    batchRef.current.forEach((callback) => {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  __name(updater, "updater");
  return [state.current, updater];
}
__name(useUpdateState, "useUpdateState");

// packages/tabs/src/hooks/useVisibleRange.ts
import { useMemo as useMemo79 } from "react";
var DEFAULT_SIZE2 = { width: 0, height: 0, left: 0, top: 0, right: 0 };
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, { tabs, tabPosition, rtl }) {
  let charUnit;
  let position2;
  let transformSize;
  if (["top", "bottom"].includes(tabPosition)) {
    charUnit = "width";
    position2 = rtl ? "right" : "left";
    transformSize = Math.abs(transform);
  } else {
    charUnit = "height";
    position2 = "top";
    transformSize = -transform;
  }
  return useMemo79(() => {
    if (!tabs.length) {
      return [0, 0];
    }
    const len = tabs.length;
    let endIndex = len;
    for (let i = 0; i < len; i += 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (offset3[position2] + offset3[charUnit] > transformSize + visibleTabContentValue) {
        endIndex = i - 1;
        break;
      }
    }
    let startIndex = 0;
    for (let i = len - 1; i >= 0; i -= 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (offset3[position2] < transformSize) {
        startIndex = i + 1;
        break;
      }
    }
    return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
  }, [
    tabOffsets,
    visibleTabContentValue,
    tabContentSizeValue,
    addNodeSizeValue,
    operationNodeSizeValue,
    transformSize,
    tabPosition,
    tabs.map((tab) => tab.key).join("_"),
    rtl
  ]);
}
__name(useVisibleRange, "useVisibleRange");

// packages/tabs/src/util.ts
function stringify3(obj) {
  let tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach((v, k) => {
      tgt[k] = v;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
__name(stringify3, "stringify");
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
__name(genDataNodeKey, "genDataNodeKey");
function getRemovable(closable, closeIcon, editable, disabled) {
  if (
    // Only editable tabs can be removed
    !editable || // Tabs cannot be removed when disabled
    disabled || // closable is false
    closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    closable === void 0 && (closeIcon === false || closeIcon === null)
  ) {
    return false;
  }
  return true;
}
__name(getRemovable, "getRemovable");

// packages/tabs/src/TabNavList/AddButton.tsx
import * as React281 from "react";
var AddButton = React281.forwardRef((props, ref) => {
  const { prefixCls, editable, locale: locale6, style: style2 } = props;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return /* @__PURE__ */ React281.createElement(
    "button",
    {
      ref,
      type: "button",
      className: `${prefixCls}-nav-add`,
      style: style2,
      "aria-label": locale6?.addAriaLabel || "Add tab",
      onClick: (event) => {
        editable.onEdit("add", { event });
      }
    },
    editable.addIcon || "+"
  );
});
var AddButton_default = AddButton;

// packages/tabs/src/TabNavList/ExtraContent.tsx
import * as React282 from "react";
var ExtraContent = React282.forwardRef((props, ref) => {
  const { position: position2, prefixCls, extra } = props;
  if (!extra) {
    return null;
  }
  let content;
  let assertExtra = {};
  if (typeof extra === "object" && !React282.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position2 === "right") {
    content = assertExtra.right;
  }
  if (position2 === "left") {
    content = assertExtra.left;
  }
  return content ? /* @__PURE__ */ React282.createElement("div", { className: `${prefixCls}-extra-content`, ref }, content) : null;
});
if (true) {
  ExtraContent.displayName = "ExtraContent";
}
var ExtraContent_default = ExtraContent;

// packages/tabs/src/TabNavList/OperationNode.tsx
var import_classnames102 = __toESM(require_classnames());
import * as React283 from "react";
import { useEffect as useEffect68, useState as useState65 } from "react";
var OperationNode = React283.forwardRef((props, ref) => {
  const {
    prefixCls,
    id,
    tabs,
    locale: locale6,
    mobile,
    more: moreProps = {},
    style: style2,
    className,
    editable,
    tabBarGutter,
    rtl,
    removeAriaLabel,
    onTabClick,
    getPopupContainer,
    popupClassName
  } = props;
  const [open3, setOpen] = useState65(false);
  const [selectedKey, setSelectedKey] = useState65(null);
  const { icon: moreIcon = "More" } = moreProps;
  const popupId = `${id}-more-popup`;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const selectedItemId = selectedKey !== null ? `${popupId}-${selectedKey}` : null;
  const dropdownAriaLabel = locale6?.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", { key, event });
  }
  __name(onRemoveTab, "onRemoveTab");
  const menu = /* @__PURE__ */ React283.createElement(
    src_default9,
    {
      onClick: ({ key, domEvent }) => {
        onTabClick(key, domEvent);
        setOpen(false);
      },
      prefixCls: `${dropdownPrefix}-menu`,
      id: popupId,
      tabIndex: -1,
      role: "listbox",
      "aria-activedescendant": selectedItemId,
      selectedKeys: [selectedKey],
      "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
    },
    tabs.map((tab) => {
      const { closable, disabled, closeIcon, key, label } = tab;
      const removable = getRemovable(closable, closeIcon, editable, disabled);
      return /* @__PURE__ */ React283.createElement(
        MenuItem_default,
        {
          key,
          id: `${popupId}-${key}`,
          role: "option",
          "aria-controls": id && `${id}-panel-${key}`,
          disabled
        },
        /* @__PURE__ */ React283.createElement("span", null, label),
        removable && /* @__PURE__ */ React283.createElement(
          "button",
          {
            type: "button",
            "aria-label": removeAriaLabel || "remove",
            tabIndex: 0,
            className: `${dropdownPrefix}-menu-item-remove`,
            onClick: (e3) => {
              e3.stopPropagation();
              onRemoveTab(e3, key);
            }
          },
          closeIcon || editable.removeIcon || "\xD7"
        )
      );
    })
  );
  function selectOffset(offset3) {
    const enabledTabs = tabs.filter((tab) => !tab.disabled);
    let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey) || 0;
    const len = enabledTabs.length;
    for (let i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset3 + len) % len;
      const tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  __name(selectOffset, "selectOffset");
  function onKeyDown2(e3) {
    const { which } = e3;
    if (!open3) {
      if ([KeyCode_default.DOWN, KeyCode_default.SPACE, KeyCode_default.ENTER].includes(which)) {
        setOpen(true);
        e3.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode_default.UP:
        selectOffset(-1);
        e3.preventDefault();
        break;
      case KeyCode_default.DOWN:
        selectOffset(1);
        e3.preventDefault();
        break;
      case KeyCode_default.ESC:
        setOpen(false);
        break;
      case KeyCode_default.SPACE:
      case KeyCode_default.ENTER:
        if (selectedKey !== null) {
          onTabClick(selectedKey, e3);
        }
        break;
    }
  }
  __name(onKeyDown2, "onKeyDown");
  useEffect68(() => {
    const ele = document.getElementById(selectedItemId);
    if (ele && ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedKey]);
  useEffect68(() => {
    if (!open3) {
      setSelectedKey(null);
    }
  }, [open3]);
  const moreStyle = {
    [rtl ? "marginRight" : "marginLeft"]: tabBarGutter
  };
  if (!tabs.length) {
    moreStyle.visibility = "hidden";
    moreStyle.order = 1;
  }
  const overlayClassName = (0, import_classnames102.default)({
    [`${dropdownPrefix}-rtl`]: rtl
  });
  const moreNode = mobile ? null : /* @__PURE__ */ React283.createElement(
    src_default8,
    {
      prefixCls: dropdownPrefix,
      overlay: menu,
      visible: tabs.length ? open3 : false,
      onVisibleChange: setOpen,
      overlayClassName: (0, import_classnames102.default)(overlayClassName, popupClassName),
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      getPopupContainer,
      ...moreProps
    },
    /* @__PURE__ */ React283.createElement(
      "button",
      {
        type: "button",
        className: `${prefixCls}-nav-more`,
        style: moreStyle,
        tabIndex: -1,
        "aria-hidden": "true",
        "aria-haspopup": "listbox",
        "aria-controls": popupId,
        id: `${id}-more`,
        "aria-expanded": open3,
        onKeyDown: onKeyDown2
      },
      moreIcon
    )
  );
  return /* @__PURE__ */ React283.createElement("div", { className: (0, import_classnames102.default)(`${prefixCls}-nav-operations`, className), style: style2, ref }, moreNode, /* @__PURE__ */ React283.createElement(AddButton_default, { prefixCls, locale: locale6, editable }));
});
var OperationNode_default = React283.memo(
  OperationNode,
  (_, next2) => (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    next2.tabMoving
  )
);

// packages/tabs/src/TabNavList/TabNode.tsx
var import_classnames103 = __toESM(require_classnames());
import * as React284 from "react";
var TabNode = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    id,
    active,
    tab: { key, label, disabled, closeIcon, icon },
    closable,
    renderWrapper,
    removeAriaLabel,
    editable,
    onClick,
    onFocus,
    style: style2
  } = props;
  const tabPrefix = `${prefixCls}-tab`;
  const removable = getRemovable(closable, closeIcon, editable, disabled);
  function onInternalClick(e3) {
    if (disabled) {
      return;
    }
    onClick(e3);
  }
  __name(onInternalClick, "onInternalClick");
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", { key, event });
  }
  __name(onRemoveTab, "onRemoveTab");
  const labelNode = React284.useMemo(
    () => icon && typeof label === "string" ? /* @__PURE__ */ React284.createElement("span", null, label) : label,
    [label, icon]
  );
  const node2 = /* @__PURE__ */ React284.createElement(
    "div",
    {
      key,
      "data-node-key": genDataNodeKey(key),
      className: (0, import_classnames103.default)(tabPrefix, {
        [`${tabPrefix}-with-remove`]: removable,
        [`${tabPrefix}-active`]: active,
        [`${tabPrefix}-disabled`]: disabled
      }),
      style: style2,
      onClick: onInternalClick
    },
    /* @__PURE__ */ React284.createElement(
      "div",
      {
        role: "tab",
        "aria-selected": active,
        id: id && `${id}-tab-${key}`,
        className: `${tabPrefix}-btn`,
        "aria-controls": id && `${id}-panel-${key}`,
        "aria-disabled": disabled,
        tabIndex: disabled ? null : 0,
        onClick: (e3) => {
          e3.stopPropagation();
          onInternalClick(e3);
        },
        onKeyDown: (e3) => {
          if ([KeyCode_default.SPACE, KeyCode_default.ENTER].includes(e3.which)) {
            e3.preventDefault();
            onInternalClick(e3);
          }
        },
        onFocus
      },
      icon && /* @__PURE__ */ React284.createElement("span", { className: `${tabPrefix}-icon` }, icon),
      label && labelNode
    ),
    removable && /* @__PURE__ */ React284.createElement(
      "button",
      {
        type: "button",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: 0,
        className: `${tabPrefix}-remove`,
        onClick: (e3) => {
          e3.stopPropagation();
          onRemoveTab(e3);
        }
      },
      closeIcon || editable.removeIcon || "\xD7"
    )
  );
  return renderWrapper ? renderWrapper(node2) : node2;
}, "TabNode");
var TabNode_default = TabNode;

// packages/tabs/src/TabNavList/index.tsx
var getTabSize = /* @__PURE__ */ __name((tab, containerRect) => {
  const { offsetWidth, offsetHeight, offsetTop, offsetLeft } = tab;
  const { width, height, x, y } = tab.getBoundingClientRect();
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, x - containerRect.x, y - containerRect.y];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
}, "getTabSize");
var getSize = /* @__PURE__ */ __name((refObj) => {
  const { offsetWidth = 0, offsetHeight = 0 } = refObj.current || {};
  if (refObj.current) {
    const { width, height } = refObj.current.getBoundingClientRect();
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height];
    }
  }
  return [offsetWidth, offsetHeight];
}, "getSize");
var getUnitValue = /* @__PURE__ */ __name((size, tabPositionTopOrBottom) => {
  return size[tabPositionTopOrBottom ? 0 : 1];
}, "getUnitValue");
var TabNavList = React285.forwardRef((props, ref) => {
  const {
    className,
    style: style2,
    id,
    animated,
    activeKey,
    rtl,
    extra,
    editable,
    locale: locale6,
    tabPosition,
    tabBarGutter,
    children,
    onTabClick,
    onTabScroll,
    indicator
  } = props;
  const { prefixCls, tabs } = React285.useContext(TabContext_default);
  const containerRef = useRef95(null);
  const extraLeftRef = useRef95(null);
  const extraRightRef = useRef95(null);
  const tabsWrapperRef = useRef95(null);
  const tabListRef = useRef95(null);
  const operationsRef = useRef95(null);
  const innerAddButtonRef = useRef95(null);
  const tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
  const [transformLeft, setTransformLeft] = useSyncState2(0, (next2, prev2) => {
    if (tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({ direction: next2 > prev2 ? "left" : "right" });
    }
  });
  const [transformTop, setTransformTop] = useSyncState2(0, (next2, prev2) => {
    if (!tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({ direction: next2 > prev2 ? "top" : "bottom" });
    }
  });
  const [containerExcludeExtraSize, setContainerExcludeExtraSize] = useState66([0, 0]);
  const [tabContentSize, setTabContentSize] = useState66([0, 0]);
  const [addSize, setAddSize] = useState66([0, 0]);
  const [operationSize, setOperationSize] = useState66([0, 0]);
  const [tabSizes, setTabSizes] = useUpdateState(/* @__PURE__ */ new Map());
  const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
  const containerExcludeExtraSizeValue = getUnitValue(
    containerExcludeExtraSize,
    tabPositionTopOrBottom
  );
  const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  const needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
  const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
  const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;
  let transformMin = 0;
  let transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
  __name(alignInRange, "alignInRange");
  const touchMovingRef = useRef95(null);
  const [lockAnimation, setLockAnimation] = useState66();
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  __name(doLockAnimation, "doLockAnimation");
  function clearTouchMoving() {
    if (touchMovingRef.current) {
      clearTimeout(touchMovingRef.current);
    }
  }
  __name(clearTouchMoving, "clearTouchMoving");
  useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
    function doMove(setState, offset3) {
      setState((value) => {
        const newValue = alignInRange(value + offset3);
        return newValue;
      });
    }
    __name(doMove, "doMove");
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  useEffect69(() => {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = setTimeout(() => {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);
  const [visibleStart, visibleEnd] = useVisibleRange(
    tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue,
    { ...props, tabs }
  );
  const scrollToTab = useEvent((key = activeKey) => {
    const tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      let newTransform = transformLeft;
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      let newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(newTransform));
    }
  });
  const tabNodeStyle = {};
  if (tabPosition === "top" || tabPosition === "bottom") {
    tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  const tabNodes = tabs.map((tab, i) => {
    const { key } = tab;
    return /* @__PURE__ */ React285.createElement(
      TabNode_default,
      {
        id,
        prefixCls,
        key,
        tab,
        style: i === 0 ? void 0 : tabNodeStyle,
        closable: tab.closable,
        editable,
        active: key === activeKey,
        renderWrapper: children,
        removeAriaLabel: locale6?.removeAriaLabel,
        onClick: (e3) => {
          onTabClick(key, e3);
        },
        onFocus: () => {
          scrollToTab(key);
          doLockAnimation();
          if (!tabsWrapperRef.current) {
            return;
          }
          if (!rtl) {
            tabsWrapperRef.current.scrollLeft = 0;
          }
          tabsWrapperRef.current.scrollTop = 0;
        }
      }
    );
  });
  const updateTabSizes = /* @__PURE__ */ __name(() => setTabSizes(() => {
    const newSizes = /* @__PURE__ */ new Map();
    const listRect = tabListRef.current?.getBoundingClientRect();
    tabs.forEach(({ key }) => {
      const btnNode = tabListRef.current?.querySelector(
        `[data-node-key="${genDataNodeKey(key)}"]`
      );
      if (btnNode) {
        const [width, height, left, top] = getTabSize(btnNode, listRect);
        newSizes.set(key, { width, height, left, top });
      }
    });
    return newSizes;
  }), "updateTabSizes");
  useEffect69(() => {
    updateTabSizes();
  }, [tabs.map((tab) => tab.key).join("_")]);
  const onListHolderResize = useUpdate(() => {
    const containerSize = getSize(containerRef);
    const extraLeftSize = getSize(extraLeftRef);
    const extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([
      containerSize[0] - extraLeftSize[0] - extraRightSize[0],
      containerSize[1] - extraLeftSize[1] - extraRightSize[1]
    ]);
    const newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    const newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);
    const tabContentFullSize = getSize(tabListRef);
    setTabContentSize([
      tabContentFullSize[0] - newAddSize[0],
      tabContentFullSize[1] - newAddSize[1]
    ]);
    updateTabSizes();
  });
  const startHiddenTabs = tabs.slice(0, visibleStart);
  const endHiddenTabs = tabs.slice(visibleEnd + 1);
  const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];
  const activeTabOffset = tabOffsets.get(activeKey);
  const { style: indicatorStyle } = useIndicator_default({
    activeTabOffset,
    horizontal: tabPositionTopOrBottom,
    indicator,
    rtl
  });
  useEffect69(() => {
    scrollToTab();
  }, [
    activeKey,
    transformMin,
    transformMax,
    stringify3(activeTabOffset),
    stringify3(tabOffsets),
    tabPositionTopOrBottom
  ]);
  useEffect69(() => {
    onListHolderResize();
  }, [rtl]);
  const hasDropdown = !!hiddenTabs.length;
  const wrapPrefix = `${prefixCls}-nav-wrap`;
  let pingLeft;
  let pingRight;
  let pingTop;
  let pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return /* @__PURE__ */ React285.createElement(src_default, { onResize: onListHolderResize }, /* @__PURE__ */ React285.createElement(
    "div",
    {
      ref: useComposeRef(ref, containerRef),
      role: "tablist",
      className: (0, import_classnames104.default)(`${prefixCls}-nav`, className),
      style: style2,
      onKeyDown: () => {
        doLockAnimation();
      }
    },
    /* @__PURE__ */ React285.createElement(ExtraContent_default, { ref: extraLeftRef, position: "left", extra, prefixCls }),
    /* @__PURE__ */ React285.createElement(src_default, { onResize: onListHolderResize }, /* @__PURE__ */ React285.createElement(
      "div",
      {
        className: (0, import_classnames104.default)(wrapPrefix, {
          [`${wrapPrefix}-ping-left`]: pingLeft,
          [`${wrapPrefix}-ping-right`]: pingRight,
          [`${wrapPrefix}-ping-top`]: pingTop,
          [`${wrapPrefix}-ping-bottom`]: pingBottom
        }),
        ref: tabsWrapperRef
      },
      /* @__PURE__ */ React285.createElement(src_default, { onResize: onListHolderResize }, /* @__PURE__ */ React285.createElement(
        "div",
        {
          ref: tabListRef,
          className: `${prefixCls}-nav-list`,
          style: {
            transform: `translate(${transformLeft}px, ${transformTop}px)`,
            transition: lockAnimation ? "none" : void 0
          }
        },
        tabNodes,
        /* @__PURE__ */ React285.createElement(
          AddButton_default,
          {
            ref: innerAddButtonRef,
            prefixCls,
            locale: locale6,
            editable,
            style: {
              ...tabNodes.length === 0 ? void 0 : tabNodeStyle,
              visibility: hasDropdown ? "hidden" : null
            }
          }
        ),
        /* @__PURE__ */ React285.createElement(
          "div",
          {
            className: (0, import_classnames104.default)(`${prefixCls}-ink-bar`, {
              [`${prefixCls}-ink-bar-animated`]: animated.inkBar
            }),
            style: indicatorStyle
          }
        )
      ))
    )),
    /* @__PURE__ */ React285.createElement(
      OperationNode_default,
      {
        ...props,
        removeAriaLabel: locale6?.removeAriaLabel,
        ref: operationsRef,
        prefixCls,
        tabs: hiddenTabs,
        className: !hasDropdown && operationsHiddenClassName,
        tabMoving: !!lockAnimation
      }
    ),
    /* @__PURE__ */ React285.createElement(ExtraContent_default, { ref: extraRightRef, position: "right", extra, prefixCls })
  ));
});
var TabNavList_default = TabNavList;

// packages/tabs/src/TabPanelList/TabPane.tsx
var import_classnames105 = __toESM(require_classnames());
import * as React286 from "react";
var TabPane = React286.forwardRef((props, ref) => {
  const { prefixCls, className, style: style2, id, active, tabKey, children } = props;
  return /* @__PURE__ */ React286.createElement(
    "div",
    {
      id: id && `${id}-panel-${tabKey}`,
      role: "tabpanel",
      tabIndex: active ? 0 : -1,
      "aria-labelledby": id && `${id}-tab-${tabKey}`,
      "aria-hidden": !active,
      style: style2,
      className: (0, import_classnames105.default)(prefixCls, active && `${prefixCls}-active`, className),
      ref
    },
    children
  );
});
if (true) {
  TabPane.displayName = "TabPane";
}
var TabPane_default = TabPane;

// packages/tabs/src/TabNavList/Wrapper.tsx
var TabNavListWrapper = /* @__PURE__ */ __name(({ renderTabBar, ...restProps }) => {
  const { tabs } = React287.useContext(TabContext_default);
  if (renderTabBar) {
    const tabNavBarProps = {
      ...restProps,
      // Legacy support. We do not use this actually
      panes: tabs.map(({ label, key, ...restTabProps }) => /* @__PURE__ */ React287.createElement(TabPane_default, { tab: label, key, tabKey: key, ...restTabProps }))
    };
    return renderTabBar(tabNavBarProps, TabNavList_default);
  }
  return /* @__PURE__ */ React287.createElement(TabNavList_default, { ...restProps });
}, "TabNavListWrapper");
if (true) {
  TabNavListWrapper.displayName = "TabNavListWrapper";
}
var Wrapper_default = TabNavListWrapper;

// packages/tabs/src/TabPanelList/index.tsx
var import_classnames106 = __toESM(require_classnames());
import * as React288 from "react";
var TabPanelList = /* @__PURE__ */ __name((props) => {
  const { id, activeKey, animated, tabPosition, destroyInactiveTabPane } = props;
  const { prefixCls, tabs } = React288.useContext(TabContext_default);
  const tabPaneAnimated = animated.tabPane;
  const tabPanePrefixCls = `${prefixCls}-tabpane`;
  return /* @__PURE__ */ React288.createElement("div", { className: (0, import_classnames106.default)(`${prefixCls}-content-holder`) }, /* @__PURE__ */ React288.createElement(
    "div",
    {
      className: (0, import_classnames106.default)(`${prefixCls}-content`, `${prefixCls}-content-${tabPosition}`, {
        [`${prefixCls}-content-animated`]: tabPaneAnimated
      })
    },
    tabs.map((item) => {
      const {
        key,
        forceRender,
        style: paneStyle,
        className: paneClassName,
        destroyInactiveTabPane: itemDestroyInactiveTabPane,
        ...restTabProps
      } = item;
      const active = key === activeKey;
      return /* @__PURE__ */ React288.createElement(
        src_default2,
        {
          key,
          visible: active,
          forceRender,
          removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
          leavedClassName: `${tabPanePrefixCls}-hidden`,
          ...animated.tabPaneMotion
        },
        ({ style: motionStyle, className: motionClassName }, ref) => /* @__PURE__ */ React288.createElement(
          TabPane_default,
          {
            ...restTabProps,
            prefixCls: tabPanePrefixCls,
            id,
            tabKey: key,
            animated: tabPaneAnimated,
            active,
            style: { ...paneStyle, ...motionStyle },
            className: (0, import_classnames106.default)(paneClassName, motionClassName),
            ref
          }
        )
      );
    })
  ));
}, "TabPanelList");
var TabPanelList_default = TabPanelList;

// packages/tabs/src/hooks/useAnimateConfig.ts
init_warning();
function useAnimateConfig(animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    if (true) {
      warning_default(
        false,
        "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work."
      );
    }
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}
__name(useAnimateConfig, "useAnimateConfig");

// packages/tabs/src/Tabs.tsx
var uuid7 = 0;
var Tabs = React289.forwardRef((props, ref) => {
  const {
    id,
    prefixCls = "rc-tabs",
    className,
    items,
    direction,
    activeKey,
    defaultActiveKey,
    editable,
    animated,
    tabPosition = "top",
    tabBarGutter,
    tabBarStyle,
    tabBarExtraContent,
    locale: locale6,
    more,
    destroyInactiveTabPane,
    renderTabBar,
    onChange,
    onTabClick,
    onTabScroll,
    getPopupContainer,
    popupClassName,
    indicator,
    ...restProps
  } = props;
  const tabs = React289.useMemo(
    () => (items || []).filter((item) => item && typeof item === "object" && "key" in item),
    [items]
  );
  const rtl = direction === "rtl";
  const mergedAnimated = useAnimateConfig(animated);
  const [mobile, setMobile] = useState67(false);
  useEffect70(() => {
    setMobile(isMobile_default());
  }, []);
  const [mergedActiveKey, setMergedActiveKey] = useMergedState(() => tabs[0]?.key, {
    value: activeKey,
    defaultValue: defaultActiveKey
  });
  const [activeIndex, setActiveIndex] = useState67(
    () => tabs.findIndex((tab) => tab.key === mergedActiveKey)
  );
  useEffect70(() => {
    let newActiveIndex = tabs.findIndex((tab) => tab.key === mergedActiveKey);
    if (newActiveIndex === -1) {
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey(tabs[newActiveIndex]?.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map((tab) => tab.key).join("_"), mergedActiveKey, activeIndex]);
  const [mergedId, setMergedId] = useMergedState(null, {
    value: id
  });
  useEffect70(() => {
    if (!id) {
      setMergedId(`rc-tabs-${false ? "test" : uuid7}`);
      uuid7 += 1;
    }
  }, []);
  function onInternalTabClick(key, e3) {
    onTabClick?.(key, e3);
    const isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange?.(key);
    }
  }
  __name(onInternalTabClick, "onInternalTabClick");
  const sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  };
  const tabNavBarProps = {
    ...sharedProps,
    editable,
    locale: locale6,
    more,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer,
    popupClassName,
    indicator
  };
  return /* @__PURE__ */ React289.createElement(TabContext_default.Provider, { value: { tabs, prefixCls } }, /* @__PURE__ */ React289.createElement(
    "div",
    {
      ref,
      id,
      className: (0, import_classnames107.default)(
        prefixCls,
        `${prefixCls}-${tabPosition}`,
        {
          [`${prefixCls}-mobile`]: mobile,
          [`${prefixCls}-editable`]: editable,
          [`${prefixCls}-rtl`]: rtl
        },
        className
      ),
      ...restProps
    },
    /* @__PURE__ */ React289.createElement(Wrapper_default, { ...tabNavBarProps, renderTabBar }),
    /* @__PURE__ */ React289.createElement(
      TabPanelList_default,
      {
        destroyInactiveTabPane,
        ...sharedProps,
        animated: mergedAnimated
      }
    )
  ));
});
if (true) {
  Tabs.displayName = "Tabs";
}
var Tabs_default = Tabs;

// packages/tabs/src/index.ts
var src_default12 = Tabs_default;

// packages/ant-design/components/tabs/hooks/useAnimateConfig.ts
var motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig2(prefixCls, animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = {
      ...motion,
      motionName: getTransitionName2(prefixCls, "switch")
    };
  }
  return mergedAnimated;
}
__name(useAnimateConfig2, "useAnimateConfig");

// packages/ant-design/components/tabs/hooks/useLegacyItems.ts
import * as React290 from "react";
function filter(items) {
  return items.filter((item) => item);
}
__name(filter, "filter");
function useLegacyItems(items, children) {
  if (true) {
    const warning5 = devUseWarning("Tabs");
    warning5.deprecated(!children, "Tabs.TabPane", "items");
  }
  if (items) {
    return items;
  }
  const childrenItems = toArray(children).map((node2) => {
    if (React290.isValidElement(node2)) {
      const { key, props } = node2;
      const { tab, ...restProps } = props || {};
      const item = {
        key: String(key),
        ...restProps,
        label: tab
      };
      return item;
    }
    return null;
  });
  return filter(childrenItems);
}
__name(useLegacyItems, "useLegacyItems");

// packages/ant-design/components/tabs/style/motion.ts
var genMotionStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationSlow } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
}, "genMotionStyle");
var motion_default2 = genMotionStyle;

// packages/ant-design/components/tabs/style/index.ts
var genCardStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardBg,
    cardGutter,
    colorBorderSecondary,
    itemSelectedColor
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardPadding,
          background: cardBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: itemSelectedColor,
          background: token2.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: unit(cardGutter)
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: unit(cardGutter)
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token2.borderRadiusLG)} 0 0 ${unit(token2.borderRadiusLG)}`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
}, "genCardStyle");
var genDropdownStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, itemHoverColor, dropdownEdgeChildVerticalPadding } = token2;
  return {
    [`${componentCls}-dropdown`]: {
      ...resetComponent(token2),
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": {
          ...textEllipsis,
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${unit(token2.paddingXXS)} ${unit(token2.paddingSM)}`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token2.marginSM
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: itemHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        }
      }
    }
  };
}, "genDropdownStyle");
var genPositionStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    margin,
    colorBorderSecondary,
    horizontalMargin,
    verticalItemPadding,
    verticalItemMargin,
    calc
  } = token2;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: horizontalMargin,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: margin,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: calc(token2.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: verticalItemPadding,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: verticalItemMargin
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: unit(calc(token2.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: true,
          value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: calc(token2.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: true,
          value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    }
  };
}, "genPositionStyle");
var genSizeStyle3 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardPaddingLG,
    horizontalItemPaddingSM,
    horizontalItemPaddingLG
  } = token2;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingSM,
            fontSize: token2.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingLG,
            fontSize: token2.titleFontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingSM
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)}`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token2.borderRadius)} 0 0 ${unit(token2.borderRadius)}`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingLG
          }
        }
      }
    }
  };
}, "genSizeStyle");
var genTabStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    itemActiveColor,
    itemHoverColor,
    iconCls,
    tabsHorizontalItemMargin,
    horizontalItemPadding,
    itemSelectedColor,
    itemColor
  } = token2;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: horizontalItemPadding,
      fontSize: token2.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: itemColor,
      "&-btn, &-remove": {
        "&:focus:not(:focus-visible), &:active": {
          color: itemActiveColor
        },
        ...genFocusStyle(token2)
      },
      "&-btn": {
        outline: "none",
        transition: `all ${token2.motionDurationSlow}`,
        [`${tabCls}-icon:not(:last-child)`]: {
          marginInlineEnd: token2.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: true,
          value: token2.calc(token2.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: true,
          value: token2.marginXS
        },
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&:hover": {
        color: itemHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: itemSelectedColor,
        textShadow: token2.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [`${iconCls}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: true,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: tabsHorizontalItemMargin
      }
    }
  };
}, "genTabStyle");
var genRtlStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, tabsHorizontalItemMarginRTL, iconCls, cardGutter, calc } = token2;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: tabsHorizontalItemMarginRTL
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(token2.marginSM)
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: unit(token2.marginXS)
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(calc(token2.marginXXS).mul(-1).equal())
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: cardGutter
            },
            marginLeft: { _skip_check_: true, value: 0 }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
}, "genRtlStyle");
var genTabsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardHeight,
    cardGutter,
    itemHoverColor,
    itemActiveColor,
    colorBorderSecondary
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardPadding,
          background: "transparent",
          border: 0,
          color: token2.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.calc(token2.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: {
          minWidth: cardHeight,
          minHeight: cardHeight,
          marginLeft: {
            _skip_check_: true,
            value: cardGutter
          },
          padding: `0 ${unit(token2.paddingXS)}`,
          background: "transparent",
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: itemHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: itemActiveColor
          },
          ...genFocusStyle(token2)
        }
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.inkBarColor,
        pointerEvents: "none"
      },
      // ============================= Tabs =============================
      ...genTabStyle(token2),
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    },
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, "genTabsStyle");
var prepareComponentToken22 = /* @__PURE__ */ __name((token2) => {
  const cardHeight = token2.controlHeightLG;
  return {
    zIndexPopup: token2.zIndexPopupBase + 50,
    cardBg: token2.colorFillAlter,
    cardHeight,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(cardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
    cardPaddingSM: `${token2.paddingXXS * 1.5}px ${token2.padding}px`,
    cardPaddingLG: `${token2.paddingXS}px ${token2.padding}px ${token2.paddingXXS * 1.5}px`,
    titleFontSize: token2.fontSize,
    titleFontSizeLG: token2.fontSizeLG,
    titleFontSizeSM: token2.fontSize,
    inkBarColor: token2.colorPrimary,
    horizontalMargin: `0 0 ${token2.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: ``,
    horizontalItemMarginRTL: ``,
    horizontalItemPadding: `${token2.paddingSM}px 0`,
    horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
    horizontalItemPaddingLG: `${token2.padding}px 0`,
    verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
    verticalItemMargin: `${token2.margin}px 0 0 0`,
    itemColor: token2.colorText,
    itemSelectedColor: token2.colorPrimary,
    itemHoverColor: token2.colorPrimaryHover,
    itemActiveColor: token2.colorPrimaryActive,
    cardGutter: token2.marginXXS / 2
  };
}, "prepareComponentToken");
var style_default26 = genStyleHooks(
  "Tabs",
  (token2) => {
    const tabsToken = merge2(token2, {
      // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
      tabsCardPadding: token2.cardPadding,
      dropdownEdgeChildVerticalPadding: token2.paddingXXS,
      tabsActiveTextShadow: "0 0 0.25px currentcolor",
      tabsDropdownHeight: 200,
      tabsDropdownWidth: 120,
      tabsHorizontalItemMargin: `0 0 0 ${unit(token2.horizontalItemGutter)}`,
      tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token2.horizontalItemGutter)}`
    });
    return [
      genSizeStyle3(tabsToken),
      genRtlStyle(tabsToken),
      genPositionStyle(tabsToken),
      genDropdownStyle(tabsToken),
      genCardStyle(tabsToken),
      genTabsStyle(tabsToken),
      motion_default2(tabsToken)
    ];
  },
  prepareComponentToken22
);

// packages/ant-design/components/tabs/TabPane.ts
var TabPane2 = /* @__PURE__ */ __name(() => null, "TabPane");
if (true) {
  TabPane2.displayName = "DeprecatedTabPane";
}
var TabPane_default2 = TabPane2;

// packages/ant-design/components/tabs/index.tsx
var Tabs2 = /* @__PURE__ */ __name((props) => {
  const {
    type: type5,
    className,
    rootClassName,
    size: customSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    removeIcon,
    moreIcon,
    popupClassName,
    children,
    items,
    animated,
    style: style2,
    indicatorSize,
    indicator,
    ...otherProps
  } = props;
  const { prefixCls: customizePrefixCls } = otherProps;
  const { direction, tabs, getPrefixCls, getPopupContainer } = React291.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tabs", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default26(prefixCls, rootCls);
  let editable;
  if (type5 === "editable-card") {
    editable = {
      onEdit: (editType, { key, event }) => {
        onEdit?.(editType === "add" ? event : key, editType);
      },
      removeIcon: removeIcon ?? tabs?.removeIcon ?? /* @__PURE__ */ React291.createElement(import_CloseOutlined8.default, null),
      addIcon: (addIcon ?? tabs?.addIcon) || /* @__PURE__ */ React291.createElement(import_PlusOutlined.default, null),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  if (true) {
    const warning5 = devUseWarning("Tabs");
    warning5(
      !("onPrevClick" in props) && !("onNextClick" in props),
      "breaking",
      "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead."
    );
    warning5(
      !(indicatorSize || tabs?.indicatorSize),
      "deprecated",
      "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead."
    );
  }
  const size = useSize_default(customSize);
  const mergedItems = useLegacyItems(items, children);
  const mergedAnimated = useAnimateConfig2(prefixCls, animated);
  const mergedStyle = { ...tabs?.style, ...style2 };
  const mergedIndicator = {
    align: indicator?.align ?? tabs?.indicator?.align,
    size: indicator?.size ?? indicatorSize ?? tabs?.indicator?.size ?? tabs?.indicatorSize
  };
  return wrapCSSVar(
    /* @__PURE__ */ React291.createElement(
      src_default12,
      {
        direction,
        getPopupContainer,
        moreTransitionName: `${rootPrefixCls}-slide-up`,
        ...otherProps,
        items: mergedItems,
        className: (0, import_classnames108.default)(
          {
            [`${prefixCls}-${size}`]: size,
            [`${prefixCls}-card`]: ["card", "editable-card"].includes(type5),
            [`${prefixCls}-editable-card`]: type5 === "editable-card",
            [`${prefixCls}-centered`]: centered
          },
          tabs?.className,
          className,
          rootClassName,
          hashId,
          cssVarCls,
          rootCls
        ),
        popupClassName: (0, import_classnames108.default)(popupClassName, hashId, cssVarCls, rootCls),
        style: mergedStyle,
        editable,
        moreIcon: moreIcon ?? tabs?.moreIcon ?? /* @__PURE__ */ React291.createElement(import_EllipsisOutlined2.default, null),
        prefixCls,
        animated: mergedAnimated,
        indicator: mergedIndicator
      }
    )
  );
}, "Tabs");
Tabs2.TabPane = TabPane_default2;
if (true) {
  Tabs2.displayName = "Tabs";
}
var tabs_default = Tabs2;

// packages/ant-design/components/card/Grid.tsx
var import_classnames109 = __toESM(require_classnames());
import * as React292 from "react";
var Grid = /* @__PURE__ */ __name(({ prefixCls, className, hoverable = true, ...props }) => {
  const { getPrefixCls } = React292.useContext(ConfigContext);
  const prefix = getPrefixCls("card", prefixCls);
  const classString = (0, import_classnames109.default)(`${prefix}-grid`, className, {
    [`${prefix}-grid-hoverable`]: hoverable
  });
  return /* @__PURE__ */ React292.createElement("div", { ...props, className: classString });
}, "Grid");
var Grid_default = Grid;

// packages/ant-design/components/card/style/index.ts
var genCardHeadStyle = /* @__PURE__ */ __name((token2) => {
  const { antCls, componentCls, headerHeight, cardPaddingBase, tabsMarginBottom } = token2;
  return {
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: headerHeight,
    marginBottom: -1,
    // Fix card grid overflow bug: https://gw.alipayobjects.com/zos/rmsportal/XonYxBikwpgbqIQBeuhk.png
    padding: `0 ${unit(cardPaddingBase)}`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.headerFontSize,
    background: token2.headerBg,
    borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
    ...clearFix(),
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": {
      display: "inline-block",
      flex: 1,
      ...textEllipsis,
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    },
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: tabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  };
}, "genCardHeadStyle");
var genCardGridStyle = /* @__PURE__ */ __name((token2) => {
  const { cardPaddingBase, colorBorderSecondary, cardShadow, lineWidth } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
}, "genCardGridStyle");
var genCardActionsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    actionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary,
    actionsBg
  } = token2;
  return {
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: actionsBg,
    borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`,
    ...clearFix(),
    "& > li": {
      margin: actionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.calc(token2.cardActionsIconSize).mul(2).equal(),
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorTextDescription,
          lineHeight: unit(token2.fontHeight),
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: unit(token2.calc(cardActionsIconSize).mul(token2.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  };
}, "genCardActionsStyle");
var genCardMetaStyle = /* @__PURE__ */ __name((token2) => ({
  margin: `${unit(token2.calc(token2.marginXXS).mul(-1).equal())} 0`,
  display: "flex",
  ...clearFix(),
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": {
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG,
    ...textEllipsis
  },
  "&-description": {
    color: token2.colorTextDescription
  }
}), "genCardMetaStyle");
var genCardTypeInnerStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, cardPaddingBase, colorFillAlter } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${unit(cardPaddingBase)}`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${unit(token2.padding)} ${unit(cardPaddingBase)}`
    }
  };
}, "genCardTypeInnerStyle");
var genCardLoadingStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
}, "genCardLoadingStyle");
var genCardStyle2 = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    cardPaddingBase,
    extraColor
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: extraColor,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: {
        padding: cardPaddingBase,
        borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`,
        ...clearFix()
      },
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        [`img, img + ${antCls}-image-mask`]: {
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    },
    [`${componentCls}-bordered`]: {
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0 `,
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        minHeight: 0,
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genCardStyle");
var genCardSizeStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, cardPaddingSM, headerHeightSM, headerFontSizeSM } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: headerHeightSM,
        padding: `0 ${unit(cardPaddingSM)}`,
        fontSize: headerFontSizeSM,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, "genCardSizeStyle");
var prepareComponentToken23 = /* @__PURE__ */ __name((token2) => ({
  headerBg: "transparent",
  headerFontSize: token2.fontSizeLG,
  headerFontSizeSM: token2.fontSize,
  headerHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
  headerHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
  actionsBg: token2.colorBgContainer,
  actionsLiMargin: `${token2.paddingSM}px 0`,
  tabsMarginBottom: -token2.padding - token2.lineWidth,
  extraColor: token2.colorText
}), "prepareComponentToken");
var style_default27 = genStyleHooks(
  "Card",
  (token2) => {
    const cardToken = merge2(token2, {
      cardShadow: token2.boxShadowCard,
      cardHeadPadding: token2.padding,
      cardPaddingBase: token2.paddingLG,
      cardActionsIconSize: token2.fontSize,
      cardPaddingSM: 12
      // Fixed padding.
    });
    return [
      // Style
      genCardStyle2(cardToken),
      // Size
      genCardSizeStyle(cardToken)
    ];
  },
  prepareComponentToken23
);

// packages/ant-design/components/card/Card.tsx
var ActionNode = /* @__PURE__ */ __name((props) => {
  const { actionClasses, actions = [], actionStyle } = props;
  return /* @__PURE__ */ React293.createElement("ul", { className: actionClasses, style: actionStyle }, actions.map((action, index3) => {
    const key = `action-${index3}`;
    return /* @__PURE__ */ React293.createElement("li", { style: { width: `${100 / actions.length}%` }, key }, /* @__PURE__ */ React293.createElement("span", null, action));
  }));
}, "ActionNode");
var Card = React293.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    extra,
    headStyle = {},
    bodyStyle = {},
    title,
    loading,
    bordered = true,
    size: customizeSize,
    type: type5,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {},
    classNames: customClassNames,
    styles: customStyles,
    ...others
  } = props;
  const { getPrefixCls, direction, card } = React293.useContext(ConfigContext);
  if (true) {
    const warning5 = devUseWarning("Card");
    [
      ["headStyle", "styles.header"],
      ["bodyStyle", "styles.body"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const onTabChange = /* @__PURE__ */ __name((key) => {
    props.onTabChange?.(key);
  }, "onTabChange");
  const moduleClass = /* @__PURE__ */ __name((moduleName) => (0, import_classnames110.default)(card?.classNames?.[moduleName], customClassNames?.[moduleName]), "moduleClass");
  const moduleStyle = /* @__PURE__ */ __name((moduleName) => ({
    ...card?.styles?.[moduleName],
    ...customStyles?.[moduleName]
  }), "moduleStyle");
  const isContainGrid = React293.useMemo(() => {
    let containGrid = false;
    React293.Children.forEach(children, (element) => {
      if (element && element.type && element.type === Grid_default) {
        containGrid = true;
      }
    });
    return containGrid;
  }, [children]);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default27(prefixCls);
  const loadingBlock = /* @__PURE__ */ React293.createElement(skeleton_default, { loading: true, active: true, paragraph: { rows: 4 }, title: false }, children);
  const hasActiveTabKey = activeTabKey !== void 0;
  const extraProps = {
    ...tabProps,
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  };
  let head;
  const mergedSize = useSize_default(customizeSize);
  const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
  const tabs = tabList ? /* @__PURE__ */ React293.createElement(
    tabs_default,
    {
      size: tabSize,
      ...extraProps,
      className: `${prefixCls}-head-tabs`,
      onChange: onTabChange,
      items: tabList.map(({ tab, ...item }) => ({ label: tab, ...item }))
    }
  ) : null;
  if (title || extra || tabs) {
    const headClasses = (0, import_classnames110.default)(`${prefixCls}-head`, moduleClass("header"));
    const titleClasses = (0, import_classnames110.default)(`${prefixCls}-head-title`, moduleClass("title"));
    const extraClasses = (0, import_classnames110.default)(`${prefixCls}-extra`, moduleClass("extra"));
    const mergedHeadStyle = {
      ...headStyle,
      ...moduleStyle("header")
    };
    head = /* @__PURE__ */ React293.createElement("div", { className: headClasses, style: mergedHeadStyle }, /* @__PURE__ */ React293.createElement("div", { className: `${prefixCls}-head-wrapper` }, title && /* @__PURE__ */ React293.createElement("div", { className: titleClasses, style: moduleStyle("title") }, title), extra && /* @__PURE__ */ React293.createElement("div", { className: extraClasses, style: moduleStyle("extra") }, extra)), tabs);
  }
  const coverClasses = (0, import_classnames110.default)(`${prefixCls}-cover`, moduleClass("cover"));
  const coverDom = cover ? /* @__PURE__ */ React293.createElement("div", { className: coverClasses, style: moduleStyle("cover") }, cover) : null;
  const bodyClasses = (0, import_classnames110.default)(`${prefixCls}-body`, moduleClass("body"));
  const mergedBodyStyle = {
    ...bodyStyle,
    ...moduleStyle("body")
  };
  const body = /* @__PURE__ */ React293.createElement("div", { className: bodyClasses, style: mergedBodyStyle }, loading ? loadingBlock : children);
  const actionClasses = (0, import_classnames110.default)(`${prefixCls}-actions`, moduleClass("actions"));
  const actionDom = actions && actions.length ? /* @__PURE__ */ React293.createElement(
    ActionNode,
    {
      actionClasses,
      actionStyle: moduleStyle("actions"),
      actions
    }
  ) : null;
  const divProps = omit(others, ["onTabChange"]);
  const classString = (0, import_classnames110.default)(
    prefixCls,
    card?.className,
    {
      [`${prefixCls}-loading`]: loading,
      [`${prefixCls}-bordered`]: bordered,
      [`${prefixCls}-hoverable`]: hoverable,
      [`${prefixCls}-contain-grid`]: isContainGrid,
      [`${prefixCls}-contain-tabs`]: tabList && tabList.length,
      [`${prefixCls}-${mergedSize}`]: mergedSize,
      [`${prefixCls}-type-${type5}`]: !!type5,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...card?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React293.createElement("div", { ref, ...divProps, className: classString, style: mergedStyle }, head, coverDom, body, actionDom)
  );
});
var Card_default = Card;

// packages/ant-design/components/card/Meta.tsx
var import_classnames111 = __toESM(require_classnames());
import * as React294 from "react";
var Meta = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, className, avatar, title, description, ...others } = props;
  const { getPrefixCls } = React294.useContext(ConfigContext);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const classString = (0, import_classnames111.default)(`${prefixCls}-meta`, className);
  const avatarDom = avatar ? /* @__PURE__ */ React294.createElement("div", { className: `${prefixCls}-meta-avatar` }, avatar) : null;
  const titleDom = title ? /* @__PURE__ */ React294.createElement("div", { className: `${prefixCls}-meta-title` }, title) : null;
  const descriptionDom = description ? /* @__PURE__ */ React294.createElement("div", { className: `${prefixCls}-meta-description` }, description) : null;
  const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ React294.createElement("div", { className: `${prefixCls}-meta-detail` }, titleDom, descriptionDom) : null;
  return /* @__PURE__ */ React294.createElement("div", { ...others, className: classString }, avatarDom, MetaDetail);
}, "Meta");
var Meta_default = Meta;

// packages/ant-design/components/card/index.ts
var Card2 = Card_default;
Card2.Grid = Grid_default;
Card2.Meta = Meta_default;
if (true) {
  Card2.displayName = "Card";
}
var card_default = Card2;

// packages/ant-design/components/carousel/index.tsx
import * as React302 from "react";

// packages/react-slick/src/slider.js
import React301 from "react";

// packages/react-slick/src/inner-slider.js
import React300 from "react";

// packages/react-slick/src/initial-state.js
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  // used by swipeEvent. differentites between touch and swipe.
  swiping: false,
  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0 },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
var initial_state_default = initialState;

// node_modules/.pnpm/throttle-debounce@5.0.0/node_modules/throttle-debounce/esm/index.js
function throttle2(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  __name(clearExistingTimeout, "clearExistingTimeout");
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  __name(cancel, "cancel");
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    __name(exec, "exec");
    function clear() {
      timeoutID = void 0;
    }
    __name(clear, "clear");
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  __name(wrapper, "wrapper");
  wrapper.cancel = cancel;
  return wrapper;
}
__name(throttle2, "throttle");
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle2(delay, callback, {
    debounceMode: atBegin !== false
  });
}
__name(debounce, "debounce");

// packages/react-slick/src/inner-slider.js
var import_classnames115 = __toESM(require_classnames());

// packages/react-slick/src/utils/innerSliderUtils.js
import React296 from "react";

// packages/react-slick/src/default-props.js
import React295 from "react";
var defaultProps = {
  accessibility: true,
  adaptiveHeight: false,
  afterChange: null,
  appendDots: (dots) => /* @__PURE__ */ React295.createElement("ul", { style: { display: "block" } }, dots),
  arrows: true,
  autoplay: false,
  autoplaySpeed: 3e3,
  beforeChange: null,
  centerMode: false,
  centerPadding: "50px",
  className: "",
  cssEase: "ease",
  customPaging: (i) => /* @__PURE__ */ React295.createElement("button", null, i + 1),
  dots: false,
  dotsClass: "slick-dots",
  draggable: true,
  easing: "linear",
  edgeFriction: 0.35,
  fade: false,
  focusOnSelect: false,
  infinite: true,
  initialSlide: 0,
  lazyLoad: null,
  nextArrow: null,
  onEdge: null,
  onInit: null,
  onLazyLoadError: null,
  onReInit: null,
  pauseOnDotsHover: false,
  pauseOnFocus: false,
  pauseOnHover: true,
  prevArrow: null,
  responsive: null,
  rows: 1,
  rtl: false,
  slide: "div",
  slidesPerRow: 1,
  slidesToScroll: 1,
  slidesToShow: 1,
  speed: 500,
  swipe: true,
  swipeEvent: null,
  swipeToSlide: false,
  touchMove: true,
  touchThreshold: 5,
  useCSS: true,
  useTransform: true,
  variableWidth: false,
  vertical: false,
  waitForAnimate: true,
  asNavFor: null
};
var default_props_default = defaultProps;

// packages/react-slick/src/utils/innerSliderUtils.js
function clamp(number4, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number4, upperBound));
}
__name(clamp, "clamp");
var safePreventDefault = /* @__PURE__ */ __name((event) => {
  const passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
}, "safePreventDefault");
var getOnDemandLazySlides = /* @__PURE__ */ __name((spec) => {
  let onDemandSlides = [];
  let startIndex = lazyStartIndex(spec);
  let endIndex = lazyEndIndex(spec);
  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
}, "getOnDemandLazySlides");
var lazyStartIndex = /* @__PURE__ */ __name((spec) => spec.currentSlide - lazySlidesOnLeft(spec), "lazyStartIndex");
var lazyEndIndex = /* @__PURE__ */ __name((spec) => spec.currentSlide + lazySlidesOnRight(spec), "lazyEndIndex");
var lazySlidesOnLeft = /* @__PURE__ */ __name((spec) => spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0, "lazySlidesOnLeft");
var lazySlidesOnRight = /* @__PURE__ */ __name((spec) => spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow, "lazySlidesOnRight");
var getWidth2 = /* @__PURE__ */ __name((elem) => elem && elem.offsetWidth || 0, "getWidth");
var getHeight = /* @__PURE__ */ __name((elem) => elem && elem.offsetHeight || 0, "getHeight");
var getSwipeDirection = /* @__PURE__ */ __name((touchObject, verticalSwiping = false) => {
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
}, "getSwipeDirection");
var canGoNext = /* @__PURE__ */ __name((spec) => {
  let canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
}, "canGoNext");
var extractObject = /* @__PURE__ */ __name((spec, keys2) => {
  let newObject = {};
  keys2.forEach((key) => newObject[key] = spec[key]);
  return newObject;
}, "extractObject");
var initializedState = /* @__PURE__ */ __name((spec) => {
  let slideCount = React296.Children.count(spec.children);
  const listNode = spec.listRef;
  let listWidth = Math.ceil(getWidth2(listNode));
  const trackNode = spec.trackRef && spec.trackRef.node;
  let trackWidth = Math.ceil(getWidth2(trackNode));
  let slideWidth;
  if (!spec.vertical) {
    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  let slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  let listHeight = slideHeight * spec.slidesToShow;
  let currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  let lazyLoadedList = spec.lazyLoadedList || [];
  let slidesToLoad = getOnDemandLazySlides({
    ...spec,
    currentSlide,
    lazyLoadedList
  });
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  let state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
}, "initializedState");
var slideHandler = /* @__PURE__ */ __name((spec) => {
  const {
    waitForAnimate,
    animating,
    fade,
    infinite,
    index: index3,
    slideCount,
    lazyLoad,
    currentSlide,
    centerMode,
    slidesToScroll,
    slidesToShow,
    useCSS
  } = spec;
  let { lazyLoadedList } = spec;
  if (waitForAnimate && animating)
    return {};
  let animationSlide = index3, finalSlide, animationLeft, finalLeft;
  let state = {}, nextState = {};
  const targetSlide = infinite ? index3 : clamp(index3, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index3 < 0 || index3 >= slideCount))
      return {};
    if (index3 < 0) {
      animationSlide = index3 + slideCount;
    } else if (index3 >= slideCount) {
      animationSlide = index3 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = { animating: false, targetSlide: animationSlide };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft({ ...spec, slideIndex: animationSlide });
    finalLeft = getTrackLeft({ ...spec, slideIndex: finalSlide });
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(
        getOnDemandLazySlides({ ...spec, currentSlide: animationSlide })
      );
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS({ ...spec, left: animationLeft }),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return { state, nextState };
}, "slideHandler");
var changeSlide = /* @__PURE__ */ __name((spec, options) => {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  const {
    slidesToScroll,
    slidesToShow,
    slideCount,
    currentSlide,
    targetSlide: previousTargetSlide,
    lazyLoad,
    infinite
  } = spec;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      let direction = siblingDirection({ ...spec, targetSlide });
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
}, "changeSlide");
var keyHandler = /* @__PURE__ */ __name((e3, accessibility, rtl) => {
  if (e3.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility)
    return "";
  if (e3.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e3.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
}, "keyHandler");
var swipeStart = /* @__PURE__ */ __name((e3, swipe, draggable) => {
  e3.target.tagName === "IMG" && safePreventDefault(e3);
  if (!swipe || !draggable && e3.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      startY: e3.touches ? e3.touches[0].pageY : e3.clientY,
      curX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      curY: e3.touches ? e3.touches[0].pageY : e3.clientY
    }
  };
}, "swipeStart");
var swipeMove = /* @__PURE__ */ __name((e3, spec) => {
  const {
    scrolling,
    animating,
    vertical,
    swipeToSlide,
    verticalSwiping,
    rtl,
    currentSlide,
    edgeFriction,
    edgeDragged,
    onEdge,
    swiped,
    swiping,
    slideCount,
    slidesToScroll,
    infinite,
    touchObject,
    swipeEvent,
    listHeight,
    listWidth
  } = spec;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e3);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e3);
  let swipeLeft, state = {};
  let curLeft = getTrackLeft(spec);
  touchObject.curX = e3.touches ? e3.touches[0].pageX : e3.clientX;
  touchObject.curY = e3.touches ? e3.touches[0].pageY : e3.clientY;
  touchObject.swipeLength = Math.round(
    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))
  );
  let verticalSwipeLength = Math.round(
    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))
  );
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return { scrolling: true };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping)
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  let dotCount = Math.ceil(slideCount / slidesToScroll);
  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  let touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = {
    ...state,
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS({ ...spec, left: swipeLeft })
  };
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e3);
  }
  return state;
}, "swipeMove");
var swipeEnd = /* @__PURE__ */ __name((e3, spec) => {
  const {
    dragging,
    swipe,
    touchObject,
    listWidth,
    touchThreshold,
    verticalSwiping,
    listHeight,
    swipeToSlide,
    scrolling,
    onSwipe,
    targetSlide,
    currentSlide,
    infinite
  } = spec;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e3);
    return {};
  }
  let minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  let state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e3);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    let slideCount, newSlide;
    let activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    let currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS({ ...spec, left: currentLeft });
  }
  return state;
}, "swipeEnd");
var getNavigableIndexes = /* @__PURE__ */ __name((spec) => {
  let max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  let indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
}, "getNavigableIndexes");
var checkNavigable = /* @__PURE__ */ __name((spec, index3) => {
  const navigables = getNavigableIndexes(spec);
  let prevNavigable = 0;
  if (index3 > navigables[navigables.length - 1]) {
    index3 = navigables[navigables.length - 1];
  } else {
    for (let n2 in navigables) {
      if (index3 < navigables[n2]) {
        index3 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index3;
}, "checkNavigable");
var getSlideCount = /* @__PURE__ */ __name((spec) => {
  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    let swipedSlide;
    const slickList = spec.listRef;
    const slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every((slide) => {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth2(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
}, "getSlideCount");
var checkSpecKeys = /* @__PURE__ */ __name((spec, keysArray) => (
  // eslint-disable-next-line no-prototype-builtins
  keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true) ? null : console.error("Keys Missing:", spec)
), "checkSpecKeys");
var getTrackCSS = /* @__PURE__ */ __name((spec) => {
  checkSpecKeys(spec, [
    "left",
    "variableWidth",
    "slideCount",
    "slidesToShow",
    "slideWidth"
  ]);
  let trackWidth, trackHeight;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    const trackChildren = spec.unslick ? spec.slideCount : spec.slideCount + 2 * spec.slidesToShow;
    trackHeight = trackChildren * spec.slideHeight;
  }
  let style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    let WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    let transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    let msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = {
      ...style2,
      WebkitTransform,
      transform,
      msTransform
    };
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = { opacity: 1 };
  if (trackWidth)
    style2.width = trackWidth;
  if (trackHeight)
    style2.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
}, "getTrackCSS");
var getTrackAnimateCSS = /* @__PURE__ */ __name((spec) => {
  checkSpecKeys(spec, [
    "left",
    "variableWidth",
    "slideCount",
    "slidesToShow",
    "slideWidth",
    "speed",
    "cssEase"
  ]);
  let style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
}, "getTrackAnimateCSS");
var getTrackLeft = /* @__PURE__ */ __name((spec) => {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, [
    "slideIndex",
    "trackRef",
    "infinite",
    "centerMode",
    "slideCount",
    "slidesToShow",
    "slidesToScroll",
    "slideWidth",
    "listWidth",
    "variableWidth",
    "slideHeight"
  ]);
  const {
    slideIndex,
    trackRef,
    infinite,
    centerMode,
    slideCount,
    slidesToShow,
    slidesToScroll,
    slideWidth,
    listWidth,
    variableWidth,
    slideHeight,
    fade,
    vertical
  } = spec;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  let slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    const trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (let slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
}, "getTrackLeft");
var getPreClones = /* @__PURE__ */ __name((spec) => {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
}, "getPreClones");
var getPostClones = /* @__PURE__ */ __name((spec) => {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
}, "getPostClones");
var getTotalSlides = /* @__PURE__ */ __name((spec) => spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec), "getTotalSlides");
var siblingDirection = /* @__PURE__ */ __name((spec) => {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
}, "siblingDirection");
var slidesOnRight = /* @__PURE__ */ __name(({
  slidesToShow,
  centerMode,
  rtl,
  centerPadding
}) => {
  if (centerMode) {
    let right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
}, "slidesOnRight");
var slidesOnLeft = /* @__PURE__ */ __name(({
  slidesToShow,
  centerMode,
  rtl,
  centerPadding
}) => {
  if (centerMode) {
    let left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
}, "slidesOnLeft");
var canUseDOM = /* @__PURE__ */ __name(() => !!(typeof window !== "undefined" && window.document && window.document.createElement), "canUseDOM");
var validSettings = Object.keys(default_props_default);
function filterSettings(settings) {
  return validSettings.reduce((acc, settingName) => {
    if (settings.hasOwnProperty(settingName)) {
      acc[settingName] = settings[settingName];
    }
    return acc;
  }, {});
}
__name(filterSettings, "filterSettings");

// packages/react-slick/src/track.js
var import_classnames112 = __toESM(require_classnames());
import React297 from "react";
var getSlideClasses = /* @__PURE__ */ __name((spec) => {
  let slickActive, slickCenter, slickCloned;
  let centerOffset, index3;
  if (spec.rtl) {
    index3 = spec.slideCount - 1 - spec.index;
  } else {
    index3 = spec.index;
  }
  slickCloned = index3 < 0 || index3 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index3 - spec.currentSlide) % spec.slideCount === 0;
    if (index3 > spec.currentSlide - centerOffset - 1 && index3 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index3 && index3 < spec.currentSlide + spec.slidesToShow;
  }
  let focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  let slickCurrent = index3 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
    // dubious in case of RTL
  };
}, "getSlideClasses");
var getSlideStyle = /* @__PURE__ */ __name((spec) => {
  let style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth;
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical && spec.slideHeight) {
      style2.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth);
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    style2.zIndex = spec.currentSlide === spec.index ? 999 : 998;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
}, "getSlideStyle");
var getKey2 = /* @__PURE__ */ __name((child, fallbackKey) => child.key + "-" + fallbackKey, "getKey");
var renderSlides = /* @__PURE__ */ __name((spec) => {
  let key;
  let slides = [];
  let preCloneSlides = [];
  let postCloneSlides = [];
  let childrenCount = React297.Children.count(spec.children);
  let startIndex = lazyStartIndex(spec);
  let endIndex = lazyEndIndex(spec);
  React297.Children.forEach(spec.children, (elem, index3) => {
    let child;
    let childOnClickOptions = {
      message: "children",
      index: index3,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index3) >= 0) {
      child = elem;
    } else {
      child = /* @__PURE__ */ React297.createElement("div", null);
    }
    let childStyle = getSlideStyle({ ...spec, index: index3 });
    let slideClass = child.props.className || "";
    let slideClasses = getSlideClasses({ ...spec, index: index3 });
    slides.push(
      React297.cloneElement(child, {
        key: "original" + getKey2(child, index3),
        "data-index": index3,
        className: (0, import_classnames112.default)(slideClasses, slideClass),
        tabIndex: "-1",
        "aria-hidden": !slideClasses["slick-active"],
        style: { outline: "none", ...child.props.style || {}, ...childStyle },
        onClick: (e3) => {
          child.props && child.props.onClick && child.props.onClick(e3);
          if (spec.focusOnSelect) {
            spec.focusOnSelect(childOnClickOptions);
          }
        }
      })
    );
    if (spec.infinite && childrenCount > 1 && spec.fade === false && !spec.unslick) {
      let preCloneNo = childrenCount - index3;
      if (preCloneNo <= getPreClones(spec)) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses({ ...spec, index: key });
        preCloneSlides.push(
          React297.cloneElement(child, {
            key: "precloned" + getKey2(child, key),
            "data-index": key,
            tabIndex: "-1",
            className: (0, import_classnames112.default)(slideClasses, slideClass),
            "aria-hidden": !slideClasses["slick-active"],
            style: { ...child.props.style || {}, ...childStyle },
            onClick: (e3) => {
              child.props && child.props.onClick && child.props.onClick(e3);
              if (spec.focusOnSelect) {
                spec.focusOnSelect(childOnClickOptions);
              }
            }
          })
        );
      }
      key = childrenCount + index3;
      if (key < endIndex) {
        child = elem;
      }
      slideClasses = getSlideClasses({ ...spec, index: key });
      postCloneSlides.push(
        React297.cloneElement(child, {
          key: "postcloned" + getKey2(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: (0, import_classnames112.default)(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: { ...child.props.style || {}, ...childStyle },
          onClick: (e3) => {
            child.props && child.props.onClick && child.props.onClick(e3);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        })
      );
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
}, "renderSlides");
var Track = class extends React297.PureComponent {
  static {
    __name(this, "Track");
  }
  node = null;
  handleRef = (ref) => {
    this.node = ref;
  };
  render() {
    const slides = renderSlides(this.props);
    const { onMouseEnter, onMouseOver, onMouseLeave } = this.props;
    const mouseEvents = { onMouseEnter, onMouseOver, onMouseLeave };
    return /* @__PURE__ */ React297.createElement(
      "div",
      {
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle,
        ...mouseEvents
      },
      slides
    );
  }
};

// packages/react-slick/src/dots.js
var import_classnames113 = __toESM(require_classnames());
import React298 from "react";
var getDotCount = /* @__PURE__ */ __name((spec) => {
  let dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
}, "getDotCount");
var Dots = class extends React298.PureComponent {
  static {
    __name(this, "Dots");
  }
  clickHandler(options, e3) {
    e3.preventDefault();
    this.props.clickHandler(options);
  }
  render() {
    const {
      onMouseEnter,
      onMouseOver,
      onMouseLeave,
      infinite,
      slidesToScroll,
      slidesToShow,
      slideCount,
      currentSlide
    } = this.props;
    let dotCount = getDotCount({
      slideCount,
      slidesToScroll,
      slidesToShow,
      infinite
    });
    const mouseEvents = { onMouseEnter, onMouseOver, onMouseLeave };
    let dots = [];
    for (let i = 0; i < dotCount; i++) {
      let _rightBound = (i + 1) * slidesToScroll - 1;
      let rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
      let _leftBound = rightBound - (slidesToScroll - 1);
      let leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
      let className = (0, import_classnames113.default)({
        "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
      });
      let dotOptions = {
        message: "dots",
        index: i,
        slidesToScroll,
        currentSlide
      };
      let onClick = this.clickHandler.bind(this, dotOptions);
      dots = dots.concat(
        /* @__PURE__ */ React298.createElement("li", { key: i, className }, React298.cloneElement(this.props.customPaging(i), { onClick }))
      );
    }
    return React298.cloneElement(this.props.appendDots(dots), {
      className: this.props.dotsClass,
      ...mouseEvents
    });
  }
};

// packages/react-slick/src/arrows.js
var import_classnames114 = __toESM(require_classnames());
import React299 from "react";
var PrevArrow = class extends React299.PureComponent {
  static {
    __name(this, "PrevArrow");
  }
  clickHandler(options, e3) {
    if (e3) {
      e3.preventDefault();
    }
    this.props.clickHandler(options, e3);
  }
  render() {
    let prevClasses = { "slick-arrow": true, "slick-prev": true };
    let prevHandler = this.clickHandler.bind(this, { message: "previous" });
    if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
      prevClasses["slick-disabled"] = true;
      prevHandler = null;
    }
    let prevArrowProps = {
      key: "0",
      "data-role": "none",
      className: (0, import_classnames114.default)(prevClasses),
      style: { display: "block" },
      onClick: prevHandler
    };
    let customProps = {
      currentSlide: this.props.currentSlide,
      slideCount: this.props.slideCount
    };
    let prevArrow;
    if (this.props.prevArrow) {
      prevArrow = React299.cloneElement(this.props.prevArrow, {
        ...prevArrowProps,
        ...customProps
      });
    } else {
      prevArrow = /* @__PURE__ */ React299.createElement("button", { key: "0", type: "button", ...prevArrowProps }, " ", "Previous");
    }
    return prevArrow;
  }
};
var NextArrow = class extends React299.PureComponent {
  static {
    __name(this, "NextArrow");
  }
  clickHandler(options, e3) {
    if (e3) {
      e3.preventDefault();
    }
    this.props.clickHandler(options, e3);
  }
  render() {
    let nextClasses = { "slick-arrow": true, "slick-next": true };
    let nextHandler = this.clickHandler.bind(this, { message: "next" });
    if (!canGoNext(this.props)) {
      nextClasses["slick-disabled"] = true;
      nextHandler = null;
    }
    let nextArrowProps = {
      key: "1",
      "data-role": "none",
      className: (0, import_classnames114.default)(nextClasses),
      style: { display: "block" },
      onClick: nextHandler
    };
    let customProps = {
      currentSlide: this.props.currentSlide,
      slideCount: this.props.slideCount
    };
    let nextArrow;
    if (this.props.nextArrow) {
      nextArrow = React299.cloneElement(this.props.nextArrow, {
        ...nextArrowProps,
        ...customProps
      });
    } else {
      nextArrow = /* @__PURE__ */ React299.createElement("button", { key: "1", type: "button", ...nextArrowProps }, " ", "Next");
    }
    return nextArrow;
  }
};

// packages/react-slick/src/inner-slider.js
var InnerSlider = class extends React300.Component {
  static {
    __name(this, "InnerSlider");
  }
  constructor(props) {
    super(props);
    this.list = null;
    this.track = null;
    this.state = {
      ...initial_state_default,
      currentSlide: this.props.initialSlide,
      targetSlide: this.props.initialSlide ? this.props.initialSlide : 0,
      slideCount: React300.Children.count(this.props.children)
    };
    this.callbackTimers = [];
    this.clickable = true;
    this.debouncedResize = null;
    const ssrState = this.ssrInit();
    this.state = { ...this.state, ...ssrState };
  }
  listRefHandler = (ref) => this.list = ref;
  trackRefHandler = (ref) => this.track = ref;
  adaptHeight = () => {
    if (this.props.adaptiveHeight && this.list) {
      const elem = this.list.querySelector(
        `[data-index="${this.state.currentSlide}"]`
      );
      this.list.style.height = getHeight(elem) + "px";
    }
  };
  componentDidMount = () => {
    this.props.onInit && this.props.onInit();
    if (this.props.lazyLoad) {
      let slidesToLoad = getOnDemandLazySlides({
        ...this.props,
        ...this.state
      });
      if (slidesToLoad.length > 0) {
        this.setState((prevState) => ({
          lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
        }));
        if (this.props.onLazyLoad) {
          this.props.onLazyLoad(slidesToLoad);
        }
      }
    }
    let spec = { listRef: this.list, trackRef: this.track, ...this.props };
    this.updateState(spec, true, () => {
      this.adaptHeight();
      this.props.autoplay && this.autoPlay("playing");
    });
    if (this.props.lazyLoad === "progressive") {
      this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1e3);
    }
    this.ro = new ResizeObserver_es_default(() => {
      if (this.state.animating) {
        this.onWindowResized(false);
        this.callbackTimers.push(
          setTimeout(() => this.onWindowResized(), this.props.speed)
        );
      } else {
        this.onWindowResized();
      }
    });
    this.ro.observe(this.list);
    document.querySelectorAll && Array.prototype.forEach.call(
      document.querySelectorAll(".slick-slide"),
      (slide) => {
        slide.onfocus = this.props.pauseOnFocus ? this.onSlideFocus : null;
        slide.onblur = this.props.pauseOnFocus ? this.onSlideBlur : null;
      }
    );
    if (window.addEventListener) {
      window.addEventListener("resize", this.onWindowResized);
    } else {
      window.attachEvent("onresize", this.onWindowResized);
    }
  };
  componentWillUnmount = () => {
    if (this.animationEndCallback) {
      clearTimeout(this.animationEndCallback);
    }
    if (this.lazyLoadTimer) {
      clearInterval(this.lazyLoadTimer);
    }
    if (this.callbackTimers.length) {
      this.callbackTimers.forEach((timer) => clearTimeout(timer));
      this.callbackTimers = [];
    }
    if (window.addEventListener) {
      window.removeEventListener("resize", this.onWindowResized);
    } else {
      window.detachEvent("onresize", this.onWindowResized);
    }
    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
    }
    this.ro.disconnect();
  };
  didPropsChange(prevProps) {
    let setTrackStyle = false;
    for (let key of Object.keys(this.props)) {
      if (!prevProps.hasOwnProperty(key)) {
        setTrackStyle = true;
        break;
      }
      if (typeof prevProps[key] === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) {
        continue;
      }
      if (prevProps[key] !== this.props[key]) {
        setTrackStyle = true;
        break;
      }
    }
    return setTrackStyle || React300.Children.count(this.props.children) !== React300.Children.count(prevProps.children);
  }
  componentDidUpdate = (prevProps) => {
    this.checkImagesLoad();
    this.props.onReInit && this.props.onReInit();
    if (this.props.lazyLoad) {
      let slidesToLoad = getOnDemandLazySlides({
        ...this.props,
        ...this.state
      });
      if (slidesToLoad.length > 0) {
        this.setState((prevState) => ({
          lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
        }));
        if (this.props.onLazyLoad) {
          this.props.onLazyLoad(slidesToLoad);
        }
      }
    }
    this.adaptHeight();
    let spec = {
      listRef: this.list,
      trackRef: this.track,
      ...this.props,
      ...this.state
    };
    const setTrackStyle = this.didPropsChange(prevProps);
    setTrackStyle && this.updateState(spec, setTrackStyle, () => {
      if (this.state.currentSlide >= React300.Children.count(this.props.children)) {
        this.changeSlide({
          message: "index",
          index: React300.Children.count(this.props.children) - this.props.slidesToShow,
          currentSlide: this.state.currentSlide
        });
      }
      if (prevProps.autoplay !== this.props.autoplay || prevProps.autoplaySpeed !== this.props.autoplaySpeed) {
        if (!prevProps.autoplay && this.props.autoplay) {
          this.autoPlay("playing");
        } else if (this.props.autoplay) {
          this.autoPlay("update");
        } else {
          this.pause("paused");
        }
      }
    });
  };
  onWindowResized = (setTrackStyle) => {
    if (this.debouncedResize)
      this.debouncedResize.cancel();
    this.debouncedResize = debounce(50, () => this.resizeWindow(setTrackStyle));
    this.debouncedResize();
  };
  resizeWindow = (setTrackStyle = true) => {
    const isTrackMounted = Boolean(this.track && this.track.node);
    if (!isTrackMounted)
      return;
    let spec = {
      listRef: this.list,
      trackRef: this.track,
      ...this.props,
      ...this.state
    };
    this.updateState(spec, setTrackStyle, () => {
      if (this.props.autoplay)
        this.autoPlay("update");
      else
        this.pause("paused");
    });
    this.setState({
      animating: false
    });
    clearTimeout(this.animationEndCallback);
    delete this.animationEndCallback;
  };
  updateState = (spec, setTrackStyle, callback) => {
    let updatedState = initializedState(spec);
    spec = { ...spec, ...updatedState, slideIndex: updatedState.currentSlide };
    let targetLeft = getTrackLeft(spec);
    spec = { ...spec, left: targetLeft };
    let trackStyle = getTrackCSS(spec);
    if (setTrackStyle || React300.Children.count(this.props.children) !== React300.Children.count(spec.children)) {
      updatedState["trackStyle"] = trackStyle;
    }
    this.setState(updatedState, callback);
  };
  ssrInit = () => {
    if (this.props.variableWidth) {
      let trackWidth2 = 0, trackLeft2 = 0;
      let childrenWidths = [];
      let preClones = getPreClones({
        ...this.props,
        ...this.state,
        slideCount: this.props.children.length
      });
      let postClones = getPostClones({
        ...this.props,
        ...this.state,
        slideCount: this.props.children.length
      });
      this.props.children.forEach((child) => {
        childrenWidths.push(child.props.style.width);
        trackWidth2 += child.props.style.width;
      });
      for (let i = 0; i < preClones; i++) {
        trackLeft2 += childrenWidths[childrenWidths.length - 1 - i];
        trackWidth2 += childrenWidths[childrenWidths.length - 1 - i];
      }
      for (let i = 0; i < postClones; i++) {
        trackWidth2 += childrenWidths[i];
      }
      for (let i = 0; i < this.state.currentSlide; i++) {
        trackLeft2 += childrenWidths[i];
      }
      let trackStyle2 = {
        width: trackWidth2 + "px",
        left: -trackLeft2 + "px"
      };
      if (this.props.centerMode) {
        let currentWidth = `${childrenWidths[this.state.currentSlide]}px`;
        trackStyle2.left = `calc(${trackStyle2.left} + (100% - ${currentWidth}) / 2 ) `;
      }
      return {
        trackStyle: trackStyle2
      };
    }
    let childrenCount = React300.Children.count(this.props.children);
    const spec = { ...this.props, ...this.state, slideCount: childrenCount };
    let slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
    let trackWidth = 100 / this.props.slidesToShow * slideCount;
    let slideWidth = 100 / slideCount;
    let trackLeft = -slideWidth * (getPreClones(spec) + this.state.currentSlide) * trackWidth / 100;
    if (this.props.centerMode) {
      trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
    }
    let trackStyle = {
      width: trackWidth + "%",
      left: trackLeft + "%"
    };
    return {
      slideWidth: slideWidth + "%",
      trackStyle
    };
  };
  checkImagesLoad = () => {
    let images = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [];
    let imagesCount = images.length, loadedCount = 0;
    Array.prototype.forEach.call(images, (image) => {
      const handler = /* @__PURE__ */ __name(() => ++loadedCount && loadedCount >= imagesCount && this.onWindowResized(), "handler");
      if (!image.onclick) {
        image.onclick = () => image.parentNode.focus();
      } else {
        const prevClickHandler = image.onclick;
        image.onclick = (e3) => {
          prevClickHandler(e3);
          image.parentNode.focus();
        };
      }
      if (!image.onload) {
        if (this.props.lazyLoad) {
          image.onload = () => {
            this.adaptHeight();
            this.callbackTimers.push(
              setTimeout(this.onWindowResized, this.props.speed)
            );
          };
        } else {
          image.onload = handler;
          image.onerror = () => {
            handler();
            this.props.onLazyLoadError && this.props.onLazyLoadError();
          };
        }
      }
    });
  };
  progressiveLazyLoad = () => {
    let slidesToLoad = [];
    const spec = { ...this.props, ...this.state };
    for (let index3 = this.state.currentSlide; index3 < this.state.slideCount + getPostClones(spec); index3++) {
      if (this.state.lazyLoadedList.indexOf(index3) < 0) {
        slidesToLoad.push(index3);
        break;
      }
    }
    for (let index3 = this.state.currentSlide - 1; index3 >= -getPreClones(spec); index3--) {
      if (this.state.lazyLoadedList.indexOf(index3) < 0) {
        slidesToLoad.push(index3);
        break;
      }
    }
    if (slidesToLoad.length > 0) {
      this.setState((state) => ({
        lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
      }));
      if (this.props.onLazyLoad) {
        this.props.onLazyLoad(slidesToLoad);
      }
    } else {
      if (this.lazyLoadTimer) {
        clearInterval(this.lazyLoadTimer);
        delete this.lazyLoadTimer;
      }
    }
  };
  slideHandler = (index3, dontAnimate = false) => {
    const { asNavFor, beforeChange, onLazyLoad, speed, afterChange } = this.props;
    const currentSlide = this.state.currentSlide;
    let { state, nextState } = slideHandler({
      index: index3,
      ...this.props,
      ...this.state,
      trackRef: this.track,
      useCSS: this.props.useCSS && !dontAnimate
    });
    if (!state)
      return;
    beforeChange && beforeChange(currentSlide, state.currentSlide);
    let slidesToLoad = state.lazyLoadedList.filter(
      (value) => this.state.lazyLoadedList.indexOf(value) < 0
    );
    onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
    if (!this.props.waitForAnimate && this.animationEndCallback) {
      clearTimeout(this.animationEndCallback);
      afterChange && afterChange(currentSlide);
      delete this.animationEndCallback;
    }
    this.setState(state, () => {
      if (asNavFor && this.asNavForIndex !== index3) {
        this.asNavForIndex = index3;
        asNavFor.innerSlider.slideHandler(index3);
      }
      if (!nextState)
        return;
      this.animationEndCallback = setTimeout(() => {
        const { animating, ...firstBatch } = nextState;
        this.setState(firstBatch, () => {
          this.callbackTimers.push(
            setTimeout(() => this.setState({ animating }), 10)
          );
          afterChange && afterChange(state.currentSlide);
          delete this.animationEndCallback;
        });
      }, speed);
    });
  };
  changeSlide = (options, dontAnimate = false) => {
    const spec = { ...this.props, ...this.state };
    let targetSlide = changeSlide(spec, options);
    if (targetSlide !== 0 && !targetSlide)
      return;
    if (dontAnimate === true) {
      this.slideHandler(targetSlide, dontAnimate);
    } else {
      this.slideHandler(targetSlide);
    }
    this.props.autoplay && this.autoPlay("update");
    if (this.props.focusOnSelect) {
      const nodes = this.list.querySelectorAll(".slick-current");
      nodes[0] && nodes[0].focus();
    }
  };
  clickHandler = (e3) => {
    if (this.clickable === false) {
      e3.stopPropagation();
      e3.preventDefault();
    }
    this.clickable = true;
  };
  keyHandler = (e3) => {
    let dir = keyHandler(e3, this.props.accessibility, this.props.rtl);
    dir !== "" && this.changeSlide({ message: dir });
  };
  selectHandler = (options) => {
    this.changeSlide(options);
  };
  disableBodyScroll = () => {
    const preventDefault = /* @__PURE__ */ __name((e3) => {
      e3 = e3 || window.event;
      if (e3.preventDefault)
        e3.preventDefault();
      e3.returnValue = false;
    }, "preventDefault");
    window.ontouchmove = preventDefault;
  };
  enableBodyScroll = () => {
    window.ontouchmove = null;
  };
  swipeStart = (e3) => {
    if (this.props.verticalSwiping) {
      this.disableBodyScroll();
    }
    let state = swipeStart(e3, this.props.swipe, this.props.draggable);
    state !== "" && this.setState(state);
  };
  swipeMove = (e3) => {
    let state = swipeMove(e3, {
      ...this.props,
      ...this.state,
      trackRef: this.track,
      listRef: this.list,
      slideIndex: this.state.currentSlide
    });
    if (!state)
      return;
    if (state["swiping"]) {
      this.clickable = false;
    }
    this.setState(state);
  };
  swipeEnd = (e3) => {
    let state = swipeEnd(e3, {
      ...this.props,
      ...this.state,
      trackRef: this.track,
      listRef: this.list,
      slideIndex: this.state.currentSlide
    });
    if (!state)
      return;
    let triggerSlideHandler = state["triggerSlideHandler"];
    delete state["triggerSlideHandler"];
    this.setState(state);
    if (triggerSlideHandler === void 0)
      return;
    this.slideHandler(triggerSlideHandler);
    if (this.props.verticalSwiping) {
      this.enableBodyScroll();
    }
  };
  touchEnd = (e3) => {
    this.swipeEnd(e3);
    this.clickable = true;
  };
  slickPrev = () => {
    this.callbackTimers.push(
      setTimeout(() => this.changeSlide({ message: "previous" }), 0)
    );
  };
  slickNext = () => {
    this.callbackTimers.push(
      setTimeout(() => this.changeSlide({ message: "next" }), 0)
    );
  };
  slickGoTo = (slide, dontAnimate = false) => {
    slide = Number(slide);
    if (isNaN(slide))
      return "";
    this.callbackTimers.push(
      setTimeout(
        () => this.changeSlide(
          {
            message: "index",
            index: slide,
            currentSlide: this.state.currentSlide
          },
          dontAnimate
        ),
        0
      )
    );
  };
  play = () => {
    var nextIndex;
    if (this.props.rtl) {
      nextIndex = this.state.currentSlide - this.props.slidesToScroll;
    } else {
      if (canGoNext({ ...this.props, ...this.state })) {
        nextIndex = this.state.currentSlide + this.props.slidesToScroll;
      } else {
        return false;
      }
    }
    this.slideHandler(nextIndex);
  };
  autoPlay = (playType) => {
    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
    }
    const autoplaying = this.state.autoplaying;
    if (playType === "update") {
      if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
        return;
      }
    } else if (playType === "leave") {
      if (autoplaying === "paused" || autoplaying === "focused") {
        return;
      }
    } else if (playType === "blur") {
      if (autoplaying === "paused" || autoplaying === "hovered") {
        return;
      }
    }
    this.autoplayTimer = setInterval(this.play, this.props.autoplaySpeed + 50);
    this.setState({ autoplaying: "playing" });
  };
  pause = (pauseType) => {
    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
      this.autoplayTimer = null;
    }
    const autoplaying = this.state.autoplaying;
    if (pauseType === "paused") {
      this.setState({ autoplaying: "paused" });
    } else if (pauseType === "focused") {
      if (autoplaying === "hovered" || autoplaying === "playing") {
        this.setState({ autoplaying: "focused" });
      }
    } else {
      if (autoplaying === "playing") {
        this.setState({ autoplaying: "hovered" });
      }
    }
  };
  onDotsOver = () => this.props.autoplay && this.pause("hovered");
  onDotsLeave = () => this.props.autoplay && this.state.autoplaying === "hovered" && this.autoPlay("leave");
  onTrackOver = () => this.props.autoplay && this.pause("hovered");
  onTrackLeave = () => this.props.autoplay && this.state.autoplaying === "hovered" && this.autoPlay("leave");
  onSlideFocus = () => this.props.autoplay && this.pause("focused");
  onSlideBlur = () => this.props.autoplay && this.state.autoplaying === "focused" && this.autoPlay("blur");
  render = () => {
    var className = (0, import_classnames115.default)("slick-slider", this.props.className, {
      "slick-vertical": this.props.vertical,
      "slick-initialized": true
    });
    let spec = { ...this.props, ...this.state };
    let trackProps = extractObject(spec, [
      "fade",
      "cssEase",
      "speed",
      "infinite",
      "centerMode",
      "focusOnSelect",
      "currentSlide",
      "lazyLoad",
      "lazyLoadedList",
      "rtl",
      "slideWidth",
      "slideHeight",
      "listHeight",
      "vertical",
      "slidesToShow",
      "slidesToScroll",
      "slideCount",
      "trackStyle",
      "variableWidth",
      "unslick",
      "centerPadding",
      "targetSlide",
      "useCSS"
    ]);
    const { pauseOnHover } = this.props;
    trackProps = {
      ...trackProps,
      onMouseEnter: pauseOnHover ? this.onTrackOver : null,
      onMouseLeave: pauseOnHover ? this.onTrackLeave : null,
      onMouseOver: pauseOnHover ? this.onTrackOver : null,
      focusOnSelect: this.props.focusOnSelect && this.clickable ? this.selectHandler : null
    };
    var dots;
    if (this.props.dots === true && this.state.slideCount >= this.props.slidesToShow) {
      let dotProps = extractObject(spec, [
        "dotsClass",
        "slideCount",
        "slidesToShow",
        "currentSlide",
        "slidesToScroll",
        "clickHandler",
        "children",
        "customPaging",
        "infinite",
        "appendDots"
      ]);
      const { pauseOnDotsHover } = this.props;
      dotProps = {
        ...dotProps,
        clickHandler: this.changeSlide,
        onMouseEnter: pauseOnDotsHover ? this.onDotsLeave : null,
        onMouseOver: pauseOnDotsHover ? this.onDotsOver : null,
        onMouseLeave: pauseOnDotsHover ? this.onDotsLeave : null
      };
      dots = /* @__PURE__ */ React300.createElement(Dots, { ...dotProps });
    }
    var prevArrow, nextArrow;
    let arrowProps = extractObject(spec, [
      "infinite",
      "centerMode",
      "currentSlide",
      "slideCount",
      "slidesToShow",
      "prevArrow",
      "nextArrow"
    ]);
    arrowProps.clickHandler = this.changeSlide;
    if (this.props.arrows) {
      prevArrow = /* @__PURE__ */ React300.createElement(PrevArrow, { ...arrowProps });
      nextArrow = /* @__PURE__ */ React300.createElement(NextArrow, { ...arrowProps });
    }
    var verticalHeightStyle = null;
    if (this.props.vertical) {
      verticalHeightStyle = {
        height: this.state.listHeight
      };
    }
    var centerPaddingStyle = null;
    if (this.props.vertical === false) {
      if (this.props.centerMode === true) {
        centerPaddingStyle = {
          padding: "0px " + this.props.centerPadding
        };
      }
    } else {
      if (this.props.centerMode === true) {
        centerPaddingStyle = {
          padding: this.props.centerPadding + " 0px"
        };
      }
    }
    const listStyle = { ...verticalHeightStyle, ...centerPaddingStyle };
    const touchMove = this.props.touchMove;
    let listProps = {
      className: "slick-list",
      style: listStyle,
      onClick: this.clickHandler,
      onMouseDown: touchMove ? this.swipeStart : null,
      onMouseMove: this.state.dragging && touchMove ? this.swipeMove : null,
      onMouseUp: touchMove ? this.swipeEnd : null,
      onMouseLeave: this.state.dragging && touchMove ? this.swipeEnd : null,
      onTouchStart: touchMove ? this.swipeStart : null,
      onTouchMove: this.state.dragging && touchMove ? this.swipeMove : null,
      onTouchEnd: touchMove ? this.touchEnd : null,
      onTouchCancel: this.state.dragging && touchMove ? this.swipeEnd : null,
      onKeyDown: this.props.accessibility ? this.keyHandler : null
    };
    let innerSliderProps = {
      className,
      dir: "ltr",
      style: this.props.style
    };
    if (this.props.unslick) {
      listProps = { className: "slick-list" };
      innerSliderProps = { className, style: this.props.style };
    }
    return /* @__PURE__ */ React300.createElement("div", { ...innerSliderProps }, !this.props.unslick ? prevArrow : "", /* @__PURE__ */ React300.createElement("div", { ref: this.listRefHandler, ...listProps }, /* @__PURE__ */ React300.createElement(Track, { ref: this.trackRefHandler, ...trackProps }, this.props.children)), !this.props.unslick ? nextArrow : "", !this.props.unslick ? dots : "");
  };
};

// packages/react-slick/src/slider.js
var import_json2mq = __toESM(require_json2mq());
var Slider = class extends React301.Component {
  static {
    __name(this, "Slider");
  }
  constructor(props) {
    super(props);
    this.state = {
      breakpoint: null
    };
    this._responsiveMediaHandlers = [];
  }
  innerSliderRefHandler = (ref) => this.innerSlider = ref;
  media(query, handler) {
    const mql = window.matchMedia(query);
    const listener = /* @__PURE__ */ __name(({ matches }) => {
      if (matches) {
        handler();
      }
    }, "listener");
    mql.addListener(listener);
    listener(mql);
    this._responsiveMediaHandlers.push({ mql, query, listener });
  }
  // handles responsive breakpoints
  componentDidMount() {
    if (this.props.responsive) {
      let breakpoints = this.props.responsive.map(
        (breakpt) => breakpt.breakpoint
      );
      breakpoints.sort((x, y) => x - y);
      breakpoints.forEach((breakpoint, index3) => {
        let bQuery;
        if (index3 === 0) {
          bQuery = (0, import_json2mq.default)({ minWidth: 0, maxWidth: breakpoint });
        } else {
          bQuery = (0, import_json2mq.default)({
            minWidth: breakpoints[index3 - 1] + 1,
            maxWidth: breakpoint
          });
        }
        canUseDOM() && this.media(bQuery, () => {
          this.setState({ breakpoint });
        });
      });
      let query = (0, import_json2mq.default)({ minWidth: breakpoints.slice(-1)[0] });
      canUseDOM() && this.media(query, () => {
        this.setState({ breakpoint: null });
      });
    }
  }
  componentWillUnmount() {
    this._responsiveMediaHandlers.forEach(function(obj) {
      obj.mql.removeListener(obj.listener);
    });
  }
  slickPrev = () => this.innerSlider.slickPrev();
  slickNext = () => this.innerSlider.slickNext();
  slickGoTo = (slide, dontAnimate = false) => this.innerSlider.slickGoTo(slide, dontAnimate);
  slickPause = () => this.innerSlider.pause("paused");
  slickPlay = () => this.innerSlider.autoPlay("play");
  render() {
    var settings;
    var newProps;
    if (this.state.breakpoint) {
      newProps = this.props.responsive.filter(
        (resp) => resp.breakpoint === this.state.breakpoint
      );
      settings = newProps[0].settings === "unslick" ? "unslick" : { ...default_props_default, ...this.props, ...newProps[0].settings };
    } else {
      settings = { ...default_props_default, ...this.props };
    }
    if (settings.centerMode) {
      if (settings.slidesToScroll > 1 && true) {
        console.warn(
          `slidesToScroll should be equal to 1 in centerMode, you are using ${settings.slidesToScroll}`
        );
      }
      settings.slidesToScroll = 1;
    }
    if (settings.fade) {
      if (settings.slidesToShow > 1 && true) {
        console.warn(
          `slidesToShow should be equal to 1 when fade is true, you're using ${settings.slidesToShow}`
        );
      }
      if (settings.slidesToScroll > 1 && true) {
        console.warn(
          `slidesToScroll should be equal to 1 when fade is true, you're using ${settings.slidesToScroll}`
        );
      }
      settings.slidesToShow = 1;
      settings.slidesToScroll = 1;
    }
    let children = React301.Children.toArray(this.props.children);
    children = children.filter((child) => {
      if (typeof child === "string") {
        return !!child.trim();
      }
      return !!child;
    });
    if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
      console.warn(
        `variableWidth is not supported in case of rows > 1 or slidesPerRow > 1`
      );
      settings.variableWidth = false;
    }
    let newChildren = [];
    let currentWidth = null;
    for (let i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
      let newSlide = [];
      for (let j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
        let row = [];
        for (let k = j; k < j + settings.slidesPerRow; k += 1) {
          if (settings.variableWidth && children[k].props.style) {
            currentWidth = children[k].props.style.width;
          }
          if (k >= children.length)
            break;
          row.push(
            React301.cloneElement(children[k], {
              key: 100 * i + 10 * j + k,
              tabIndex: -1,
              style: {
                width: `${100 / settings.slidesPerRow}%`,
                display: "inline-block"
              }
            })
          );
        }
        newSlide.push(/* @__PURE__ */ React301.createElement("div", { key: 10 * i + j }, row));
      }
      if (settings.variableWidth) {
        newChildren.push(
          /* @__PURE__ */ React301.createElement("div", { key: i, style: { width: currentWidth } }, newSlide)
        );
      } else {
        newChildren.push(/* @__PURE__ */ React301.createElement("div", { key: i }, newSlide));
      }
    }
    if (settings === "unslick") {
      const className = "regular slider " + (this.props.className || "");
      return /* @__PURE__ */ React301.createElement("div", { className }, children);
    } else if (newChildren.length <= settings.slidesToShow && !settings.infinite) {
      settings.unslick = true;
    }
    return /* @__PURE__ */ React301.createElement(
      InnerSlider,
      {
        style: this.props.style,
        ref: this.innerSliderRefHandler,
        ...filterSettings(settings)
      },
      newChildren
    );
  }
};

// packages/react-slick/src/index.js
var src_default13 = Slider;

// packages/ant-design/components/carousel/index.tsx
var import_classnames116 = __toESM(require_classnames());

// packages/ant-design/components/carousel/style/index.ts
var genCarouselStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls, carouselArrowSize, carouselDotOffset, marginXXS } = token2;
  const arrowOffset = token2.calc(carouselArrowSize).mul(-1.25).equal();
  const carouselDotMargin = marginXXS;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: carouselArrowSize,
        height: carouselArrowSize,
        marginTop: token2.calc(carouselArrowSize).mul(-1).div(2).equal(),
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::before": {
          content: '"\u2190"'
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::before": {
          content: '"\u2192"'
        }
      },
      // Dots
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        margin: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: carouselDotOffset
        },
        "&-top": {
          top: carouselDotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: token2.dotWidth,
          height: token2.dotHeight,
          marginInline: carouselDotMargin,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${token2.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: token2.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: token2.colorBgContainer,
            border: 0,
            borderRadius: token2.dotHeight,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${token2.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: token2.calc(carouselDotMargin).mul(-1).equal(),
              content: '""'
            }
          },
          "&.slick-active": {
            width: token2.dotActiveWidth,
            "& button": {
              background: token2.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    }
  };
}, "genCarouselStyle");
var genCarouselVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, carouselDotOffset, marginXXS } = token2;
  const reverseSizeOfDot = {
    width: token2.dotHeight,
    height: token2.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token2.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: carouselDotOffset
        },
        "&-right": {
          insetInlineEnd: carouselDotOffset,
          insetInlineStart: "auto"
        },
        li: {
          // reverse width and height in vertical situation
          ...reverseSizeOfDot,
          margin: `${unit(marginXXS)} 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&.slick-active": {
            ...reverseSizeOfDot,
            button: reverseSizeOfDot
          }
        }
      }
    }
  };
}, "genCarouselVerticalStyle");
var genCarouselRtlStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return [
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl",
        // Dots
        ".slick-dots": {
          [`${componentCls}-rtl&`]: {
            flexDirection: "row-reverse"
          }
        }
      }
    },
    {
      [`${componentCls}-vertical`]: {
        ".slick-dots": {
          [`${componentCls}-rtl&`]: {
            flexDirection: "column"
          }
        }
      }
    }
  ];
}, "genCarouselRtlStyle");
var prepareComponentToken24 = /* @__PURE__ */ __name(() => {
  const dotActiveWidth = 24;
  return {
    dotWidth: 16,
    dotHeight: 3,
    dotWidthActive: dotActiveWidth,
    dotActiveWidth
  };
}, "prepareComponentToken");
var style_default28 = genStyleHooks(
  "Carousel",
  (token2) => {
    const { controlHeightLG, controlHeightSM } = token2;
    const carouselToken = merge2(token2, {
      carouselArrowSize: token2.calc(controlHeightLG).div(2).equal(),
      carouselDotOffset: token2.calc(controlHeightSM).div(2).equal()
    });
    return [
      genCarouselStyle(carouselToken),
      genCarouselVerticalStyle(carouselToken),
      genCarouselRtlStyle(carouselToken)
    ];
  },
  prepareComponentToken24,
  {
    deprecatedTokens: [["dotWidthActive", "dotActiveWidth"]]
  }
);

// packages/ant-design/components/carousel/index.tsx
var Carousel = React302.forwardRef((props, ref) => {
  const {
    dots = true,
    arrows = false,
    draggable = false,
    waitForAnimate = false,
    dotPosition = "bottom",
    vertical = dotPosition === "left" || dotPosition === "right",
    rootClassName,
    className: customClassName,
    style: style2,
    id,
    ...otherProps
  } = props;
  const { getPrefixCls, direction, carousel } = React302.useContext(ConfigContext);
  const slickRef = React302.useRef();
  const goTo = /* @__PURE__ */ __name((slide, dontAnimate = false) => {
    slickRef.current.slickGoTo(slide, dontAnimate);
  }, "goTo");
  React302.useImperativeHandle(
    ref,
    () => ({
      goTo,
      autoPlay: slickRef.current.innerSlider.autoPlay,
      innerSlider: slickRef.current.innerSlider,
      prev: slickRef.current.slickPrev,
      next: slickRef.current.slickNext
    }),
    [slickRef.current]
  );
  const prevCount = React302.useRef(React302.Children.count(props.children));
  React302.useEffect(() => {
    if (prevCount.current !== React302.Children.count(props.children)) {
      goTo(props.initialSlide || 0, false);
      prevCount.current = React302.Children.count(props.children);
    }
  }, [props.children]);
  const newProps = {
    vertical,
    className: (0, import_classnames116.default)(customClassName, carousel?.className),
    style: { ...carousel?.style, ...style2 },
    ...otherProps
  };
  if (newProps.effect === "fade") {
    newProps.fade = true;
  }
  const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
  const dotsClass = "slick-dots";
  const enableDots = !!dots;
  const dsClass = (0, import_classnames116.default)(
    dotsClass,
    `${dotsClass}-${dotPosition}`,
    typeof dots === "boolean" ? false : dots?.className
  );
  const [wrapCSSVar, hashId, cssVarCls] = style_default28(prefixCls);
  const className = (0, import_classnames116.default)(
    prefixCls,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-vertical`]: newProps.vertical
    },
    hashId,
    cssVarCls,
    rootClassName
  );
  return wrapCSSVar(
    /* @__PURE__ */ React302.createElement("div", { className, id }, /* @__PURE__ */ React302.createElement(
      src_default13,
      {
        ref: slickRef,
        ...newProps,
        dots: enableDots,
        dotsClass: dsClass,
        arrows,
        draggable,
        verticalSwiping: vertical,
        waitForAnimate
      }
    ))
  );
});
if (true) {
  Carousel.displayName = "Carousel";
}
var carousel_default = Carousel;

// packages/ant-design/components/cascader/index.tsx
var import_classnames122 = __toESM(require_classnames());
import * as React324 from "react";

// packages/cascader/src/Cascader.tsx
import * as React319 from "react";

// packages/cascader/src/context.ts
import * as React303 from "react";
var CascaderContext = React303.createContext({});
var context_default8 = CascaderContext;

// packages/cascader/src/hooks/useSearchOptions.ts
import * as React304 from "react";
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = /* @__PURE__ */ __name((search, options, { label = "" }) => options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase())), "defaultFilter");
var defaultRender = /* @__PURE__ */ __name((inputValue, path2, prefixCls, fieldNames) => path2.map((opt) => opt[fieldNames.label]).join(" / "), "defaultRender");
var useSearchOptions_default = /* @__PURE__ */ __name((search, options, fieldNames, prefixCls, config, changeOnSelect) => {
  const { filter: filter3 = defaultFilter, render: render2 = defaultRender, limit = 50, sort } = config;
  return React304.useMemo(() => {
    const filteredOptions = [];
    if (!search) {
      return [];
    }
    function dig(list, pathOptions, parentDisabled = false) {
      list.forEach((option) => {
        if (!sort && limit !== false && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.children];
        const mergedDisabled = parentDisabled || option.disabled;
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect
          changeOnSelect
        ) {
          if (filter3(search, connectedPathOptions, { label: fieldNames.label })) {
            filteredOptions.push({
              ...option,
              disabled: mergedDisabled,
              [fieldNames.label]: render2(
                search,
                connectedPathOptions,
                prefixCls,
                fieldNames
              ),
              [SEARCH_MARK]: connectedPathOptions,
              [fieldNames.children]: void 0
            });
          }
        }
        if (children) {
          dig(
            option[fieldNames.children],
            connectedPathOptions,
            mergedDisabled
          );
        }
      });
    }
    __name(dig, "dig");
    dig(options, []);
    if (sort) {
      filteredOptions.sort((a, b) => {
        return sort(a[SEARCH_MARK], b[SEARCH_MARK], search, fieldNames);
      });
    }
    return limit !== false && limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  }, [search, options, fieldNames, prefixCls, render2, changeOnSelect, filter3, sort, limit]);
}, "default");

// packages/cascader/src/utils/commonUtil.ts
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
__name(toPathKey, "toPathKey");
function toPathKeys(value) {
  return value.map(toPathKey);
}
__name(toPathKeys, "toPathKeys");
function toPathValueStr(pathKey2) {
  return pathKey2.split(VALUE_SPLIT);
}
__name(toPathValueStr, "toPathValueStr");
function fillFieldNames2(fieldNames) {
  const { label, value, children } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
__name(fillFieldNames2, "fillFieldNames");
function isLeaf(option, fieldNames) {
  return option.isLeaf ?? !option[fieldNames.children]?.length;
}
__name(isLeaf, "isLeaf");
function scrollIntoParentView(element) {
  const parent = element.parentElement;
  if (!parent) {
    return;
  }
  const elementToParent = element.offsetTop - parent.offsetTop;
  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({ top: elementToParent });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({ top: elementToParent + element.offsetHeight - parent.offsetHeight });
  }
}
__name(scrollIntoParentView, "scrollIntoParentView");
function getFullPathKeys(options, fieldNames) {
  return options.map(
    (item) => item[SEARCH_MARK]?.map((opt) => opt[fieldNames.value])
  );
}
__name(getFullPathKeys, "getFullPathKeys");
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
__name(isMultipleValue, "isMultipleValue");
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}
__name(toRawValues, "toRawValues");

// packages/cascader/src/utils/treeUtil.ts
function formatStrategyValues(pathKeys, getKeyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  const keyPathEntities = getKeyPathEntities();
  return pathKeys.filter((key) => {
    const entity = keyPathEntities[key];
    const parent = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    if (entity && entity.node.disabled) {
      return true;
    }
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
  });
}
__name(formatStrategyValues, "formatStrategyValues");
function toPathOptions(valueCells, options, fieldNames, stringMode = false) {
  let currentList = options;
  const valueOptions = [];
  for (let i = 0; i < valueCells.length; i += 1) {
    const valueCell = valueCells[i];
    const foundIndex = currentList?.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList?.[foundIndex] : null;
    valueOptions.push({
      value: foundOption?.[fieldNames.value] ?? valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption?.[fieldNames.children];
  }
  return valueOptions;
}
__name(toPathOptions, "toPathOptions");

// packages/cascader/src/hooks/useDisplayValues.ts
import * as React305 from "react";
var useDisplayValues_default = /* @__PURE__ */ __name((rawValues, options, fieldNames, multiple, displayRender) => {
  return React305.useMemo(() => {
    const mergedDisplayRender = displayRender || // Default displayRender
    ((labels) => {
      const mergedLabels = multiple ? labels.slice(-1) : labels;
      const SPLIT3 = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT3);
      }
      return mergedLabels.reduce((list, label, index3) => {
        const keyedLabel = React305.isValidElement(label) ? React305.cloneElement(label, { key: index3 }) : label;
        if (index3 === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT3, keyedLabel];
      }, []);
    });
    return rawValues.map((valueCells) => {
      const valueOptions = toPathOptions(valueCells, options, fieldNames);
      const label = mergedDisplayRender(
        valueOptions.map(({ option, value: value2 }) => option?.[fieldNames.label] ?? value2),
        valueOptions.map(({ option }) => option)
      );
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells,
        disabled: valueOptions[valueOptions.length - 1]?.option?.disabled
      };
    });
  }, [rawValues, options, fieldNames, displayRender, multiple]);
}, "default");

// packages/cascader/src/hooks/useMissingValues.ts
import * as React306 from "react";
function useMissingValues(options, fieldNames) {
  return React306.useCallback(
    (rawValues) => {
      const missingValues = [];
      const existsValues = [];
      rawValues.forEach((valueCell) => {
        const pathOptions = toPathOptions(valueCell, options, fieldNames);
        if (pathOptions.every((opt) => opt.option)) {
          existsValues.push(valueCell);
        } else {
          missingValues.push(valueCell);
        }
      });
      return [existsValues, missingValues];
    },
    [options, fieldNames]
  );
}
__name(useMissingValues, "useMissingValues");

// packages/cascader/src/hooks/useOptions.ts
import * as React308 from "react";

// packages/cascader/src/hooks/useEntities.ts
import * as React307 from "react";

// packages/tree/src/utils/treeUtil.ts
init_warning();

// packages/tree/src/utils/keyUtil.ts
function getEntity(keyEntities, key) {
  return keyEntities[key];
}
__name(getEntity, "getEntity");

// packages/tree/src/utils/treeUtil.ts
function getPosition(level, index3) {
  return `${level}-${index3}`;
}
__name(getPosition, "getPosition");
function isTreeNode(node2) {
  return node2 && node2.type && node2.type.isTreeNode;
}
__name(isTreeNode, "isTreeNode");
function getKey3(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
__name(getKey3, "getKey");
function fillFieldNames3(fieldNames) {
  const { title, _title, key, children } = fieldNames || {};
  const mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || "key",
    children: children || "children"
  };
}
__name(fillFieldNames3, "fillFieldNames");
function warningWithoutKey(treeData, fieldNames) {
  const keys2 = /* @__PURE__ */ new Map();
  function dig(list, path2 = "") {
    (list || []).forEach((treeNode) => {
      const key = treeNode[fieldNames.key];
      const children = treeNode[fieldNames.children];
      warning_default(
        key !== null && key !== void 0,
        `Tree node must have a certain key: [${path2}${key}]`
      );
      const recordKey = String(key);
      warning_default(
        !keys2.has(recordKey) || key === null || key === void 0,
        `Same 'key' exist in the Tree: ${recordKey}`
      );
      keys2.set(recordKey, true);
      dig(children, `${path2}${recordKey} > `);
    });
  }
  __name(dig, "dig");
  dig(treeData);
}
__name(warningWithoutKey, "warningWithoutKey");
function convertTreeToData(rootNodes) {
  function dig(node2) {
    const treeNodes = toArray(node2);
    return treeNodes.map((treeNode) => {
      if (!isTreeNode(treeNode)) {
        warning_default(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      const { key } = treeNode;
      const { children, ...rest } = treeNode.props;
      const dataNode = {
        key,
        ...rest
      };
      const parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter((dataNode) => dataNode);
  }
  __name(dig, "dig");
  return dig(rootNodes);
}
__name(convertTreeToData, "convertTreeToData");
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  const {
    _title: fieldTitles,
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames3(fieldNames);
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list, parent = null) {
    return list.map((treeNode, index3) => {
      const pos = getPosition(parent ? parent.pos : "0", index3);
      const mergedKey = getKey3(treeNode[fieldKey], pos);
      let mergedTitle;
      for (let i = 0; i < fieldTitles.length; i += 1) {
        const fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      const flattenNode = {
        ...omit(treeNode, [...fieldTitles, fieldKey, fieldChildren]),
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [...parent ? parent.isStart : [], index3 === 0],
        isEnd: [...parent ? parent.isEnd : [], index3 === list.length - 1]
      };
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  __name(dig, "dig");
  dig(treeNodeList);
  return flattenList;
}
__name(flattenTreeData, "flattenTreeData");
function traverseDataNodes(dataNodes, callback, config) {
  let mergedConfig = {};
  if (typeof config === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = { externalGetKey: config };
  }
  mergedConfig = mergedConfig || {};
  const { childrenPropName, externalGetKey, fieldNames } = mergedConfig;
  const { key: fieldKey, children: fieldChildren } = fillFieldNames3(fieldNames);
  const mergeChildrenPropName = childrenPropName || fieldChildren;
  let syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = /* @__PURE__ */ __name((node2) => node2[externalGetKey], "syntheticGetKey");
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = /* @__PURE__ */ __name((node2) => externalGetKey(node2), "syntheticGetKey");
    }
  } else {
    syntheticGetKey = /* @__PURE__ */ __name((node2, pos) => getKey3(node2[fieldKey], pos), "syntheticGetKey");
  }
  function processNode(node2, index3, parent, pathNodes) {
    const children = node2 ? node2[mergeChildrenPropName] : dataNodes;
    const pos = node2 ? getPosition(parent.pos, index3) : "0";
    const connectNodes = node2 ? [...pathNodes, node2] : [];
    if (node2) {
      const key = syntheticGetKey(node2, pos);
      const data = {
        node: node2,
        index: index3,
        pos,
        key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    if (children) {
      children.forEach((subNode, subIndex) => {
        processNode(
          subNode,
          subIndex,
          {
            node: node2,
            pos,
            level: parent ? parent.level + 1 : -1
          },
          connectNodes
        );
      });
    }
  }
  __name(processNode, "processNode");
  processNode(null);
}
__name(traverseDataNodes, "traverseDataNodes");
function convertDataToEntities(dataNodes, {
  initWrapper,
  processEntity,
  onProcessFinished,
  externalGetKey,
  childrenPropName,
  fieldNames
} = {}, legacyExternalGetKey) {
  const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  const posEntities = {};
  const keyEntities = {};
  let wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(
    dataNodes,
    (item) => {
      const { node: node2, index: index3, pos, key, parentPos, level, nodes } = item;
      const entity = { node: node2, nodes, index: index3, key, pos, level };
      const mergedKey = getKey3(key, pos);
      posEntities[pos] = entity;
      keyEntities[mergedKey] = entity;
      entity.parent = posEntities[parentPos];
      if (entity.parent) {
        entity.parent.children = entity.parent.children || [];
        entity.parent.children.push(entity);
      }
      if (processEntity) {
        processEntity(entity, wrapper);
      }
    },
    { externalGetKey: mergedExternalGetKey, childrenPropName, fieldNames }
  );
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
__name(convertDataToEntities, "convertDataToEntities");
function getTreeNodeProps(key, {
  expandedKeys,
  selectedKeys,
  loadedKeys,
  loadingKeys,
  checkedKeys,
  halfCheckedKeys,
  dragOverNodeKey,
  dropPosition,
  keyEntities
}) {
  const entity = getEntity(keyEntities, key);
  const treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ""),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
__name(getTreeNodeProps, "getTreeNodeProps");
function convertNodePropsToEventData(props) {
  const {
    data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey
  } = props;
  const eventData = {
    ...data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  };
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get() {
        warning_default(
          false,
          "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."
        );
        return props;
      }
    });
  }
  return eventData;
}
__name(convertNodePropsToEventData, "convertNodePropsToEventData");

// packages/cascader/src/hooks/useEntities.ts
var useEntities_default = /* @__PURE__ */ __name((options, fieldNames) => {
  const cacheRef = React307.useRef({
    options: [],
    info: { keyEntities: {}, pathKeyEntities: {} }
  });
  const getEntities = React307.useCallback(() => {
    if (cacheRef.current.options !== options) {
      cacheRef.current.options = options;
      cacheRef.current.info = convertDataToEntities(options, {
        fieldNames,
        initWrapper: (wrapper) => ({
          ...wrapper,
          pathKeyEntities: {}
        }),
        processEntity: (entity, wrapper) => {
          const pathKey2 = entity.nodes.map((node2) => node2[fieldNames.value]).join(VALUE_SPLIT);
          wrapper.pathKeyEntities[pathKey2] = entity;
          entity.key = pathKey2;
        }
      });
    }
    return cacheRef.current.info.pathKeyEntities;
  }, [fieldNames, options]);
  return getEntities;
}, "default");

// packages/cascader/src/hooks/useOptions.ts
function useOptions2(mergedFieldNames, options) {
  const mergedOptions = React308.useMemo(() => options || [], [options]);
  const getPathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
  const getValueByKeyPath = React308.useCallback(
    (pathKeys) => {
      const keyPathEntities = getPathKeyEntities();
      return pathKeys.map((pathKey2) => {
        const { nodes } = keyPathEntities[pathKey2];
        return nodes.map((node2) => node2[mergedFieldNames.value]);
      });
    },
    [getPathKeyEntities, mergedFieldNames]
  );
  return [mergedOptions, getPathKeyEntities, getValueByKeyPath];
}
__name(useOptions2, "useOptions");

// packages/cascader/src/hooks/useSearchConfig.ts
init_warning();
import * as React309 from "react";
function useSearchConfig(showSearch) {
  return React309.useMemo(() => {
    if (!showSearch) {
      return [false, {}];
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50
    };
    if (showSearch && typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    if (searchConfig.limit <= 0) {
      delete searchConfig.limit;
      if (true) {
        warning_default(false, "'limit' of showSearch should be positive number or false.");
      }
    }
    return [true, searchConfig];
  }, [showSearch]);
}
__name(useSearchConfig, "useSearchConfig");

// packages/tree/src/utils/conductUtil.ts
init_warning();
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  const filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach((key) => {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
__name(removeFromCheckedKeys, "removeFromCheckedKeys");
function isCheckDisabled(node2) {
  const { disabled, disableCheckbox, checkable } = node2 || {};
  return !!(disabled || disableCheckbox) || checkable === false;
}
__name(isCheckDisabled, "isCheckDisabled");
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  const halfCheckedKeys = /* @__PURE__ */ new Set();
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const { key, node: node2, children = [] } = entity;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const { parent, node: node2 } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({ key }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
__name(fillConductCheck, "fillConductCheck");
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  let halfCheckedKeys = new Set(halfKeys);
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const { key, node: node2, children = [] } = entity;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const { parent, node: node2 } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({ key }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
__name(cleanConductCheck, "cleanConductCheck");
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  const warningMissKeys = [];
  let syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  const keys2 = new Set(
    keyList.filter((key) => {
      const hasEntity = !!getEntity(keyEntities, key);
      if (!hasEntity) {
        warningMissKeys.push(key);
      }
      return hasEntity;
    })
  );
  const levelEntities = /* @__PURE__ */ new Map();
  let maxLevel = 0;
  Object.keys(keyEntities).forEach((key) => {
    const entity = keyEntities[key];
    const { level } = entity;
    let levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warning_default(
    !warningMissKeys.length,
    `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map((key) => `'${key}'`).join(", ")}`
  );
  let result;
  if (checked === true) {
    result = fillConductCheck(
      keys2,
      levelEntities,
      maxLevel,
      syntheticGetCheckDisabled
    );
  } else {
    result = cleanConductCheck(
      keys2,
      checked.halfCheckedKeys,
      levelEntities,
      maxLevel,
      syntheticGetCheckDisabled
    );
  }
  return result;
}
__name(conductCheck, "conductCheck");

// packages/cascader/src/hooks/useSelect.ts
function useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy) {
  return (valuePath) => {
    if (!multiple) {
      triggerChange(valuePath);
    } else {
      const pathKey2 = toPathKey(valuePath);
      const checkedPathKeys = toPathKeys(checkedValues);
      const halfCheckedPathKeys = toPathKeys(halfCheckedValues);
      const existInChecked = checkedPathKeys.includes(pathKey2);
      const existInMissing = missingCheckedValues.some(
        (valueCells) => toPathKey(valueCells) === pathKey2
      );
      let nextCheckedValues = checkedValues;
      let nextMissingValues = missingCheckedValues;
      if (existInMissing && !existInChecked) {
        nextMissingValues = missingCheckedValues.filter(
          (valueCells) => toPathKey(valueCells) !== pathKey2
        );
      } else {
        const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey2) : [...checkedPathKeys, pathKey2];
        const pathKeyEntities = getPathKeyEntities();
        let checkedKeys;
        if (existInChecked) {
          ({ checkedKeys } = conductCheck(
            nextRawCheckedKeys,
            { checked: false, halfCheckedKeys: halfCheckedPathKeys },
            pathKeyEntities
          ));
        } else {
          ({ checkedKeys } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities));
        }
        const deDuplicatedKeys = formatStrategyValues(
          checkedKeys,
          getPathKeyEntities,
          showCheckedStrategy
        );
        nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
      }
      triggerChange([...nextMissingValues, ...nextCheckedValues]);
    }
  };
}
__name(useSelect, "useSelect");

// packages/cascader/src/hooks/useValues.ts
import * as React310 from "react";
function useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues) {
  return React310.useMemo(() => {
    const [existValues, missingValues] = getMissingValues(rawValues);
    if (!multiple || !rawValues.length) {
      return [existValues, [], missingValues];
    }
    const keyPathValues = toPathKeys(existValues);
    const keyPathEntities = getPathKeyEntities();
    const { checkedKeys, halfCheckedKeys } = conductCheck(keyPathValues, true, keyPathEntities);
    return [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
  }, [multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues]);
}
__name(useValues, "useValues");

// packages/cascader/src/OptionList/index.tsx
import * as React317 from "react";

// packages/cascader/src/OptionList/List.tsx
var import_classnames119 = __toESM(require_classnames());
import * as React316 from "react";

// packages/cascader/src/OptionList/CacheContent.tsx
import * as React311 from "react";
var CacheContent = React311.memo(
  ({ children }) => children,
  (_, next2) => !next2.open
);
if (true) {
  CacheContent.displayName = "CacheContent";
}
var CacheContent_default = CacheContent;

// packages/cascader/src/OptionList/Column.tsx
var import_classnames118 = __toESM(require_classnames());
import * as React313 from "react";

// packages/cascader/src/OptionList/Checkbox.tsx
var import_classnames117 = __toESM(require_classnames());
import * as React312 from "react";
function Checkbox2({
  prefixCls,
  checked,
  halfChecked,
  disabled,
  onClick,
  disableCheckbox
}) {
  const { checkable } = React312.useContext(context_default8);
  const customCheckbox = typeof checkable !== "boolean" ? checkable : null;
  return /* @__PURE__ */ React312.createElement(
    "span",
    {
      className: (0, import_classnames117.default)(`${prefixCls}`, {
        [`${prefixCls}-checked`]: checked,
        [`${prefixCls}-indeterminate`]: !checked && halfChecked,
        [`${prefixCls}-disabled`]: disabled || disableCheckbox
      }),
      onClick
    },
    customCheckbox
  );
}
__name(Checkbox2, "Checkbox");

// packages/cascader/src/OptionList/Column.tsx
var FIX_LABEL = "__cascader_fix_label__";
function Column({
  prefixCls,
  multiple,
  options,
  activeValue,
  prevValuePath,
  onToggleOpen,
  onSelect,
  onActive,
  checkedSet,
  halfCheckedSet,
  loadingKeys,
  isSelectable,
  searchValue
}) {
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon,
    loadingIcon,
    dropdownMenuColumnStyle,
    optionRender
  } = React313.useContext(context_default8);
  const hoverOpen = expandTrigger === "hover";
  const optionInfoList = React313.useMemo(
    () => options.map((option) => {
      const { disabled, disableCheckbox } = option;
      const searchOptions = option[SEARCH_MARK];
      const label = option[FIX_LABEL] ?? option[fieldNames.label];
      const value = option[fieldNames.value];
      const isMergedLeaf = isLeaf(option, fieldNames);
      const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value]) : [...prevValuePath, value];
      const fullPathKey = toPathKey(fullPath);
      const isLoading = loadingKeys.includes(fullPathKey);
      const checked = checkedSet.has(fullPathKey);
      const halfChecked = halfCheckedSet.has(fullPathKey);
      return {
        disabled,
        label,
        value,
        isLeaf: isMergedLeaf,
        isLoading,
        checked,
        halfChecked,
        option,
        disableCheckbox,
        fullPath,
        fullPathKey
      };
    }),
    [options, checkedSet, fieldNames, halfCheckedSet, loadingKeys, prevValuePath]
  );
  return /* @__PURE__ */ React313.createElement("ul", { className: menuPrefixCls, role: "menu" }, optionInfoList.map(
    ({
      disabled,
      label,
      value,
      isLeaf: isMergedLeaf,
      isLoading,
      checked,
      halfChecked,
      option,
      fullPath,
      fullPathKey,
      disableCheckbox
    }) => {
      const triggerOpenPath = /* @__PURE__ */ __name(() => {
        if (disabled || searchValue) {
          return;
        }
        const nextValueCells = [...fullPath];
        if (hoverOpen && isMergedLeaf) {
          nextValueCells.pop();
        }
        onActive(nextValueCells);
      }, "triggerOpenPath");
      const triggerSelect = /* @__PURE__ */ __name(() => {
        if (isSelectable(option)) {
          onSelect(fullPath, isMergedLeaf);
        }
      }, "triggerSelect");
      let title;
      if (typeof option.title === "string") {
        title = option.title;
      } else if (typeof label === "string") {
        title = label;
      }
      return /* @__PURE__ */ React313.createElement(
        "li",
        {
          key: fullPathKey,
          className: (0, import_classnames118.default)(menuItemPrefixCls, {
            [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
            [`${menuItemPrefixCls}-active`]: activeValue === value || activeValue === fullPathKey,
            [`${menuItemPrefixCls}-disabled`]: disabled,
            [`${menuItemPrefixCls}-loading`]: isLoading
          }),
          style: dropdownMenuColumnStyle,
          role: "menuitemcheckbox",
          title,
          "aria-checked": checked,
          "data-path-key": fullPathKey,
          onClick: () => {
            triggerOpenPath();
            if (disableCheckbox) {
              return;
            }
            if (!multiple || isMergedLeaf) {
              triggerSelect();
            }
          },
          onDoubleClick: () => {
            if (changeOnSelect) {
              onToggleOpen(false);
            }
          },
          onMouseEnter: () => {
            if (hoverOpen) {
              triggerOpenPath();
            }
          },
          onMouseDown: (e3) => {
            e3.preventDefault();
          }
        },
        multiple && /* @__PURE__ */ React313.createElement(
          Checkbox2,
          {
            prefixCls: `${prefixCls}-checkbox`,
            checked,
            halfChecked,
            disabled: disabled || disableCheckbox,
            disableCheckbox,
            onClick: (e3) => {
              if (disableCheckbox) {
                return;
              }
              e3.stopPropagation();
              triggerSelect();
            }
          }
        ),
        /* @__PURE__ */ React313.createElement("div", { className: `${menuItemPrefixCls}-content` }, optionRender ? optionRender(option) : label),
        !isLoading && expandIcon && !isMergedLeaf && /* @__PURE__ */ React313.createElement("div", { className: `${menuItemPrefixCls}-expand-icon` }, expandIcon),
        isLoading && loadingIcon && /* @__PURE__ */ React313.createElement("div", { className: `${menuItemPrefixCls}-loading-icon` }, loadingIcon)
      );
    }
  ));
}
__name(Column, "Column");

// packages/cascader/src/OptionList/useActive.ts
import * as React314 from "react";
var useActive2 = /* @__PURE__ */ __name((multiple, open3) => {
  const { values } = React314.useContext(context_default8);
  const firstValueCells = values[0];
  const [activeValueCells, setActiveValueCells] = React314.useState([]);
  React314.useEffect(
    () => {
      if (!multiple) {
        setActiveValueCells(firstValueCells || []);
      }
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [open3, firstValueCells]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  return [activeValueCells, setActiveValueCells];
}, "useActive");
var useActive_default = useActive2;

// packages/cascader/src/OptionList/useKeyboard.ts
import * as React315 from "react";
var useKeyboard_default = /* @__PURE__ */ __name((ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {
  const { direction, searchValue, toggleOpen, open: open3 } = contextProps;
  const rtl = direction === "rtl";
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = React315.useMemo(() => {
    let activeIndex = -1;
    let currentOptions = options;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.length;
    const pathKeys = getFullPathKeys(options, fieldNames);
    for (let i = 0; i < len && currentOptions; i += 1) {
      const nextActiveIndex = currentOptions.findIndex(
        (option, index3) => (pathKeys[index3] ? toPathKey(pathKeys[index3]) : option[fieldNames.value]) === activeValueCells[i]
      );
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells[i]);
      currentOptions = currentOptions[activeIndex][fieldNames.children];
    }
    let activeOptions = options;
    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];
    }
    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];
  }, [activeValueCells, fieldNames, options]);
  const internalSetActiveValueCells = /* @__PURE__ */ __name((next2) => {
    setActiveValueCells(next2);
  }, "internalSetActiveValueCells");
  const offsetActiveOption = /* @__PURE__ */ __name((offset3) => {
    const len = lastActiveOptions.length;
    let currentIndex = lastActiveIndex;
    if (currentIndex === -1 && offset3 < 0) {
      currentIndex = len;
    }
    for (let i = 0; i < len; i += 1) {
      currentIndex = (currentIndex + offset3 + len) % len;
      const option = lastActiveOptions[currentIndex];
      if (option && !option.disabled) {
        const nextActiveCells = validActiveValueCells.slice(0, -1).concat(
          fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]
        );
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  }, "offsetActiveOption");
  const prevColumn = /* @__PURE__ */ __name(() => {
    if (validActiveValueCells.length > 1) {
      const nextActiveCells = validActiveValueCells.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      toggleOpen(false);
    }
  }, "prevColumn");
  const nextColumn = /* @__PURE__ */ __name(() => {
    const nextOptions = lastActiveOptions[lastActiveIndex]?.[fieldNames.children] || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells, nextOption[fieldNames.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  }, "nextColumn");
  React315.useImperativeHandle(ref, () => ({
    // scrollTo: treeRef.current?.scrollTo,
    onKeyDown: (event) => {
      const { which } = event;
      switch (which) {
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset3 = 0;
          if (which === KeyCode_default.UP) {
            offset3 = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset3 = 1;
          }
          if (offset3 !== 0) {
            offsetActiveOption(offset3);
          }
          break;
        }
        case KeyCode_default.LEFT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.RIGHT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode_default.BACKSPACE: {
          if (!searchValue) {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.ENTER: {
          if (validActiveValueCells.length) {
            const option = lastActiveOptions[lastActiveIndex];
            const originOptions = option?.[SEARCH_MARK] || [];
            if (originOptions.length) {
              onKeyBoardSelect(
                originOptions.map((opt) => opt[fieldNames.value]),
                originOptions[originOptions.length - 1]
              );
            } else {
              onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);
            }
          }
          break;
        }
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open3) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    }
  }));
}, "default");

// packages/cascader/src/OptionList/List.tsx
var RawOptionList = React316.forwardRef((props, ref) => {
  const { prefixCls, multiple, searchValue, toggleOpen, notFoundContent, direction, open: open3 } = props;
  const containerRef = React316.useRef(null);
  const rtl = direction === "rtl";
  const {
    options,
    values,
    halfValues,
    fieldNames,
    changeOnSelect,
    onSelect,
    searchOptions,
    dropdownPrefixCls,
    loadData,
    expandTrigger
  } = React316.useContext(context_default8);
  const mergedPrefixCls = dropdownPrefixCls || prefixCls;
  const [loadingKeys, setLoadingKeys] = React316.useState([]);
  const internalLoadData = /* @__PURE__ */ __name((valueCells) => {
    if (!loadData || searchValue) {
      return;
    }
    const optionList = toPathOptions(valueCells, options, fieldNames);
    const rawOptions = optionList.map(({ option }) => option);
    const lastOption = rawOptions[rawOptions.length - 1];
    if (lastOption && !isLeaf(lastOption, fieldNames)) {
      const pathKey2 = toPathKey(valueCells);
      setLoadingKeys((keys2) => [...keys2, pathKey2]);
      loadData(rawOptions);
    }
  }, "internalLoadData");
  React316.useEffect(() => {
    if (loadingKeys.length) {
      loadingKeys.forEach((loadingKey) => {
        const valueStrCells = toPathValueStr(loadingKey);
        const optionList = toPathOptions(valueStrCells, options, fieldNames, true).map(
          ({ option }) => option
        );
        const lastOption = optionList[optionList.length - 1];
        if (!lastOption || lastOption[fieldNames.children] || isLeaf(lastOption, fieldNames)) {
          setLoadingKeys((keys2) => keys2.filter((key) => key !== loadingKey));
        }
      });
    }
  }, [options, loadingKeys, fieldNames]);
  const checkedSet = React316.useMemo(() => new Set(toPathKeys(values)), [values]);
  const halfCheckedSet = React316.useMemo(() => new Set(toPathKeys(halfValues)), [halfValues]);
  const [activeValueCells, setActiveValueCells] = useActive_default(multiple, open3);
  const onPathOpen = /* @__PURE__ */ __name((nextValueCells) => {
    setActiveValueCells(nextValueCells);
    internalLoadData(nextValueCells);
  }, "onPathOpen");
  const isSelectable = /* @__PURE__ */ __name((option) => {
    const { disabled } = option;
    const isMergedLeaf = isLeaf(option, fieldNames);
    return !disabled && (isMergedLeaf || changeOnSelect || multiple);
  }, "isSelectable");
  const onPathSelect = /* @__PURE__ */ __name((valuePath, leaf, fromKeyboard = false) => {
    onSelect(valuePath);
    if (!multiple && (leaf || changeOnSelect && (expandTrigger === "hover" || fromKeyboard))) {
      toggleOpen(false);
    }
  }, "onPathSelect");
  const mergedOptions = React316.useMemo(() => {
    if (searchValue) {
      return searchOptions;
    }
    return options;
  }, [searchValue, searchOptions, options]);
  const optionColumns = React316.useMemo(() => {
    const optionList = [{ options: mergedOptions }];
    let currentList = mergedOptions;
    const fullPathKeys = getFullPathKeys(currentList, fieldNames);
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const activeValueCell = activeValueCells[i];
      const currentOption = currentList.find(
        (option, index3) => (fullPathKeys[index3] ? toPathKey(fullPathKeys[index3]) : option[fieldNames.value]) === activeValueCell
      );
      const subOptions = currentOption?.[fieldNames.children];
      if (!subOptions?.length) {
        break;
      }
      currentList = subOptions;
      optionList.push({ options: subOptions });
    }
    return optionList;
  }, [mergedOptions, activeValueCells, fieldNames]);
  const onKeyboardSelect = /* @__PURE__ */ __name((selectValueCells, option) => {
    if (isSelectable(option)) {
      onPathSelect(selectValueCells, isLeaf(option, fieldNames), true);
    }
  }, "onKeyboardSelect");
  useKeyboard_default(ref, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect, {
    direction,
    searchValue,
    toggleOpen,
    open: open3
  });
  React316.useEffect(() => {
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const cellPath = activeValueCells.slice(0, i + 1);
      const cellKeyPath = toPathKey(cellPath);
      const ele = containerRef.current?.querySelector(
        `li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`
        // matches unescaped double quotes
      );
      if (ele) {
        scrollIntoParentView(ele);
      }
    }
  }, [activeValueCells]);
  const isEmpty2 = !optionColumns[0]?.options?.length;
  const emptyList = [
    {
      [fieldNames.value]: "__EMPTY__",
      [FIX_LABEL]: notFoundContent,
      disabled: true
    }
  ];
  const columnProps = {
    ...props,
    multiple: !isEmpty2 && multiple,
    onSelect: onPathSelect,
    onActive: onPathOpen,
    onToggleOpen: toggleOpen,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  };
  const mergedOptionColumns = isEmpty2 ? [{ options: emptyList }] : optionColumns;
  const columnNodes = mergedOptionColumns.map((col, index3) => {
    const prevValuePath = activeValueCells.slice(0, index3);
    const activeValue = activeValueCells[index3];
    return /* @__PURE__ */ React316.createElement(
      Column,
      {
        key: index3,
        ...columnProps,
        searchValue,
        prefixCls: mergedPrefixCls,
        options: col.options,
        prevValuePath,
        activeValue
      }
    );
  });
  return /* @__PURE__ */ React316.createElement(CacheContent_default, { open: open3 }, /* @__PURE__ */ React316.createElement(
    "div",
    {
      className: (0, import_classnames119.default)(`${mergedPrefixCls}-menus`, {
        [`${mergedPrefixCls}-menu-empty`]: isEmpty2,
        [`${mergedPrefixCls}-rtl`]: rtl
      }),
      ref: containerRef
    },
    columnNodes
  ));
});
if (true) {
  RawOptionList.displayName = "RawOptionList";
}
var List_default3 = RawOptionList;

// packages/cascader/src/OptionList/index.tsx
var RefOptionList2 = React317.forwardRef((props, ref) => {
  const baseProps = useBaseProps();
  return /* @__PURE__ */ React317.createElement(List_default3, { ...props, ...baseProps, ref });
});
var OptionList_default2 = RefOptionList2;

// packages/cascader/src/Panel.tsx
var import_classnames120 = __toESM(require_classnames());
import * as React318 from "react";
function noop3() {
}
__name(noop3, "noop");
function Panel2(props) {
  const {
    prefixCls = "rc-cascader",
    style: style2,
    className,
    options,
    checkable,
    defaultValue,
    value,
    fieldNames,
    changeOnSelect,
    onChange,
    showCheckedStrategy,
    loadData,
    expandTrigger,
    expandIcon = ">",
    loadingIcon,
    direction,
    notFoundContent = "Not Found"
  } = props;
  const multiple = !!checkable;
  const [rawValues, setRawValues] = useMergedState(defaultValue, { value, postState: toRawValues });
  const mergedFieldNames = React318.useMemo(
    () => fillFieldNames2(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions2(
    mergedFieldNames,
    options
  );
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(
    multiple,
    rawValues,
    getPathKeyEntities,
    getValueByKeyPath,
    getMissingValues
  );
  const triggerChange = useEvent((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map(
        (valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option)
      );
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(
    multiple,
    triggerChange,
    checkedValues,
    halfCheckedValues,
    missingCheckedValues,
    getPathKeyEntities,
    getValueByKeyPath,
    showCheckedStrategy
  );
  const onInternalSelect = useEvent((valuePath) => {
    handleSelection(valuePath);
  });
  const cascaderContext = React318.useMemo(
    () => ({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions: [],
      dropdownPrefixCls: void 0,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle: void 0
    }),
    [
      mergedOptions,
      mergedFieldNames,
      checkedValues,
      halfCheckedValues,
      changeOnSelect,
      onInternalSelect,
      checkable,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon
    ]
  );
  const panelPrefixCls = `${prefixCls}-panel`;
  const isEmpty2 = !mergedOptions.length;
  return /* @__PURE__ */ React318.createElement(context_default8.Provider, { value: cascaderContext }, /* @__PURE__ */ React318.createElement(
    "div",
    {
      className: (0, import_classnames120.default)(
        panelPrefixCls,
        {
          [`${panelPrefixCls}-rtl`]: direction === "rtl",
          [`${panelPrefixCls}-empty`]: isEmpty2
        },
        className
      ),
      style: style2
    },
    isEmpty2 ? notFoundContent : /* @__PURE__ */ React318.createElement(
      List_default3,
      {
        prefixCls,
        searchValue: "",
        multiple,
        toggleOpen: noop3,
        open: true,
        direction
      }
    )
  ));
}
__name(Panel2, "Panel");

// packages/cascader/src/utils/warningPropsUtil.ts
init_warning();
function warningProps2(props) {
  const { onPopupVisibleChange, popupVisible, popupClassName, popupPlacement } = props;
  warning_default(
    !onPopupVisibleChange,
    "`onPopupVisibleChange` is deprecated. Please use `onDropdownVisibleChange` instead."
  );
  warning_default(popupVisible === void 0, "`popupVisible` is deprecated. Please use `open` instead.");
  warning_default(
    popupClassName === void 0,
    "`popupClassName` is deprecated. Please use `dropdownClassName` instead."
  );
  warning_default(
    popupPlacement === void 0,
    "`popupPlacement` is deprecated. Please use `placement` instead."
  );
}
__name(warningProps2, "warningProps");
function warningNullOptions2(options, fieldNames) {
  if (options) {
    const recursiveOptions = /* @__PURE__ */ __name((optionsList) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames?.value] === null) {
          warning_default(false, "`value` in Cascader options should not be `null`.");
          return true;
        }
        if (Array.isArray(option[fieldNames?.children]) && recursiveOptions(option[fieldNames?.children])) {
          return true;
        }
      }
    }, "recursiveOptions");
    recursiveOptions(options);
  }
}
__name(warningNullOptions2, "warningNullOptions");
var warningPropsUtil_default2 = warningProps2;

// packages/cascader/src/Cascader.tsx
var Cascader = React319.forwardRef((props, ref) => {
  const {
    // MISC
    id,
    prefixCls = "rc-cascader",
    fieldNames,
    // Value
    defaultValue,
    value,
    changeOnSelect,
    onChange,
    displayRender,
    checkable,
    // Search
    autoClearSearchValue = true,
    searchValue,
    onSearch,
    showSearch,
    // Trigger
    expandTrigger,
    // Options
    options,
    dropdownPrefixCls,
    loadData,
    // Open
    popupVisible,
    open: open3,
    popupClassName,
    dropdownClassName,
    dropdownMenuColumnStyle,
    dropdownStyle: customDropdownStyle,
    popupPlacement,
    placement,
    onDropdownVisibleChange,
    onPopupVisibleChange,
    // Icon
    expandIcon = ">",
    loadingIcon,
    // Children
    children,
    dropdownMatchSelectWidth = false,
    showCheckedStrategy = SHOW_PARENT,
    optionRender,
    ...restProps
  } = props;
  const mergedId = useId3(id);
  const multiple = !!checkable;
  const [rawValues, setRawValues] = useMergedState(defaultValue, { value, postState: toRawValues });
  const mergedFieldNames = React319.useMemo(
    () => fillFieldNames2(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions2(
    mergedFieldNames,
    options
  );
  const [mergedSearchValue, setSearchValue] = useMergedState("", {
    value: searchValue,
    postState: (search) => search || ""
  });
  const onInternalSearch = /* @__PURE__ */ __name((searchText, info) => {
    setSearchValue(searchText);
    if (info.source !== "blur" && onSearch) {
      onSearch(searchText);
    }
  }, "onInternalSearch");
  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch);
  const searchOptions = useSearchOptions_default(
    mergedSearchValue,
    mergedOptions,
    mergedFieldNames,
    dropdownPrefixCls || prefixCls,
    searchConfig,
    changeOnSelect
  );
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(
    multiple,
    rawValues,
    getPathKeyEntities,
    getValueByKeyPath,
    getMissingValues
  );
  const deDuplicatedValues = React319.useMemo(() => {
    const checkedKeys = toPathKeys(checkedValues);
    const deduplicateKeys = formatStrategyValues(
      checkedKeys,
      getPathKeyEntities,
      showCheckedStrategy
    );
    return [...missingCheckedValues, ...getValueByKeyPath(deduplicateKeys)];
  }, [
    checkedValues,
    getPathKeyEntities,
    getValueByKeyPath,
    missingCheckedValues,
    showCheckedStrategy
  ]);
  const displayValues = useDisplayValues_default(
    deDuplicatedValues,
    mergedOptions,
    mergedFieldNames,
    multiple,
    displayRender
  );
  const triggerChange = useEvent((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map(
        (valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option)
      );
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(
    multiple,
    triggerChange,
    checkedValues,
    halfCheckedValues,
    missingCheckedValues,
    getPathKeyEntities,
    getValueByKeyPath,
    showCheckedStrategy
  );
  const onInternalSelect = useEvent((valuePath) => {
    if (!multiple || autoClearSearchValue) {
      setSearchValue("");
    }
    handleSelection(valuePath);
  });
  const onDisplayValuesChange = /* @__PURE__ */ __name((_, info) => {
    if (info.type === "clear") {
      triggerChange([]);
      return;
    }
    const { valueCells } = info.values[0];
    onInternalSelect(valueCells);
  }, "onDisplayValuesChange");
  const mergedOpen = open3 !== void 0 ? open3 : popupVisible;
  const mergedDropdownClassName = dropdownClassName || popupClassName;
  const mergedPlacement = placement || popupPlacement;
  const onInternalDropdownVisibleChange = /* @__PURE__ */ __name((nextVisible) => {
    onDropdownVisibleChange?.(nextVisible);
    onPopupVisibleChange?.(nextVisible);
  }, "onInternalDropdownVisibleChange");
  if (true) {
    warningPropsUtil_default2(props);
    warningNullOptions2(mergedOptions, mergedFieldNames);
  }
  const cascaderContext = React319.useMemo(
    () => ({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      optionRender
    }),
    [
      mergedOptions,
      mergedFieldNames,
      checkedValues,
      halfCheckedValues,
      changeOnSelect,
      onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      optionRender
    ]
  );
  const emptyOptions = !(mergedSearchValue ? searchOptions : mergedOptions).length;
  const dropdownStyle = (
    // Search to match width
    mergedSearchValue && searchConfig.matchInputWidth || // Empty keep the width
    emptyOptions ? {} : {
      minWidth: "auto"
    }
  );
  return /* @__PURE__ */ React319.createElement(context_default8.Provider, { value: cascaderContext }, /* @__PURE__ */ React319.createElement(
    BaseSelect_default,
    {
      ...restProps,
      ref,
      id: mergedId,
      prefixCls,
      autoClearSearchValue,
      dropdownMatchSelectWidth,
      dropdownStyle: {
        ...dropdownStyle,
        ...customDropdownStyle
      },
      displayValues,
      onDisplayValuesChange,
      mode: multiple ? "multiple" : void 0,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      showSearch: mergedShowSearch,
      OptionList: OptionList_default2,
      emptyOptions,
      open: mergedOpen,
      dropdownClassName: mergedDropdownClassName,
      placement: mergedPlacement,
      onDropdownVisibleChange: onInternalDropdownVisibleChange,
      getRawInputElement: () => children
    }
  ));
});
if (true) {
  Cascader.displayName = "Cascader";
}
Cascader.SHOW_PARENT = SHOW_PARENT;
Cascader.SHOW_CHILD = SHOW_CHILD;
Cascader.Panel = Panel2;
var Cascader_default = Cascader;

// packages/cascader/src/index.tsx
var src_default14 = Cascader_default;

// packages/ant-design/components/cascader/hooks/useBase.ts
import * as React320 from "react";
function useBase(customizePrefixCls, direction) {
  const { getPrefixCls, direction: rootDirection, renderEmpty } = React320.useContext(ConfigContext);
  const mergedDirection = direction || rootDirection;
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const cascaderPrefixCls = getPrefixCls("cascader", customizePrefixCls);
  return [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty];
}
__name(useBase, "useBase");

// packages/ant-design/components/cascader/hooks/useCheckable.tsx
import * as React321 from "react";
function useCheckable(cascaderPrefixCls, multiple) {
  return React321.useMemo(
    () => multiple ? /* @__PURE__ */ React321.createElement("span", { className: `${cascaderPrefixCls}-checkbox-inner` }) : false,
    [multiple]
  );
}
__name(useCheckable, "useCheckable");

// packages/ant-design/components/cascader/hooks/useColumnIcons.tsx
var import_LeftOutlined2 = __toESM(require_LeftOutlined3());
var import_LoadingOutlined4 = __toESM(require_LoadingOutlined3());
var import_RightOutlined3 = __toESM(require_RightOutlined3());
import * as React322 from "react";
function useColumnIcons(prefixCls, rtl, expandIcon) {
  let mergedExpandIcon = expandIcon;
  if (!expandIcon) {
    mergedExpandIcon = rtl ? /* @__PURE__ */ React322.createElement(import_LeftOutlined2.default, null) : /* @__PURE__ */ React322.createElement(import_RightOutlined3.default, null);
  }
  const loadingIcon = /* @__PURE__ */ React322.createElement("span", { className: `${prefixCls}-menu-item-loading-icon` }, /* @__PURE__ */ React322.createElement(import_LoadingOutlined4.default, { spin: true }));
  return [mergedExpandIcon, loadingIcon];
}
__name(useColumnIcons, "useColumnIcons");

// packages/ant-design/components/cascader/Panel.tsx
var import_classnames121 = __toESM(require_classnames());
import * as React323 from "react";

// packages/ant-design/components/checkbox/style/index.ts
var genCheckboxStyle = /* @__PURE__ */ __name((token2) => {
  const { checkboxCls } = token2;
  const wrapperCls = `${checkboxCls}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${checkboxCls}-group`]: {
        ...resetComponent(token2),
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: token2.marginXS,
        // Group > Grid
        [`> ${token2.antCls}-row`]: {
          flex: 1
        }
      },
      // Wrapper
      [wrapperCls]: {
        ...resetComponent(token2),
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${wrapperCls}`]: {
          marginInlineStart: 0
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            // FIXME: magic
            height: 14
            // FIXME: magic
          }
        }
      },
      // Wrapper > Checkbox
      [checkboxCls]: {
        ...resetComponent(token2),
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        borderRadius: token2.borderRadiusSM,
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${checkboxCls}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: {
            ...genFocusOutline(token2)
          }
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          display: "block",
          width: token2.checkboxSize,
          height: token2.checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "25%",
            display: "table",
            width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
            height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
            border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper & Wrapper > Checkbox
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
          }
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        }
      }
    },
    // ================= Indeterminate =================
    {
      [checkboxCls]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            backgroundColor: token2.colorBgContainer,
            borderColor: token2.colorBorder,
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: token2.calc(token2.fontSizeLG).div(2).equal(),
              height: token2.calc(token2.fontSizeLG).div(2).equal(),
              backgroundColor: token2.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${checkboxCls}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token2.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token2.colorTextDisabled
        }
      }
    }
  ];
}, "genCheckboxStyle");
function getStyle2(prefixCls, token2) {
  const checkboxToken = merge2(token2, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token2.controlInteractiveSize
  });
  return [genCheckboxStyle(checkboxToken)];
}
__name(getStyle2, "getStyle");
var style_default29 = genStyleHooks("Checkbox", (token2, { prefixCls }) => [getStyle2(prefixCls, token2)]);

// packages/ant-design/components/cascader/style/columns.ts
var getColumnsStyle = /* @__PURE__ */ __name((token2) => {
  const { prefixCls, componentCls } = token2;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
  &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
  ${cascaderMenuItemCls}-loading-icon
`;
  return [
    // ==================== Checkbox ====================
    getStyle2(`${prefixCls}-checkbox`, token2),
    {
      [componentCls]: {
        // ================== Checkbox ==================
        "&-checkbox": {
          top: 0,
          marginInlineEnd: token2.paddingXS
        },
        // ==================== Menu ====================
        // >>> Menus
        "&-menus": {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          [`&${componentCls}-menu-empty`]: {
            [`${componentCls}-menu`]: {
              width: "100%",
              height: "auto",
              [cascaderMenuItemCls]: {
                color: token2.colorTextDisabled
              }
            }
          }
        },
        // >>> Menu
        "&-menu": {
          flexGrow: 1,
          flexShrink: 0,
          minWidth: token2.controlItemWidth,
          height: token2.dropdownHeight,
          margin: 0,
          padding: token2.menuPadding,
          overflow: "auto",
          verticalAlign: "top",
          listStyle: "none",
          "-ms-overflow-style": "-ms-autohiding-scrollbar",
          // https://github.com/ant-design/ant-design/issues/11857
          "&:not(:last-child)": {
            borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          },
          "&-item": {
            ...textEllipsis,
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "center",
            padding: token2.optionPadding,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            "&:hover": {
              background: token2.controlItemBgHover
            },
            "&-disabled": {
              color: token2.colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                background: "transparent"
              },
              [iconCls]: {
                color: token2.colorTextDisabled
              }
            },
            [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
              [`&, &:hover`]: {
                fontWeight: token2.optionSelectedFontWeight,
                backgroundColor: token2.optionSelectedBg
              }
            },
            "&-content": {
              flex: "auto"
            },
            [iconCls]: {
              marginInlineStart: token2.paddingXXS,
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeIcon
            },
            "&-keyword": {
              color: token2.colorHighlight
            }
          }
        }
      }
    }
  ];
}, "getColumnsStyle");
var columns_default = getColumnsStyle;

// packages/ant-design/components/cascader/style/index.ts
var genBaseStyle8 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls } = token2;
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token2.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [
        {
          [`&${antCls}-select-dropdown`]: {
            padding: 0
          }
        },
        columns_default(token2)
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2)
  ];
}, "genBaseStyle");
var prepareComponentToken25 = /* @__PURE__ */ __name((token2) => {
  const itemPaddingVertical = Math.round(
    (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2
  );
  return {
    controlWidth: 184,
    controlItemWidth: 111,
    dropdownHeight: 180,
    optionSelectedBg: token2.controlItemBgActive,
    optionSelectedFontWeight: token2.fontWeightStrong,
    optionPadding: `${itemPaddingVertical}px ${token2.paddingSM}px`,
    menuPadding: token2.paddingXXS
  };
}, "prepareComponentToken");
var style_default30 = genStyleHooks("Cascader", (token2) => [genBaseStyle8(token2)], prepareComponentToken25);

// packages/ant-design/components/cascader/style/panel.ts
var genPanelStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-panel`]: [
      columns_default(token2),
      {
        display: "inline-flex",
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
        borderRadius: token2.borderRadiusLG,
        overflowX: "auto",
        maxWidth: "100%",
        [`${componentCls}-menus`]: {
          alignItems: "stretch"
        },
        [`${componentCls}-menu`]: {
          height: "auto"
        },
        "&-empty": {
          padding: token2.paddingXXS
        }
      }
    ]
  };
}, "genPanelStyle");
var panel_default2 = genComponentStyleHook(
  ["Cascader", "Panel"],
  (token2) => genPanelStyle2(token2),
  prepareComponentToken25
);

// packages/ant-design/components/cascader/Panel.tsx
var CascaderPanel = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    multiple,
    rootClassName,
    notFoundContent,
    direction,
    expandIcon
  } = props;
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase(
    customizePrefixCls,
    direction
  );
  const rootCls = useCSSVarCls_default(cascaderPrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default30(cascaderPrefixCls, rootCls);
  panel_default2(cascaderPrefixCls);
  const isRtl = mergedDirection === "rtl";
  const [mergedExpandIcon, loadingIcon] = useColumnIcons(prefixCls, isRtl, expandIcon);
  const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || /* @__PURE__ */ React323.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  return wrapCSSVar(
    /* @__PURE__ */ React323.createElement(
      Panel2,
      {
        ...props,
        checkable,
        prefixCls: cascaderPrefixCls,
        className: (0, import_classnames121.default)(className, hashId, rootClassName, cssVarCls, rootCls),
        notFoundContent: mergedNotFoundContent,
        direction: mergedDirection,
        expandIcon: mergedExpandIcon,
        loadingIcon
      }
    )
  );
}, "CascaderPanel");
var Panel_default2 = CascaderPanel;

// packages/ant-design/components/cascader/index.tsx
var { SHOW_CHILD: SHOW_CHILD2, SHOW_PARENT: SHOW_PARENT2 } = src_default14;
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce(
    (list, cur, index3) => index3 === 0 ? [cur] : [...list, lowerKeyword, cur],
    []
  );
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index3) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index3 % 2 === 1) {
      originWorld = // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React324.createElement("span", { className: `${prefixCls}-menu-item-keyword`, key: `separator-${index3}` }, originWorld);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
__name(highlightKeyword, "highlightKeyword");
var defaultSearchRender = /* @__PURE__ */ __name((inputValue, path2, prefixCls, fieldNames) => {
  const optionList = [];
  const lower2 = inputValue.toLowerCase();
  path2.forEach((node2, index3) => {
    if (index3 !== 0) {
      optionList.push(" / ");
    }
    let label = node2[fieldNames.label];
    const type5 = typeof label;
    if (type5 === "string" || type5 === "number") {
      label = highlightKeyword(String(label), lower2, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
}, "defaultSearchRender");
var Cascader2 = React324.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    multiple,
    bordered = true,
    transitionName,
    choiceTransitionName = "",
    popupClassName,
    dropdownClassName,
    expandIcon,
    placement,
    showSearch,
    allowClear = true,
    notFoundContent,
    direction,
    getPopupContainer,
    status: customStatus,
    showArrow,
    builtinPlacements,
    style: style2,
    variant: customVariant,
    ...rest
  } = props;
  const restProps = omit(rest, ["suffixIcon"]);
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    popupOverflow,
    cascader
  } = React324.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React324.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  if (true) {
    const warning5 = devUseWarning("Cascader");
    warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
    warning5(
      !("showArrow" in props),
      "deprecated",
      "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."
    );
    warning5.deprecated(!("bordered" in props), "bordered", "variant");
  }
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase(
    customizePrefixCls,
    direction
  );
  const isRtl = mergedDirection === "rtl";
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapSelectCSSVar, hashId, cssVarCls] = style_default12(prefixCls, rootCls);
  const cascaderRootCls = useCSSVarCls_default(cascaderPrefixCls);
  const [wrapCascaderCSSVar] = style_default30(cascaderPrefixCls, cascaderRootCls);
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
  const mergedNotFoundContent = notFoundContent || renderEmpty?.("Cascader") || /* @__PURE__ */ React324.createElement(defaultRenderEmpty_default, { componentName: "Cascader" });
  const mergedDropdownClassName = (0, import_classnames122.default)(
    popupClassName || dropdownClassName,
    `${cascaderPrefixCls}-dropdown`,
    {
      [`${cascaderPrefixCls}-dropdown-rtl`]: mergedDirection === "rtl"
    },
    rootClassName,
    rootCls,
    cascaderRootCls,
    hashId,
    cssVarCls
  );
  const mergedShowSearch = React324.useMemo(() => {
    if (!showSearch) {
      return showSearch;
    }
    let searchConfig = {
      render: defaultSearchRender
    };
    if (typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    return searchConfig;
  }, [showSearch]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React324.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [mergedExpandIcon, loadingIcon] = useColumnIcons(prefixCls, isRtl, expandIcon);
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  const showSuffixIcon = useShowArrow(props.suffixIcon, showArrow);
  const { suffixIcon, removeIcon, clearIcon } = useIcons({
    ...props,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    multiple,
    prefixCls,
    componentName: "Cascader"
  });
  const memoPlacement = React324.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return isRtl ? "bottomRight" : "bottomLeft";
  }, [placement, isRtl]);
  const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
  const [zIndex] = useZIndex("SelectLike", restProps.dropdownStyle?.zIndex);
  const renderNode = /* @__PURE__ */ React324.createElement(
    src_default14,
    {
      prefixCls,
      className: (0, import_classnames122.default)(
        !customizePrefixCls && cascaderPrefixCls,
        {
          [`${prefixCls}-lg`]: mergedSize === "large",
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-rtl`]: isRtl,
          [`${prefixCls}-${variant}`]: enableVariantCls,
          [`${prefixCls}-in-form-item`]: isFormItemInput
        },
        getStatusClassNames(prefixCls, mergedStatus, hasFeedback),
        compactItemClassnames,
        cascader?.className,
        className,
        rootClassName,
        rootCls,
        cascaderRootCls,
        hashId,
        cssVarCls
      ),
      disabled: mergedDisabled,
      style: { ...cascader?.style, ...style2 },
      ...restProps,
      builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
      direction: mergedDirection,
      placement: memoPlacement,
      notFoundContent: mergedNotFoundContent,
      allowClear: mergedAllowClear,
      showSearch: mergedShowSearch,
      expandIcon: mergedExpandIcon,
      suffixIcon,
      removeIcon,
      loadingIcon,
      checkable,
      dropdownClassName: mergedDropdownClassName,
      dropdownPrefixCls: customizePrefixCls || cascaderPrefixCls,
      dropdownStyle: { ...restProps.dropdownStyle, zIndex },
      choiceTransitionName: getTransitionName2(rootPrefixCls, "", choiceTransitionName),
      transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      ref
    }
  );
  return wrapCascaderCSSVar(wrapSelectCSSVar(renderNode));
});
if (true) {
  Cascader2.displayName = "Cascader";
}
var PurePanel8 = PurePanel_default3(Cascader2);
Cascader2.SHOW_PARENT = SHOW_PARENT2;
Cascader2.SHOW_CHILD = SHOW_CHILD2;
Cascader2.Panel = Panel_default2;
Cascader2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel8;
var cascader_default = Cascader2;

// packages/ant-design/components/checkbox/Checkbox.tsx
var import_classnames123 = __toESM(require_classnames());
import * as React326 from "react";

// packages/ant-design/components/checkbox/GroupContext.ts
import React325 from "react";
var GroupContext = React325.createContext(null);
var GroupContext_default = GroupContext;

// packages/ant-design/components/checkbox/Checkbox.tsx
var InternalCheckbox = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    indeterminate = false,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    skipGroup = false,
    disabled,
    ...restProps
  } = props;
  const { getPrefixCls, direction, checkbox } = React326.useContext(ConfigContext);
  const checkboxGroup = React326.useContext(GroupContext_default);
  const { isFormItemInput } = React326.useContext(FormItemInputContext);
  const contextDisabled = React326.useContext(DisabledContext_default);
  const mergedDisabled = (checkboxGroup?.disabled || disabled) ?? contextDisabled;
  const prevValue = React326.useRef(restProps.value);
  if (true) {
    const warning5 = devUseWarning("Checkbox");
    warning5(
      "checked" in restProps || !!checkboxGroup || !("value" in restProps),
      "usage",
      "`value` is not a valid prop, do you mean `checked`?"
    );
  }
  React326.useEffect(() => {
    checkboxGroup?.registerValue(restProps.value);
  }, []);
  React326.useEffect(() => {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup?.cancelValue(prevValue.current);
      checkboxGroup?.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return () => checkboxGroup?.cancelValue(restProps.value);
  }, [restProps.value]);
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default29(prefixCls, rootCls);
  const checkboxProps = { ...restProps };
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = (...args) => {
      if (restProps.onChange) {
        restProps.onChange(...args);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({ label: children, value: restProps.value });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
  }
  const classString = (0, import_classnames123.default)(
    `${prefixCls}-wrapper`,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
      [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
    },
    checkbox?.className,
    className,
    rootClassName,
    cssVarCls,
    rootCls,
    hashId
  );
  const checkboxClass = (0, import_classnames123.default)(
    {
      [`${prefixCls}-indeterminate`]: indeterminate
    },
    TARGET_CLS,
    hashId
  );
  const ariaChecked = indeterminate ? "mixed" : void 0;
  return wrapCSSVar(
    /* @__PURE__ */ React326.createElement(wave_default, { component: "Checkbox", disabled: mergedDisabled }, /* @__PURE__ */ React326.createElement(
      "label",
      {
        className: classString,
        style: { ...checkbox?.style, ...style2 },
        onMouseEnter,
        onMouseLeave
      },
      /* @__PURE__ */ React326.createElement(
        src_default11,
        {
          "aria-checked": ariaChecked,
          ...checkboxProps,
          prefixCls,
          className: checkboxClass,
          disabled: mergedDisabled,
          ref
        }
      ),
      children !== void 0 && /* @__PURE__ */ React326.createElement("span", null, children)
    ))
  );
}, "InternalCheckbox");
var Checkbox3 = React326.forwardRef(InternalCheckbox);
if (true) {
  Checkbox3.displayName = "Checkbox";
}
var Checkbox_default = Checkbox3;

// packages/ant-design/components/checkbox/Group.tsx
var import_classnames124 = __toESM(require_classnames());
import * as React327 from "react";
var CheckboxGroup = React327.forwardRef(
  (props, ref) => {
    const {
      defaultValue,
      children,
      options = [],
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      onChange,
      ...restProps
    } = props;
    const { getPrefixCls, direction } = React327.useContext(ConfigContext);
    const [value, setValue] = React327.useState(restProps.value || defaultValue || []);
    const [registeredValues, setRegisteredValues] = React327.useState([]);
    React327.useEffect(() => {
      if ("value" in restProps) {
        setValue(restProps.value || []);
      }
    }, [restProps.value]);
    const memoOptions = React327.useMemo(
      () => options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return { label: option, value: option };
        }
        return option;
      }),
      [options]
    );
    const cancelValue = /* @__PURE__ */ __name((val) => {
      setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
    }, "cancelValue");
    const registerValue = /* @__PURE__ */ __name((val) => {
      setRegisteredValues((prevValues) => [...prevValues, val]);
    }, "registerValue");
    const toggleOption = /* @__PURE__ */ __name((option) => {
      const optionIndex = value.indexOf(option.value);
      const newValue = [...value];
      if (optionIndex === -1) {
        newValue.push(option.value);
      } else {
        newValue.splice(optionIndex, 1);
      }
      if (!("value" in restProps)) {
        setValue(newValue);
      }
      onChange?.(
        newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
          const indexA = memoOptions.findIndex((opt) => opt.value === a);
          const indexB = memoOptions.findIndex((opt) => opt.value === b);
          return indexA - indexB;
        })
      );
    }, "toggleOption");
    const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default29(prefixCls, rootCls);
    const domProps = omit(restProps, ["value", "disabled"]);
    const childrenNode = options.length ? memoOptions.map((option) => /* @__PURE__ */ React327.createElement(
      Checkbox_default,
      {
        prefixCls,
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        value: option.value,
        checked: value.includes(option.value),
        onChange: option.onChange,
        className: `${groupPrefixCls}-item`,
        style: option.style,
        title: option.title,
        id: option.id,
        required: option.required
      },
      option.label
    )) : children;
    const context = {
      toggleOption,
      value,
      disabled: restProps.disabled,
      name: restProps.name,
      // https://github.com/ant-design/ant-design/issues/16376
      registerValue,
      cancelValue
    };
    const classString = (0, import_classnames124.default)(
      groupPrefixCls,
      {
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      },
      className,
      rootClassName,
      cssVarCls,
      rootCls,
      hashId
    );
    return wrapCSSVar(
      /* @__PURE__ */ React327.createElement("div", { className: classString, style: style2, ...domProps, ref }, /* @__PURE__ */ React327.createElement(GroupContext_default.Provider, { value: context }, childrenNode))
    );
  }
);
var Group_default = CheckboxGroup;

// packages/ant-design/components/checkbox/index.ts
var Checkbox4 = Checkbox_default;
Checkbox4.Group = Group_default;
Checkbox4.__ANT_CHECKBOX = true;
if (true) {
  Checkbox4.displayName = "Checkbox";
}
var checkbox_default = Checkbox4;

// packages/ant-design/components/grid/col.tsx
var import_classnames125 = __toESM(require_classnames());
import * as React328 from "react";

// packages/ant-design/components/grid/RowContext.ts
import { createContext as createContext39 } from "react";
var RowContext = createContext39({});
var RowContext_default = RowContext;

// packages/ant-design/components/grid/style/index.ts
var genGridRowStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    // Grid system
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, "genGridRowStyle");
var genGridColStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    // Grid system
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, "genGridColStyle");
var genLoopGridColumnsStyle = /* @__PURE__ */ __name((token2, sizeCls) => {
  const { prefixCls, componentCls, gridColumns } = token2;
  const gridColumnsStyle = {};
  for (let i = gridColumns; i >= 0; i--) {
    if (i === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
        // https://github.com/ant-design/ant-design/issues/44456
        // Form set `display: flex` on Col which will override `display: block`.
        // Let's get it from css variable to support override.
        {
          ["--ant-display"]: "block",
          // Fallback to display if variable not support
          display: "block"
        },
        {
          display: "var(--ant-display)",
          flex: `0 0 ${i / gridColumns * 100}%`,
          maxWidth: `${i / gridColumns * 100}%`
        }
      ];
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: i
      };
    }
  }
  gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
    flex: `var(--${prefixCls}${sizeCls}-flex)`
  };
  return gridColumnsStyle;
}, "genLoopGridColumnsStyle");
var genGridStyle = /* @__PURE__ */ __name((token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls), "genGridStyle");
var genGridMediaStyle = /* @__PURE__ */ __name((token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${unit(screenSize)})`]: {
    ...genGridStyle(token2, sizeCls)
  }
}), "genGridMediaStyle");
var prepareRowComponentToken = /* @__PURE__ */ __name(() => ({}), "prepareRowComponentToken");
var prepareColComponentToken = /* @__PURE__ */ __name(() => ({}), "prepareColComponentToken");
var useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
var useColStyle = genStyleHooks(
  "Grid",
  (token2) => {
    const gridToken = merge2(token2, {
      gridColumns: 24
      // Row is divided into 24 parts in Grid
    });
    const gridMediaSizesMap = {
      "-sm": gridToken.screenSMMin,
      "-md": gridToken.screenMDMin,
      "-lg": gridToken.screenLGMin,
      "-xl": gridToken.screenXLMin,
      "-xxl": gridToken.screenXXLMin
    };
    return [
      genGridColStyle(gridToken),
      genGridStyle(gridToken, ""),
      genGridStyle(gridToken, "-xs"),
      Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => ({ ...pre, ...cur }), {})
    ];
  },
  prepareColComponentToken
);

// packages/ant-design/components/grid/col.tsx
function parseFlex(flex) {
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
__name(parseFlex, "parseFlex");
var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Col = React328.forwardRef((props, ref) => {
  const { getPrefixCls, direction } = React328.useContext(ConfigContext);
  const { gutter, wrap } = React328.useContext(RowContext_default);
  const {
    prefixCls: customizePrefixCls,
    span,
    order,
    offset: offset3,
    push,
    pull,
    className,
    children,
    flex,
    style: style2,
    ...others
  } = props;
  const prefixCls = getPrefixCls("col", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = useColStyle(prefixCls);
  const sizeStyle = {};
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (typeof propSize === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = {
      ...sizeClassObj,
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    };
    if (sizeProps.flex) {
      sizeClassObj[`${prefixCls}-${size}-flex`] = true;
      sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
    }
  });
  const classes = (0, import_classnames125.default)(
    prefixCls,
    {
      [`${prefixCls}-${span}`]: span !== void 0,
      [`${prefixCls}-order-${order}`]: order,
      [`${prefixCls}-offset-${offset3}`]: offset3,
      [`${prefixCls}-push-${push}`]: push,
      [`${prefixCls}-pull-${pull}`]: pull
    },
    className,
    sizeClassObj,
    hashId,
    cssVarCls
  );
  const mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    const horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return wrapCSSVar(
    /* @__PURE__ */ React328.createElement(
      "div",
      {
        ...others,
        style: { ...mergedStyle, ...style2, ...sizeStyle },
        className: classes,
        ref
      },
      children
    )
  );
});
if (true) {
  Col.displayName = "Col";
}
var col_default = Col;

// packages/ant-design/components/grid/row.tsx
var import_classnames126 = __toESM(require_classnames());
import * as React329 from "react";
function useMergedPropByScreen(oriProp, screen) {
  const [prop, setProp] = React329.useState(typeof oriProp === "string" ? oriProp : "");
  const calcMergedAlignOrJustify = /* @__PURE__ */ __name(() => {
    if (typeof oriProp === "string") {
      setProp(oriProp);
    }
    if (typeof oriProp !== "object") {
      return;
    }
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (!screen[breakpoint]) {
        continue;
      }
      const curVal = oriProp[breakpoint];
      if (curVal !== void 0) {
        setProp(curVal);
        return;
      }
    }
  }, "calcMergedAlignOrJustify");
  React329.useEffect(() => {
    calcMergedAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
__name(useMergedPropByScreen, "useMergedPropByScreen");
var Row = React329.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style: style2,
    children,
    gutter = 0,
    wrap,
    ...others
  } = props;
  const { getPrefixCls, direction } = React329.useContext(ConfigContext);
  const [screens, setScreens] = React329.useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  });
  const [curScreens, setCurScreens] = React329.useState({
    xs: false,
    sm: false,
    md: false,
    lg: false,
    xl: false,
    xxl: false
  });
  const mergedAlign = useMergedPropByScreen(align, curScreens);
  const mergedJustify = useMergedPropByScreen(justify, curScreens);
  const gutterRef = React329.useRef(gutter);
  const responsiveObserver = useResponsiveObserver();
  React329.useEffect(() => {
    const token2 = responsiveObserver.subscribe((screen) => {
      setCurScreens(screen);
      const currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
        setScreens(screen);
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  const getGutter = /* @__PURE__ */ __name(() => {
    const results = [void 0, void 0];
    const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    normalizedGutter.forEach((g, index3) => {
      if (typeof g === "object") {
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if (screens[breakpoint] && g[breakpoint] !== void 0) {
            results[index3] = g[breakpoint];
            break;
          }
        }
      } else {
        results[index3] = g;
      }
    });
    return results;
  }, "getGutter");
  const prefixCls = getPrefixCls("row", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = useRowStyle(prefixCls);
  const gutters = getGutter();
  const classes = (0, import_classnames126.default)(
    prefixCls,
    {
      [`${prefixCls}-no-wrap`]: wrap === false,
      [`${prefixCls}-${mergedJustify}`]: mergedJustify,
      [`${prefixCls}-${mergedAlign}`]: mergedAlign,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    hashId,
    cssVarCls
  );
  const rowStyle = {};
  const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  const [gutterH, gutterV] = gutters;
  rowStyle.rowGap = gutterV;
  const rowContext = React329.useMemo(
    () => ({ gutter: [gutterH, gutterV], wrap }),
    [gutterH, gutterV, wrap]
  );
  return wrapCSSVar(
    /* @__PURE__ */ React329.createElement(RowContext_default.Provider, { value: rowContext }, /* @__PURE__ */ React329.createElement("div", { ...others, className: classes, style: { ...rowStyle, ...style2 }, ref }, children))
  );
});
if (true) {
  Row.displayName = "Row";
}
var row_default = Row;

// packages/ant-design/components/grid/index.ts
function useBreakpoint2() {
  return useBreakpoint_default();
}
__name(useBreakpoint2, "useBreakpoint");
var grid_default = { useBreakpoint: useBreakpoint2 };

// packages/ant-design/components/col/index.ts
var col_default2 = col_default;

// packages/ant-design/components/collapse/Collapse.tsx
var import_RightOutlined4 = __toESM(require_RightOutlined3());
var import_classnames131 = __toESM(require_classnames());
import * as React335 from "react";

// packages/collapse/src/Collapse.tsx
var import_classnames129 = __toESM(require_classnames());
init_warning();
import React333 from "react";

// packages/collapse/src/hooks/useItems.tsx
import React332 from "react";

// packages/collapse/src/Panel.tsx
var import_classnames128 = __toESM(require_classnames());
import React331 from "react";

// packages/collapse/src/PanelContent.tsx
var import_classnames127 = __toESM(require_classnames());
import React330 from "react";
var PanelContent = React330.forwardRef((props, ref) => {
  const { prefixCls, forceRender, className, style: style2, children, isActive: isActive2, role } = props;
  const [rendered, setRendered] = React330.useState(isActive2 || forceRender);
  React330.useEffect(() => {
    if (forceRender || isActive2) {
      setRendered(true);
    }
  }, [forceRender, isActive2]);
  if (!rendered) {
    return null;
  }
  return /* @__PURE__ */ React330.createElement(
    "div",
    {
      ref,
      className: (0, import_classnames127.default)(
        `${prefixCls}-content`,
        {
          [`${prefixCls}-content-active`]: isActive2,
          [`${prefixCls}-content-inactive`]: !isActive2
        },
        className
      ),
      style: style2,
      role
    },
    /* @__PURE__ */ React330.createElement("div", { className: `${prefixCls}-content-box` }, children)
  );
});
PanelContent.displayName = "PanelContent";
var PanelContent_default = PanelContent;

// packages/collapse/src/Panel.tsx
var CollapsePanel = React331.forwardRef((props, ref) => {
  const {
    showArrow = true,
    headerClass,
    isActive: isActive2,
    onItemClick,
    forceRender,
    className,
    prefixCls,
    collapsible,
    accordion,
    panelKey,
    extra,
    header,
    expandIcon,
    openMotion,
    destroyInactivePanel,
    children,
    ...resetProps
  } = props;
  const disabled = collapsible === "disabled";
  const collapsibleHeader = collapsible === "header";
  const collapsibleIcon = collapsible === "icon";
  const ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
  const handleItemClick = /* @__PURE__ */ __name(() => {
    onItemClick?.(panelKey);
  }, "handleItemClick");
  const handleKeyDown = /* @__PURE__ */ __name((e3) => {
    if (e3.key === "Enter" || e3.keyCode === KeyCode_default.ENTER || e3.which === KeyCode_default.ENTER) {
      handleItemClick();
    }
  }, "handleKeyDown");
  let iconNode = typeof expandIcon === "function" ? expandIcon(props) : /* @__PURE__ */ React331.createElement("i", { className: "arrow" });
  if (iconNode) {
    iconNode = /* @__PURE__ */ React331.createElement(
      "div",
      {
        className: `${prefixCls}-expand-icon`,
        onClick: ["header", "icon"].includes(collapsible) ? handleItemClick : void 0
      },
      iconNode
    );
  }
  const collapsePanelClassNames = (0, import_classnames128.default)(
    {
      [`${prefixCls}-item`]: true,
      [`${prefixCls}-item-active`]: isActive2,
      [`${prefixCls}-item-disabled`]: disabled
    },
    className
  );
  const headerClassName = (0, import_classnames128.default)(headerClass, {
    [`${prefixCls}-header`]: true,
    [`${prefixCls}-header-collapsible-only`]: collapsibleHeader,
    [`${prefixCls}-icon-collapsible-only`]: collapsibleIcon
  });
  const headerProps = {
    className: headerClassName,
    "aria-expanded": isActive2,
    "aria-disabled": disabled,
    onKeyDown: handleKeyDown
  };
  if (!collapsibleHeader && !collapsibleIcon) {
    headerProps.onClick = handleItemClick;
    headerProps.role = accordion ? "tab" : "button";
    headerProps.tabIndex = disabled ? -1 : 0;
  }
  return /* @__PURE__ */ React331.createElement("div", { ...resetProps, ref, className: collapsePanelClassNames }, /* @__PURE__ */ React331.createElement("div", { ...headerProps }, showArrow && iconNode, /* @__PURE__ */ React331.createElement(
    "span",
    {
      className: `${prefixCls}-header-text`,
      onClick: collapsible === "header" ? handleItemClick : void 0
    },
    header
  ), ifExtraExist && /* @__PURE__ */ React331.createElement("div", { className: `${prefixCls}-extra` }, extra)), /* @__PURE__ */ React331.createElement(
    src_default2,
    {
      visible: isActive2,
      leavedClassName: `${prefixCls}-content-hidden`,
      ...openMotion,
      forceRender,
      removeOnLeave: destroyInactivePanel
    },
    ({ className: motionClassName, style: motionStyle }, motionRef) => {
      return /* @__PURE__ */ React331.createElement(
        PanelContent_default,
        {
          ref: motionRef,
          prefixCls,
          className: motionClassName,
          style: motionStyle,
          isActive: isActive2,
          forceRender,
          role: accordion ? "tabpanel" : void 0
        },
        children
      );
    }
  ));
});
var Panel_default3 = CollapsePanel;

// packages/collapse/src/hooks/useItems.tsx
var convertItemsToNodes3 = /* @__PURE__ */ __name((items, props) => {
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyInactivePanel,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon
  } = props;
  return items.map((item, index3) => {
    const {
      children,
      label,
      key: rawKey,
      collapsible: rawCollapsible,
      onItemClick: rawOnItemClick,
      destroyInactivePanel: rawDestroyInactivePanel,
      ...restProps
    } = item;
    const key = String(rawKey ?? index3);
    const mergeCollapsible = rawCollapsible ?? collapsible;
    const mergeDestroyInactivePanel = rawDestroyInactivePanel ?? destroyInactivePanel;
    const handleItemClick = /* @__PURE__ */ __name((value) => {
      if (mergeCollapsible === "disabled")
        return;
      onItemClick(value);
      rawOnItemClick?.(value);
    }, "handleItemClick");
    let isActive2 = false;
    if (accordion) {
      isActive2 = activeKey[0] === key;
    } else {
      isActive2 = activeKey.indexOf(key) > -1;
    }
    return /* @__PURE__ */ React332.createElement(
      Panel_default3,
      {
        ...restProps,
        prefixCls,
        key,
        panelKey: key,
        isActive: isActive2,
        accordion,
        openMotion,
        expandIcon,
        header: label,
        collapsible: mergeCollapsible,
        onItemClick: handleItemClick,
        destroyInactivePanel: mergeDestroyInactivePanel
      },
      children
    );
  });
}, "convertItemsToNodes");
var getNewChild = /* @__PURE__ */ __name((child, index3, props) => {
  if (!child)
    return null;
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyInactivePanel,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon
  } = props;
  const key = child.key || String(index3);
  const {
    header,
    headerClass,
    destroyInactivePanel: childDestroyInactivePanel,
    collapsible: childCollapsible,
    onItemClick: childOnItemClick
  } = child.props;
  let isActive2 = false;
  if (accordion) {
    isActive2 = activeKey[0] === key;
  } else {
    isActive2 = activeKey.indexOf(key) > -1;
  }
  const mergeCollapsible = childCollapsible ?? collapsible;
  const handleItemClick = /* @__PURE__ */ __name((value) => {
    if (mergeCollapsible === "disabled")
      return;
    onItemClick(value);
    childOnItemClick?.(value);
  }, "handleItemClick");
  const childProps = {
    key,
    panelKey: key,
    header,
    headerClass,
    isActive: isActive2,
    prefixCls,
    destroyInactivePanel: childDestroyInactivePanel ?? destroyInactivePanel,
    openMotion,
    accordion,
    children: child.props.children,
    onItemClick: handleItemClick,
    expandIcon,
    collapsible: mergeCollapsible
  };
  if (typeof child.type === "string") {
    return child;
  }
  Object.keys(childProps).forEach((propName) => {
    if (typeof childProps[propName] === "undefined") {
      delete childProps[propName];
    }
  });
  return React332.cloneElement(child, childProps);
}, "getNewChild");
function useItems3(items, rawChildren, props) {
  if (Array.isArray(items)) {
    return convertItemsToNodes3(items, props);
  }
  return toArray(rawChildren).map((child, index3) => getNewChild(child, index3, props));
}
__name(useItems3, "useItems");
var useItems_default = useItems3;

// packages/collapse/src/Collapse.tsx
function getActiveKeysArray(activeKey) {
  let currentActiveKey = activeKey;
  if (!Array.isArray(currentActiveKey)) {
    const activeKeyType = typeof currentActiveKey;
    currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
  }
  return currentActiveKey.map((key) => String(key));
}
__name(getActiveKeysArray, "getActiveKeysArray");
var Collapse = React333.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-collapse",
    destroyInactivePanel = false,
    style: style2,
    accordion,
    className,
    children,
    collapsible,
    openMotion,
    expandIcon,
    activeKey: rawActiveKey,
    defaultActiveKey,
    onChange,
    items
  } = props;
  const collapseClassName = (0, import_classnames129.default)(prefixCls, className);
  const [activeKey, setActiveKey] = useMergedState([], {
    value: rawActiveKey,
    onChange: (v) => onChange?.(v),
    defaultValue: defaultActiveKey,
    postState: getActiveKeysArray
  });
  const onItemClick = /* @__PURE__ */ __name((key) => setActiveKey(() => {
    if (accordion) {
      return activeKey[0] === key ? [] : [key];
    }
    const index3 = activeKey.indexOf(key);
    const isActive2 = index3 > -1;
    if (isActive2) {
      return activeKey.filter((item) => item !== key);
    }
    return [...activeKey, key];
  }), "onItemClick");
  warning_default(
    !children,
    "[rc-collapse] `children` will be removed in next major version. Please use `items` instead."
  );
  const mergedChildren = useItems_default(items, children, {
    prefixCls,
    accordion,
    openMotion,
    expandIcon,
    collapsible,
    destroyInactivePanel,
    onItemClick,
    activeKey
  });
  return /* @__PURE__ */ React333.createElement(
    "div",
    {
      ref,
      className: collapseClassName,
      style: style2,
      role: accordion ? "tablist" : void 0,
      ...pickAttrs(props, { aria: true, data: true })
    },
    mergedChildren
  );
});
var Collapse_default = Object.assign(Collapse, {
  /**
   * @deprecated use `items` instead, will be removed in `v4.0.0`
   */
  Panel: Panel_default3
});

// packages/collapse/src/index.tsx
var src_default15 = Collapse_default;
var { Panel: Panel3 } = Collapse_default;

// packages/ant-design/components/collapse/CollapsePanel.tsx
var import_classnames130 = __toESM(require_classnames());
import * as React334 from "react";
var CollapsePanel2 = React334.forwardRef((props, ref) => {
  if (true) {
    const warning5 = devUseWarning("Collapse.Panel");
    warning5.deprecated(!("disabled" in props), "disabled", 'collapsible="disabled"');
  }
  const { getPrefixCls } = React334.useContext(ConfigContext);
  const { prefixCls: customizePrefixCls, className, showArrow = true } = props;
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const collapsePanelClassName = (0, import_classnames130.default)(
    {
      [`${prefixCls}-no-arrow`]: !showArrow
    },
    className
  );
  return /* @__PURE__ */ React334.createElement(
    src_default15.Panel,
    {
      ref,
      ...props,
      prefixCls,
      className: collapsePanelClassName
    }
  );
});
var CollapsePanel_default = CollapsePanel2;

// packages/ant-design/components/collapse/style/index.ts
var genBaseStyle9 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    contentBg,
    padding,
    headerBg,
    headerPadding,
    collapseHeaderPaddingSM,
    collapseHeaderPaddingLG,
    collapsePanelBorderRadius,
    lineWidth,
    lineType,
    colorBorder,
    colorText,
    colorTextHeading,
    colorTextDisabled,
    fontSizeLG,
    lineHeight,
    lineHeightLG,
    marginSM,
    paddingSM,
    paddingLG,
    paddingXS,
    motionDurationSlow,
    fontSizeIcon,
    contentPadding,
    fontHeight,
    fontHeightLG
  } = token2;
  const borderBase = `${unit(lineWidth)} ${lineType} ${colorBorder}`;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      backgroundColor: headerBg,
      border: borderBase,
      borderBottom: 0,
      borderRadius: collapsePanelBorderRadius,
      [`&-rtl`]: {
        direction: "rtl"
      },
      [`& > ${componentCls}-item`]: {
        borderBottom: borderBase,
        [`&:last-child`]: {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(
              collapsePanelBorderRadius
            )}`
          }
        },
        [`> ${componentCls}-header`]: {
          position: "relative",
          // Compatible with old version of antd, should remove in next version
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: headerPadding,
          color: colorTextHeading,
          lineHeight,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}, visibility 0s`,
          [`> ${componentCls}-header-text`]: {
            flex: "auto"
          },
          "&:focus": {
            outline: "none"
          },
          // >>>>> Arrow
          [`${componentCls}-expand-icon`]: {
            height: fontHeight,
            display: "flex",
            alignItems: "center",
            paddingInlineEnd: marginSM
          },
          [`${componentCls}-arrow`]: {
            ...resetIcon(),
            fontSize: fontSizeIcon,
            // when `transform: rotate()` is applied to icon's root element
            transition: `transform ${motionDurationSlow}`,
            // when `transform: rotate()` is applied to icon's child element
            svg: {
              transition: `transform ${motionDurationSlow}`
            }
          },
          // >>>>> Text
          [`${componentCls}-header-text`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${componentCls}-icon-collapsible-only`]: {
          cursor: "unset",
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        }
      },
      [`${componentCls}-content`]: {
        color: colorText,
        backgroundColor: contentBg,
        borderTop: borderBase,
        [`& > ${componentCls}-content-box`]: {
          padding: contentPadding
        },
        [`&-hidden`]: {
          display: "none"
        }
      },
      [`&-small`]: {
        [`> ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingSM,
            paddingInlineStart: paddingXS,
            [`> ${componentCls}-expand-icon`]: {
              // Arrow offset
              marginInlineStart: token2.calc(paddingSM).sub(paddingXS).equal()
            }
          },
          [`> ${componentCls}-content > ${componentCls}-content-box`]: {
            padding: paddingSM
          }
        }
      },
      [`&-large`]: {
        [`> ${componentCls}-item`]: {
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingLG,
            paddingInlineStart: padding,
            [`> ${componentCls}-expand-icon`]: {
              height: fontHeightLG,
              // Arrow offset
              marginInlineStart: token2.calc(paddingLG).sub(padding).equal()
            }
          },
          [`> ${componentCls}-content > ${componentCls}-content-box`]: {
            padding: paddingLG
          }
        }
      },
      [`${componentCls}-item:last-child`]: {
        [`> ${componentCls}-content`]: {
          borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}`
        }
      },
      [`& ${componentCls}-item-disabled > ${componentCls}-header`]: {
        [`
          &,
          & > .arrow
        `]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Position ==========================
      [`&${componentCls}-icon-position-end`]: {
        [`& > ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            [`${componentCls}-expand-icon`]: {
              order: 1,
              paddingInlineEnd: 0,
              paddingInlineStart: marginSM
            }
          }
        }
      }
    }
  };
}, "genBaseStyle");
var genArrowStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
  return {
    [`${componentCls}-rtl`]: {
      [fixedSelector]: {
        transform: `rotate(180deg)`
      }
    }
  };
}, "genArrowStyle");
var genBorderlessStyle3 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    headerBg,
    paddingXXS,
    colorBorder
  } = token2;
  return {
    [`${componentCls}-borderless`]: {
      backgroundColor: headerBg,
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: `1px solid ${colorBorder}`
      },
      [`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: {
        borderRadius: 0
      },
      [`> ${componentCls}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${componentCls}-item > ${componentCls}-content`]: {
        backgroundColor: "transparent",
        borderTop: 0
      },
      [`> ${componentCls}-item > ${componentCls}-content > ${componentCls}-content-box`]: {
        paddingTop: paddingXXS
      }
    }
  };
}, "genBorderlessStyle");
var genGhostStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, paddingSM } = token2;
  return {
    [`${componentCls}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: 0,
        [`> ${componentCls}-content`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${componentCls}-content-box`]: {
            paddingBlock: paddingSM
          }
        }
      }
    }
  };
}, "genGhostStyle");
var prepareComponentToken26 = /* @__PURE__ */ __name((token2) => ({
  headerPadding: `${token2.paddingSM}px ${token2.padding}px`,
  headerBg: token2.colorFillAlter,
  contentPadding: `${token2.padding}px 16px`,
  // Fixed Value
  contentBg: token2.colorBgContainer
}), "prepareComponentToken");
var style_default31 = genStyleHooks(
  "Collapse",
  (token2) => {
    const collapseToken = merge2(token2, {
      collapseHeaderPaddingSM: `${unit(token2.paddingXS)} ${unit(token2.paddingSM)}`,
      collapseHeaderPaddingLG: `${unit(token2.padding)} ${unit(token2.paddingLG)}`,
      collapsePanelBorderRadius: token2.borderRadiusLG
    });
    return [
      genBaseStyle9(collapseToken),
      genBorderlessStyle3(collapseToken),
      genGhostStyle(collapseToken),
      genArrowStyle(collapseToken),
      collapse_default(collapseToken)
    ];
  },
  prepareComponentToken26
);

// packages/ant-design/components/collapse/Collapse.tsx
var Collapse2 = React335.forwardRef((props, ref) => {
  const { getPrefixCls, direction, collapse } = React335.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    bordered = true,
    ghost,
    size: customizeSize,
    expandIconPosition = "start",
    children,
    expandIcon
  } = props;
  const mergedSize = useSize_default((ctx) => customizeSize ?? ctx ?? "middle");
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [wrapCSSVar, hashId, cssVarCls] = style_default31(prefixCls);
  if (true) {
    const warning5 = devUseWarning("Collapse");
    warning5(
      expandIconPosition !== "left" && expandIconPosition !== "right",
      "deprecated",
      "`expandIconPosition` with `left` or `right` is deprecated. Please use `start` or `end` instead."
    );
  }
  const mergedExpandIconPosition = React335.useMemo(() => {
    if (expandIconPosition === "left") {
      return "start";
    }
    return expandIconPosition === "right" ? "end" : expandIconPosition;
  }, [expandIconPosition]);
  const mergedExpandIcon = expandIcon ?? collapse?.expandIcon;
  const renderExpandIcon3 = React335.useCallback(
    (panelProps = {}) => {
      const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : /* @__PURE__ */ React335.createElement(import_RightOutlined4.default, { rotate: panelProps.isActive ? 90 : void 0 });
      return cloneElement3(icon, () => ({
        className: (0, import_classnames131.default)(icon?.props?.className, `${prefixCls}-arrow`)
      }));
    },
    [mergedExpandIcon, prefixCls]
  );
  const collapseClassName = (0, import_classnames131.default)(
    `${prefixCls}-icon-position-${mergedExpandIconPosition}`,
    {
      [`${prefixCls}-borderless`]: !bordered,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-ghost`]: !!ghost,
      [`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
    },
    collapse?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const openMotion = {
    ...motion_default(rootPrefixCls),
    motionAppear: false,
    leavedClassName: `${prefixCls}-content-hidden`
  };
  const items = React335.useMemo(
    () => children ? toArray(children).map((child, index3) => {
      if (child.props?.disabled) {
        const key = child.key ?? String(index3);
        const { disabled, collapsible } = child.props;
        const childProps = {
          ...omit(child.props, ["disabled"]),
          key,
          collapsible: collapsible ?? (disabled ? "disabled" : void 0)
        };
        return cloneElement3(child, childProps);
      }
      return child;
    }) : null,
    [children]
  );
  return wrapCSSVar(
    // @ts-ignore
    /* @__PURE__ */ React335.createElement(
      src_default15,
      {
        ref,
        openMotion,
        ...omit(props, ["rootClassName"]),
        expandIcon: renderExpandIcon3,
        prefixCls,
        className: collapseClassName,
        style: { ...collapse?.style, ...style2 }
      },
      items
    )
  );
});
if (true) {
  Collapse2.displayName = "Collapse";
}
var Collapse_default2 = Object.assign(Collapse2, { Panel: CollapsePanel_default });

// packages/ant-design/components/collapse/index.ts
var collapse_default2 = Collapse_default2;

// packages/ant-design/components/color-picker/ColorPicker.tsx
var import_classnames153 = __toESM(require_classnames());
import React374, { useContext as useContext144, useMemo as useMemo109, useRef as useRef121 } from "react";

// packages/ant-design/components/color-picker/ColorPickerPanel.tsx
import React372 from "react";

// packages/ant-design/components/divider/index.tsx
var import_classnames132 = __toESM(require_classnames());
import * as React336 from "react";

// packages/ant-design/components/divider/style/index.ts
var genSharedDividerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth,
    textPaddingInline,
    orientationMargin,
    verticalMarginInline
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: verticalMarginInline,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${unit(lineWidth)} solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${unit(token2.dividerHorizontalGutterMargin)} 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${unit(token2.dividerHorizontalWithTextGutterMargin)} 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${unit(lineWidth)} solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-left`]: {
        "&::before": {
          width: `calc(${orientationMargin} * 100%)`
        },
        "&::after": {
          width: `calc(100% - ${orientationMargin} * 100%)`
        }
      },
      [`&-horizontal${componentCls}-with-text-right`]: {
        "&::before": {
          width: `calc(100% - ${orientationMargin} * 100%)`
        },
        "&::after": {
          width: `calc(${orientationMargin} * 100%)`
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: textPaddingInline
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${unit(lineWidth)} 0 0`
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    }
  };
}, "genSharedDividerStyle");
var prepareComponentToken27 = /* @__PURE__ */ __name((token2) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: token2.marginXS
}), "prepareComponentToken");
var style_default32 = genStyleHooks(
  "Divider",
  (token2) => {
    const dividerToken = merge2(token2, {
      dividerHorizontalWithTextGutterMargin: token2.margin,
      dividerHorizontalGutterMargin: token2.marginLG,
      sizePaddingEdgeHorizontal: 0
    });
    return [genSharedDividerStyle(dividerToken)];
  },
  prepareComponentToken27,
  {
    unitless: {
      orientationMargin: true
    }
  }
);

// packages/ant-design/components/divider/index.tsx
var Divider2 = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction, divider } = React336.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type: type5 = "horizontal",
    orientation = "center",
    orientationMargin,
    className,
    rootClassName,
    children,
    dashed,
    plain,
    style: style2,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("divider", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default32(prefixCls);
  const orientationPrefix = orientation.length > 0 ? `-${orientation}` : orientation;
  const hasChildren = !!children;
  const hasCustomMarginLeft = orientation === "left" && orientationMargin != null;
  const hasCustomMarginRight = orientation === "right" && orientationMargin != null;
  const classString = (0, import_classnames132.default)(
    prefixCls,
    divider?.className,
    hashId,
    cssVarCls,
    `${prefixCls}-${type5}`,
    {
      [`${prefixCls}-with-text`]: hasChildren,
      [`${prefixCls}-with-text${orientationPrefix}`]: hasChildren,
      [`${prefixCls}-dashed`]: !!dashed,
      [`${prefixCls}-plain`]: !!plain,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft,
      [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight
    },
    className,
    rootClassName
  );
  const memoizedOrientationMargin = React336.useMemo(() => {
    if (typeof orientationMargin === "number") {
      return orientationMargin;
    }
    if (/^\d+$/.test(orientationMargin)) {
      return Number(orientationMargin);
    }
    return orientationMargin;
  }, [orientationMargin]);
  const innerStyle = {
    ...hasCustomMarginLeft && { marginLeft: memoizedOrientationMargin },
    ...hasCustomMarginRight && { marginRight: memoizedOrientationMargin }
  };
  if (true) {
    const warning5 = devUseWarning("Divider");
    warning5(
      !children || type5 !== "vertical",
      "usage",
      "`children` not working in `vertical` mode."
    );
  }
  return wrapCSSVar(
    /* @__PURE__ */ React336.createElement(
      "div",
      {
        className: classString,
        style: { ...divider?.style, ...style2 },
        ...restProps,
        role: "separator"
      },
      children && type5 !== "vertical" && /* @__PURE__ */ React336.createElement("span", { className: `${prefixCls}-inner-text`, style: innerStyle }, children)
    )
  );
}, "Divider");
if (true) {
  Divider2.displayName = "Divider";
}
var divider_default = Divider2;

// packages/ant-design/components/color-picker/components/PanelPicker.tsx
import React369, { useContext as useContext142 } from "react";

// packages/color-picker/src/ColorPicker.tsx
import React344, { forwardRef as forwardRef77, useMemo as useMemo100 } from "react";

// packages/color-picker/src/color.ts
init_public_api();
var getRoundNumber = /* @__PURE__ */ __name((value) => Math.round(Number(value || 0)), "getRoundNumber");
var convertHsb2Hsv = /* @__PURE__ */ __name((color) => {
  if (color && typeof color === "object" && "h" in color && "b" in color) {
    const { b, ...resets } = color;
    return {
      ...resets,
      v: b
    };
  }
  if (typeof color === "string" && /hsb/.test(color)) {
    return color.replace(/hsb/, "hsv");
  }
  return color;
}, "convertHsb2Hsv");
var Color = class extends TinyColor {
  static {
    __name(this, "Color");
  }
  constructor(color) {
    super(convertHsb2Hsv(color));
  }
  toHsbString() {
    const hsb = this.toHsb();
    const saturation = getRoundNumber(hsb.s * 100);
    const lightness = getRoundNumber(hsb.b * 100);
    const hue = getRoundNumber(hsb.h);
    const alpha = hsb.a;
    const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
    const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha.toFixed(
      alpha === 0 ? 0 : 2
    )})`;
    return alpha === 1 ? hsbString : hsbaString;
  }
  toHsb() {
    let hsv = this.toHsv();
    if (typeof this.originalInput === "object" && this.originalInput) {
      if ("h" in this.originalInput) {
        hsv = this.originalInput;
      }
    }
    const { v, ...resets } = hsv;
    return {
      ...resets,
      b: hsv.v,
      a: this.a
    };
  }
};

// packages/color-picker/src/util.ts
var ColorPickerPrefixCls = "rc-color-picker";
var generateColor = /* @__PURE__ */ __name((color) => {
  if (color instanceof Color) {
    return color;
  }
  return new Color(color);
}, "generateColor");
var defaultColor = generateColor("#1677ff");
var calculateColor = /* @__PURE__ */ __name((props) => {
  const { offset: offset3, targetRef, containerRef, color, type: type5 } = props;
  const { width, height } = containerRef.current.getBoundingClientRect();
  const { width: targetWidth, height: targetHeight } = targetRef.current.getBoundingClientRect();
  const centerOffsetX = targetWidth / 2;
  const centerOffsetY = targetHeight / 2;
  const saturation = (offset3.x + centerOffsetX) / width;
  const bright = 1 - (offset3.y + centerOffsetY) / height;
  const hsb = color.toHsb();
  const alphaOffset = saturation;
  const hueOffset = (offset3.x + centerOffsetX) / width * 360;
  if (type5) {
    switch (type5) {
      case "hue":
        return generateColor({
          ...hsb,
          h: hueOffset <= 0 ? 0 : hueOffset
        });
      case "alpha":
        return generateColor({
          ...hsb,
          a: alphaOffset <= 0 ? 0 : alphaOffset
        });
    }
  }
  return generateColor({
    h: hsb.h,
    s: saturation <= 0 ? 0 : saturation,
    b: bright >= 1 ? 1 : bright,
    a: hsb.a
  });
}, "calculateColor");
var calculateOffset = /* @__PURE__ */ __name((containerRef, targetRef, color, type5) => {
  const { width, height } = containerRef.current.getBoundingClientRect();
  const { width: targetWidth, height: targetHeight } = targetRef.current.getBoundingClientRect();
  const centerOffsetX = targetWidth / 2;
  const centerOffsetY = targetHeight / 2;
  const hsb = color.toHsb();
  if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
    return;
  }
  if (type5) {
    switch (type5) {
      case "hue":
        return {
          x: hsb.h / 360 * width - centerOffsetX,
          y: -centerOffsetY / 3
        };
      case "alpha":
        return {
          x: hsb.a / 1 * width - centerOffsetX,
          y: -centerOffsetY / 3
        };
    }
  }
  return {
    x: hsb.s * width - centerOffsetX,
    y: (1 - hsb.b) * height - centerOffsetY
  };
}, "calculateOffset");

// packages/color-picker/src/ColorPicker.tsx
var import_classnames136 = __toESM(require_classnames());

// packages/color-picker/src/components/ColorBlock.tsx
var import_classnames133 = __toESM(require_classnames());
import React337 from "react";
var ColorBlock = /* @__PURE__ */ __name(({
  color,
  prefixCls,
  className,
  style: style2,
  onClick
}) => {
  const colorBlockCls = `${prefixCls}-color-block`;
  return /* @__PURE__ */ React337.createElement(
    "div",
    {
      className: (0, import_classnames133.default)(colorBlockCls, className),
      style: style2,
      onClick
    },
    /* @__PURE__ */ React337.createElement(
      "div",
      {
        className: `${colorBlockCls}-inner`,
        style: {
          background: color
        }
      }
    )
  );
}, "ColorBlock");
var ColorBlock_default = ColorBlock;

// packages/color-picker/src/components/Picker.tsx
import React341, { useRef as useRef102 } from "react";

// packages/color-picker/src/hooks/useColorDrag.ts
import { useEffect as useEffect77, useRef as useRef101, useState as useState72 } from "react";
function getPosition2(e3) {
  const obj = "touches" in e3 ? e3.touches[0] : e3;
  const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
  const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
  return { pageX: obj.pageX - scrollXOffset, pageY: obj.pageY - scrollYOffset };
}
__name(getPosition2, "getPosition");
function useColorDrag(props) {
  const {
    offset: offset3,
    targetRef,
    containerRef,
    direction,
    onDragChange,
    onDragChangeComplete,
    calculate,
    color,
    disabledDrag
  } = props;
  const [offsetValue, setOffsetValue] = useState72(offset3 || { x: 0, y: 0 });
  const mouseMoveRef = useRef101(null);
  const mouseUpRef = useRef101(null);
  const dragRef = useRef101({
    flag: false
  });
  useEffect77(() => {
    if (dragRef.current.flag === false) {
      const calcOffset = calculate?.(containerRef);
      if (calcOffset) {
        setOffsetValue(calcOffset);
      }
    }
  }, [color, containerRef]);
  useEffect77(
    () => () => {
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      document.removeEventListener("touchmove", mouseMoveRef.current);
      document.removeEventListener("touchend", mouseUpRef.current);
      mouseMoveRef.current = null;
      mouseUpRef.current = null;
    },
    []
  );
  const updateOffset = /* @__PURE__ */ __name((e3) => {
    const { pageX, pageY } = getPosition2(e3);
    const {
      x: rectX,
      y: rectY,
      width,
      height
    } = containerRef.current.getBoundingClientRect();
    const { width: targetWidth, height: targetHeight } = targetRef.current.getBoundingClientRect();
    const centerOffsetX = targetWidth / 2;
    const centerOffsetY = targetHeight / 2;
    const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
    const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
    const calcOffset = {
      x: offsetX,
      y: direction === "x" ? offsetValue.y : offsetY
    };
    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
      return false;
    }
    setOffsetValue(calcOffset);
    onDragChange?.(calcOffset);
  }, "updateOffset");
  const onDragMove = /* @__PURE__ */ __name((e3) => {
    e3.preventDefault();
    updateOffset(e3);
  }, "onDragMove");
  const onDragStop = /* @__PURE__ */ __name((e3) => {
    e3.preventDefault();
    dragRef.current.flag = false;
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    document.removeEventListener("touchmove", mouseMoveRef.current);
    document.removeEventListener("touchend", mouseUpRef.current);
    mouseMoveRef.current = null;
    mouseUpRef.current = null;
    onDragChangeComplete?.();
  }, "onDragStop");
  const onDragStart = /* @__PURE__ */ __name((e3) => {
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    if (disabledDrag) {
      return;
    }
    updateOffset(e3);
    dragRef.current.flag = true;
    document.addEventListener("mousemove", onDragMove);
    document.addEventListener("mouseup", onDragStop);
    document.addEventListener("touchmove", onDragMove);
    document.addEventListener("touchend", onDragStop);
    mouseMoveRef.current = onDragMove;
    mouseUpRef.current = onDragStop;
  }, "onDragStart");
  return [offsetValue, onDragStart];
}
__name(useColorDrag, "useColorDrag");
var useColorDrag_default = useColorDrag;

// packages/color-picker/src/components/Handler.tsx
var import_classnames134 = __toESM(require_classnames());
import React338 from "react";
var Handler = /* @__PURE__ */ __name(({ size = "default", color, prefixCls }) => {
  return /* @__PURE__ */ React338.createElement(
    "div",
    {
      className: (0, import_classnames134.default)(`${prefixCls}-handler`, {
        [`${prefixCls}-handler-sm`]: size === "small"
      }),
      style: {
        backgroundColor: color
      }
    }
  );
}, "Handler");
var Handler_default = Handler;

// packages/color-picker/src/components/Palette.tsx
import React339 from "react";
var Palette = /* @__PURE__ */ __name(({ children, style: style2, prefixCls }) => {
  return /* @__PURE__ */ React339.createElement(
    "div",
    {
      className: `${prefixCls}-palette`,
      style: {
        position: "relative",
        ...style2
      }
    },
    children
  );
}, "Palette");
var Palette_default = Palette;

// packages/color-picker/src/components/Transform.tsx
import React340, { forwardRef as forwardRef76 } from "react";
var Transform = forwardRef76((props, ref) => {
  const { children, offset: offset3 } = props;
  return /* @__PURE__ */ React340.createElement(
    "div",
    {
      ref,
      style: {
        position: "absolute",
        left: offset3.x,
        top: offset3.y,
        zIndex: 1
      }
    },
    children
  );
});
var Transform_default = Transform;

// packages/color-picker/src/components/Picker.tsx
var Picker2 = /* @__PURE__ */ __name(({
  color,
  onChange,
  prefixCls,
  onChangeComplete,
  disabled
}) => {
  const pickerRef = useRef102();
  const transformRef = useRef102();
  const colorRef = useRef102(color);
  const onDragChange = useEvent((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: pickerRef,
      color
    });
    colorRef.current = calcColor;
    onChange(calcColor);
  });
  const [offset3, dragStartHandle] = useColorDrag_default({
    color,
    containerRef: pickerRef,
    targetRef: transformRef,
    calculate: (containerRef) => calculateOffset(containerRef, transformRef, color),
    onDragChange,
    onDragChangeComplete: () => onChangeComplete?.(colorRef.current),
    disabledDrag: disabled
  });
  return /* @__PURE__ */ React341.createElement(
    "div",
    {
      ref: pickerRef,
      className: `${prefixCls}-select`,
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    },
    /* @__PURE__ */ React341.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ React341.createElement(Transform_default, { offset: offset3, ref: transformRef }, /* @__PURE__ */ React341.createElement(Handler_default, { color: color.toRgbString(), prefixCls })), /* @__PURE__ */ React341.createElement(
      "div",
      {
        className: `${prefixCls}-saturation`,
        style: {
          backgroundColor: `hsl(${color.toHsb().h},100%, 50%)`,
          backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
        }
      }
    ))
  );
}, "Picker");
var Picker_default = Picker2;

// packages/color-picker/src/components/Slider.tsx
var import_classnames135 = __toESM(require_classnames());
import React343, { useRef as useRef103 } from "react";

// packages/color-picker/src/components/Gradient.tsx
import React342, { useMemo as useMemo99 } from "react";
var Gradient = /* @__PURE__ */ __name(({ colors, children, direction = "to right", type: type5, prefixCls }) => {
  const gradientColors = useMemo99(
    () => colors.map((color, idx) => {
      const result = generateColor(color);
      if (type5 === "alpha" && idx === colors.length - 1) {
        result.setAlpha(1);
      }
      return result.toRgbString();
    }).join(","),
    [colors, type5]
  );
  return /* @__PURE__ */ React342.createElement(
    "div",
    {
      className: `${prefixCls}-gradient`,
      style: {
        position: "absolute",
        inset: 0,
        background: `linear-gradient(${direction}, ${gradientColors})`
      }
    },
    children
  );
}, "Gradient");
var Gradient_default = Gradient;

// packages/color-picker/src/components/Slider.tsx
var Slider2 = /* @__PURE__ */ __name(({
  gradientColors,
  direction,
  type: type5 = "hue",
  color,
  value,
  onChange,
  onChangeComplete,
  disabled,
  prefixCls
}) => {
  const sliderRef = useRef103();
  const transformRef = useRef103();
  const colorRef = useRef103(color);
  const onDragChange = useEvent((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: sliderRef,
      color,
      type: type5
    });
    colorRef.current = calcColor;
    onChange(calcColor);
  });
  const [offset3, dragStartHandle] = useColorDrag_default({
    color,
    targetRef: transformRef,
    containerRef: sliderRef,
    calculate: (containerRef) => calculateOffset(containerRef, transformRef, color, type5),
    onDragChange,
    onDragChangeComplete() {
      onChangeComplete?.(colorRef.current, type5);
    },
    direction: "x",
    disabledDrag: disabled
  });
  return /* @__PURE__ */ React343.createElement(
    "div",
    {
      ref: sliderRef,
      className: (0, import_classnames135.default)(
        `${prefixCls}-slider`,
        `${prefixCls}-slider-${type5}`
      ),
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    },
    /* @__PURE__ */ React343.createElement(Palette_default, { prefixCls }, /* @__PURE__ */ React343.createElement(Transform_default, { offset: offset3, ref: transformRef }, /* @__PURE__ */ React343.createElement(Handler_default, { size: "small", color: value, prefixCls })), /* @__PURE__ */ React343.createElement(
      Gradient_default,
      {
        colors: gradientColors,
        direction,
        type: type5,
        prefixCls
      }
    ))
  );
}, "Slider");
var Slider_default = Slider2;

// packages/color-picker/src/hooks/useColorState.ts
import { useEffect as useEffect78, useState as useState73 } from "react";
function hasValue3(value) {
  return value !== void 0;
}
__name(hasValue3, "hasValue");
var useColorState = /* @__PURE__ */ __name((defaultStateValue, option) => {
  const { defaultValue, value } = option;
  const [colorValue, setColorValue] = useState73(() => {
    let mergeState;
    if (hasValue3(value)) {
      mergeState = value;
    } else if (hasValue3(defaultValue)) {
      mergeState = defaultValue;
    } else {
      mergeState = defaultStateValue;
    }
    return generateColor(mergeState);
  });
  useEffect78(() => {
    if (value) {
      setColorValue(generateColor(value));
    }
  }, [value]);
  return [colorValue, setColorValue];
}, "useColorState");
var useColorState_default = useColorState;

// packages/color-picker/src/ColorPicker.tsx
var hueColor = [
  "rgb(255, 0, 0) 0%",
  "rgb(255, 255, 0) 17%",
  "rgb(0, 255, 0) 33%",
  "rgb(0, 255, 255) 50%",
  "rgb(0, 0, 255) 67%",
  "rgb(255, 0, 255) 83%",
  "rgb(255, 0, 0) 100%"
];
var ColorPicker_default = forwardRef77((props, ref) => {
  const {
    value,
    defaultValue,
    prefixCls = ColorPickerPrefixCls,
    onChange,
    onChangeComplete,
    className,
    style: style2,
    panelRender,
    disabledAlpha = false,
    disabled = false
  } = props;
  const [colorValue, setColorValue] = useColorState_default(defaultColor, {
    value,
    defaultValue
  });
  const alphaColor = useMemo100(() => {
    const rgb = generateColor(colorValue.toRgbString());
    rgb.setAlpha(1);
    return rgb.toRgbString();
  }, [colorValue]);
  const mergeCls = (0, import_classnames136.default)(`${prefixCls}-panel`, className, {
    [`${prefixCls}-panel-disabled`]: disabled
  });
  const basicProps = {
    prefixCls,
    onChangeComplete,
    disabled
  };
  const handleChange = /* @__PURE__ */ __name((data, type5) => {
    if (!value) {
      setColorValue(data);
    }
    onChange?.(data, type5);
  }, "handleChange");
  const defaultPanel = /* @__PURE__ */ React344.createElement(React344.Fragment, null, /* @__PURE__ */ React344.createElement(Picker_default, { color: colorValue, onChange: handleChange, ...basicProps }), /* @__PURE__ */ React344.createElement("div", { className: `${prefixCls}-slider-container` }, /* @__PURE__ */ React344.createElement(
    "div",
    {
      className: (0, import_classnames136.default)(`${prefixCls}-slider-group`, {
        [`${prefixCls}-slider-group-disabled-alpha`]: disabledAlpha
      })
    },
    /* @__PURE__ */ React344.createElement(
      Slider_default,
      {
        gradientColors: hueColor,
        color: colorValue,
        value: `hsl(${colorValue.toHsb().h},100%, 50%)`,
        onChange: (color) => handleChange(color, "hue"),
        ...basicProps
      }
    ),
    !disabledAlpha && /* @__PURE__ */ React344.createElement(
      Slider_default,
      {
        type: "alpha",
        gradientColors: ["rgba(255, 0, 4, 0) 0%", alphaColor],
        color: colorValue,
        value: colorValue.toRgbString(),
        onChange: (color) => handleChange(color, "alpha"),
        ...basicProps
      }
    )
  ), /* @__PURE__ */ React344.createElement(ColorBlock_default, { color: colorValue.toRgbString(), prefixCls })));
  return /* @__PURE__ */ React344.createElement("div", { className: mergeCls, style: style2, ref }, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
});

// packages/color-picker/src/index.tsx
var src_default16 = ColorPicker_default;

// packages/ant-design/components/color-picker/context.ts
import React345 from "react";
var PanelPickerContext = React345.createContext({});
var PanelPresetsContext = React345.createContext({});
var { Provider: PanelPickerProvider } = PanelPickerContext;
var { Provider: PanelPresetsProvider } = PanelPresetsContext;

// packages/ant-design/components/color-picker/color.ts
var toHexFormat = /* @__PURE__ */ __name((value, alpha) => value?.replace(/[^\w/]/gi, "").slice(0, alpha ? 8 : 6) || "", "toHexFormat");
var getHex = /* @__PURE__ */ __name((value, alpha) => value ? toHexFormat(value, alpha) : "", "getHex");
var ColorFactory = class {
  constructor(color) {
    this.cleared = false;
    this.metaColor = new Color(color);
    if (!color) {
      this.metaColor.setAlpha(0);
      this.cleared = true;
    }
  }
  static {
    __name(this, "ColorFactory");
  }
  toHsb() {
    return this.metaColor.toHsb();
  }
  toHsbString() {
    return this.metaColor.toHsbString();
  }
  toHex() {
    return getHex(this.toHexString(), this.metaColor.getAlpha() < 1);
  }
  toHexString() {
    return this.metaColor.getAlpha() === 1 ? this.metaColor.toHexString() : this.metaColor.toHex8String();
  }
  toRgb() {
    return this.metaColor.toRgb();
  }
  toRgbString() {
    return this.metaColor.toRgbString();
  }
};

// packages/ant-design/components/color-picker/util.ts
var generateColor2 = /* @__PURE__ */ __name((color) => {
  if (color instanceof ColorFactory) {
    return color;
  }
  return new ColorFactory(color);
}, "generateColor");
var getRoundNumber2 = /* @__PURE__ */ __name((value) => Math.round(Number(value || 0)), "getRoundNumber");
var getAlphaColor3 = /* @__PURE__ */ __name((color) => getRoundNumber2(color.toHsb().a * 100), "getAlphaColor");
var genAlphaColor = /* @__PURE__ */ __name((color, alpha) => {
  const hsba = color.toHsb();
  hsba.a = alpha || 1;
  return generateColor2(hsba);
}, "genAlphaColor");

// packages/ant-design/components/color-picker/components/ColorClear.tsx
import React346 from "react";
var ColorClear = /* @__PURE__ */ __name(({ prefixCls, value, onChange }) => {
  const handleClick = /* @__PURE__ */ __name(() => {
    if (value && !value.cleared) {
      const hsba = value.toHsb();
      hsba.a = 0;
      const genColor = generateColor2(hsba);
      genColor.cleared = true;
      onChange?.(genColor);
    }
  }, "handleClick");
  return /* @__PURE__ */ React346.createElement("div", { className: `${prefixCls}-clear`, onClick: handleClick });
}, "ColorClear");
var ColorClear_default = ColorClear;

// packages/ant-design/components/color-picker/components/ColorInput.tsx
import React368, { useMemo as useMemo106 } from "react";

// packages/ant-design/components/color-picker/components/ColorAlphaInput.tsx
import React354, { useEffect as useEffect84, useState as useState78 } from "react";

// packages/ant-design/components/color-picker/components/ColorSteppers.tsx
var import_classnames142 = __toESM(require_classnames());
import React353, { useEffect as useEffect83, useState as useState77 } from "react";

// packages/ant-design/components/input-number/index.tsx
var import_DownOutlined3 = __toESM(require_DownOutlined3());
var import_UpOutlined = __toESM(require_UpOutlined3());
var import_classnames141 = __toESM(require_classnames());
import * as React352 from "react";

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
  return typeof BigInt === "function";
}
__name(supportBigInt, "supportBigInt");

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/numberUtil.js
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
__name(isEmpty, "isEmpty");
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
__name(trimNumber, "trimNumber");
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
__name(isE, "isE");
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
__name(getNumberPrecision, "getNumberPrecision");
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
__name(num2str, "num2str");
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}
__name(validateNumber, "validateNumber");

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js
var BigIntDecimal = /* @__PURE__ */ function() {
  function BigIntDecimal2(value) {
    _classCallCheck(this, BigIntDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "negative", void 0);
    _defineProperty(this, "integer", void 0);
    _defineProperty(this, "decimal", void 0);
    _defineProperty(this, "decimalLen", void 0);
    _defineProperty(this, "empty", void 0);
    _defineProperty(this, "nan", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-" || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  __name(BigIntDecimal2, "BigIntDecimal");
  _createClass(BigIntDecimal2, [{
    key: "getMark",
    value: /* @__PURE__ */ __name(function getMark2() {
      return this.negative ? "-" : "";
    }, "getMark")
  }, {
    key: "getIntegerStr",
    value: /* @__PURE__ */ __name(function getIntegerStr() {
      return this.integer.toString();
    }, "getIntegerStr")
    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: /* @__PURE__ */ __name(function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }, "getDecimalStr")
    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: /* @__PURE__ */ __name(function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }, "alignDecimal")
  }, {
    key: "negate",
    value: /* @__PURE__ */ __name(function negate() {
      var clone = new BigIntDecimal2(this.toString());
      clone.negative = !clone.negative;
      return clone;
    }, "negate")
  }, {
    key: "cal",
    value: /* @__PURE__ */ __name(function cal(offset3, calculator, calDecimalLen) {
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
      var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
      var nextDecimalLength = calDecimalLen(maxDecimalLength);
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
    }, "cal")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function add(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value);
      }
      var offset3 = new BigIntDecimal2(value);
      if (offset3.isInvalidate()) {
        return this;
      }
      return this.cal(offset3, function(num1, num2) {
        return num1 + num2;
      }, function(len) {
        return len;
      });
    }, "add")
  }, {
    key: "multi",
    value: /* @__PURE__ */ __name(function multi(value) {
      var target = new BigIntDecimal2(value);
      if (this.isInvalidate() || target.isInvalidate()) {
        return new BigIntDecimal2(NaN);
      }
      return this.cal(target, function(num1, num2) {
        return num1 * num2;
      }, function(len) {
        return len * 2;
      });
    }, "multi")
  }, {
    key: "isEmpty",
    value: /* @__PURE__ */ __name(function isEmpty2() {
      return this.empty;
    }, "isEmpty")
  }, {
    key: "isNaN",
    value: /* @__PURE__ */ __name(function isNaN2() {
      return this.nan;
    }, "isNaN")
  }, {
    key: "isInvalidate",
    value: /* @__PURE__ */ __name(function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }, "isInvalidate")
  }, {
    key: "equals",
    value: /* @__PURE__ */ __name(function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }, "equals")
  }, {
    key: "lessEquals",
    value: /* @__PURE__ */ __name(function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }, "lessEquals")
  }, {
    key: "toNumber",
    value: /* @__PURE__ */ __name(function toNumber() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }, "toNumber")
  }, {
    key: "toString",
    value: /* @__PURE__ */ __name(function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }, "toString")
  }]);
  return BigIntDecimal2;
}();

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/NumberDecimal.js
var NumberDecimal = /* @__PURE__ */ function() {
  function NumberDecimal2(value) {
    _classCallCheck(this, NumberDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "number", void 0);
    _defineProperty(this, "empty", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  __name(NumberDecimal2, "NumberDecimal");
  _createClass(NumberDecimal2, [{
    key: "negate",
    value: /* @__PURE__ */ __name(function negate() {
      return new NumberDecimal2(-this.toNumber());
    }, "negate")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function add(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }, "add")
  }, {
    key: "multi",
    value: /* @__PURE__ */ __name(function multi(value) {
      var target = Number(value);
      if (this.isInvalidate() || Number.isNaN(target)) {
        return new NumberDecimal2(NaN);
      }
      var number4 = this.number * target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }, "multi")
  }, {
    key: "isEmpty",
    value: /* @__PURE__ */ __name(function isEmpty2() {
      return this.empty;
    }, "isEmpty")
  }, {
    key: "isNaN",
    value: /* @__PURE__ */ __name(function isNaN2() {
      return Number.isNaN(this.number);
    }, "isNaN")
  }, {
    key: "isInvalidate",
    value: /* @__PURE__ */ __name(function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }, "isInvalidate")
  }, {
    key: "equals",
    value: /* @__PURE__ */ __name(function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }, "equals")
  }, {
    key: "lessEquals",
    value: /* @__PURE__ */ __name(function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }, "lessEquals")
  }, {
    key: "toNumber",
    value: /* @__PURE__ */ __name(function toNumber() {
      return this.number;
    }, "toNumber")
  }, {
    key: "toString",
    value: /* @__PURE__ */ __name(function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }, "toString")
  }]);
  return NumberDecimal2;
}();

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
__name(getMiniDecimal, "getMiniDecimal");
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
__name(toFixed, "toFixed");

// node_modules/.pnpm/@rc-component+mini-decimal@1.1.0/node_modules/@rc-component/mini-decimal/es/index.js
var es_default6 = getMiniDecimal;

// packages/input-number/src/InputNumber.tsx
var import_classnames140 = __toESM(require_classnames());

// packages/input/src/BaseInput.tsx
var import_classnames137 = __toESM(require_classnames());
import React347, { cloneElement as cloneElement16, useRef as useRef104 } from "react";

// packages/input/src/utils/commonUtils.ts
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
__name(hasAddon, "hasAddon");
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
__name(hasPrefixSuffix, "hasPrefixSuffix");
function cloneEvent(event, target, value) {
  const currentTarget = target.cloneNode(true);
  const newEvent = Object.create(event, {
    target: { value: currentTarget },
    currentTarget: { value: currentTarget }
  });
  currentTarget.value = value;
  if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
    currentTarget.selectionStart = target.selectionStart;
    currentTarget.selectionEnd = target.selectionEnd;
  }
  return newEvent;
}
__name(cloneEvent, "cloneEvent");
function resolveOnChange(target, e3, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  let event = e3;
  if (e3.type === "click") {
    event = cloneEvent(e3, target, "");
    onChange(event);
    return;
  }
  if (target.type !== "file" && targetValue !== void 0) {
    event = cloneEvent(e3, target, targetValue);
    onChange(event);
    return;
  }
  onChange(event);
}
__name(resolveOnChange, "resolveOnChange");
function triggerFocus(element, option) {
  if (!element)
    return;
  element.focus(option);
  const { cursor } = option || {};
  if (cursor) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
__name(triggerFocus, "triggerFocus");

// packages/input/src/BaseInput.tsx
var BaseInput = /* @__PURE__ */ __name((props) => {
  const {
    inputElement: inputEl,
    children,
    prefixCls,
    prefix,
    suffix,
    addonBefore,
    addonAfter,
    className,
    style: style2,
    disabled,
    readOnly,
    focused,
    triggerFocus: triggerFocus3,
    allowClear,
    value,
    handleReset,
    hidden,
    classes,
    classNames: classNames253,
    dataAttrs,
    styles,
    components
  } = props;
  const inputElement = children ?? inputEl;
  const AffixWrapperComponent = components?.affixWrapper || "span";
  const GroupWrapperComponent = components?.groupWrapper || "span";
  const WrapperComponent = components?.wrapper || "span";
  const GroupAddonComponent = components?.groupAddon || "span";
  const containerRef = useRef104(null);
  const onInputClick = /* @__PURE__ */ __name((e3) => {
    if (containerRef.current?.contains(e3.target)) {
      triggerFocus3?.();
    }
  }, "onInputClick");
  const hasAffix = hasPrefixSuffix(props);
  let element = cloneElement16(inputElement, {
    value,
    className: (0, import_classnames137.default)(inputElement.props.className, !hasAffix && classNames253?.variant) || null
  });
  if (hasAffix) {
    let clearIcon = null;
    if (allowClear) {
      const needClear = !disabled && !readOnly && value;
      const clearIconCls = `${prefixCls}-clear-icon`;
      const iconNode = typeof allowClear === "object" && allowClear?.clearIcon ? allowClear.clearIcon : "\u2716";
      clearIcon = /* @__PURE__ */ React347.createElement(
        "span",
        {
          onClick: handleReset,
          onMouseDown: (e3) => e3.preventDefault(),
          className: (0, import_classnames137.default)(clearIconCls, {
            [`${clearIconCls}-hidden`]: !needClear,
            [`${clearIconCls}-has-suffix`]: !!suffix
          }),
          role: "button",
          tabIndex: -1
        },
        iconNode
      );
    }
    const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
    const affixWrapperCls = (0, import_classnames137.default)(
      affixWrapperPrefixCls,
      {
        [`${prefixCls}-disabled`]: disabled,
        [`${affixWrapperPrefixCls}-disabled`]: disabled,
        // Not used, but keep it
        [`${affixWrapperPrefixCls}-focused`]: focused,
        // Not used, but keep it
        [`${affixWrapperPrefixCls}-readonly`]: readOnly,
        [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
      },
      classes?.affixWrapper,
      classNames253?.affixWrapper,
      classNames253?.variant
    );
    const suffixNode = (suffix || allowClear) && /* @__PURE__ */ React347.createElement(
      "span",
      {
        className: (0, import_classnames137.default)(`${prefixCls}-suffix`, classNames253?.suffix),
        style: styles?.suffix
      },
      clearIcon,
      suffix
    );
    element = /* @__PURE__ */ React347.createElement(
      AffixWrapperComponent,
      {
        className: affixWrapperCls,
        style: styles?.affixWrapper,
        onClick: onInputClick,
        ...dataAttrs?.affixWrapper,
        ref: containerRef
      },
      prefix && /* @__PURE__ */ React347.createElement(
        "span",
        {
          className: (0, import_classnames137.default)(`${prefixCls}-prefix`, classNames253?.prefix),
          style: styles?.prefix
        },
        prefix
      ),
      element,
      suffixNode
    );
  }
  if (hasAddon(props)) {
    const wrapperCls = `${prefixCls}-group`;
    const addonCls = `${wrapperCls}-addon`;
    const groupWrapperCls = `${wrapperCls}-wrapper`;
    const mergedWrapperClassName = (0, import_classnames137.default)(
      `${prefixCls}-wrapper`,
      wrapperCls,
      classes?.wrapper,
      classNames253?.wrapper
    );
    const mergedGroupClassName = (0, import_classnames137.default)(
      groupWrapperCls,
      {
        [`${groupWrapperCls}-disabled`]: disabled
      },
      classes?.group,
      classNames253?.groupWrapper
    );
    element = /* @__PURE__ */ React347.createElement(GroupWrapperComponent, { className: mergedGroupClassName }, /* @__PURE__ */ React347.createElement(WrapperComponent, { className: mergedWrapperClassName }, addonBefore && /* @__PURE__ */ React347.createElement(GroupAddonComponent, { className: addonCls }, addonBefore), element, addonAfter && /* @__PURE__ */ React347.createElement(GroupAddonComponent, { className: addonCls }, addonAfter)));
  }
  return React347.cloneElement(element, {
    className: (0, import_classnames137.default)(element.props?.className, className) || null,
    style: {
      ...element.props?.style,
      ...style2
    },
    hidden
  });
}, "BaseInput");
var BaseInput_default = BaseInput;

// packages/input/src/Input.tsx
var import_classnames138 = __toESM(require_classnames());
import React349, {
  forwardRef as forwardRef78,
  useEffect as useEffect79,
  useImperativeHandle as useImperativeHandle26,
  useRef as useRef105,
  useState as useState74
} from "react";

// packages/input/src/hooks/useCount.ts
import * as React348 from "react";
function useCount(count, showCount) {
  return React348.useMemo(() => {
    let mergedConfig = {};
    if (showCount) {
      mergedConfig.show = typeof showCount === "object" && showCount.formatter ? showCount.formatter : !!showCount;
    }
    mergedConfig = {
      ...mergedConfig,
      ...count
    };
    const { show, ...rest } = mergedConfig;
    return {
      ...rest,
      show: !!show,
      showFormatter: typeof show === "function" ? show : void 0,
      strategy: rest.strategy || ((value) => value.length)
    };
  }, [count, showCount]);
}
__name(useCount, "useCount");

// packages/input/src/Input.tsx
var Input3 = forwardRef78((props, ref) => {
  const {
    autoComplete,
    onChange,
    onFocus,
    onBlur,
    onPressEnter,
    onKeyDown: onKeyDown2,
    prefixCls = "rc-input",
    disabled,
    htmlSize,
    className,
    maxLength,
    suffix,
    showCount,
    count,
    type: type5 = "text",
    classes,
    classNames: classNames253,
    styles,
    onCompositionStart,
    onCompositionEnd,
    ...rest
  } = props;
  const [focused, setFocused] = useState74(false);
  const compositionRef = useRef105(false);
  const inputRef = useRef105(null);
  const focus = /* @__PURE__ */ __name((option) => {
    if (inputRef.current) {
      triggerFocus(inputRef.current, option);
    }
  }, "focus");
  const [value, setValue] = useMergedState(props.defaultValue, {
    value: props.value
  });
  const formatValue2 = value === void 0 || value === null ? "" : String(value);
  const [selection, setSelection] = useState74(null);
  const countConfig = useCount(count, showCount);
  const mergedMax = countConfig.max || maxLength;
  const valueLength = countConfig.strategy(formatValue2);
  const isOutOfRange = !!mergedMax && valueLength > mergedMax;
  useImperativeHandle26(ref, () => ({
    focus,
    blur: () => {
      inputRef.current?.blur();
    },
    setSelectionRange: (start, end, direction) => {
      inputRef.current?.setSelectionRange(start, end, direction);
    },
    select: () => {
      inputRef.current?.select();
    },
    input: inputRef.current
  }));
  useEffect79(() => {
    setFocused((prev2) => prev2 && disabled ? false : prev2);
  }, [disabled]);
  const triggerChange = /* @__PURE__ */ __name((e3, currentValue, info) => {
    let cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([
          inputRef.current?.selectionStart || 0,
          inputRef.current?.selectionEnd || 0
        ]);
      }
    } else if (info.source === "compositionEnd") {
      return;
    }
    setValue(cutValue);
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e3, onChange, cutValue);
    }
  }, "triggerChange");
  useEffect79(() => {
    if (selection) {
      inputRef.current?.setSelectionRange(...selection);
    }
  }, [selection]);
  const onInternalChange = /* @__PURE__ */ __name((e3) => {
    triggerChange(e3, e3.target.value, {
      source: "change"
    });
  }, "onInternalChange");
  const onInternalCompositionEnd = /* @__PURE__ */ __name((e3) => {
    compositionRef.current = false;
    triggerChange(e3, e3.currentTarget.value, {
      source: "compositionEnd"
    });
    onCompositionEnd?.(e3);
  }, "onInternalCompositionEnd");
  const handleKeyDown = /* @__PURE__ */ __name((e3) => {
    if (onPressEnter && e3.key === "Enter") {
      onPressEnter(e3);
    }
    onKeyDown2?.(e3);
  }, "handleKeyDown");
  const handleFocus = /* @__PURE__ */ __name((e3) => {
    setFocused(true);
    onFocus?.(e3);
  }, "handleFocus");
  const handleBlur = /* @__PURE__ */ __name((e3) => {
    setFocused(false);
    onBlur?.(e3);
  }, "handleBlur");
  const handleReset = /* @__PURE__ */ __name((e3) => {
    setValue("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e3, onChange);
    }
  }, "handleReset");
  const outOfRangeCls = isOutOfRange && `${prefixCls}-out-of-range`;
  const getInputElement = /* @__PURE__ */ __name(() => {
    const otherProps = omit(
      props,
      [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "showCount",
        "count",
        "classes",
        "htmlSize",
        "styles",
        "classNames"
      ]
    );
    return /* @__PURE__ */ React349.createElement(
      "input",
      {
        autoComplete,
        ...otherProps,
        onChange: onInternalChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        className: (0, import_classnames138.default)(
          prefixCls,
          {
            [`${prefixCls}-disabled`]: disabled
          },
          classNames253?.input
        ),
        style: styles?.input,
        ref: inputRef,
        size: htmlSize,
        type: type5,
        onCompositionStart: (e3) => {
          compositionRef.current = true;
          onCompositionStart?.(e3);
        },
        onCompositionEnd: onInternalCompositionEnd
      }
    );
  }, "getInputElement");
  const getSuffix = /* @__PURE__ */ __name(() => {
    const hasMaxLength = Number(mergedMax) > 0;
    if (suffix || countConfig.show) {
      const dataCount = countConfig.showFormatter ? countConfig.showFormatter({
        value: formatValue2,
        count: valueLength,
        maxLength: mergedMax
      }) : `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
      return /* @__PURE__ */ React349.createElement(React349.Fragment, null, countConfig.show && /* @__PURE__ */ React349.createElement(
        "span",
        {
          className: (0, import_classnames138.default)(
            `${prefixCls}-show-count-suffix`,
            {
              [`${prefixCls}-show-count-has-suffix`]: !!suffix
            },
            classNames253?.count
          ),
          style: {
            ...styles?.count
          }
        },
        dataCount
      ), suffix);
    }
    return null;
  }, "getSuffix");
  return /* @__PURE__ */ React349.createElement(
    BaseInput_default,
    {
      ...rest,
      prefixCls,
      className: (0, import_classnames138.default)(className, outOfRangeCls),
      handleReset,
      value: formatValue2,
      focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled,
      classes,
      classNames: classNames253,
      styles
    },
    getInputElement()
  );
});
var Input_default4 = Input3;

// packages/input/src/index.tsx
var src_default17 = Input_default4;

// packages/input-number/src/InputNumber.tsx
import * as React351 from "react";

// packages/input-number/src/hooks/useCursor.ts
init_warning();
import { useRef as useRef106 } from "react";
function useCursor(input, focused) {
  const selectionRef = useRef106(null);
  function recordCursor() {
    try {
      const { selectionStart: start, selectionEnd: end, value } = input;
      const beforeTxt = value.substring(0, start);
      const afterTxt = value.substring(end);
      selectionRef.current = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e3) {
    }
  }
  __name(recordCursor, "recordCursor");
  function restoreCursor() {
    if (input && selectionRef.current && focused) {
      try {
        const { value } = input;
        const { beforeTxt, afterTxt, start } = selectionRef.current;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.current.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e3) {
        warning_default(
          false,
          `Something warning of cursor restore. Please fire issue about this: ${e3.message}`
        );
      }
    }
  }
  __name(restoreCursor, "restoreCursor");
  return [recordCursor, restoreCursor];
}
__name(useCursor, "useCursor");

// packages/input-number/src/StepHandler.tsx
var import_classnames139 = __toESM(require_classnames());
import * as React350 from "react";

// packages/util/src/hooks/useMobile.ts
import { useState as useState75 } from "react";
var useMobile = /* @__PURE__ */ __name(() => {
  const [mobile, setMobile] = useState75(false);
  useLayoutEffect_default(() => {
    setMobile(isMobile_default());
  }, []);
  return mobile;
}, "useMobile");
var useMobile_default = useMobile;

// packages/input-number/src/StepHandler.tsx
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
function StepHandler({
  prefixCls,
  upNode,
  downNode,
  upDisabled,
  downDisabled,
  onStep
}) {
  const stepTimeoutRef = React350.useRef();
  const frameIds = React350.useRef([]);
  const onStepRef = React350.useRef();
  onStepRef.current = onStep;
  const onStopStep = /* @__PURE__ */ __name(() => {
    clearTimeout(stepTimeoutRef.current);
  }, "onStopStep");
  const onStepMouseDown = /* @__PURE__ */ __name((e3, up) => {
    e3.preventDefault();
    onStopStep();
    onStepRef.current(up);
    function loopStep() {
      onStepRef.current(up);
      stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }
    __name(loopStep, "loopStep");
    stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  }, "onStepMouseDown");
  React350.useEffect(() => () => {
    onStopStep();
    frameIds.current.forEach((id) => raf_default.cancel(id));
  }, []);
  const isMobile = useMobile_default();
  if (isMobile) {
    return null;
  }
  const handlerClassName = `${prefixCls}-handler`;
  const upClassName = (0, import_classnames139.default)(handlerClassName, `${handlerClassName}-up`, {
    [`${handlerClassName}-up-disabled`]: upDisabled
  });
  const downClassName = (0, import_classnames139.default)(handlerClassName, `${handlerClassName}-down`, {
    [`${handlerClassName}-down-disabled`]: downDisabled
  });
  const safeOnStopStep = /* @__PURE__ */ __name(() => frameIds.current.push(raf_default(onStopStep)), "safeOnStopStep");
  const sharedHandlerProps = {
    unselectable: "on",
    role: "button",
    onMouseUp: safeOnStopStep,
    onMouseLeave: safeOnStopStep
  };
  return /* @__PURE__ */ React350.createElement("div", { className: `${handlerClassName}-wrap` }, /* @__PURE__ */ React350.createElement(
    "span",
    {
      ...sharedHandlerProps,
      onMouseDown: (e3) => {
        onStepMouseDown(e3, true);
      },
      "aria-label": "Increase Value",
      "aria-disabled": upDisabled,
      className: upClassName
    },
    upNode || /* @__PURE__ */ React350.createElement("span", { unselectable: "on", className: `${prefixCls}-handler-up-inner` })
  ), /* @__PURE__ */ React350.createElement(
    "span",
    {
      ...sharedHandlerProps,
      onMouseDown: (e3) => {
        onStepMouseDown(e3, false);
      },
      "aria-label": "Decrease Value",
      "aria-disabled": downDisabled,
      className: downClassName
    },
    downNode || /* @__PURE__ */ React350.createElement("span", { unselectable: "on", className: `${prefixCls}-handler-down-inner` })
  ));
}
__name(StepHandler, "StepHandler");

// packages/input-number/src/utils/numberUtil.ts
function getDecupleSteps(step) {
  const stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
  const hasPoint = stepStr.includes(".");
  if (!hasPoint) {
    return step + "0";
  }
  return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}
__name(getDecupleSteps, "getDecupleSteps");

// packages/input-number/src/hooks/useFrame.ts
import { useRef as useRef108, useEffect as useEffect81 } from "react";
var useFrame_default = /* @__PURE__ */ __name(() => {
  const idRef = useRef108(0);
  const cleanUp = /* @__PURE__ */ __name(() => {
    raf_default.cancel(idRef.current);
  }, "cleanUp");
  useEffect81(() => cleanUp, []);
  return (callback) => {
    cleanUp();
    idRef.current = raf_default(() => {
      callback();
    });
  };
}, "default");

// packages/input-number/src/InputNumber.tsx
var getDecimalValue = /* @__PURE__ */ __name((stringMode, decimalValue) => {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
}, "getDecimalValue");
var getDecimalIfValidate = /* @__PURE__ */ __name((value) => {
  const decimal = es_default6(value);
  return decimal.isInvalidate() ? null : decimal;
}, "getDecimalIfValidate");
var InternalInputNumber = React351.forwardRef(
  (props, ref) => {
    const {
      prefixCls = "rc-input-number",
      className,
      style: style2,
      min,
      max,
      step = 1,
      defaultValue,
      value,
      disabled,
      readOnly,
      upHandler,
      downHandler,
      keyboard,
      changeOnWheel = false,
      controls = true,
      classNames: classNames253,
      stringMode,
      parser,
      formatter,
      precision,
      decimalSeparator,
      onChange,
      onInput,
      onPressEnter,
      onStep,
      changeOnBlur = true,
      ...inputProps
    } = props;
    const inputClassName = `${prefixCls}-input`;
    const inputRef = React351.useRef(null);
    const [focus, setFocus] = React351.useState(false);
    const userTypingRef = React351.useRef(false);
    const compositionRef = React351.useRef(false);
    const shiftKeyRef = React351.useRef(false);
    const [decimalValue, setDecimalValue] = React351.useState(
      () => es_default6(value ?? defaultValue)
    );
    function setUncontrolledDecimalValue(newDecimal) {
      if (value === void 0) {
        setDecimalValue(newDecimal);
      }
    }
    __name(setUncontrolledDecimalValue, "setUncontrolledDecimalValue");
    const getPrecision = React351.useCallback(
      (numStr, userTyping) => {
        if (userTyping) {
          return void 0;
        }
        if (precision >= 0) {
          return precision;
        }
        return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
      },
      [precision, step]
    );
    const mergedParser = React351.useCallback(
      (num) => {
        const numStr = String(num);
        if (parser) {
          return parser(numStr);
        }
        let parsedStr = numStr;
        if (decimalSeparator) {
          parsedStr = parsedStr.replace(decimalSeparator, ".");
        }
        return parsedStr.replace(/[^\w.-]+/g, "");
      },
      [parser, decimalSeparator]
    );
    const inputValueRef = React351.useRef("");
    const mergedFormatter = React351.useCallback(
      (number4, userTyping) => {
        if (formatter) {
          return formatter(number4, { userTyping, input: String(inputValueRef.current) });
        }
        let str = typeof number4 === "number" ? num2str(number4) : number4;
        if (!userTyping) {
          const mergedPrecision = getPrecision(str, userTyping);
          if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
            const separatorStr = decimalSeparator || ".";
            str = toFixed(str, separatorStr, mergedPrecision);
          }
        }
        return str;
      },
      [formatter, getPrecision, decimalSeparator]
    );
    const [inputValue, setInternalInputValue] = React351.useState(() => {
      const initValue = defaultValue ?? value;
      if (decimalValue.isInvalidate() && ["string", "number"].includes(typeof initValue)) {
        return Number.isNaN(initValue) ? "" : initValue;
      }
      return mergedFormatter(decimalValue.toString(), false);
    });
    inputValueRef.current = inputValue;
    function setInputValue(newValue, userTyping) {
      setInternalInputValue(
        mergedFormatter(
          // Invalidate number is sometime passed by external control, we should let it go
          // Otherwise is controlled by internal interactive logic which check by userTyping
          // You can ref 'show limited value when input is not focused' test for more info.
          newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
          userTyping
        )
      );
    }
    __name(setInputValue, "setInputValue");
    const maxDecimal = React351.useMemo(() => getDecimalIfValidate(max), [max, precision]);
    const minDecimal = React351.useMemo(() => getDecimalIfValidate(min), [min, precision]);
    const upDisabled = React351.useMemo(() => {
      if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return maxDecimal.lessEquals(decimalValue);
    }, [maxDecimal, decimalValue]);
    const downDisabled = React351.useMemo(() => {
      if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return decimalValue.lessEquals(minDecimal);
    }, [minDecimal, decimalValue]);
    const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);
    const getRangeValue = /* @__PURE__ */ __name((target) => {
      if (maxDecimal && !target.lessEquals(maxDecimal)) {
        return maxDecimal;
      }
      if (minDecimal && !minDecimal.lessEquals(target)) {
        return minDecimal;
      }
      return null;
    }, "getRangeValue");
    const isInRange2 = /* @__PURE__ */ __name((target) => !getRangeValue(target), "isInRange");
    const triggerValueUpdate = /* @__PURE__ */ __name((newValue, userTyping) => {
      let updateValue = newValue;
      let isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!readOnly && !disabled && isRangeValidate) {
        const numStr = updateValue.toString();
        const mergedPrecision = getPrecision(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = es_default6(toFixed(numStr, ".", mergedPrecision));
          if (!isInRange2(updateValue)) {
            updateValue = es_default6(toFixed(numStr, ".", mergedPrecision, true));
          }
        }
        if (!updateValue.equals(decimalValue)) {
          setUncontrolledDecimalValue(updateValue);
          onChange?.(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
          if (value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue;
    }, "triggerValueUpdate");
    const onNextPromise = useFrame_default();
    const collectInputValue = /* @__PURE__ */ __name((inputStr) => {
      recordCursor();
      inputValueRef.current = inputStr;
      setInternalInputValue(inputStr);
      if (!compositionRef.current) {
        const finalValue = mergedParser(inputStr);
        const finalDecimal = es_default6(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      onInput?.(inputStr);
      onNextPromise(() => {
        let nextInputStr = inputStr;
        if (!parser) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue(nextInputStr);
        }
      });
    }, "collectInputValue");
    const onCompositionStart = /* @__PURE__ */ __name(() => {
      compositionRef.current = true;
    }, "onCompositionStart");
    const onCompositionEnd = /* @__PURE__ */ __name(() => {
      compositionRef.current = false;
      collectInputValue(inputRef.current.value);
    }, "onCompositionEnd");
    const onInternalInput = /* @__PURE__ */ __name((e3) => {
      collectInputValue(e3.target.value);
    }, "onInternalInput");
    const onInternalStep = /* @__PURE__ */ __name((up) => {
      if (up && upDisabled || !up && downDisabled) {
        return;
      }
      userTypingRef.current = false;
      let stepDecimal = es_default6(shiftKeyRef.current ? getDecupleSteps(step) : step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      const target = (decimalValue || es_default6(0)).add(stepDecimal.toString());
      const updatedValue = triggerValueUpdate(target, false);
      onStep?.(getDecimalValue(stringMode, updatedValue), {
        offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
        type: up ? "up" : "down"
      });
      inputRef.current?.focus();
    }, "onInternalStep");
    const flushInputValue = /* @__PURE__ */ __name((userTyping) => {
      const parsedValue = es_default6(mergedParser(inputValue));
      let formatValue2;
      if (!parsedValue.isNaN()) {
        formatValue2 = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue2 = triggerValueUpdate(decimalValue, userTyping);
      }
      if (value !== void 0) {
        setInputValue(decimalValue, false);
      } else if (!formatValue2.isNaN()) {
        setInputValue(formatValue2, false);
      }
    }, "flushInputValue");
    const onBeforeInput = /* @__PURE__ */ __name(() => {
      userTypingRef.current = true;
    }, "onBeforeInput");
    const onKeyDown2 = /* @__PURE__ */ __name((event) => {
      const { key, shiftKey } = event;
      userTypingRef.current = true;
      shiftKeyRef.current = shiftKey;
      if (key === "Enter") {
        if (!compositionRef.current) {
          userTypingRef.current = false;
        }
        flushInputValue(false);
        onPressEnter?.(event);
      }
      if (keyboard === false) {
        return;
      }
      if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
        onInternalStep(key === "Up" || key === "ArrowUp");
        event.preventDefault();
      }
    }, "onKeyDown");
    const onKeyUp = /* @__PURE__ */ __name(() => {
      userTypingRef.current = false;
      shiftKeyRef.current = false;
    }, "onKeyUp");
    React351.useEffect(() => {
      if (changeOnWheel && focus) {
        const onWheel = /* @__PURE__ */ __name((event) => {
          onInternalStep(event.deltaY < 0);
          event.preventDefault();
        }, "onWheel");
        const input = inputRef.current;
        if (input) {
          input.addEventListener("wheel", onWheel, { passive: false });
          return () => input.removeEventListener("wheel", onWheel);
        }
      }
    });
    const onBlur = /* @__PURE__ */ __name(() => {
      if (changeOnBlur) {
        flushInputValue(false);
      }
      setFocus(false);
      userTypingRef.current = false;
    }, "onBlur");
    useLayoutUpdateEffect(() => {
      if (!decimalValue.isInvalidate()) {
        setInputValue(decimalValue, false);
      }
    }, [precision, formatter]);
    useLayoutUpdateEffect(() => {
      const newValue = es_default6(value);
      setDecimalValue(newValue);
      const currentParsedValue = es_default6(mergedParser(inputValue));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
        setInputValue(newValue, userTypingRef.current);
      }
    }, [value]);
    useLayoutUpdateEffect(() => {
      if (formatter) {
        restoreCursor();
      }
    }, [inputValue]);
    return /* @__PURE__ */ React351.createElement(
      "div",
      {
        className: (0, import_classnames140.default)(prefixCls, className, {
          [`${prefixCls}-focused`]: focus,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-readonly`]: readOnly,
          [`${prefixCls}-not-a-number`]: decimalValue.isNaN(),
          [`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange2(decimalValue)
        }),
        style: style2,
        onFocus: () => {
          setFocus(true);
        },
        onBlur,
        onKeyDown: onKeyDown2,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBeforeInput
      },
      controls && /* @__PURE__ */ React351.createElement(
        StepHandler,
        {
          prefixCls,
          upNode: upHandler,
          downNode: downHandler,
          upDisabled,
          downDisabled,
          onStep: onInternalStep
        }
      ),
      /* @__PURE__ */ React351.createElement("div", { className: `${inputClassName}-wrap` }, /* @__PURE__ */ React351.createElement(
        "input",
        {
          autoComplete: "off",
          role: "spinbutton",
          "aria-valuemin": min,
          "aria-valuemax": max,
          "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
          step,
          ...inputProps,
          ref: composeRef(inputRef, ref),
          className: inputClassName,
          value: inputValue,
          onChange: onInternalInput,
          disabled,
          readOnly
        }
      ))
    );
  }
);
var InputNumber = React351.forwardRef(
  (props, ref) => {
    const {
      disabled,
      style: style2,
      prefixCls,
      value,
      prefix,
      suffix,
      addonBefore,
      addonAfter,
      className,
      classNames: classNames253,
      ...rest
    } = props;
    const inputFocusRef = React351.useRef(null);
    const focus = /* @__PURE__ */ __name((option) => {
      if (inputFocusRef.current) {
        triggerFocus(inputFocusRef.current, option);
      }
    }, "focus");
    return /* @__PURE__ */ React351.createElement(
      BaseInput_default,
      {
        className,
        triggerFocus: focus,
        prefixCls,
        value,
        disabled,
        style: style2,
        prefix,
        suffix,
        addonAfter,
        addonBefore,
        classNames: classNames253,
        components: {
          affixWrapper: "div",
          groupWrapper: "div",
          wrapper: "div",
          groupAddon: "div"
        }
      },
      /* @__PURE__ */ React351.createElement(
        InternalInputNumber,
        {
          prefixCls,
          disabled,
          ref: composeRef(inputFocusRef, ref),
          className: classNames253?.input,
          ...rest
        }
      )
    );
  }
);
InputNumber.displayName = "InputNumber";
var InputNumber_default = InputNumber;

// packages/input-number/src/index.ts
var src_default18 = InputNumber_default;

// packages/ant-design/components/input-number/style/token.ts
init_public_api();
var prepareComponentToken28 = /* @__PURE__ */ __name((token2) => {
  const handleVisible = token2.handleVisible ?? "auto";
  return {
    ...initComponentToken(token2),
    controlWidth: 90,
    handleWidth: token2.controlHeightSM - token2.lineWidth * 2,
    handleFontSize: token2.fontSize / 2,
    handleVisible,
    handleActiveBg: token2.colorFillAlter,
    handleBg: token2.colorBgContainer,
    filledHandleBg: new TinyColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
    handleHoverColor: token2.colorPrimary,
    handleBorderColor: token2.colorBorder,
    handleOpacity: handleVisible === true ? 1 : 0
  };
}, "prepareComponentToken");

// packages/ant-design/components/input-number/style/index.ts
var genRadiusStyle = /* @__PURE__ */ __name(({ componentCls, borderRadiusSM, borderRadiusLG }, size) => {
  const borderRadius = size === "lg" ? borderRadiusLG : borderRadiusSM;
  return {
    [`&-${size}`]: {
      [`${componentCls}-handler-wrap`]: {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      [`${componentCls}-handler-up`]: {
        borderStartEndRadius: borderRadius
      },
      [`${componentCls}-handler-down`]: {
        borderEndEndRadius: borderRadius
      }
    }
  };
}, "genRadiusStyle");
var genInputNumberStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    borderRadius,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    colorError,
    paddingInlineSM,
    paddingBlockSM,
    paddingBlockLG,
    paddingInlineLG,
    colorTextDescription,
    motionDurationMid,
    handleHoverColor,
    paddingInline,
    paddingBlock,
    handleBg,
    handleActiveBg,
    colorTextDisabled,
    borderRadiusSM,
    borderRadiusLG,
    controlWidth,
    handleOpacity,
    handleBorderColor,
    filledHandleBg,
    lineHeightLG,
    calc
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...genBasicInputStyle(token2),
        display: "inline-block",
        width: controlWidth,
        margin: 0,
        padding: 0,
        borderRadius,
        // Variants
        ...genOutlinedStyle2(token2, {
          [`${componentCls}-handler-wrap`]: {
            background: handleBg,
            [`${componentCls}-handler-down`]: {
              borderBlockStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}`
            }
          }
        }),
        ...genFilledStyle2(token2, {
          [`${componentCls}-handler-wrap`]: {
            background: filledHandleBg,
            [`${componentCls}-handler-down`]: {
              borderBlockStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}`
            }
          },
          "&:focus-within": {
            [`${componentCls}-handler-wrap`]: {
              background: handleBg
            }
          }
        }),
        ...genBorderlessStyle2(token2),
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          borderRadius: borderRadiusLG,
          [`input${componentCls}-input`]: {
            height: calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal(),
            padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: borderRadiusSM,
          [`input${componentCls}-input`]: {
            height: calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal(),
            padding: `${unit(paddingBlockSM)} ${unit(paddingInlineSM)}`
          }
        },
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          [`${componentCls}-input-wrap`]: {
            input: {
              color: colorError
            }
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": {
          ...resetComponent(token2),
          ...genInputGroupStyle(token2),
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            // https://github.com/ant-design/ant-design/issues/6403
            [`${componentCls}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG,
                fontSize: token2.fontSizeLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            },
            // Variants
            ...genOutlinedGroupStyle(token2),
            ...genFilledGroupStyle(token2),
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/45764
            [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          }
        },
        [`&-disabled ${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [componentCls]: {
          "&-input": {
            ...resetComponent(token2),
            width: "100%",
            padding: `${unit(paddingBlock)} ${unit(paddingInline)}`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius,
            outline: 0,
            transition: `all ${motionDurationMid} linear`,
            appearance: "textfield",
            fontSize: "inherit",
            ...genPlaceholderStyle(token2.colorTextPlaceholder),
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          }
        }
      }
    },
    // Handler
    {
      [componentCls]: {
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          opacity: 1
        },
        [`${componentCls}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: token2.handleWidth,
          height: "100%",
          borderStartStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          borderEndStartRadius: 0,
          opacity: handleOpacity,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${componentCls}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: token2.handleFontSize
            }
          }
        },
        [`${componentCls}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: colorTextDescription,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${unit(lineWidth)} ${lineType} ${handleBorderColor}`,
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: handleActiveBg
          },
          // Hover
          "&:hover": {
            height: `60%`,
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              color: handleHoverColor
            }
          },
          "&-up-inner, &-down-inner": {
            ...resetIcon(),
            color: colorTextDescription,
            transition: `all ${motionDurationMid} linear`,
            userSelect: "none"
          }
        },
        [`${componentCls}-handler-up`]: {
          borderStartEndRadius: borderRadius
        },
        [`${componentCls}-handler-down`]: {
          borderEndEndRadius: borderRadius
        },
        ...genRadiusStyle(token2, "lg"),
        ...genRadiusStyle(token2, "sm"),
        // Disabled
        "&-disabled, &-readonly": {
          [`${componentCls}-handler-wrap`]: {
            display: "none"
          },
          [`${componentCls}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: colorTextDisabled
        }
      }
    }
  ];
}, "genInputNumberStyles");
var genAffixWrapperStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    paddingBlock,
    paddingInline,
    inputAffixPadding,
    controlWidth,
    borderRadiusLG,
    borderRadiusSM,
    paddingInlineLG,
    paddingInlineSM,
    paddingBlockLG,
    paddingBlockSM
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: {
      [`input${componentCls}-input`]: {
        padding: `${unit(paddingBlock)} 0`
      },
      ...genBasicInputStyle(token2),
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: controlWidth,
      padding: 0,
      paddingInlineStart: paddingInline,
      "&-lg": {
        borderRadius: borderRadiusLG,
        paddingInlineStart: paddingInlineLG,
        [`input${componentCls}-input`]: {
          padding: `${unit(paddingBlockLG)} 0`
        }
      },
      "&-sm": {
        borderRadius: borderRadiusSM,
        paddingInlineStart: paddingInlineSM,
        [`input${componentCls}-input`]: {
          padding: `${unit(paddingBlockSM)} 0`
        }
      },
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`&-disabled > ${componentCls}-disabled`]: {
        background: "transparent"
      },
      [`> div${componentCls}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${componentCls}-focused`]: {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}-handler-wrap`]: {
        zIndex: 2
      },
      [componentCls]: {
        color: "inherit",
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: paddingInline,
          marginInlineStart: inputAffixPadding
        }
      }
    }
  };
}, "genAffixWrapperStyles");
var style_default33 = genStyleHooks(
  "InputNumber",
  (token2) => {
    const inputNumberToken = merge2(token2, initInputToken(token2));
    return [
      genInputNumberStyles(inputNumberToken),
      genAffixWrapperStyles(inputNumberToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputNumberToken)
    ];
  },
  prepareComponentToken28,
  {
    unitless: {
      handleOpacity: true
    }
  }
);

// packages/ant-design/components/input-number/index.tsx
var InputNumber2 = React352.forwardRef((props, ref) => {
  if (true) {
    const { deprecated } = devUseWarning("InputNumber");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const { getPrefixCls, direction } = React352.useContext(ConfigContext);
  const inputRef = React352.useRef(null);
  React352.useImperativeHandle(ref, () => inputRef.current);
  const {
    className,
    rootClassName,
    size: customizeSize,
    disabled: customDisabled,
    prefixCls: customizePrefixCls,
    addonBefore,
    addonAfter,
    prefix,
    bordered,
    readOnly,
    status: customStatus,
    controls,
    variant: customVariant,
    ...others
  } = props;
  const prefixCls = getPrefixCls("input-number", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default33(prefixCls, rootCls);
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  let upIcon = /* @__PURE__ */ React352.createElement(import_UpOutlined.default, { className: `${prefixCls}-handler-up-inner` });
  let downIcon = /* @__PURE__ */ React352.createElement(import_DownOutlined3.default, { className: `${prefixCls}-handler-down-inner` });
  const controlsTemp = typeof controls === "boolean" ? controls : void 0;
  if (typeof controls === "object") {
    upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ React352.createElement("span", { className: `${prefixCls}-handler-up-inner` }, controls.upIcon);
    downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ React352.createElement("span", { className: `${prefixCls}-handler-down-inner` }, controls.downIcon);
  }
  const {
    hasFeedback,
    status: contextStatus,
    isFormItemInput,
    feedbackIcon
  } = React352.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React352.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
  const suffixNode = hasFeedback && /* @__PURE__ */ React352.createElement(React352.Fragment, null, feedbackIcon);
  const inputNumberClass = (0, import_classnames141.default)(
    {
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-in-form-item`]: isFormItemInput
    },
    hashId
  );
  const wrapperClassName = `${prefixCls}-group`;
  const element = /* @__PURE__ */ React352.createElement(
    src_default18,
    {
      ref: inputRef,
      disabled: mergedDisabled,
      className: (0, import_classnames141.default)(cssVarCls, rootCls, className, rootClassName, compactItemClassnames),
      upHandler: upIcon,
      downHandler: downIcon,
      prefixCls,
      readOnly,
      controls: controlsTemp,
      prefix,
      suffix: suffixNode,
      addonAfter: addonAfter && /* @__PURE__ */ React352.createElement(NoCompactStyle, null, /* @__PURE__ */ React352.createElement(NoFormStyle, { override: true, status: true }, addonAfter)),
      addonBefore: addonBefore && /* @__PURE__ */ React352.createElement(NoCompactStyle, null, /* @__PURE__ */ React352.createElement(NoFormStyle, { override: true, status: true }, addonBefore)),
      classNames: {
        input: inputNumberClass,
        variant: (0, import_classnames141.default)(
          {
            [`${prefixCls}-${variant}`]: enableVariantCls
          },
          getStatusClassNames(prefixCls, mergedStatus, hasFeedback)
        ),
        affixWrapper: (0, import_classnames141.default)(
          {
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
          },
          hashId
        ),
        wrapper: (0, import_classnames141.default)(
          {
            [`${wrapperClassName}-rtl`]: direction === "rtl"
          },
          hashId
        ),
        groupWrapper: (0, import_classnames141.default)(
          {
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
          },
          getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback),
          hashId
        )
      },
      ...others
    }
  );
  return wrapCSSVar(element);
});
var TypedInputNumber = InputNumber2;
var PureInputNumber = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React352.createElement(config_provider_default, { theme: { components: { InputNumber: { handleVisible: true } } } }, /* @__PURE__ */ React352.createElement(InputNumber2, { ...props })), "PureInputNumber");
if (true) {
  TypedInputNumber.displayName = "InputNumber";
}
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
var input_number_default = TypedInputNumber;

// packages/ant-design/components/color-picker/components/ColorSteppers.tsx
var ColorSteppers = /* @__PURE__ */ __name(({
  prefixCls,
  min = 0,
  max = 100,
  value,
  onChange,
  className,
  formatter
}) => {
  const colorSteppersPrefixCls = `${prefixCls}-steppers`;
  const [stepValue, setStepValue] = useState77(value);
  useEffect83(() => {
    if (!Number.isNaN(value)) {
      setStepValue(value);
    }
  }, [value]);
  return /* @__PURE__ */ React353.createElement(
    input_number_default,
    {
      className: (0, import_classnames142.default)(colorSteppersPrefixCls, className),
      min,
      max,
      value: stepValue,
      formatter,
      size: "small",
      onChange: (step) => {
        if (!value) {
          setStepValue(step || 0);
        }
        onChange?.(step);
      }
    }
  );
}, "ColorSteppers");
var ColorSteppers_default = ColorSteppers;

// packages/ant-design/components/color-picker/components/ColorAlphaInput.tsx
var ColorAlphaInput = /* @__PURE__ */ __name(({ prefixCls, value, onChange }) => {
  const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
  const [alphaValue, setAlphaValue] = useState78(generateColor2(value || "#000"));
  useEffect84(() => {
    if (value) {
      setAlphaValue(value);
    }
  }, [value]);
  const handleAlphaChange = /* @__PURE__ */ __name((step) => {
    const hsba = alphaValue.toHsb();
    hsba.a = (step || 0) / 100;
    const genColor = generateColor2(hsba);
    if (!value) {
      setAlphaValue(genColor);
    }
    onChange?.(genColor);
  }, "handleAlphaChange");
  return /* @__PURE__ */ React354.createElement(
    ColorSteppers_default,
    {
      value: getAlphaColor3(alphaValue),
      prefixCls,
      formatter: (step) => `${step}%`,
      className: colorAlphaInputPrefixCls,
      onChange: handleAlphaChange
    }
  );
}, "ColorAlphaInput");
var ColorAlphaInput_default = ColorAlphaInput;

// packages/ant-design/components/color-picker/components/ColorHexInput.tsx
import React365, { useEffect as useEffect91, useState as useState82 } from "react";

// packages/ant-design/components/input/Group.tsx
var import_classnames143 = __toESM(require_classnames());
import * as React355 from "react";
import { useContext as useContext136, useMemo as useMemo103 } from "react";
var Group2 = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction } = useContext136(ConfigContext);
  const { prefixCls: customizePrefixCls, className } = props;
  const prefixCls = getPrefixCls("input-group", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input");
  const [wrapCSSVar, hashId] = style_default22(inputPrefixCls);
  const cls5 = (0, import_classnames143.default)(
    prefixCls,
    {
      [`${prefixCls}-lg`]: props.size === "large",
      [`${prefixCls}-sm`]: props.size === "small",
      [`${prefixCls}-compact`]: props.compact,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    hashId,
    className
  );
  const formItemContext = useContext136(FormItemInputContext);
  const groupFormItemContext = useMemo103(
    () => ({
      ...formItemContext,
      isFormItemInput: false
    }),
    [formItemContext]
  );
  if (true) {
    const warning5 = devUseWarning("Input.Group");
    warning5.deprecated(false, "Input.Group", "Space.Compact");
  }
  return wrapCSSVar(
    /* @__PURE__ */ React355.createElement(
      "span",
      {
        className: cls5,
        style: props.style,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      },
      /* @__PURE__ */ React355.createElement(FormItemInputContext.Provider, { value: groupFormItemContext }, props.children)
    )
  );
}, "Group");
var Group_default2 = Group2;

// packages/ant-design/components/input/Input.tsx
var import_classnames144 = __toESM(require_classnames());
import React357, { forwardRef as forwardRef81, useContext as useContext137, useEffect as useEffect86, useRef as useRef112 } from "react";

// packages/ant-design/components/_util/getAllowClear.tsx
var import_CloseCircleFilled6 = __toESM(require_CloseCircleFilled3());
import React356 from "react";
var getAllowClear = /* @__PURE__ */ __name((allowClear) => {
  let mergedAllowClear;
  if (typeof allowClear === "object" && allowClear?.clearIcon) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ React356.createElement(import_CloseCircleFilled6.default, null)
    };
  }
  return mergedAllowClear;
}, "getAllowClear");
var getAllowClear_default = getAllowClear;

// packages/ant-design/components/input/hooks/useRemovePasswordTimeout.ts
import { useEffect as useEffect85, useRef as useRef111 } from "react";
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = useRef111([]);
  const removePasswordTimeout = /* @__PURE__ */ __name(() => {
    removePasswordTimeoutRef.current.push(
      setTimeout(() => {
        if (inputRef.current?.input && inputRef.current?.input.getAttribute("type") === "password" && inputRef.current?.input.hasAttribute("value")) {
          inputRef.current?.input.removeAttribute("value");
        }
      })
    );
  }, "removePasswordTimeout");
  useEffect85(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach((timer) => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}
__name(useRemovePasswordTimeout, "useRemovePasswordTimeout");

// packages/ant-design/components/input/utils.ts
function hasPrefixSuffix2(props) {
  return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}
__name(hasPrefixSuffix2, "hasPrefixSuffix");

// packages/ant-design/components/input/Input.tsx
function triggerFocus2(element, option) {
  if (!element) {
    return;
  }
  element.focus(option);
  const { cursor } = option || {};
  if (cursor) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
        break;
    }
  }
}
__name(triggerFocus2, "triggerFocus");
var Input4 = forwardRef81((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur,
    onFocus,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    style: style2,
    styles,
    rootClassName,
    onChange,
    classNames: classes,
    variant: customVariant,
    ...rest
  } = props;
  if (true) {
    const { deprecated } = devUseWarning("Input");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const { getPrefixCls, direction, input } = React357.useContext(ConfigContext);
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const inputRef = useRef112(null);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default22(prefixCls, rootCls);
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customSize ?? compactSize ?? ctx);
  const disabled = React357.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const { status: contextStatus, hasFeedback, feedbackIcon } = useContext137(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const inputHasPrefixSuffix = hasPrefixSuffix2(props) || !!hasFeedback;
  const prevHasPrefixSuffix = useRef112(inputHasPrefixSuffix);
  if (true) {
    const warning5 = devUseWarning("Input");
    useEffect86(() => {
      if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) {
        warning5(
          document.activeElement === inputRef.current?.input,
          "usage",
          `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`
        );
      }
      prevHasPrefixSuffix.current = inputHasPrefixSuffix;
    }, [inputHasPrefixSuffix]);
  }
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  const handleBlur = /* @__PURE__ */ __name((e3) => {
    removePasswordTimeout();
    onBlur?.(e3);
  }, "handleBlur");
  const handleFocus = /* @__PURE__ */ __name((e3) => {
    removePasswordTimeout();
    onFocus?.(e3);
  }, "handleFocus");
  const handleChange = /* @__PURE__ */ __name((e3) => {
    removePasswordTimeout();
    onChange?.(e3);
  }, "handleChange");
  const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React357.createElement(React357.Fragment, null, suffix, hasFeedback && feedbackIcon);
  const mergedAllowClear = getAllowClear_default(allowClear ?? input?.allowClear);
  const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
  return wrapCSSVar(
    /* @__PURE__ */ React357.createElement(
      src_default17,
      {
        ref: composeRef(ref, inputRef),
        prefixCls,
        autoComplete: input?.autoComplete,
        ...rest,
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        style: { ...input?.style, ...style2 },
        styles: { ...input?.styles, ...styles },
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: (0, import_classnames144.default)(
          className,
          rootClassName,
          cssVarCls,
          rootCls,
          compactItemClassnames,
          input?.className
        ),
        onChange: handleChange,
        addonAfter: addonAfter && /* @__PURE__ */ React357.createElement(NoCompactStyle, null, /* @__PURE__ */ React357.createElement(NoFormStyle, { override: true, status: true }, addonAfter)),
        addonBefore: addonBefore && /* @__PURE__ */ React357.createElement(NoCompactStyle, null, /* @__PURE__ */ React357.createElement(NoFormStyle, { override: true, status: true }, addonBefore)),
        classNames: {
          ...classes,
          ...input?.classNames,
          input: (0, import_classnames144.default)(
            {
              [`${prefixCls}-sm`]: mergedSize === "small",
              [`${prefixCls}-lg`]: mergedSize === "large",
              [`${prefixCls}-rtl`]: direction === "rtl"
            },
            classes?.input,
            input?.classNames?.input,
            hashId
          ),
          variant: (0, import_classnames144.default)(
            {
              [`${prefixCls}-${variant}`]: enableVariantCls
            },
            getStatusClassNames(prefixCls, mergedStatus)
          ),
          affixWrapper: (0, import_classnames144.default)(
            {
              [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
            },
            hashId
          ),
          wrapper: (0, import_classnames144.default)(
            {
              [`${prefixCls}-group-rtl`]: direction === "rtl"
            },
            hashId
          ),
          groupWrapper: (0, import_classnames144.default)(
            {
              [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
              [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
            },
            getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback),
            hashId
          )
        }
      }
    )
  );
});
if (true) {
  Input4.displayName = "Input";
}
var Input_default5 = Input4;

// packages/ant-design/components/input/OTP/index.tsx
var import_classnames145 = __toESM(require_classnames());
import * as React359 from "react";

// packages/ant-design/components/input/style/otp.ts
var genOTPStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, paddingXS } = token2;
  return {
    [`${componentCls}`]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: paddingXS,
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-input`]: {
        textAlign: "center",
        paddingInline: token2.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token2.paddingXS
      }
    }
  };
}, "genOTPStyle");
var otp_default = genStyleHooks(
  ["Input", "OTP"],
  (token2) => {
    const inputToken = merge2(token2, initInputToken(token2));
    return [genOTPStyle(inputToken)];
  },
  initComponentToken
);

// packages/ant-design/components/input/OTP/OTPInput.tsx
import * as React358 from "react";
var OTPInput = React358.forwardRef((props, ref) => {
  const { value, onChange, onActiveChange, index: index3, ...restProps } = props;
  const onInternalChange = /* @__PURE__ */ __name((e3) => {
    onChange(index3, e3.target.value);
  }, "onInternalChange");
  const inputRef = React358.useRef(null);
  React358.useImperativeHandle(ref, () => inputRef.current);
  const syncSelection = /* @__PURE__ */ __name(() => {
    raf_default(() => {
      const inputEle = inputRef.current?.input;
      if (document.activeElement === inputEle && inputEle) {
        inputEle.select();
      }
    });
  }, "syncSelection");
  const onInternalKeyDown = /* @__PURE__ */ __name(({ key }) => {
    if (key === "ArrowLeft") {
      onActiveChange(index3 - 1);
    } else if (key === "ArrowRight") {
      onActiveChange(index3 + 1);
    }
    syncSelection();
  }, "onInternalKeyDown");
  const onInternalKeyUp = /* @__PURE__ */ __name((e3) => {
    if (e3.key === "Backspace" && !value) {
      onActiveChange(index3 - 1);
    }
    syncSelection();
  }, "onInternalKeyUp");
  return /* @__PURE__ */ React358.createElement(
    Input_default5,
    {
      ...restProps,
      ref: inputRef,
      value,
      onInput: onInternalChange,
      onFocus: syncSelection,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onMouseDown: syncSelection,
      onMouseUp: syncSelection
    }
  );
});
var OTPInput_default = OTPInput;

// packages/ant-design/components/input/OTP/index.tsx
function strToArr(str) {
  return (str || "").split("");
}
__name(strToArr, "strToArr");
var OTP = React359.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    length: length2 = 6,
    size: customSize,
    defaultValue,
    value,
    onChange,
    formatter,
    variant,
    disabled,
    status: customStatus,
    autoFocus,
    ...restProps
  } = props;
  const { getPrefixCls, direction } = React359.useContext(ConfigContext);
  const prefixCls = getPrefixCls("otp", customizePrefixCls);
  const domAttrs = pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  });
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = otp_default(prefixCls, rootCls);
  const mergedSize = useSize_default((ctx) => customSize ?? ctx);
  const formContext = React359.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(formContext.status, customStatus);
  const proxyFormContext = React359.useMemo(
    () => ({
      ...formContext,
      status: mergedStatus,
      hasFeedback: false,
      feedbackIcon: null
    }),
    [formContext, mergedStatus]
  );
  const containerRef = React359.useRef(null);
  const refs = React359.useRef({});
  React359.useImperativeHandle(ref, () => ({
    focus: () => {
      refs.current[0]?.focus();
    },
    blur: () => {
      for (let i = 0; i < length2; i += 1) {
        refs.current[i]?.blur();
      }
    },
    nativeElement: containerRef.current
  }));
  const internalFormatter = /* @__PURE__ */ __name((txt) => formatter ? formatter(txt) : txt, "internalFormatter");
  const [valueCells, setValueCells] = React359.useState(
    strToArr(internalFormatter(defaultValue || ""))
  );
  React359.useEffect(() => {
    if (value !== void 0) {
      setValueCells(strToArr(value));
    }
  }, [value]);
  const triggerValueCellsChange = useEvent((nextValueCells) => {
    setValueCells(nextValueCells);
    if (onChange && nextValueCells.length === length2 && nextValueCells.every((c) => c) && nextValueCells.some((c, index3) => valueCells[index3] !== c)) {
      onChange(nextValueCells.join(""));
    }
  });
  const patchValue = useEvent((index3, txt) => {
    let nextCells = [...valueCells];
    for (let i = 0; i < index3; i += 1) {
      if (!nextCells[i]) {
        nextCells[i] = "";
      }
    }
    if (txt.length <= 1) {
      nextCells[index3] = txt;
    } else {
      nextCells = nextCells.slice(0, index3).concat(strToArr(txt));
    }
    nextCells = nextCells.slice(0, length2);
    for (let i = nextCells.length - 1; i >= 0; i -= 1) {
      if (nextCells[i]) {
        break;
      }
      nextCells.pop();
    }
    const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
    nextCells = strToArr(formattedValue).map((c, i) => {
      if (c === " " && !nextCells[i]) {
        return nextCells[i];
      }
      return c;
    });
    return nextCells;
  });
  const onInputChange = /* @__PURE__ */ __name((index3, txt) => {
    const nextCells = patchValue(index3, txt);
    const nextIndex = Math.min(index3 + txt.length, length2 - 1);
    if (nextIndex !== index3) {
      refs.current[nextIndex]?.focus();
    }
    triggerValueCellsChange(nextCells);
  }, "onInputChange");
  const onInputActiveChange = /* @__PURE__ */ __name((nextIndex) => {
    refs.current[nextIndex]?.focus();
  }, "onInputActiveChange");
  const inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus
  };
  return wrapCSSVar(
    /* @__PURE__ */ React359.createElement(
      "div",
      {
        ...domAttrs,
        ref: containerRef,
        className: (0, import_classnames145.default)(
          prefixCls,
          {
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large",
            [`${prefixCls}-rtl`]: direction === "rtl"
          },
          cssVarCls,
          hashId
        )
      },
      /* @__PURE__ */ React359.createElement(FormItemInputContext.Provider, { value: proxyFormContext }, new Array(length2).fill(0).map((_, index3) => {
        const key = `otp-${index3}`;
        const singleValue = valueCells[index3] || "";
        return /* @__PURE__ */ React359.createElement(
          OTPInput_default,
          {
            ref: (inputEle) => {
              refs.current[index3] = inputEle;
            },
            key,
            index: index3,
            size: mergedSize,
            htmlSize: 1,
            className: `${prefixCls}-input`,
            onChange: onInputChange,
            value: singleValue,
            onActiveChange: onInputActiveChange,
            autoFocus: index3 === 0 && autoFocus,
            ...inputSharedProps
          }
        );
      }))
    )
  );
});
var OTP_default = OTP;

// packages/ant-design/components/input/Password.tsx
var import_EyeInvisibleOutlined = __toESM(require_EyeInvisibleOutlined3());
var import_EyeOutlined = __toESM(require_EyeOutlined3());
var import_classnames146 = __toESM(require_classnames());
import * as React360 from "react";
import { useRef as useRef115, useState as useState80 } from "react";
var defaultIconRender = /* @__PURE__ */ __name((visible) => visible ? /* @__PURE__ */ React360.createElement(import_EyeOutlined.default, null) : /* @__PURE__ */ React360.createElement(import_EyeInvisibleOutlined.default, null), "defaultIconRender");
var actionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = React360.forwardRef((props, ref) => {
  const { visibilityToggle = true } = props;
  const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
  const [visible, setVisible] = useState80(
    () => visibilityControlled ? visibilityToggle.visible : false
  );
  const inputRef = useRef115(null);
  React360.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = /* @__PURE__ */ __name(() => {
    const { disabled } = props;
    if (disabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    setVisible((prevState) => {
      const newState = !prevState;
      if (typeof visibilityToggle === "object") {
        visibilityToggle.onVisibleChange?.(newState);
      }
      return newState;
    });
  }, "onVisibleChange");
  const getIcon2 = /* @__PURE__ */ __name((prefixCls2) => {
    const { action = "click", iconRender = defaultIconRender } = props;
    const iconTrigger = actionMap[action] || "";
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: (e3) => {
        e3.preventDefault();
      },
      onMouseUp: (e3) => {
        e3.preventDefault();
      }
    };
    return React360.cloneElement(
      React360.isValidElement(icon) ? icon : /* @__PURE__ */ React360.createElement("span", null, icon),
      iconProps
    );
  }, "getIcon");
  const {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size,
    ...restProps
  } = props;
  const { getPrefixCls } = React360.useContext(ConfigContext);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const prefixCls = getPrefixCls("input-password", customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon2(prefixCls);
  const inputClassName = (0, import_classnames146.default)(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = {
    ...omit(restProps, ["suffix", "iconRender", "visibilityToggle"]),
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: suffixIcon
  };
  if (size) {
    omittedProps.size = size;
  }
  return /* @__PURE__ */ React360.createElement(Input_default5, { ref: composeRef(ref, inputRef), ...omittedProps });
});
if (true) {
  Password.displayName = "Input.Password";
}
var Password_default = Password;

// packages/ant-design/components/input/Search.tsx
var import_SearchOutlined2 = __toESM(require_SearchOutlined3());
var import_classnames147 = __toESM(require_classnames());
import * as React361 from "react";
var Search = React361.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    suffix,
    enterButton = false,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd,
    ...restProps
  } = props;
  const { getPrefixCls, direction } = React361.useContext(ConfigContext);
  const composedRef = React361.useRef(false);
  const prefixCls = getPrefixCls("input-search", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const { compactSize } = useCompactItemContext(prefixCls, direction);
  const size = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const inputRef = React361.useRef(null);
  const onChange = /* @__PURE__ */ __name((e3) => {
    if (e3 && e3.target && e3.type === "click" && customOnSearch) {
      customOnSearch(e3.target.value, e3, {
        source: "clear"
      });
    }
    if (customOnChange) {
      customOnChange(e3);
    }
  }, "onChange");
  const onMouseDown = /* @__PURE__ */ __name((e3) => {
    if (document.activeElement === inputRef.current?.input) {
      e3.preventDefault();
    }
  }, "onMouseDown");
  const onSearch = /* @__PURE__ */ __name((e3) => {
    if (customOnSearch) {
      customOnSearch(inputRef.current?.input?.value, e3, {
        source: "input"
      });
    }
  }, "onSearch");
  const onPressEnter = /* @__PURE__ */ __name((e3) => {
    if (composedRef.current || loading) {
      return;
    }
    onSearch(e3);
  }, "onPressEnter");
  const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ React361.createElement(import_SearchOutlined2.default, null) : null;
  const btnClassName = `${prefixCls}-button`;
  let button;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement3(enterButtonAsElement, {
      onMouseDown,
      onClick: (e3) => {
        enterButtonAsElement?.props?.onClick?.(e3);
        onSearch(e3);
      },
      key: "enterButton",
      ...isAntdButton ? {
        className: btnClassName,
        size
      } : {}
    });
  } else {
    button = /* @__PURE__ */ React361.createElement(
      button_default2,
      {
        className: btnClassName,
        type: enterButton ? "primary" : void 0,
        size,
        disabled,
        key: "enterButton",
        onMouseDown,
        onClick: onSearch,
        loading,
        icon: searchIcon
      },
      enterButton
    );
  }
  if (addonAfter) {
    button = [
      button,
      cloneElement3(addonAfter, {
        key: "addonAfter"
      })
    ];
  }
  const cls5 = (0, import_classnames147.default)(
    prefixCls,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${size}`]: !!size,
      [`${prefixCls}-with-button`]: !!enterButton
    },
    className
  );
  const handleOnCompositionStart = /* @__PURE__ */ __name((e3) => {
    composedRef.current = true;
    onCompositionStart?.(e3);
  }, "handleOnCompositionStart");
  const handleOnCompositionEnd = /* @__PURE__ */ __name((e3) => {
    composedRef.current = false;
    onCompositionEnd?.(e3);
  }, "handleOnCompositionEnd");
  return /* @__PURE__ */ React361.createElement(
    Input_default5,
    {
      ref: composeRef(inputRef, ref),
      onPressEnter,
      ...restProps,
      size,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      prefixCls: inputPrefixCls,
      addonAfter: button,
      suffix,
      onChange,
      className: cls5,
      disabled
    }
  );
});
if (true) {
  Search.displayName = "Search";
}
var Search_default = Search;

// packages/ant-design/components/input/TextArea.tsx
var import_classnames150 = __toESM(require_classnames());
import * as React364 from "react";
import { forwardRef as forwardRef87 } from "react";

// packages/textarea/src/TextArea.tsx
var import_classnames149 = __toESM(require_classnames());
import React363, { useEffect as useEffect90, useImperativeHandle as useImperativeHandle31, useRef as useRef118 } from "react";

// packages/textarea/src/ResizableTextArea.tsx
var import_classnames148 = __toESM(require_classnames());
import * as React362 from "react";

// packages/textarea/src/calculateNodeHeight.tsx
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
var SIZING_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "font-variant",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing",
  "word-break",
  "white-space"
];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node2, useCache = false) {
  const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  const style2 = window.getComputedStyle(node2);
  const boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  const paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  const sizingStyle = SIZING_STYLE.map(
    (name) => `${name}:${style2.getPropertyValue(name)}`
  ).join(";");
  const nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
__name(calculateNodeStyling, "calculateNodeStyling");
function calculateAutoSizeStyle(uiTextNode, useCache = false, minRows = null, maxRows = null) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute(
      "wrap",
      uiTextNode.getAttribute("wrap")
    );
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  const { paddingSize, borderSize, boxSizing, sizingStyle } = calculateNodeStyling(uiTextNode, useCache);
  hiddenTextarea.setAttribute(
    "style",
    `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`
  );
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  let minHeight = void 0;
  let maxHeight = void 0;
  let overflowY;
  let height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  const style2 = {
    height,
    overflowY,
    resize: "none"
  };
  if (minHeight) {
    style2.minHeight = minHeight;
  }
  if (maxHeight) {
    style2.maxHeight = maxHeight;
  }
  return style2;
}
__name(calculateAutoSizeStyle, "calculateAutoSizeStyle");

// packages/textarea/src/ResizableTextArea.tsx
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = React362.forwardRef(
  (props, ref) => {
    const {
      prefixCls,
      onPressEnter,
      defaultValue,
      value,
      autoSize,
      onResize: onResize2,
      className,
      style: style2,
      disabled,
      onChange,
      // Test only
      onInternalAutoSize,
      ...restProps
    } = props;
    const [mergedValue, setMergedValue] = useMergedState(defaultValue, {
      value,
      postState: (val) => val ?? ""
    });
    const onInternalChange = /* @__PURE__ */ __name((event) => {
      setMergedValue(event.target.value);
      onChange?.(event);
    }, "onInternalChange");
    const textareaRef = React362.useRef();
    React362.useImperativeHandle(ref, () => ({
      textArea: textareaRef.current
    }));
    const [minRows, maxRows] = React362.useMemo(() => {
      if (autoSize && typeof autoSize === "object") {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]);
    const needAutoSize = !!autoSize;
    const fixFirefoxAutoScroll = /* @__PURE__ */ __name(() => {
      try {
        if (document.activeElement === textareaRef.current) {
          const { selectionStart, selectionEnd, scrollTop } = textareaRef.current;
          textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
          textareaRef.current.scrollTop = scrollTop;
        }
      } catch (e3) {
      }
    }, "fixFirefoxAutoScroll");
    const [resizeState, setResizeState] = React362.useState(RESIZE_STABLE);
    const [autoSizeStyle, setAutoSizeStyle] = React362.useState();
    const startResize = /* @__PURE__ */ __name(() => {
      setResizeState(RESIZE_START);
      if (false) {
        onInternalAutoSize?.();
      }
    }, "startResize");
    useLayoutEffect_default(() => {
      if (needAutoSize) {
        startResize();
      }
    }, [value, minRows, maxRows, needAutoSize]);
    useLayoutEffect_default(() => {
      if (resizeState === RESIZE_START) {
        setResizeState(RESIZE_MEASURING);
      } else if (resizeState === RESIZE_MEASURING) {
        const textareaStyles = calculateAutoSizeStyle(
          textareaRef.current,
          false,
          minRows,
          maxRows
        );
        setResizeState(RESIZE_STABLE);
        setAutoSizeStyle(textareaStyles);
      } else {
        fixFirefoxAutoScroll();
      }
    }, [resizeState]);
    const resizeRafRef = React362.useRef();
    const cleanRaf = /* @__PURE__ */ __name(() => {
      raf_default.cancel(resizeRafRef.current);
    }, "cleanRaf");
    const onInternalResize = /* @__PURE__ */ __name((size) => {
      if (resizeState === RESIZE_STABLE) {
        onResize2?.(size);
        if (autoSize) {
          cleanRaf();
          resizeRafRef.current = raf_default(() => {
            startResize();
          });
        }
      }
    }, "onInternalResize");
    React362.useEffect(() => cleanRaf, []);
    const mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
    const mergedStyle = {
      ...style2,
      ...mergedAutoSizeStyle
    };
    if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
      mergedStyle.overflowY = "hidden";
      mergedStyle.overflowX = "hidden";
    }
    return /* @__PURE__ */ React362.createElement(
      src_default,
      {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize2)
      },
      /* @__PURE__ */ React362.createElement(
        "textarea",
        {
          ...restProps,
          ref: textareaRef,
          style: mergedStyle,
          className: (0, import_classnames148.default)(prefixCls, className, {
            [`${prefixCls}-disabled`]: disabled
          }),
          disabled,
          value: mergedValue,
          onChange: onInternalChange
        }
      )
    );
  }
);
var ResizableTextArea_default = ResizableTextArea;

// packages/textarea/src/TextArea.tsx
var TextArea = React363.forwardRef(
  ({
    defaultValue,
    value: customValue,
    onFocus,
    onBlur,
    onChange,
    allowClear,
    maxLength,
    onCompositionStart,
    onCompositionEnd,
    suffix,
    prefixCls = "rc-textarea",
    showCount,
    count,
    className,
    style: style2,
    disabled,
    hidden,
    classNames: classNames253,
    styles,
    onResize: onResize2,
    readOnly,
    ...rest
  }, ref) => {
    const [value, setValue] = useMergedState(defaultValue, {
      value: customValue,
      defaultValue
    });
    const formatValue2 = value === void 0 || value === null ? "" : String(value);
    const [focused, setFocused] = React363.useState(false);
    const compositionRef = React363.useRef(false);
    const [textareaResized, setTextareaResized] = React363.useState(null);
    const resizableTextAreaRef = useRef118(null);
    const getTextArea = /* @__PURE__ */ __name(() => resizableTextAreaRef.current?.textArea, "getTextArea");
    const focus = /* @__PURE__ */ __name(() => {
      getTextArea().focus();
    }, "focus");
    useImperativeHandle31(ref, () => ({
      resizableTextArea: resizableTextAreaRef.current,
      focus,
      blur: () => {
        getTextArea().blur();
      }
    }));
    useEffect90(() => {
      setFocused((prev2) => !disabled && prev2);
    }, [disabled]);
    const [selection, setSelection] = React363.useState(null);
    React363.useEffect(() => {
      if (selection) {
        getTextArea().setSelectionRange(...selection);
      }
    }, [selection]);
    const countConfig = useCount(count, showCount);
    const mergedMax = countConfig.max ?? maxLength;
    const hasMaxLength = Number(mergedMax) > 0;
    const valueLength = countConfig.strategy(formatValue2);
    const isOutOfRange = !!mergedMax && valueLength > mergedMax;
    const triggerChange = /* @__PURE__ */ __name((e3, currentValue) => {
      let cutValue = currentValue;
      if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
        cutValue = countConfig.exceedFormatter(currentValue, {
          max: countConfig.max
        });
        if (currentValue !== cutValue) {
          setSelection([
            getTextArea().selectionStart || 0,
            getTextArea().selectionEnd || 0
          ]);
        }
      }
      setValue(cutValue);
      resolveOnChange(e3.currentTarget, e3, onChange, cutValue);
    }, "triggerChange");
    const onInternalCompositionStart = /* @__PURE__ */ __name((e3) => {
      compositionRef.current = true;
      onCompositionStart?.(e3);
    }, "onInternalCompositionStart");
    const onInternalCompositionEnd = /* @__PURE__ */ __name((e3) => {
      compositionRef.current = false;
      triggerChange(e3, e3.currentTarget.value);
      onCompositionEnd?.(e3);
    }, "onInternalCompositionEnd");
    const onInternalChange = /* @__PURE__ */ __name((e3) => {
      triggerChange(e3, e3.target.value);
    }, "onInternalChange");
    const handleKeyDown = /* @__PURE__ */ __name((e3) => {
      const { onPressEnter, onKeyDown: onKeyDown2 } = rest;
      if (e3.key === "Enter" && onPressEnter) {
        onPressEnter(e3);
      }
      onKeyDown2?.(e3);
    }, "handleKeyDown");
    const handleFocus = /* @__PURE__ */ __name((e3) => {
      setFocused(true);
      onFocus?.(e3);
    }, "handleFocus");
    const handleBlur = /* @__PURE__ */ __name((e3) => {
      setFocused(false);
      onBlur?.(e3);
    }, "handleBlur");
    const handleReset = /* @__PURE__ */ __name((e3) => {
      setValue("");
      focus();
      resolveOnChange(getTextArea(), e3, onChange);
    }, "handleReset");
    let suffixNode = suffix;
    let dataCount;
    if (countConfig.show) {
      if (countConfig.showFormatter) {
        dataCount = countConfig.showFormatter({
          value: formatValue2,
          count: valueLength,
          maxLength: mergedMax
        });
      } else {
        dataCount = `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
      }
      suffixNode = /* @__PURE__ */ React363.createElement(React363.Fragment, null, suffixNode, /* @__PURE__ */ React363.createElement(
        "span",
        {
          className: (0, import_classnames149.default)(`${prefixCls}-data-count`, classNames253?.count),
          style: styles?.count
        },
        dataCount
      ));
    }
    const handleResize = /* @__PURE__ */ __name((size) => {
      onResize2?.(size);
      if (getTextArea()?.style.height) {
        setTextareaResized(true);
      }
    }, "handleResize");
    const isPureTextArea = !rest.autoSize && !showCount && !allowClear;
    return /* @__PURE__ */ React363.createElement(
      BaseInput_default,
      {
        value: formatValue2,
        allowClear,
        handleReset,
        suffix: suffixNode,
        prefixCls,
        classNames: {
          ...classNames253,
          affixWrapper: (0, import_classnames149.default)(classNames253?.affixWrapper, {
            [`${prefixCls}-show-count`]: showCount,
            [`${prefixCls}-textarea-allow-clear`]: allowClear
          })
        },
        disabled,
        focused,
        className: (0, import_classnames149.default)(className, isOutOfRange && `${prefixCls}-out-of-range`),
        style: {
          ...style2,
          ...textareaResized && !isPureTextArea ? { height: "auto" } : {}
        },
        dataAttrs: {
          affixWrapper: {
            "data-count": typeof dataCount === "string" ? dataCount : void 0
          }
        },
        hidden,
        readOnly
      },
      /* @__PURE__ */ React363.createElement(
        ResizableTextArea_default,
        {
          ...rest,
          maxLength,
          onKeyDown: handleKeyDown,
          onChange: onInternalChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: onInternalCompositionStart,
          onCompositionEnd: onInternalCompositionEnd,
          className: (0, import_classnames149.default)(classNames253?.textarea),
          style: { ...styles?.textarea, resize: style2?.resize },
          disabled,
          prefixCls,
          onResize: handleResize,
          ref: resizableTextAreaRef,
          readOnly
        }
      )
    );
  }
);
var TextArea_default = TextArea;

// packages/textarea/src/index.tsx
var src_default19 = TextArea_default;

// packages/ant-design/components/input/TextArea.tsx
var TextArea2 = forwardRef87((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear,
    classNames: classes,
    rootClassName,
    className,
    style: style2,
    styles,
    variant: customVariant,
    ...rest
  } = props;
  if (true) {
    const { deprecated } = devUseWarning("TextArea");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const { getPrefixCls, direction, textArea } = React364.useContext(ConfigContext);
  const mergedSize = useSize_default(customizeSize);
  const disabled = React364.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React364.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const innerRef = React364.useRef(null);
  React364.useImperativeHandle(ref, () => ({
    resizableTextArea: innerRef.current?.resizableTextArea,
    focus: (option) => {
      triggerFocus2(innerRef.current?.resizableTextArea?.textArea, option);
    },
    blur: () => innerRef.current?.blur()
  }));
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default22(prefixCls, rootCls);
  const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
  const mergedAllowClear = getAllowClear_default(allowClear ?? textArea?.allowClear);
  return wrapCSSVar(
    /* @__PURE__ */ React364.createElement(
      src_default19,
      {
        autoComplete: textArea?.autoComplete,
        ...rest,
        style: { ...textArea?.style, ...style2 },
        styles: { ...textArea?.styles, ...styles },
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        className: (0, import_classnames150.default)(cssVarCls, rootCls, className, rootClassName, textArea?.className),
        classNames: {
          ...classes,
          ...textArea?.classNames,
          textarea: (0, import_classnames150.default)(
            {
              [`${prefixCls}-sm`]: mergedSize === "small",
              [`${prefixCls}-lg`]: mergedSize === "large"
            },
            hashId,
            classes?.textarea,
            textArea?.classNames?.textarea
          ),
          variant: (0, import_classnames150.default)(
            {
              [`${prefixCls}-${variant}`]: enableVariantCls
            },
            getStatusClassNames(prefixCls, mergedStatus)
          ),
          affixWrapper: (0, import_classnames150.default)(
            `${prefixCls}-textarea-affix-wrapper`,
            {
              [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
              [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
              [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
              [`${prefixCls}-textarea-show-count`]: props.showCount || props.count?.show
            },
            hashId
          )
        },
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ React364.createElement("span", { className: `${prefixCls}-textarea-suffix` }, feedbackIcon),
        ref: innerRef
      }
    )
  );
});
var TextArea_default2 = TextArea2;

// packages/ant-design/components/input/index.ts
var Input5 = Input_default5;
Input5.Group = Group_default2;
Input5.Search = Search_default;
Input5.TextArea = TextArea_default2;
Input5.Password = Password_default;
Input5.OTP = OTP_default;
var input_default = Input5;

// packages/ant-design/components/color-picker/components/ColorHexInput.tsx
var hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
var isHexString = /* @__PURE__ */ __name((hex2) => hexReg.test(`#${hex2}`), "isHexString");
var ColorHexInput = /* @__PURE__ */ __name(({ prefixCls, value, onChange }) => {
  const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
  const [hexValue, setHexValue] = useState82(value?.toHex());
  useEffect91(() => {
    const hex2 = value?.toHex();
    if (isHexString(hex2) && value) {
      setHexValue(toHexFormat(hex2));
    }
  }, [value]);
  const handleHexChange = /* @__PURE__ */ __name((e3) => {
    const originValue = e3.target.value;
    setHexValue(toHexFormat(originValue));
    if (isHexString(toHexFormat(originValue, true))) {
      onChange?.(generateColor2(originValue));
    }
  }, "handleHexChange");
  return /* @__PURE__ */ React365.createElement(
    input_default,
    {
      className: colorHexInputPrefixCls,
      value: hexValue,
      prefix: "#",
      onChange: handleHexChange,
      size: "small"
    }
  );
}, "ColorHexInput");
var ColorHexInput_default = ColorHexInput;

// packages/ant-design/components/color-picker/components/ColorHsbInput.tsx
import React366, { useEffect as useEffect92, useState as useState83 } from "react";
var ColorHsbInput = /* @__PURE__ */ __name(({ prefixCls, value, onChange }) => {
  const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
  const [hsbValue, setHsbValue] = useState83(generateColor2(value || "#000"));
  useEffect92(() => {
    if (value) {
      setHsbValue(value);
    }
  }, [value]);
  const handleHsbChange = /* @__PURE__ */ __name((step, type5) => {
    const hsb = hsbValue.toHsb();
    hsb[type5] = type5 === "h" ? step : (step || 0) / 100;
    const genColor = generateColor2(hsb);
    if (!value) {
      setHsbValue(genColor);
    }
    onChange?.(genColor);
  }, "handleHsbChange");
  return /* @__PURE__ */ React366.createElement("div", { className: colorHsbInputPrefixCls }, /* @__PURE__ */ React366.createElement(
    ColorSteppers_default,
    {
      max: 360,
      min: 0,
      value: Number(hsbValue.toHsb().h),
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => getRoundNumber2(step || 0).toString(),
      onChange: (step) => handleHsbChange(Number(step), "h")
    }
  ), /* @__PURE__ */ React366.createElement(
    ColorSteppers_default,
    {
      max: 100,
      min: 0,
      value: Number(hsbValue.toHsb().s) * 100,
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => `${getRoundNumber2(step || 0)}%`,
      onChange: (step) => handleHsbChange(Number(step), "s")
    }
  ), /* @__PURE__ */ React366.createElement(
    ColorSteppers_default,
    {
      max: 100,
      min: 0,
      value: Number(hsbValue.toHsb().b) * 100,
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => `${getRoundNumber2(step || 0)}%`,
      onChange: (step) => handleHsbChange(Number(step), "b")
    }
  ));
}, "ColorHsbInput");
var ColorHsbInput_default = ColorHsbInput;

// packages/ant-design/components/color-picker/components/ColorRgbInput.tsx
import React367, { useEffect as useEffect93, useState as useState84 } from "react";
var ColorRgbInput = /* @__PURE__ */ __name(({ prefixCls, value, onChange }) => {
  const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
  const [rgbValue, setRgbValue] = useState84(generateColor2(value || "#000"));
  useEffect93(() => {
    if (value) {
      setRgbValue(value);
    }
  }, [value]);
  const handleRgbChange = /* @__PURE__ */ __name((step, type5) => {
    const rgb = rgbValue.toRgb();
    rgb[type5] = step || 0;
    const genColor = generateColor2(rgb);
    if (!value) {
      setRgbValue(genColor);
    }
    onChange?.(genColor);
  }, "handleRgbChange");
  return /* @__PURE__ */ React367.createElement("div", { className: colorRgbInputPrefixCls }, /* @__PURE__ */ React367.createElement(
    ColorSteppers_default,
    {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().r),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "r")
    }
  ), /* @__PURE__ */ React367.createElement(
    ColorSteppers_default,
    {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().g),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "g")
    }
  ), /* @__PURE__ */ React367.createElement(
    ColorSteppers_default,
    {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().b),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "b")
    }
  ));
}, "ColorRgbInput");
var ColorRgbInput_default = ColorRgbInput;

// packages/ant-design/components/color-picker/components/ColorInput.tsx
var selectOptions = ["hex" /* hex */, "hsb" /* hsb */, "rgb" /* rgb */].map((format2) => ({
  value: format2,
  label: format2.toLocaleUpperCase()
}));
var ColorInput = /* @__PURE__ */ __name((props) => {
  const { prefixCls, format: format2, value, disabledAlpha, onFormatChange, onChange } = props;
  const [colorFormat, setColorFormat] = useMergedState("hex" /* hex */, {
    value: format2,
    onChange: onFormatChange
  });
  const colorInputPrefixCls = `${prefixCls}-input`;
  const handleFormatChange = /* @__PURE__ */ __name((newFormat) => {
    setColorFormat(newFormat);
  }, "handleFormatChange");
  const steppersNode = useMemo106(() => {
    const inputProps = { value, prefixCls, onChange };
    switch (colorFormat) {
      case "hsb" /* hsb */:
        return /* @__PURE__ */ React368.createElement(ColorHsbInput_default, { ...inputProps });
      case "rgb" /* rgb */:
        return /* @__PURE__ */ React368.createElement(ColorRgbInput_default, { ...inputProps });
      case "hex" /* hex */:
      default:
        return /* @__PURE__ */ React368.createElement(ColorHexInput_default, { ...inputProps });
    }
  }, [colorFormat, prefixCls, value, onChange]);
  return /* @__PURE__ */ React368.createElement("div", { className: `${colorInputPrefixCls}-container` }, /* @__PURE__ */ React368.createElement(
    select_default,
    {
      value: colorFormat,
      variant: "borderless",
      getPopupContainer: (current) => current,
      popupMatchSelectWidth: 68,
      placement: "bottomRight",
      onChange: handleFormatChange,
      className: `${prefixCls}-format-select`,
      size: "small",
      options: selectOptions
    }
  ), /* @__PURE__ */ React368.createElement("div", { className: colorInputPrefixCls }, steppersNode), !disabledAlpha && /* @__PURE__ */ React368.createElement(ColorAlphaInput_default, { prefixCls, value, onChange }));
}, "ColorInput");
var ColorInput_default = ColorInput;

// packages/ant-design/components/color-picker/components/PanelPicker.tsx
var PanelPicker = /* @__PURE__ */ __name(() => {
  const {
    prefixCls,
    allowClear,
    value,
    disabledAlpha,
    onChange,
    onClear,
    onChangeComplete,
    ...injectProps
  } = useContext142(PanelPickerContext);
  return /* @__PURE__ */ React369.createElement(React369.Fragment, null, allowClear && /* @__PURE__ */ React369.createElement(
    ColorClear_default,
    {
      prefixCls,
      value,
      onChange: (clearColor) => {
        onChange?.(clearColor);
        onClear?.();
      },
      ...injectProps
    }
  ), /* @__PURE__ */ React369.createElement(
    src_default16,
    {
      prefixCls,
      value: value?.toHsb(),
      disabledAlpha,
      onChange: (colorValue, type5) => {
        onChange?.(generateColor2(colorValue), type5, true);
      },
      onChangeComplete: (colorValue) => {
        onChangeComplete?.(generateColor2(colorValue));
      }
    }
  ), /* @__PURE__ */ React369.createElement(
    ColorInput_default,
    {
      value,
      onChange,
      prefixCls,
      disabledAlpha,
      ...injectProps
    }
  ));
}, "PanelPicker");
var PanelPicker_default = PanelPicker;

// packages/ant-design/components/color-picker/components/PanelPresets.tsx
import React371, { useContext as useContext143 } from "react";

// packages/ant-design/components/color-picker/components/ColorPresets.tsx
import React370, { useMemo as useMemo107 } from "react";
var import_classnames151 = __toESM(require_classnames());
var genPresetColor2 = /* @__PURE__ */ __name((list) => list.map((value) => {
  value.colors = value.colors.map(generateColor2);
  return value;
}), "genPresetColor");
var isBright = /* @__PURE__ */ __name((value, bgColorToken) => {
  const { r: r2, g, b, a } = value.toRgb();
  const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
  if (a <= 0.5) {
    return hsv.v > 0.5;
  }
  return r2 * 0.299 + g * 0.587 + b * 0.114 > 192;
}, "isBright");
var genCollapsePanelKey = /* @__PURE__ */ __name(({ label }) => `panel-${label}`, "genCollapsePanelKey");
var ColorPresets = /* @__PURE__ */ __name(({ prefixCls, presets, value: color, onChange }) => {
  const [locale6] = useLocale_default("ColorPicker");
  const [, token2] = useToken();
  const [presetsValue] = useMergedState(genPresetColor2(presets), {
    value: genPresetColor2(presets),
    postState: genPresetColor2
  });
  const colorPresetsPrefixCls = `${prefixCls}-presets`;
  const activeKeys = useMemo107(
    () => presetsValue.reduce((acc, preset) => {
      const { defaultOpen = true } = preset;
      if (defaultOpen)
        acc.push(genCollapsePanelKey(preset));
      return acc;
    }, []),
    [presetsValue]
  );
  const handleClick = /* @__PURE__ */ __name((colorValue) => {
    onChange?.(colorValue);
  }, "handleClick");
  const items = presetsValue.map((preset) => ({
    key: genCollapsePanelKey(preset),
    label: /* @__PURE__ */ React370.createElement("div", { className: `${colorPresetsPrefixCls}-label` }, preset?.label),
    children: /* @__PURE__ */ React370.createElement("div", { className: `${colorPresetsPrefixCls}-items` }, Array.isArray(preset?.colors) && preset.colors?.length > 0 ? preset.colors.map((presetColor, index3) => /* @__PURE__ */ React370.createElement(
      ColorBlock_default,
      {
        key: `preset-${index3}-${presetColor.toHexString()}`,
        color: generateColor2(presetColor).toRgbString(),
        prefixCls,
        className: (0, import_classnames151.default)(`${colorPresetsPrefixCls}-color`, {
          [`${colorPresetsPrefixCls}-color-checked`]: presetColor.toHexString() === color?.toHexString(),
          [`${colorPresetsPrefixCls}-color-bright`]: isBright(
            presetColor,
            token2.colorBgElevated
          )
        }),
        onClick: () => handleClick(presetColor)
      }
    )) : /* @__PURE__ */ React370.createElement("span", { className: `${colorPresetsPrefixCls}-empty` }, locale6.presetEmpty))
  }));
  return /* @__PURE__ */ React370.createElement("div", { className: colorPresetsPrefixCls }, /* @__PURE__ */ React370.createElement(collapse_default2, { defaultActiveKey: activeKeys, ghost: true, items }));
}, "ColorPresets");
var ColorPresets_default = ColorPresets;

// packages/ant-design/components/color-picker/components/PanelPresets.tsx
var PanelPresets = /* @__PURE__ */ __name(() => {
  const { prefixCls, value, presets, onChange } = useContext143(PanelPresetsContext);
  return Array.isArray(presets) ? /* @__PURE__ */ React371.createElement(ColorPresets_default, { value, presets, prefixCls, onChange }) : null;
}, "PanelPresets");
var PanelPresets_default = PanelPresets;

// packages/ant-design/components/color-picker/ColorPickerPanel.tsx
var ColorPickerPanel = /* @__PURE__ */ __name((props) => {
  const { prefixCls, presets, panelRender, color, onChange, onClear, ...injectProps } = props;
  const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
  const panelPickerProps = {
    prefixCls,
    value: color,
    onChange,
    onClear,
    ...injectProps
  };
  const panelPresetsProps = React372.useMemo(
    () => ({
      prefixCls,
      value: color,
      presets,
      onChange
    }),
    [prefixCls, color, presets, onChange]
  );
  const innerPanel = /* @__PURE__ */ React372.createElement("div", { className: `${colorPickerPanelPrefixCls}-content` }, /* @__PURE__ */ React372.createElement(PanelPicker_default, null), Array.isArray(presets) && /* @__PURE__ */ React372.createElement(divider_default, null), /* @__PURE__ */ React372.createElement(PanelPresets_default, null));
  return /* @__PURE__ */ React372.createElement(PanelPickerProvider, { value: panelPickerProps }, /* @__PURE__ */ React372.createElement(PanelPresetsProvider, { value: panelPresetsProps }, /* @__PURE__ */ React372.createElement("div", { className: colorPickerPanelPrefixCls }, typeof panelRender === "function" ? panelRender(innerPanel, {
    components: {
      Picker: PanelPicker_default,
      Presets: PanelPresets_default
    }
  }) : innerPanel)));
}, "ColorPickerPanel");
if (true) {
  ColorPickerPanel.displayName = "ColorPickerPanel";
}
var ColorPickerPanel_default = ColorPickerPanel;

// packages/ant-design/components/color-picker/components/ColorTrigger.tsx
import React373, { forwardRef as forwardRef88, useMemo as useMemo108 } from "react";
var import_classnames152 = __toESM(require_classnames());
var ColorTrigger = forwardRef88((props, ref) => {
  const { color, prefixCls, open: open3, disabled, format: format2, className, showText, ...rest } = props;
  const colorTriggerPrefixCls = `${prefixCls}-trigger`;
  const containerNode = useMemo108(
    () => color.cleared ? /* @__PURE__ */ React373.createElement(ColorClear_default, { prefixCls }) : /* @__PURE__ */ React373.createElement(ColorBlock_default, { prefixCls, color: color.toRgbString() }),
    [color, prefixCls]
  );
  const genColorString = /* @__PURE__ */ __name(() => {
    const hexString = color.toHexString().toUpperCase();
    const alpha = getAlphaColor3(color);
    switch (format2) {
      case "rgb":
        return color.toRgbString();
      case "hsb":
        return color.toHsbString();
      case "hex":
      default:
        return alpha < 100 ? `${hexString.slice(0, 7)},${alpha}%` : hexString;
    }
  }, "genColorString");
  const renderText = /* @__PURE__ */ __name(() => {
    if (typeof showText === "function") {
      return showText(color);
    }
    if (showText) {
      return genColorString();
    }
  }, "renderText");
  return /* @__PURE__ */ React373.createElement(
    "div",
    {
      ref,
      className: (0, import_classnames152.default)(colorTriggerPrefixCls, className, {
        [`${colorTriggerPrefixCls}-active`]: open3,
        [`${colorTriggerPrefixCls}-disabled`]: disabled
      }),
      ...rest
    },
    containerNode,
    showText && /* @__PURE__ */ React373.createElement("div", { className: `${colorTriggerPrefixCls}-text` }, renderText())
  );
});
var ColorTrigger_default = ColorTrigger;

// packages/ant-design/components/color-picker/hooks/useColorState.ts
import { useEffect as useEffect94, useRef as useRef120, useState as useState85 } from "react";
var INIT_COLOR_REF = {};
function hasValue4(value) {
  return value !== void 0;
}
__name(hasValue4, "hasValue");
var useColorState2 = /* @__PURE__ */ __name((defaultStateValue, option) => {
  const { defaultValue, value } = option;
  const prevColor = useRef120(generateColor2(""));
  const [colorValue, _setColorValue] = useState85(() => {
    let mergedState;
    if (hasValue4(value)) {
      mergedState = value;
    } else if (hasValue4(defaultValue)) {
      mergedState = defaultValue;
    } else {
      mergedState = defaultStateValue;
    }
    const color = generateColor2(mergedState || "");
    prevColor.current = color;
    return color;
  });
  const setColorValue = /* @__PURE__ */ __name((color) => {
    _setColorValue(color);
    prevColor.current = color;
  }, "setColorValue");
  const prevValue = useRef120(INIT_COLOR_REF);
  useEffect94(() => {
    if (prevValue.current === value) {
      return;
    }
    prevValue.current = value;
    if (hasValue4(value)) {
      const newColor = generateColor2(value || "");
      if (prevColor.current.cleared === true) {
        newColor.cleared = "controlled";
      }
      setColorValue(newColor);
    }
  }, [value]);
  return [colorValue, setColorValue, prevColor];
}, "useColorState");
var useColorState_default2 = useColorState2;

// packages/ant-design/components/color-picker/style/color-block.ts
var getTransBg = /* @__PURE__ */ __name((size, colorFill) => ({
  backgroundImage: `conic-gradient(${colorFill} 0 25%, transparent 0 50%, ${colorFill} 0 75%, transparent 0)`,
  backgroundSize: `${size} ${size}`
}), "getTransBg");
var genColorBlockStyle = /* @__PURE__ */ __name((token2, size) => {
  const { componentCls, borderRadiusSM, colorPickerInsetShadow, lineWidth, colorFillSecondary } = token2;
  return {
    [`${componentCls}-color-block`]: {
      position: "relative",
      borderRadius: borderRadiusSM,
      width: size,
      height: size,
      boxShadow: colorPickerInsetShadow,
      ...getTransBg("50%", token2.colorFillSecondary),
      [`${componentCls}-color-block-inner`]: {
        width: "100%",
        height: "100%",
        border: `${unit(lineWidth)} solid ${colorFillSecondary}`,
        borderRadius: "inherit"
      }
    }
  };
}, "genColorBlockStyle");
var color_block_default = genColorBlockStyle;

// packages/ant-design/components/color-picker/style/input.ts
var genInputStyle2 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    fontSizeSM,
    lineHeightSM,
    colorPickerAlphaInputWidth,
    marginXXS,
    paddingXXS,
    controlHeightSM,
    marginXS,
    fontSizeIcon,
    paddingXS,
    colorTextPlaceholder,
    colorPickerInputNumberHandleWidth,
    lineWidth
  } = token2;
  return {
    [`${componentCls}-input-container`]: {
      display: "flex",
      [`${componentCls}-steppers${antCls}-input-number`]: {
        fontSize: fontSizeSM,
        lineHeight: lineHeightSM,
        [`${antCls}-input-number-input`]: {
          paddingInlineStart: paddingXXS,
          paddingInlineEnd: 0
        },
        [`${antCls}-input-number-handler-wrap`]: {
          width: colorPickerInputNumberHandleWidth
        }
      },
      [`${componentCls}-steppers${componentCls}-alpha-input`]: {
        flex: `0 0 ${unit(colorPickerAlphaInputWidth)}`,
        marginInlineStart: marginXXS
      },
      [`${componentCls}-format-select${antCls}-select`]: {
        marginInlineEnd: marginXS,
        width: "auto",
        "&-single": {
          [`${antCls}-select-selector`]: {
            padding: 0,
            border: 0
          },
          [`${antCls}-select-arrow`]: {
            insetInlineEnd: 0
          },
          [`${antCls}-select-selection-item`]: {
            paddingInlineEnd: token2.calc(fontSizeIcon).add(marginXXS).equal(),
            fontSize: fontSizeSM,
            lineHeight: `${unit(controlHeightSM)}`
          },
          [`${antCls}-select-item-option-content`]: {
            fontSize: fontSizeSM,
            lineHeight: lineHeightSM
          },
          [`${antCls}-select-dropdown`]: {
            [`${antCls}-select-item`]: {
              minHeight: "auto"
            }
          }
        }
      },
      [`${componentCls}-input`]: {
        gap: marginXXS,
        alignItems: "center",
        flex: 1,
        width: 0,
        [`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
          display: "flex",
          gap: marginXXS,
          alignItems: "center"
        },
        [`${componentCls}-steppers`]: {
          flex: 1
        },
        [`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
          flex: 1,
          padding: `0 ${unit(paddingXS)}`,
          [`${antCls}-input`]: {
            fontSize: fontSizeSM,
            textTransform: "uppercase",
            lineHeight: unit(token2.calc(controlHeightSM).sub(token2.calc(lineWidth).mul(2)).equal())
          },
          [`${antCls}-input-prefix`]: {
            color: colorTextPlaceholder
          }
        }
      }
    }
  };
}, "genInputStyle");
var input_default2 = genInputStyle2;

// packages/ant-design/components/color-picker/style/picker.ts
var genPickerStyle2 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    controlHeightLG,
    borderRadiusSM,
    colorPickerInsetShadow,
    marginSM,
    colorBgElevated,
    colorFillSecondary,
    lineWidthBold,
    colorPickerHandlerSize,
    colorPickerHandlerSizeSM,
    colorPickerSliderHeight
  } = token2;
  return {
    [`${componentCls}-select`]: {
      [`${componentCls}-palette`]: {
        minHeight: token2.calc(controlHeightLG).mul(4).equal(),
        overflow: "hidden",
        borderRadius: borderRadiusSM
      },
      [`${componentCls}-saturation`]: {
        position: "absolute",
        borderRadius: "inherit",
        boxShadow: colorPickerInsetShadow,
        inset: 0
      },
      marginBottom: marginSM
    },
    [`${componentCls}-handler`]: {
      width: colorPickerHandlerSize,
      height: colorPickerHandlerSize,
      border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
      position: "relative",
      borderRadius: "50%",
      cursor: "pointer",
      boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
      "&-sm": {
        width: colorPickerHandlerSizeSM,
        height: colorPickerHandlerSizeSM
      }
    },
    [`${componentCls}-slider`]: {
      borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
      [`${componentCls}-palette`]: {
        height: colorPickerSliderHeight
      },
      [`${componentCls}-gradient`]: {
        borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
        boxShadow: colorPickerInsetShadow
      },
      "&-alpha": getTransBg(`${unit(colorPickerSliderHeight)}`, token2.colorFillSecondary),
      "&-hue": { marginBottom: marginSM }
    },
    [`${componentCls}-slider-container`]: {
      display: "flex",
      gap: marginSM,
      marginBottom: marginSM,
      [`${componentCls}-slider-group`]: {
        flex: 1,
        "&-disabled-alpha": {
          display: "flex",
          alignItems: "center",
          [`${componentCls}-slider`]: {
            flex: 1,
            marginBottom: 0
          }
        }
      }
    }
  };
}, "genPickerStyle");
var picker_default = genPickerStyle2;

// packages/ant-design/components/color-picker/style/presets.ts
var genPresetsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    colorTextQuaternary,
    paddingXXS,
    colorPickerPresetColorSize,
    fontSizeSM,
    colorText,
    lineHeightSM,
    lineWidth,
    borderRadius,
    colorFill,
    colorWhite,
    marginXXS,
    paddingXS,
    fontHeightSM
  } = token2;
  return {
    [`${componentCls}-presets`]: {
      [`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
        padding: 0,
        [`${antCls}-collapse-expand-icon`]: {
          height: fontHeightSM,
          color: colorTextQuaternary,
          paddingInlineEnd: paddingXXS
        }
      },
      [`${antCls}-collapse`]: {
        display: "flex",
        flexDirection: "column",
        gap: marginXXS
      },
      [`${antCls}-collapse-item > ${antCls}-collapse-content > ${antCls}-collapse-content-box`]: {
        padding: `${unit(paddingXS)} 0`
      },
      "&-label": {
        fontSize: fontSizeSM,
        color: colorText,
        lineHeight: lineHeightSM
      },
      "&-items": {
        display: "flex",
        flexWrap: "wrap",
        gap: token2.calc(marginXXS).mul(1.5).equal(),
        [`${componentCls}-presets-color`]: {
          position: "relative",
          cursor: "pointer",
          width: colorPickerPresetColorSize,
          height: colorPickerPresetColorSize,
          "&::before": {
            content: '""',
            pointerEvents: "none",
            width: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            height: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            position: "absolute",
            top: token2.calc(lineWidth).mul(-2).equal(),
            insetInlineStart: token2.calc(lineWidth).mul(-2).equal(),
            borderRadius,
            border: `${unit(lineWidth)} solid transparent`,
            transition: `border-color ${token2.motionDurationMid} ${token2.motionEaseInBack}`
          },
          "&:hover::before": {
            borderColor: colorFill
          },
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: token2.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
            height: token2.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
            border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          },
          [`&${componentCls}-presets-color-checked`]: {
            "&::after": {
              opacity: 1,
              borderColor: colorWhite,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `transform ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            },
            [`&${componentCls}-presets-color-bright`]: {
              "&::after": {
                borderColor: "rgba(0, 0, 0, 0.45)"
              }
            }
          }
        }
      },
      "&-empty": {
        fontSize: fontSizeSM,
        color: colorTextQuaternary
      }
    }
  };
}, "genPresetsStyle");
var presets_default = genPresetsStyle;

// packages/ant-design/components/color-picker/style/index.ts
var genActiveStyle = /* @__PURE__ */ __name((token2, borderColor, outlineColor) => ({
  borderInlineEndWidth: token2.lineWidth,
  borderColor,
  boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${outlineColor}`,
  outline: 0
}), "genActiveStyle");
var genRtlStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    "&-rtl": {
      [`${componentCls}-presets-color`]: {
        "&::after": {
          direction: "ltr"
        }
      },
      [`${componentCls}-clear`]: {
        "&::after": {
          direction: "ltr"
        }
      }
    }
  };
}, "genRtlStyle");
var genClearStyle = /* @__PURE__ */ __name((token2, size, extraStyle) => {
  const { componentCls, borderRadiusSM, lineWidth, colorSplit, colorBorder, red6 } = token2;
  return {
    [`${componentCls}-clear`]: {
      width: size,
      height: size,
      borderRadius: borderRadiusSM,
      border: `${unit(lineWidth)} solid ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      cursor: "pointer",
      transition: `all ${token2.motionDurationFast}`,
      ...extraStyle,
      "&::after": {
        content: '""',
        position: "absolute",
        insetInlineEnd: lineWidth,
        top: 0,
        display: "block",
        width: 40,
        // maximum
        height: 2,
        // fixed
        transformOrigin: "right",
        transform: "rotate(-45deg)",
        backgroundColor: red6
      },
      "&:hover": {
        borderColor: colorBorder
      }
    }
  };
}, "genClearStyle");
var genStatusStyle2 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorHover,
    colorWarningHover,
    colorErrorOutline,
    colorWarningOutline
  } = token2;
  return {
    [`&${componentCls}-status-error`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorError, colorErrorOutline)
      }
    },
    [`&${componentCls}-status-warning`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorWarning, colorWarningOutline)
      }
    }
  };
}, "genStatusStyle");
var genSizeStyle4 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    controlHeightLG,
    controlHeightSM,
    controlHeight,
    controlHeightXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusXS,
    borderRadiusLG,
    fontSizeLG
  } = token2;
  return {
    [`&${componentCls}-lg`]: {
      minWidth: controlHeightLG,
      height: controlHeightLG,
      borderRadius: borderRadiusLG,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeight,
        height: controlHeight,
        borderRadius
      },
      [`${componentCls}-trigger-text`]: {
        fontSize: fontSizeLG
      }
    },
    [`&${componentCls}-sm`]: {
      minWidth: controlHeightSM,
      height: controlHeightSM,
      borderRadius: borderRadiusSM,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeightXS,
        height: controlHeightXS,
        borderRadius: borderRadiusXS
      }
    }
  };
}, "genSizeStyle");
var genColorPickerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    colorPickerWidth,
    colorPrimary,
    motionDurationMid,
    colorBgElevated,
    colorTextDisabled,
    colorText,
    colorBgContainerDisabled,
    borderRadius,
    marginXS,
    marginSM,
    controlHeight,
    controlHeightSM,
    colorBgTextActive,
    colorPickerPresetColorSize,
    colorPickerPreviewSize,
    lineWidth,
    colorBorder,
    paddingXXS,
    fontSize,
    colorPrimaryHover,
    controlOutline
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-inner`]: {
          "&-content": {
            display: "flex",
            flexDirection: "column",
            width: colorPickerWidth,
            [`& > ${antCls}-divider`]: {
              margin: `${unit(marginSM)} 0 ${unit(marginXS)}`
            }
          },
          [`${componentCls}-panel`]: {
            ...picker_default(token2)
          },
          ...color_block_default(token2, colorPickerPreviewSize),
          ...input_default2(token2),
          ...presets_default(token2),
          ...genClearStyle(token2, colorPickerPresetColorSize, {
            marginInlineStart: "auto",
            marginBottom: marginXS
          })
        },
        "&-trigger": {
          minWidth: controlHeight,
          height: controlHeight,
          borderRadius,
          border: `${unit(lineWidth)} solid ${colorBorder}`,
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          transition: `all ${motionDurationMid}`,
          background: colorBgElevated,
          padding: token2.calc(paddingXXS).sub(lineWidth).equal(),
          [`${componentCls}-trigger-text`]: {
            marginInlineStart: marginXS,
            marginInlineEnd: token2.calc(marginXS).sub(token2.calc(paddingXXS).sub(lineWidth)).equal(),
            fontSize,
            color: colorText
          },
          "&:hover": {
            borderColor: colorPrimaryHover
          },
          [`&${componentCls}-trigger-active`]: {
            ...genActiveStyle(token2, colorPrimary, controlOutline)
          },
          "&-disabled": {
            color: colorTextDisabled,
            background: colorBgContainerDisabled,
            cursor: "not-allowed",
            "&:hover": {
              borderColor: colorBgTextActive
            },
            [`${componentCls}-trigger-text`]: {
              color: colorTextDisabled
            }
          },
          ...genClearStyle(token2, controlHeightSM),
          ...color_block_default(token2, controlHeightSM),
          ...genStatusStyle2(token2),
          ...genSizeStyle4(token2)
        },
        ...genRtlStyle2(token2)
      }
    }
  ];
}, "genColorPickerStyle");
var style_default34 = genStyleHooks("ColorPicker", (token2) => {
  const { colorTextQuaternary, marginSM } = token2;
  const colorPickerSliderHeight = 8;
  const colorPickerToken = merge2(token2, {
    colorPickerWidth: 234,
    colorPickerHandlerSize: 16,
    colorPickerHandlerSizeSM: 12,
    colorPickerAlphaInputWidth: 44,
    colorPickerInputNumberHandleWidth: 16,
    colorPickerPresetColorSize: 18,
    colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
    colorPickerSliderHeight,
    colorPickerPreviewSize: token2.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
  });
  return [genColorPickerStyle(colorPickerToken)];
});

// packages/ant-design/components/color-picker/ColorPicker.tsx
var ColorPicker = /* @__PURE__ */ __name((props) => {
  const {
    value,
    defaultValue,
    format: format2,
    defaultFormat,
    allowClear = false,
    presets,
    children,
    trigger = "click",
    open: open3,
    disabled,
    placement = "bottomLeft",
    arrow = true,
    panelRender,
    showText,
    style: style2,
    className,
    size: customizeSize,
    rootClassName,
    prefixCls: customizePrefixCls,
    styles,
    disabledAlpha = false,
    onFormatChange,
    onChange,
    onClear,
    onOpenChange,
    onChangeComplete,
    getPopupContainer,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    destroyTooltipOnHide,
    ...rest
  } = props;
  const { getPrefixCls, direction, colorPicker } = useContext144(ConfigContext);
  const contextDisabled = useContext144(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const [colorValue, setColorValue, prevValue] = useColorState_default2("", {
    value,
    defaultValue
  });
  const [popupOpen, setPopupOpen] = useMergedState(false, {
    value: open3,
    postState: (openData) => !mergedDisabled && openData,
    onChange: onOpenChange
  });
  const [formatValue2, setFormatValue] = useMergedState(format2, {
    value: format2,
    defaultValue: defaultFormat,
    onChange: onFormatChange
  });
  const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
  const isAlphaColor = useMemo109(() => getAlphaColor3(colorValue) < 100, [colorValue]);
  const { status: contextStatus } = React374.useContext(FormItemInputContext);
  const mergedSize = useSize_default(customizeSize);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default34(prefixCls, rootCls);
  const rtlCls = { [`${prefixCls}-rtl`]: direction };
  const mergedRootCls = (0, import_classnames153.default)(rootClassName, cssVarCls, rootCls, rtlCls);
  const mergedCls = (0, import_classnames153.default)(
    getStatusClassNames(prefixCls, contextStatus),
    {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large"
    },
    colorPicker?.className,
    mergedRootCls,
    className,
    hashId
  );
  const mergedPopupCls = (0, import_classnames153.default)(prefixCls, mergedRootCls);
  const popupAllowCloseRef = useRef121(true);
  if (true) {
    const warning5 = devUseWarning("ColorPicker");
    warning5(
      !(disabledAlpha && isAlphaColor),
      "usage",
      "`disabledAlpha` will make the alpha to be 100% when use alpha color."
    );
  }
  const handleChange = /* @__PURE__ */ __name((data, type5, pickColor) => {
    let color = generateColor2(data);
    const isNull = value === null || !value && defaultValue === null;
    if (prevValue.current?.cleared || isNull) {
      if (getAlphaColor3(colorValue) === 0 && type5 !== "alpha") {
        color = genAlphaColor(color);
      }
    }
    if (disabledAlpha && isAlphaColor) {
      color = genAlphaColor(color);
    }
    if (pickColor) {
      popupAllowCloseRef.current = false;
    } else {
      onChangeComplete?.(color);
    }
    setColorValue(color);
    onChange?.(color, color.toHexString());
  }, "handleChange");
  const handleClear = /* @__PURE__ */ __name(() => {
    onClear?.();
  }, "handleClear");
  const handleChangeComplete = /* @__PURE__ */ __name((color) => {
    popupAllowCloseRef.current = true;
    let changeColor = generateColor2(color);
    if (disabledAlpha && isAlphaColor) {
      changeColor = genAlphaColor(color);
    }
    onChangeComplete?.(changeColor);
  }, "handleChangeComplete");
  const popoverProps = {
    open: popupOpen,
    trigger,
    placement,
    arrow,
    rootClassName,
    getPopupContainer,
    autoAdjustOverflow: autoAdjustOverflow3,
    destroyTooltipOnHide
  };
  const colorBaseProps = {
    prefixCls,
    color: colorValue,
    allowClear,
    disabled: mergedDisabled,
    disabledAlpha,
    presets,
    panelRender,
    format: formatValue2,
    onFormatChange: setFormatValue,
    onChangeComplete: handleChangeComplete
  };
  const mergedStyle = { ...colorPicker?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React374.createElement(
      popover_default,
      {
        style: styles?.popup,
        overlayInnerStyle: styles?.popupOverlayInner,
        onOpenChange: (visible) => {
          if (popupAllowCloseRef.current && !mergedDisabled) {
            setPopupOpen(visible);
          }
        },
        content: /* @__PURE__ */ React374.createElement(NoFormStyle, { override: true, status: true }, /* @__PURE__ */ React374.createElement(
          ColorPickerPanel_default,
          {
            ...colorBaseProps,
            onChange: handleChange,
            onChangeComplete: handleChangeComplete,
            onClear: handleClear
          }
        )),
        overlayClassName: mergedPopupCls,
        ...popoverProps
      },
      children || /* @__PURE__ */ React374.createElement(
        ColorTrigger_default,
        {
          open: popupOpen,
          className: mergedCls,
          style: mergedStyle,
          prefixCls,
          disabled: mergedDisabled,
          showText,
          format: formatValue2,
          ...rest,
          color: colorValue
        }
      )
    )
  );
}, "ColorPicker");
if (true) {
  ColorPicker.displayName = "ColorPicker";
}
var PurePanel9 = PurePanel_default3(
  ColorPicker,
  "color-picker",
  /* istanbul ignore next */
  (prefixCls) => prefixCls,
  (props) => ({
    ...props,
    placement: "bottom",
    autoAdjustOverflow: false
  })
);
ColorPicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel9;
var ColorPicker_default2 = ColorPicker;

// packages/ant-design/components/color-picker/index.ts
var color_picker_default = ColorPicker_default2;

// packages/ant-design/components/date-picker/generatePicker/generateRangePicker.tsx
var import_CalendarOutlined = __toESM(require_CalendarOutlined3());
var import_ClockCircleOutlined = __toESM(require_ClockCircleOutlined3());
var import_SwapRightOutlined = __toESM(require_SwapRightOutlined3());
var import_classnames154 = __toESM(require_classnames());
import * as React377 from "react";
import { forwardRef as forwardRef89, useContext as useContext146, useImperativeHandle as useImperativeHandle33 } from "react";

// packages/ant-design/components/date-picker/util.ts
import * as React375 from "react";
function getPlaceholder(locale6, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale6.lang.yearPlaceholder) {
    return locale6.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale6.lang.quarterPlaceholder) {
    return locale6.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale6.lang.monthPlaceholder) {
    return locale6.lang.monthPlaceholder;
  }
  if (picker === "week" && locale6.lang.weekPlaceholder) {
    return locale6.lang.weekPlaceholder;
  }
  if (picker === "time" && locale6.timePickerLocale.placeholder) {
    return locale6.timePickerLocale.placeholder;
  }
  return locale6.lang.placeholder;
}
__name(getPlaceholder, "getPlaceholder");
function getRangePlaceholder(locale6, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale6.lang.yearPlaceholder) {
    return locale6.lang.rangeYearPlaceholder;
  }
  if (picker === "quarter" && locale6.lang.quarterPlaceholder) {
    return locale6.lang.rangeQuarterPlaceholder;
  }
  if (picker === "month" && locale6.lang.monthPlaceholder) {
    return locale6.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale6.lang.weekPlaceholder) {
    return locale6.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale6.timePickerLocale.placeholder) {
    return locale6.timePickerLocale.rangePlaceholder;
  }
  return locale6.lang.rangePlaceholder;
}
__name(getRangePlaceholder, "getRangePlaceholder");
function transPlacement2DropdownAlign(direction, placement) {
  const overflow = {
    adjustX: 1,
    adjustY: 1
  };
  switch (placement) {
    case "bottomLeft": {
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
    case "bottomRight": {
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow
      };
    }
    case "topLeft": {
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow
      };
    }
    case "topRight": {
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow
      };
    }
    default: {
      return {
        points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
  }
}
__name(transPlacement2DropdownAlign, "transPlacement2DropdownAlign");
function useIcons2(props, prefixCls) {
  const { allowClear = true } = props;
  const { clearIcon, removeIcon } = useIcons({
    ...props,
    prefixCls,
    componentName: "DatePicker"
  });
  const mergedAllowClear = React375.useMemo(() => {
    if (allowClear === false) {
      return false;
    }
    const allowClearConfig = allowClear === true ? {} : allowClear;
    return {
      clearIcon,
      ...allowClearConfig
    };
  }, [allowClear, clearIcon]);
  return [mergedAllowClear, removeIcon];
}
__name(useIcons2, "useIcons");

// packages/ant-design/components/date-picker/generatePicker/useComponents.ts
import { useMemo as useMemo111 } from "react";

// packages/ant-design/components/date-picker/PickerButton.tsx
import * as React376 from "react";
function PickerButton(props) {
  return /* @__PURE__ */ React376.createElement(button_default2, { size: "small", type: "primary", ...props });
}
__name(PickerButton, "PickerButton");

// packages/ant-design/components/date-picker/generatePicker/useComponents.ts
function useComponents(components) {
  return useMemo111(
    () => ({
      button: PickerButton,
      ...components
    }),
    [components]
  );
}
__name(useComponents, "useComponents");

// packages/ant-design/components/date-picker/generatePicker/generateRangePicker.tsx
function generateRangePicker(generateConfig2) {
  const RangePicker3 = forwardRef89((props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      getPopupContainer: customGetPopupContainer,
      components,
      className,
      style: style2,
      placement,
      size: customizeSize,
      disabled: customDisabled,
      bordered = true,
      placeholder,
      popupClassName,
      dropdownClassName,
      status: customStatus,
      rootClassName,
      variant: customVariant,
      ...restProps
    } = props;
    const innerRef = React377.useRef(null);
    const { getPrefixCls, direction, getPopupContainer, rangePicker } = useContext146(ConfigContext);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
    const { picker } = props;
    const rootPrefixCls = getPrefixCls();
    const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [wrapCSSVar, hashId, cssVarCls] = style_default23(prefixCls, rootCls);
    if (true) {
      const warning5 = devUseWarning("DatePicker.RangePicker");
      warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
      warning5.deprecated(!("bordered" in props), "bordered", "variant");
    }
    const [mergedAllowClear] = useIcons2(props, prefixCls);
    const mergedComponents = useComponents(components);
    const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
    const disabled = React377.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled ?? disabled;
    const formItemContext = useContext146(FormItemInputContext);
    const { hasFeedback, status: contextStatus, feedbackIcon } = formItemContext;
    const suffixNode = /* @__PURE__ */ React377.createElement(React377.Fragment, null, picker === "time" ? /* @__PURE__ */ React377.createElement(import_ClockCircleOutlined.default, null) : /* @__PURE__ */ React377.createElement(import_CalendarOutlined.default, null), hasFeedback && feedbackIcon);
    useImperativeHandle33(ref, () => innerRef.current);
    const [contextLocale] = useLocale_default("Calendar", en_US_default4);
    const locale6 = { ...contextLocale, ...props.locale };
    const [zIndex] = useZIndex("DatePicker", props.popupStyle?.zIndex);
    return wrapCSSVar(
      /* @__PURE__ */ React377.createElement(NoCompactStyle, null, /* @__PURE__ */ React377.createElement(
        RangePicker_default,
        {
          separator: /* @__PURE__ */ React377.createElement("span", { "aria-label": "to", className: `${prefixCls}-separator` }, /* @__PURE__ */ React377.createElement(import_SwapRightOutlined.default, null)),
          disabled: mergedDisabled,
          ref: innerRef,
          popupAlign: transPlacement2DropdownAlign(direction, placement),
          placeholder: getRangePlaceholder(locale6, picker, placeholder),
          suffixIcon: suffixNode,
          prevIcon: /* @__PURE__ */ React377.createElement("span", { className: `${prefixCls}-prev-icon` }),
          nextIcon: /* @__PURE__ */ React377.createElement("span", { className: `${prefixCls}-next-icon` }),
          superPrevIcon: /* @__PURE__ */ React377.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
          superNextIcon: /* @__PURE__ */ React377.createElement("span", { className: `${prefixCls}-super-next-icon` }),
          transitionName: `${rootPrefixCls}-slide-up`,
          ...restProps,
          className: (0, import_classnames154.default)(
            {
              [`${prefixCls}-${mergedSize}`]: mergedSize,
              [`${prefixCls}-${variant}`]: enableVariantCls
            },
            getStatusClassNames(
              prefixCls,
              getMergedStatus(contextStatus, customStatus),
              hasFeedback
            ),
            hashId,
            compactItemClassnames,
            className,
            rangePicker?.className,
            cssVarCls,
            rootCls,
            rootClassName
          ),
          style: { ...rangePicker?.style, ...style2 },
          locale: locale6.lang,
          prefixCls,
          getPopupContainer: customGetPopupContainer || getPopupContainer,
          generateConfig: generateConfig2,
          components: mergedComponents,
          direction,
          classNames: {
            popup: (0, import_classnames154.default)(
              hashId,
              popupClassName || dropdownClassName,
              cssVarCls,
              rootCls,
              rootClassName
            )
          },
          styles: {
            popup: {
              ...props.popupStyle,
              zIndex
            }
          },
          allowClear: mergedAllowClear
        }
      ))
    );
  });
  if (true) {
    RangePicker3.displayName = "RangePicker";
  }
  return RangePicker3;
}
__name(generateRangePicker, "generateRangePicker");

// packages/ant-design/components/date-picker/generatePicker/generateSinglePicker.tsx
var import_CalendarOutlined2 = __toESM(require_CalendarOutlined3());
var import_ClockCircleOutlined2 = __toESM(require_ClockCircleOutlined3());
var import_classnames155 = __toESM(require_classnames());
import * as React378 from "react";
import { forwardRef as forwardRef90, useContext as useContext148, useImperativeHandle as useImperativeHandle34 } from "react";
function generatePicker(generateConfig2) {
  function getPicker(picker, displayName) {
    const consumerName = displayName === "TimePicker" ? "timePicker" : "datePicker";
    const Picker3 = forwardRef90((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        getPopupContainer: customizeGetPopupContainer,
        components,
        style: style2,
        className,
        rootClassName,
        size: customizeSize,
        bordered,
        placement,
        placeholder,
        popupClassName,
        dropdownClassName,
        disabled: customDisabled,
        status: customStatus,
        variant: customVariant,
        onCalendarChange,
        ...restProps
      } = props;
      const {
        getPrefixCls,
        direction,
        getPopupContainer,
        // Consume different styles according to different names
        [consumerName]: consumerStyle
      } = useContext148(ConfigContext);
      const prefixCls = getPrefixCls("picker", customizePrefixCls);
      const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
      const innerRef = React378.useRef(null);
      const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
      const rootCls = useCSSVarCls_default(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = style_default23(prefixCls, rootCls);
      useImperativeHandle34(ref, () => innerRef.current);
      const additionalProps = {
        showToday: true
      };
      const mergedPicker = picker || props.picker;
      const rootPrefixCls = getPrefixCls();
      const { onSelect, multiple } = restProps;
      const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
      const onInternalCalendarChange = /* @__PURE__ */ __name((date4, dateStr, info) => {
        onCalendarChange?.(date4, dateStr, info);
        if (hasLegacyOnSelect) {
          onSelect(date4);
        }
      }, "onInternalCalendarChange");
      if (true) {
        const warning5 = devUseWarning(displayName || "DatePicker");
        warning5(
          picker !== "quarter",
          "deprecated",
          `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`
        );
        warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
        warning5.deprecated(!("bordered" in props), "bordered", "variant");
        warning5.deprecated(!hasLegacyOnSelect, "onSelect", "onCalendarChange");
      }
      const [mergedAllowClear, removeIcon] = useIcons2(props, prefixCls);
      const mergedComponents = useComponents(components);
      const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
      const disabled = React378.useContext(DisabledContext_default);
      const mergedDisabled = customDisabled ?? disabled;
      const formItemContext = useContext148(FormItemInputContext);
      const { hasFeedback, status: contextStatus, feedbackIcon } = formItemContext;
      const suffixNode = /* @__PURE__ */ React378.createElement(React378.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ React378.createElement(import_ClockCircleOutlined2.default, null) : /* @__PURE__ */ React378.createElement(import_CalendarOutlined2.default, null), hasFeedback && feedbackIcon);
      const [contextLocale] = useLocale_default("DatePicker", en_US_default4);
      const locale6 = { ...contextLocale, ...props.locale };
      const [zIndex] = useZIndex("DatePicker", props.popupStyle?.zIndex);
      return wrapCSSVar(
        /* @__PURE__ */ React378.createElement(NoCompactStyle, null, /* @__PURE__ */ React378.createElement(
          src_default10,
          {
            ref: innerRef,
            placeholder: getPlaceholder(locale6, mergedPicker, placeholder),
            suffixIcon: suffixNode,
            dropdownAlign: transPlacement2DropdownAlign(direction, placement),
            prevIcon: /* @__PURE__ */ React378.createElement("span", { className: `${prefixCls}-prev-icon` }),
            nextIcon: /* @__PURE__ */ React378.createElement("span", { className: `${prefixCls}-next-icon` }),
            superPrevIcon: /* @__PURE__ */ React378.createElement("span", { className: `${prefixCls}-super-prev-icon` }),
            superNextIcon: /* @__PURE__ */ React378.createElement("span", { className: `${prefixCls}-super-next-icon` }),
            transitionName: `${rootPrefixCls}-slide-up`,
            picker,
            onCalendarChange: onInternalCalendarChange,
            ...additionalProps,
            ...restProps,
            locale: locale6.lang,
            className: (0, import_classnames155.default)(
              {
                [`${prefixCls}-${mergedSize}`]: mergedSize,
                [`${prefixCls}-${variant}`]: enableVariantCls
              },
              getStatusClassNames(
                prefixCls,
                getMergedStatus(contextStatus, customStatus),
                hasFeedback
              ),
              hashId,
              compactItemClassnames,
              consumerStyle?.className,
              className,
              cssVarCls,
              rootCls,
              rootClassName
            ),
            style: { ...consumerStyle?.style, ...style2 },
            prefixCls,
            getPopupContainer: customizeGetPopupContainer || getPopupContainer,
            generateConfig: generateConfig2,
            components: mergedComponents,
            direction,
            disabled: mergedDisabled,
            classNames: {
              popup: (0, import_classnames155.default)(
                hashId,
                cssVarCls,
                rootCls,
                rootClassName,
                popupClassName || dropdownClassName
              )
            },
            styles: {
              popup: {
                ...props.popupStyle,
                zIndex
              }
            },
            allowClear: mergedAllowClear,
            removeIcon
          }
        ))
      );
    });
    if (displayName) {
      Picker3.displayName = displayName;
    }
    return Picker3;
  }
  __name(getPicker, "getPicker");
  const DatePicker2 = getPicker();
  const WeekPicker = getPicker("week", "WeekPicker");
  const MonthPicker = getPicker("month", "MonthPicker");
  const YearPicker = getPicker("year", "YearPicker");
  const QuarterPicker = getPicker("quarter", "QuarterPicker");
  const TimePicker2 = getPicker("time", "TimePicker");
  return { DatePicker: DatePicker2, WeekPicker, MonthPicker, YearPicker, TimePicker: TimePicker2, QuarterPicker };
}
__name(generatePicker, "generatePicker");

// packages/ant-design/components/date-picker/generatePicker/index.tsx
function generatePicker2(generateConfig2) {
  const { DatePicker: DatePicker2, WeekPicker, MonthPicker, YearPicker, TimePicker: TimePicker2, QuarterPicker } = generatePicker(generateConfig2);
  const RangePicker3 = generateRangePicker(generateConfig2);
  const MergedDatePicker = DatePicker2;
  MergedDatePicker.WeekPicker = WeekPicker;
  MergedDatePicker.MonthPicker = MonthPicker;
  MergedDatePicker.YearPicker = YearPicker;
  MergedDatePicker.RangePicker = RangePicker3;
  MergedDatePicker.TimePicker = TimePicker2;
  MergedDatePicker.QuarterPicker = QuarterPicker;
  if (true) {
    MergedDatePicker.displayName = "DatePicker";
  }
  return MergedDatePicker;
}
__name(generatePicker2, "generatePicker");
var generatePicker_default = generatePicker2;

// packages/ant-design/components/date-picker/index.ts
var DatePicker = generatePicker_default(dayjs_default);
function postPureProps2(props) {
  const dropdownAlign = transPlacement2DropdownAlign(props.direction, props.placement);
  dropdownAlign.overflow.adjustY = false;
  dropdownAlign.overflow.adjustX = false;
  return {
    ...props,
    dropdownAlign
  };
}
__name(postPureProps2, "postPureProps");
var PurePanel10 = PurePanel_default3(DatePicker, "picker", null, postPureProps2);
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel10;
var PureRangePanel = PurePanel_default3(DatePicker.RangePicker, "picker", null, postPureProps2);
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
DatePicker.generatePicker = generatePicker_default;
var date_picker_default = DatePicker;

// packages/ant-design/components/descriptions/index.tsx
var import_classnames157 = __toESM(require_classnames());
import * as React383 from "react";

// packages/ant-design/components/descriptions/constant.ts
var DEFAULT_COLUMN_MAP = {
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
var constant_default = DEFAULT_COLUMN_MAP;

// packages/ant-design/components/descriptions/DescriptionsContext.ts
import React379 from "react";
var DescriptionsContext = React379.createContext({});
var DescriptionsContext_default = DescriptionsContext;

// packages/ant-design/components/descriptions/hooks/useItems.ts
import * as React380 from "react";
var transChildren2Items = /* @__PURE__ */ __name((childNodes) => toArray(childNodes).map((node2) => ({ ...node2?.props, key: node2.key })), "transChildren2Items");
function useItems4(screens, items, children) {
  const mergedItems = React380.useMemo(
    () => (
      // Take `items` first or convert `children` into items
      items || transChildren2Items(children)
    ),
    [items, children]
  );
  const responsiveItems = React380.useMemo(
    () => mergedItems.map(({ span, ...restItem }) => ({
      ...restItem,
      span: typeof span === "number" ? span : matchScreen(screens, span)
    })),
    [mergedItems, screens]
  );
  return responsiveItems;
}
__name(useItems4, "useItems");

// packages/ant-design/components/descriptions/hooks/useRow.ts
import { useMemo as useMemo113 } from "react";
function getFilledItem(rowItem, rowRestCol, span) {
  let clone = rowItem;
  let exceed = false;
  if (span === void 0 || span > rowRestCol) {
    clone = {
      ...rowItem,
      span: rowRestCol
    };
    exceed = span !== void 0;
  }
  return [clone, exceed];
}
__name(getFilledItem, "getFilledItem");
function getCalcRows(rowItems, mergedColumn) {
  const rows = [];
  let tmpRow = [];
  let rowRestCol = mergedColumn;
  let exceed = false;
  rowItems.filter((n2) => n2).forEach((rowItem, index3) => {
    const span = rowItem?.span;
    const mergedSpan = span || 1;
    if (index3 === rowItems.length - 1) {
      const [item, itemExceed] = getFilledItem(rowItem, rowRestCol, span);
      exceed = exceed || itemExceed;
      tmpRow.push(item);
      rows.push(tmpRow);
      return;
    }
    if (mergedSpan < rowRestCol) {
      rowRestCol -= mergedSpan;
      tmpRow.push(rowItem);
    } else {
      const [item, itemExceed] = getFilledItem(rowItem, rowRestCol, mergedSpan);
      exceed = exceed || itemExceed;
      tmpRow.push(item);
      rows.push(tmpRow);
      rowRestCol = mergedColumn;
      tmpRow = [];
    }
  });
  return [rows, exceed];
}
__name(getCalcRows, "getCalcRows");
var useRow = /* @__PURE__ */ __name((mergedColumn, items) => {
  const [rows, exceed] = useMemo113(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);
  if (true) {
    const warning5 = devUseWarning("Descriptions");
    warning5(!exceed, "usage", "Sum of column `span` in a line not match `column` of Descriptions.");
  }
  return rows;
}, "useRow");
var useRow_default = useRow;

// packages/ant-design/components/descriptions/Item.ts
var DescriptionsItem = /* @__PURE__ */ __name(({ children }) => children, "DescriptionsItem");
var Item_default2 = DescriptionsItem;

// packages/ant-design/components/descriptions/Row.tsx
import * as React382 from "react";

// packages/ant-design/components/descriptions/Cell.tsx
var import_classnames156 = __toESM(require_classnames());
import * as React381 from "react";
function notEmpty(val) {
  return val !== void 0 && val !== null;
}
__name(notEmpty, "notEmpty");
var Cell = /* @__PURE__ */ __name((props) => {
  const {
    itemPrefixCls,
    component,
    span,
    className,
    style: style2,
    labelStyle,
    contentStyle,
    bordered,
    label,
    content,
    colon,
    type: type5
  } = props;
  const Component11 = component;
  if (bordered) {
    return /* @__PURE__ */ React381.createElement(
      Component11,
      {
        className: (0, import_classnames156.default)(
          {
            [`${itemPrefixCls}-item-label`]: type5 === "label",
            [`${itemPrefixCls}-item-content`]: type5 === "content"
          },
          className
        ),
        style: style2,
        colSpan: span
      },
      notEmpty(label) && /* @__PURE__ */ React381.createElement("span", { style: labelStyle }, label),
      notEmpty(content) && /* @__PURE__ */ React381.createElement("span", { style: contentStyle }, content)
    );
  }
  return /* @__PURE__ */ React381.createElement(
    Component11,
    {
      className: (0, import_classnames156.default)(`${itemPrefixCls}-item`, className),
      style: style2,
      colSpan: span
    },
    /* @__PURE__ */ React381.createElement("div", { className: `${itemPrefixCls}-item-container` }, (label || label === 0) && /* @__PURE__ */ React381.createElement(
      "span",
      {
        className: (0, import_classnames156.default)(`${itemPrefixCls}-item-label`, {
          [`${itemPrefixCls}-item-no-colon`]: !colon
        }),
        style: labelStyle
      },
      label
    ), (content || content === 0) && /* @__PURE__ */ React381.createElement("span", { className: (0, import_classnames156.default)(`${itemPrefixCls}-item-content`), style: contentStyle }, content))
  );
}, "Cell");
var Cell_default = Cell;

// packages/ant-design/components/descriptions/Row.tsx
function renderCells(items, { colon, prefixCls, bordered }, {
  component,
  type: type5,
  showLabel,
  showContent,
  labelStyle: rootLabelStyle,
  contentStyle: rootContentStyle
}) {
  return items.map(
    ({
      label,
      children,
      prefixCls: itemPrefixCls = prefixCls,
      className,
      style: style2,
      labelStyle,
      contentStyle,
      span = 1,
      key
    }, index3) => {
      if (typeof component === "string") {
        return /* @__PURE__ */ React382.createElement(
          Cell_default,
          {
            key: `${type5}-${key || index3}`,
            className,
            style: style2,
            labelStyle: { ...rootLabelStyle, ...labelStyle },
            contentStyle: { ...rootContentStyle, ...contentStyle },
            span,
            colon,
            component,
            itemPrefixCls,
            bordered,
            label: showLabel ? label : null,
            content: showContent ? children : null,
            type: type5
          }
        );
      }
      return [
        /* @__PURE__ */ React382.createElement(
          Cell_default,
          {
            key: `label-${key || index3}`,
            className,
            style: { ...rootLabelStyle, ...style2, ...labelStyle },
            span: 1,
            colon,
            component: component[0],
            itemPrefixCls,
            bordered,
            label,
            type: "label"
          }
        ),
        /* @__PURE__ */ React382.createElement(
          Cell_default,
          {
            key: `content-${key || index3}`,
            className,
            style: { ...rootContentStyle, ...style2, ...contentStyle },
            span: span * 2 - 1,
            component: component[1],
            itemPrefixCls,
            bordered,
            content: children,
            type: "content"
          }
        )
      ];
    }
  );
}
__name(renderCells, "renderCells");
var Row2 = /* @__PURE__ */ __name((props) => {
  const descContext = React382.useContext(DescriptionsContext_default);
  const { prefixCls, vertical, row, index: index3, bordered } = props;
  if (vertical) {
    return /* @__PURE__ */ React382.createElement(React382.Fragment, null, /* @__PURE__ */ React382.createElement("tr", { key: `label-${index3}`, className: `${prefixCls}-row` }, renderCells(row, props, {
      component: "th",
      type: "label",
      showLabel: true,
      ...descContext
    })), /* @__PURE__ */ React382.createElement("tr", { key: `content-${index3}`, className: `${prefixCls}-row` }, renderCells(row, props, {
      component: "td",
      type: "content",
      showContent: true,
      ...descContext
    })));
  }
  return /* @__PURE__ */ React382.createElement("tr", { key: index3, className: `${prefixCls}-row` }, renderCells(row, props, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    ...descContext
  }));
}, "Row");
var Row_default = Row2;

// packages/ant-design/components/descriptions/style/index.ts
var genBorderedStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, labelBg } = token2;
  return {
    [`&${componentCls}-bordered`]: {
      [`> ${componentCls}-view`]: {
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
        "> table": {
          tableLayout: "auto"
        },
        [`${componentCls}-row`]: {
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
          "&:last-child": {
            borderBottom: "none"
          },
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.padding)} ${unit(token2.paddingLG)}`,
            borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
            "&:last-child": {
              borderInlineEnd: "none"
            }
          },
          [`> ${componentCls}-item-label`]: {
            color: token2.colorTextSecondary,
            backgroundColor: labelBg,
            "&::after": {
              display: "none"
            }
          }
        }
      },
      [`&${componentCls}-middle`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.paddingSM)} ${unit(token2.paddingLG)}`
          }
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.paddingXS)} ${unit(token2.padding)}`
          }
        }
      }
    }
  };
}, "genBorderedStyle");
var genDescriptionStyles = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    extraColor,
    itemPaddingBottom,
    colonMarginRight,
    colonMarginLeft,
    titleMarginBottom
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBorderedStyle(token2),
      [`&-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: titleMarginBottom
      },
      [`${componentCls}-title`]: {
        ...textEllipsis,
        flex: "auto",
        color: token2.titleColor,
        fontWeight: token2.fontWeightStrong,
        fontSize: token2.fontSizeLG,
        lineHeight: token2.lineHeightLG
      },
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: extraColor,
        fontSize: token2.fontSize
      },
      [`${componentCls}-view`]: {
        width: "100%",
        borderRadius: token2.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed",
          borderCollapse: "collapse"
        }
      },
      [`${componentCls}-row`]: {
        "> th, > td": {
          paddingBottom: itemPaddingBottom
        },
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`${componentCls}-item-label`]: {
        color: token2.colorTextTertiary,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          // magic for position
          marginInline: `${unit(colonMarginLeft)} ${unit(colonMarginRight)}`
        },
        [`&${componentCls}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${componentCls}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${componentCls}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: token2.contentColor,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${componentCls}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${componentCls}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${componentCls}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline"
          }
        }
      },
      "&-middle": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token2.paddingSM
          }
        }
      },
      "&-small": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token2.paddingXS
          }
        }
      }
    }
  };
}, "genDescriptionStyles");
var prepareComponentToken29 = /* @__PURE__ */ __name((token2) => ({
  labelBg: token2.colorFillAlter,
  titleColor: token2.colorText,
  titleMarginBottom: token2.fontSizeSM * token2.lineHeightSM,
  itemPaddingBottom: token2.padding,
  colonMarginRight: token2.marginXS,
  colonMarginLeft: token2.marginXXS / 2,
  contentColor: token2.colorText,
  extraColor: token2.colorText
}), "prepareComponentToken");
var style_default35 = genStyleHooks(
  "Descriptions",
  (token2) => {
    const descriptionToken = merge2(token2, {});
    return genDescriptionStyles(descriptionToken);
  },
  prepareComponentToken29
);

// packages/ant-design/components/descriptions/index.tsx
var Descriptions = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    extra,
    column: column2,
    colon = true,
    bordered,
    layout,
    children,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    labelStyle,
    contentStyle,
    items,
    ...restProps
  } = props;
  const { getPrefixCls, direction, descriptions } = React383.useContext(ConfigContext);
  const prefixCls = getPrefixCls("descriptions", customizePrefixCls);
  const screens = useBreakpoint_default();
  const mergedColumn = React383.useMemo(() => {
    if (typeof column2 === "number") {
      return column2;
    }
    return matchScreen(screens, {
      ...constant_default,
      ...column2
    }) ?? 3;
  }, [screens, column2]);
  const mergedItems = useItems4(screens, items, children);
  const mergedSize = useSize_default(customizeSize);
  const rows = useRow_default(mergedColumn, mergedItems);
  const [wrapCSSVar, hashId, cssVarCls] = style_default35(prefixCls);
  const contextValue = React383.useMemo(
    () => ({ labelStyle, contentStyle }),
    [labelStyle, contentStyle]
  );
  return wrapCSSVar(
    /* @__PURE__ */ React383.createElement(DescriptionsContext_default.Provider, { value: contextValue }, /* @__PURE__ */ React383.createElement(
      "div",
      {
        className: (0, import_classnames157.default)(
          prefixCls,
          descriptions?.className,
          {
            [`${prefixCls}-${mergedSize}`]: mergedSize && mergedSize !== "default",
            [`${prefixCls}-bordered`]: !!bordered,
            [`${prefixCls}-rtl`]: direction === "rtl"
          },
          className,
          rootClassName,
          hashId,
          cssVarCls
        ),
        style: { ...descriptions?.style, ...style2 },
        ...restProps
      },
      (title || extra) && /* @__PURE__ */ React383.createElement("div", { className: `${prefixCls}-header` }, title && /* @__PURE__ */ React383.createElement("div", { className: `${prefixCls}-title` }, title), extra && /* @__PURE__ */ React383.createElement("div", { className: `${prefixCls}-extra` }, extra)),
      /* @__PURE__ */ React383.createElement("div", { className: `${prefixCls}-view` }, /* @__PURE__ */ React383.createElement("table", null, /* @__PURE__ */ React383.createElement("tbody", null, rows.map((row, index3) => /* @__PURE__ */ React383.createElement(
        Row_default,
        {
          key: index3,
          index: index3,
          colon,
          prefixCls,
          vertical: layout === "vertical",
          bordered,
          row
        }
      )))))
    ))
  );
}, "Descriptions");
if (true) {
  Descriptions.displayName = "Descriptions";
}
Descriptions.Item = Item_default2;
var descriptions_default = Descriptions;

// packages/ant-design/components/drawer/index.tsx
var import_classnames161 = __toESM(require_classnames());
import * as React389 from "react";

// packages/drawer/src/Drawer.tsx
import * as React387 from "react";

// packages/drawer/src/context.ts
import * as React384 from "react";
var DrawerContext = React384.createContext(null);
var RefContext2 = React384.createContext({});
var context_default9 = DrawerContext;

// packages/drawer/src/DrawerPopup.tsx
var import_classnames159 = __toESM(require_classnames());
import * as React386 from "react";

// packages/drawer/src/DrawerPanel.tsx
var import_classnames158 = __toESM(require_classnames());
import * as React385 from "react";
var DrawerPanel = /* @__PURE__ */ __name((props) => {
  const { prefixCls, className, containerRef, ...restProps } = props;
  const { panel: panelRef } = React385.useContext(RefContext2);
  const mergedRef = useComposeRef(panelRef, containerRef);
  return /* @__PURE__ */ React385.createElement(
    "div",
    {
      className: (0, import_classnames158.default)(`${prefixCls}-content`, className),
      role: "dialog",
      ref: mergedRef,
      ...pickAttrs(props, { aria: true }),
      "aria-modal": "true",
      ...restProps
    }
  );
}, "DrawerPanel");
if (true) {
  DrawerPanel.displayName = "DrawerPanel";
}
var DrawerPanel_default = DrawerPanel;

// packages/drawer/src/util.ts
init_warning();
init_canUseDom();
function parseWidthHeight(value) {
  if (typeof value === "string" && String(Number(value)) === value) {
    warning_default(
      false,
      "Invalid value type of `width` or `height` which should be number type instead."
    );
    return Number(value);
  }
  return value;
}
__name(parseWidthHeight, "parseWidthHeight");
function warnCheck(props) {
  warning_default(
    !("wrapperClassName" in props),
    `'wrapperClassName' is removed. Please use 'rootClassName' instead.`
  );
  warning_default(
    canUseDom() || !props.open,
    `Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.`
  );
}
__name(warnCheck, "warnCheck");

// packages/drawer/src/DrawerPopup.tsx
var sentinelStyle2 = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none",
  position: "absolute"
};
function DrawerPopup(props, ref) {
  const {
    prefixCls,
    open: open3,
    placement,
    inline: inline3,
    push,
    forceRender,
    autoFocus,
    keyboard,
    // classNames
    classNames: drawerClassNames,
    // Root
    rootClassName,
    rootStyle,
    zIndex,
    // Drawer
    className,
    id,
    style: style2,
    motion: motion2,
    width,
    height,
    children,
    // Mask
    mask,
    maskClosable,
    maskMotion,
    maskClassName,
    maskStyle,
    // Events
    afterOpenChange,
    onClose,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    styles
  } = props;
  const panelRef = React386.useRef();
  const sentinelStartRef = React386.useRef();
  const sentinelEndRef = React386.useRef();
  React386.useImperativeHandle(ref, () => panelRef.current);
  const onPanelKeyDown = /* @__PURE__ */ __name((event) => {
    const { keyCode, shiftKey } = event;
    switch (keyCode) {
      case KeyCode_default.TAB: {
        if (keyCode === KeyCode_default.TAB) {
          if (!shiftKey && document.activeElement === sentinelEndRef.current) {
            sentinelStartRef.current?.focus({ preventScroll: true });
          } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
            sentinelEndRef.current?.focus({ preventScroll: true });
          }
        }
        break;
      }
      case KeyCode_default.ESC: {
        if (onClose && keyboard) {
          event.stopPropagation();
          onClose(event);
        }
        break;
      }
    }
  }, "onPanelKeyDown");
  React386.useEffect(() => {
    if (open3 && autoFocus) {
      panelRef.current?.focus({ preventScroll: true });
    }
  }, [open3]);
  const [pushed, setPushed] = React386.useState(false);
  const parentContext = React386.useContext(context_default9);
  let pushConfig;
  if (typeof push === "boolean") {
    pushConfig = push ? {} : { distance: 0 };
  } else {
    pushConfig = push || {};
  }
  const pushDistance = pushConfig?.distance ?? parentContext?.pushDistance ?? 180;
  const mergedContext = React386.useMemo(
    () => ({
      pushDistance,
      push: () => {
        setPushed(true);
      },
      pull: () => {
        setPushed(false);
      }
    }),
    [pushDistance]
  );
  React386.useEffect(() => {
    if (open3) {
      parentContext?.push?.();
    } else {
      parentContext?.pull?.();
    }
  }, [open3]);
  React386.useEffect(
    () => () => {
      parentContext?.pull?.();
    },
    []
  );
  const maskNode = mask && /* @__PURE__ */ React386.createElement(src_default2, { key: "mask", ...maskMotion, visible: open3 }, ({ className: motionMaskClassName, style: motionMaskStyle }, maskRef) => /* @__PURE__ */ React386.createElement(
    "div",
    {
      className: (0, import_classnames159.default)(
        `${prefixCls}-mask`,
        motionMaskClassName,
        drawerClassNames?.mask,
        maskClassName
      ),
      style: {
        ...motionMaskStyle,
        ...maskStyle,
        ...styles?.mask
      },
      onClick: maskClosable && open3 ? onClose : void 0,
      ref: maskRef
    }
  ));
  const motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
  const wrapperStyle = {};
  if (pushed && pushDistance) {
    switch (placement) {
      case "top":
        wrapperStyle.transform = `translateY(${pushDistance}px)`;
        break;
      case "bottom":
        wrapperStyle.transform = `translateY(${-pushDistance}px)`;
        break;
      case "left":
        wrapperStyle.transform = `translateX(${pushDistance}px)`;
        break;
      default:
        wrapperStyle.transform = `translateX(${-pushDistance}px)`;
        break;
    }
  }
  if (placement === "left" || placement === "right") {
    wrapperStyle.width = parseWidthHeight(width);
  } else {
    wrapperStyle.height = parseWidthHeight(height);
  }
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const panelNode = /* @__PURE__ */ React386.createElement(
    src_default2,
    {
      key: "panel",
      ...motionProps,
      visible: open3,
      forceRender,
      onVisibleChanged: (nextVisible) => {
        afterOpenChange?.(nextVisible);
      },
      removeOnLeave: false,
      leavedClassName: `${prefixCls}-content-wrapper-hidden`
    },
    ({ className: motionClassName, style: motionStyle }, motionRef) => {
      return /* @__PURE__ */ React386.createElement(
        "div",
        {
          className: (0, import_classnames159.default)(
            `${prefixCls}-content-wrapper`,
            drawerClassNames?.wrapper,
            motionClassName
          ),
          style: {
            ...wrapperStyle,
            ...motionStyle,
            ...styles?.wrapper
          },
          ...pickAttrs(props, { data: true })
        },
        /* @__PURE__ */ React386.createElement(
          DrawerPanel_default,
          {
            id,
            containerRef: motionRef,
            prefixCls,
            className: (0, import_classnames159.default)(className, drawerClassNames?.content),
            style: {
              ...style2,
              ...styles?.content
            },
            ...pickAttrs(props, { aria: true }),
            ...eventHandlers
          },
          children
        )
      );
    }
  );
  const containerStyle = {
    ...rootStyle
  };
  if (zIndex) {
    containerStyle.zIndex = zIndex;
  }
  return /* @__PURE__ */ React386.createElement(context_default9.Provider, { value: mergedContext }, /* @__PURE__ */ React386.createElement(
    "div",
    {
      className: (0, import_classnames159.default)(
        prefixCls,
        `${prefixCls}-${placement}`,
        rootClassName,
        {
          [`${prefixCls}-open`]: open3,
          [`${prefixCls}-inline`]: inline3
        }
      ),
      style: containerStyle,
      tabIndex: -1,
      ref: panelRef,
      onKeyDown: onPanelKeyDown
    },
    maskNode,
    /* @__PURE__ */ React386.createElement(
      "div",
      {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle2,
        "aria-hidden": "true",
        "data-sentinel": "start"
      }
    ),
    panelNode,
    /* @__PURE__ */ React386.createElement(
      "div",
      {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle2,
        "aria-hidden": "true",
        "data-sentinel": "end"
      }
    )
  ));
}
__name(DrawerPopup, "DrawerPopup");
var RefDrawerPopup = React386.forwardRef(DrawerPopup);
if (true) {
  RefDrawerPopup.displayName = "DrawerPopup";
}
var DrawerPopup_default = RefDrawerPopup;

// packages/drawer/src/Drawer.tsx
var Drawer = /* @__PURE__ */ __name((props) => {
  const {
    open: open3 = false,
    prefixCls = "rc-drawer",
    placement = "right",
    autoFocus = true,
    keyboard = true,
    width = 378,
    mask = true,
    maskClosable = true,
    getContainer: getContainer2,
    forceRender,
    afterOpenChange,
    destroyOnClose,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    // Refs
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React387.useState(false);
  if (true) {
    warnCheck(props);
  }
  const [mounted, setMounted] = React387.useState(false);
  useLayoutEffect_default(() => {
    setMounted(true);
  }, []);
  const mergedOpen = mounted ? open3 : false;
  const popupRef = React387.useRef();
  const lastActiveRef = React387.useRef();
  useLayoutEffect_default(() => {
    if (mergedOpen) {
      lastActiveRef.current = document.activeElement;
    }
  }, [mergedOpen]);
  const internalAfterOpenChange = /* @__PURE__ */ __name((nextVisible) => {
    setAnimatedVisible(nextVisible);
    afterOpenChange?.(nextVisible);
    if (!nextVisible && lastActiveRef.current && !popupRef.current?.contains(lastActiveRef.current)) {
      lastActiveRef.current?.focus({ preventScroll: true });
    }
  }, "internalAfterOpenChange");
  const refContext = React387.useMemo(
    () => ({
      panel: panelRef
    }),
    [panelRef]
  );
  if (!forceRender && !animatedVisible && !mergedOpen && destroyOnClose) {
    return null;
  }
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const drawerPopupProps = {
    ...props,
    open: mergedOpen,
    prefixCls,
    placement,
    autoFocus,
    keyboard,
    width,
    mask,
    maskClosable,
    inline: getContainer2 === false,
    afterOpenChange: internalAfterOpenChange,
    ref: popupRef,
    ...eventHandlers
  };
  return /* @__PURE__ */ React387.createElement(RefContext2.Provider, { value: refContext }, /* @__PURE__ */ React387.createElement(
    es_default4,
    {
      open: mergedOpen || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer2,
      autoLock: mask && (mergedOpen || animatedVisible)
    },
    /* @__PURE__ */ React387.createElement(DrawerPopup_default, { ...drawerPopupProps })
  ));
}, "Drawer");
if (true) {
  Drawer.displayName = "Drawer";
}
var Drawer_default = Drawer;

// packages/drawer/src/index.ts
var src_default20 = Drawer_default;

// packages/ant-design/components/drawer/DrawerPanel.tsx
var import_classnames160 = __toESM(require_classnames());
import * as React388 from "react";
var DrawerPanel2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    title,
    footer,
    extra,
    onClose,
    headerStyle,
    bodyStyle,
    footerStyle,
    children,
    classNames: drawerClassNames,
    styles: drawerStyles
  } = props;
  const { drawer: drawerContext } = React388.useContext(ConfigContext);
  const customCloseIconRender = React388.useCallback(
    (icon) => /* @__PURE__ */ React388.createElement("button", { type: "button", onClick: onClose, "aria-label": "Close", className: `${prefixCls}-close` }, icon),
    [onClose]
  );
  const [mergedClosable, mergedCloseIcon] = useClosable(
    pickClosable(props),
    pickClosable(drawerContext),
    {
      closable: true,
      closeIconRender: customCloseIconRender
    }
  );
  const headerNode = React388.useMemo(() => {
    if (!title && !mergedClosable) {
      return null;
    }
    return /* @__PURE__ */ React388.createElement(
      "div",
      {
        style: {
          ...drawerContext?.styles?.header,
          ...headerStyle,
          ...drawerStyles?.header
        },
        className: (0, import_classnames160.default)(
          `${prefixCls}-header`,
          {
            [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra
          },
          drawerContext?.classNames?.header,
          drawerClassNames?.header
        )
      },
      /* @__PURE__ */ React388.createElement("div", { className: `${prefixCls}-header-title` }, mergedCloseIcon, title && /* @__PURE__ */ React388.createElement("div", { className: `${prefixCls}-title` }, title)),
      extra && /* @__PURE__ */ React388.createElement("div", { className: `${prefixCls}-extra` }, extra)
    );
  }, [mergedClosable, mergedCloseIcon, extra, headerStyle, prefixCls, title]);
  const footerNode = React388.useMemo(() => {
    if (!footer) {
      return null;
    }
    const footerClassName = `${prefixCls}-footer`;
    return /* @__PURE__ */ React388.createElement(
      "div",
      {
        className: (0, import_classnames160.default)(
          footerClassName,
          drawerContext?.classNames?.footer,
          drawerClassNames?.footer
        ),
        style: {
          ...drawerContext?.styles?.footer,
          ...footerStyle,
          ...drawerStyles?.footer
        }
      },
      footer
    );
  }, [footer, footerStyle, prefixCls]);
  return /* @__PURE__ */ React388.createElement(React388.Fragment, null, headerNode, /* @__PURE__ */ React388.createElement(
    "div",
    {
      className: (0, import_classnames160.default)(
        `${prefixCls}-body`,
        drawerClassNames?.body,
        drawerContext?.classNames?.body
      ),
      style: {
        ...drawerContext?.styles?.body,
        ...bodyStyle,
        ...drawerStyles?.body
      }
    },
    children
  ), footerNode);
}, "DrawerPanel");
var DrawerPanel_default2 = DrawerPanel2;

// packages/ant-design/components/drawer/style/motion.ts
var getMoveTranslate = /* @__PURE__ */ __name((direction) => {
  const value = "100%";
  return {
    left: `translateX(-${value})`,
    right: `translateX(${value})`,
    top: `translateY(-${value})`,
    bottom: `translateY(${value})`
  }[direction];
}, "getMoveTranslate");
var getEnterLeaveStyle = /* @__PURE__ */ __name((startStyle, endStyle) => ({
  "&-enter, &-appear": {
    ...startStyle,
    "&-active": endStyle
  },
  "&-leave": {
    ...endStyle,
    "&-active": startStyle
  }
}), "getEnterLeaveStyle");
var getFadeStyle = /* @__PURE__ */ __name((from2, duration) => ({
  "&-enter, &-appear, &-leave": {
    "&-start": {
      transition: "none"
    },
    "&-active": {
      transition: `all ${duration}`
    }
  },
  ...getEnterLeaveStyle(
    {
      opacity: from2
    },
    {
      opacity: 1
    }
  )
}), "getFadeStyle");
var getPanelMotionStyles = /* @__PURE__ */ __name((direction, duration) => [
  getFadeStyle(0.7, duration),
  getEnterLeaveStyle(
    {
      transform: getMoveTranslate(direction)
    },
    {
      transform: "none"
    }
  )
], "getPanelMotionStyles");
var genMotionStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationSlow } = token2;
  return {
    [componentCls]: {
      // ======================== Mask ========================
      [`${componentCls}-mask-motion`]: getFadeStyle(0, motionDurationSlow),
      // ======================= Panel ========================
      [`${componentCls}-panel-motion`]: ["left", "right", "top", "bottom"].reduce(
        (obj, direction) => ({
          ...obj,
          [`&-${direction}`]: getPanelMotionStyles(direction, motionDurationSlow)
        }),
        {}
      )
    }
  };
}, "genMotionStyle");
var motion_default3 = genMotionStyle2;

// packages/ant-design/components/drawer/style/index.ts
var genDrawerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    borderRadiusSM,
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    paddingXS,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginXS,
    colorIcon,
    colorIconHover,
    colorBgTextHover,
    colorBgTextActive,
    colorText,
    fontWeightStrong,
    footerPaddingBlock,
    footerPaddingInline,
    calc
  } = token2;
  const wrapperCls = `${componentCls}-content-wrapper`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        display: "flex",
        flexDirection: "column",
        [`&${componentCls}-left`]: {
          boxShadow: token2.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token2.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token2.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token2.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto"
      },
      // ==================== Content =====================
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        maxWidth: "100vw",
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token2.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token2.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerDown
      },
      [`${componentCls}-content`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      // Header
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${unit(padding)} ${unit(paddingLG)}`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-flex",
        width: calc(fontSizeLG).add(paddingXS).equal(),
        height: calc(fontSizeLG).add(paddingXS).equal(),
        borderRadius: borderRadiusSM,
        justifyContent: "center",
        alignItems: "center",
        marginInlineEnd: marginXS,
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`,
        textRendering: "auto",
        "&:hover": {
          color: colorIconHover,
          backgroundColor: colorBgTextHover,
          textDecoration: "none"
        },
        "&:active": {
          backgroundColor: colorBgTextActive
        },
        ...genFocusStyle(token2)
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        color: colorText,
        fontWeight: token2.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      // Body
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto"
      },
      // Footer
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${unit(footerPaddingBlock)} ${unit(footerPaddingInline)}`,
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, "genDrawerStyle");
var prepareComponentToken30 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase,
  footerPaddingBlock: token2.paddingXS,
  footerPaddingInline: token2.padding
}), "prepareComponentToken");
var style_default36 = genStyleHooks(
  "Drawer",
  (token2) => {
    const drawerToken = merge2(token2, {});
    return [genDrawerStyle(drawerToken), motion_default3(drawerToken)];
  },
  prepareComponentToken30
);

// packages/ant-design/components/drawer/index.tsx
var defaultPushState = { distance: 180 };
var Drawer2 = /* @__PURE__ */ __name((props) => {
  const {
    rootClassName,
    width,
    height,
    size = "default",
    mask = true,
    push = defaultPushState,
    open: open3,
    afterOpenChange,
    onClose,
    prefixCls: customizePrefixCls,
    getContainer: customizeGetContainer,
    style: style2,
    className,
    // Deprecated
    visible,
    afterVisibleChange,
    maskStyle,
    drawerStyle,
    contentWrapperStyle,
    ...rest
  } = props;
  const { getPopupContainer, getPrefixCls, direction, drawer } = React389.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default36(prefixCls);
  const getContainer2 = (
    // 有可能为 false，所以不能直接判断
    customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer
  );
  const drawerClassName = (0, import_classnames161.default)(
    {
      "no-mask": !mask,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    rootClassName,
    hashId,
    cssVarCls
  );
  if (true) {
    const warning5 = devUseWarning("Drawer");
    [
      ["visible", "open"],
      ["afterVisibleChange", "afterOpenChange"],
      ["headerStyle", "styles.header"],
      ["bodyStyle", "styles.body"],
      ["footerStyle", "styles.footer"],
      ["contentWrapperStyle", "styles.wrapper"],
      ["maskStyle", "styles.mask"],
      ["drawerStyle", "styles.content"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (getContainer2 !== void 0 && props.style?.position === "absolute") {
      warning5(
        false,
        "breaking",
        "`style` is replaced by `rootStyle` in v5. Please check that `position: absolute` is necessary."
      );
    }
  }
  const mergedWidth = React389.useMemo(
    () => width ?? (size === "large" ? 736 : 378),
    [width, size]
  );
  const mergedHeight = React389.useMemo(
    () => height ?? (size === "large" ? 736 : 378),
    [height, size]
  );
  const maskMotion = {
    motionName: getTransitionName2(prefixCls, "mask-motion"),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  };
  const panelMotion = /* @__PURE__ */ __name((motionPlacement) => ({
    motionName: getTransitionName2(prefixCls, `panel-motion-${motionPlacement}`),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  }), "panelMotion");
  const panelRef = usePanelRef();
  const [zIndex, contextZIndex] = useZIndex("Drawer", rest.zIndex);
  const { classNames: propClassNames = {}, styles: propStyles = {} } = rest;
  const { classNames: contextClassNames = {}, styles: contextStyles = {} } = drawer || {};
  return wrapCSSVar(
    /* @__PURE__ */ React389.createElement(NoCompactStyle, null, /* @__PURE__ */ React389.createElement(NoFormStyle, { status: true, override: true }, /* @__PURE__ */ React389.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ React389.createElement(
      src_default20,
      {
        prefixCls,
        onClose,
        maskMotion,
        motion: panelMotion,
        ...rest,
        classNames: {
          mask: (0, import_classnames161.default)(propClassNames.mask, contextClassNames.mask),
          content: (0, import_classnames161.default)(propClassNames.content, contextClassNames.content)
        },
        styles: {
          mask: {
            ...propStyles.mask,
            ...maskStyle,
            ...contextStyles.mask
          },
          content: {
            ...propStyles.content,
            ...drawerStyle,
            ...contextStyles.content
          },
          wrapper: {
            ...propStyles.wrapper,
            ...contentWrapperStyle,
            ...contextStyles.wrapper
          }
        },
        open: open3 ?? visible,
        mask,
        push,
        width: mergedWidth,
        height: mergedHeight,
        style: { ...drawer?.style, ...style2 },
        className: (0, import_classnames161.default)(drawer?.className, className),
        rootClassName: drawerClassName,
        getContainer: getContainer2,
        afterOpenChange: afterOpenChange ?? afterVisibleChange,
        panelRef,
        zIndex
      },
      /* @__PURE__ */ React389.createElement(DrawerPanel_default2, { prefixCls, ...rest, onClose })
    ))))
  );
}, "Drawer");
var PurePanel11 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    style: style2,
    className,
    placement = "right",
    ...restProps
  } = props;
  const { getPrefixCls } = React389.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default36(prefixCls);
  const cls5 = (0, import_classnames161.default)(
    prefixCls,
    `${prefixCls}-pure`,
    `${prefixCls}-${placement}`,
    hashId,
    cssVarCls,
    className
  );
  return wrapCSSVar(
    /* @__PURE__ */ React389.createElement("div", { className: cls5, style: style2 }, /* @__PURE__ */ React389.createElement(DrawerPanel_default2, { prefixCls, ...restProps }))
  );
}, "PurePanel");
Drawer2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel11;
if (true) {
  Drawer2.displayName = "Drawer";
}
var drawer_default = Drawer2;

// packages/ant-design/components/dropdown/dropdown-button.tsx
var import_EllipsisOutlined3 = __toESM(require_EllipsisOutlined3());
var import_classnames163 = __toESM(require_classnames());
import * as React393 from "react";

// packages/ant-design/components/space/index.tsx
var import_classnames162 = __toESM(require_classnames());
import * as React392 from "react";

// packages/ant-design/components/_util/gapSize.ts
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}
__name(isPresetSize, "isPresetSize");
function isValidGapNumber(size) {
  if (!size) {
    return false;
  }
  return typeof size === "number" && !Number.isNaN(size);
}
__name(isValidGapNumber, "isValidGapNumber");

// packages/ant-design/components/space/context.ts
import React390 from "react";
var SpaceContext = React390.createContext({
  latestIndex: 0
});
var SpaceContextProvider = SpaceContext.Provider;

// packages/ant-design/components/space/Item.tsx
import * as React391 from "react";
var Item3 = /* @__PURE__ */ __name(({ className, index: index3, children, split, style: style2 }) => {
  const { latestIndex } = React391.useContext(SpaceContext);
  if (children === null || children === void 0) {
    return null;
  }
  return /* @__PURE__ */ React391.createElement(React391.Fragment, null, /* @__PURE__ */ React391.createElement("div", { className, style: style2 }, children), index3 < latestIndex && split && /* @__PURE__ */ React391.createElement("span", { className: `${className}-split` }, split));
}, "Item");
var Item_default3 = Item3;

// packages/ant-design/components/space/index.tsx
var InternalSpace = React392.forwardRef((props, ref) => {
  const { getPrefixCls, space, direction: directionConfig } = React392.useContext(ConfigContext);
  const {
    size = space?.size || "small",
    align,
    className,
    rootClassName,
    children,
    direction = "horizontal",
    prefixCls: customizePrefixCls,
    split,
    style: style2,
    wrap = false,
    classNames: customClassNames,
    styles,
    ...otherProps
  } = props;
  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
  const isPresetVerticalSize = isPresetSize(verticalSize);
  const isPresetHorizontalSize = isPresetSize(horizontalSize);
  const isValidVerticalSize = isValidGapNumber(verticalSize);
  const isValidHorizontalSize = isValidGapNumber(horizontalSize);
  const childNodes = toArray(children, { keepEmpty: true });
  const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
  const prefixCls = getPrefixCls("space", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default6(prefixCls);
  const cls5 = (0, import_classnames162.default)(
    prefixCls,
    space?.className,
    hashId,
    `${prefixCls}-${direction}`,
    {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
      [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
      [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
    },
    className,
    rootClassName,
    cssVarCls
  );
  const itemClassName = (0, import_classnames162.default)(
    `${prefixCls}-item`,
    customClassNames?.item ?? space?.classNames?.item
  );
  let latestIndex = 0;
  const nodes = childNodes.map((child, i) => {
    if (child !== null && child !== void 0) {
      latestIndex = i;
    }
    const key = child && child.key || `${itemClassName}-${i}`;
    return /* @__PURE__ */ React392.createElement(
      Item_default3,
      {
        className: itemClassName,
        key,
        index: i,
        split,
        style: styles?.item ?? space?.styles?.item
      },
      child
    );
  });
  const spaceContext = React392.useMemo(() => ({ latestIndex }), [latestIndex]);
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = "wrap";
  }
  if (!isPresetHorizontalSize && isValidHorizontalSize) {
    gapStyle.columnGap = horizontalSize;
  }
  if (!isPresetVerticalSize && isValidVerticalSize) {
    gapStyle.rowGap = verticalSize;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React392.createElement(
      "div",
      {
        ref,
        className: cls5,
        style: { ...gapStyle, ...space?.style, ...style2 },
        ...otherProps
      },
      /* @__PURE__ */ React392.createElement(SpaceContextProvider, { value: spaceContext }, nodes)
    )
  );
});
var Space = InternalSpace;
Space.Compact = Compact_default;
if (true) {
  Space.displayName = "Space";
}
var space_default = Space;

// packages/ant-design/components/dropdown/dropdown-button.tsx
var DropdownButton = /* @__PURE__ */ __name((props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React393.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type: type5 = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    overlay,
    trigger,
    align,
    open: open3,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = /* @__PURE__ */ React393.createElement(import_EllipsisOutlined3.default, null),
    title,
    buttonsRender = /* @__PURE__ */ __name((buttons) => buttons, "buttonsRender"),
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const buttonPrefixCls = `${prefixCls}-button`;
  const dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  };
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const classes = (0, import_classnames163.default)(buttonPrefixCls, compactItemClassnames, className);
  if ("overlay" in props) {
    dropdownProps.overlay = overlay;
  }
  if ("open" in props) {
    dropdownProps.open = open3;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  const leftButton = /* @__PURE__ */ React393.createElement(
    button_default2,
    {
      type: type5,
      danger,
      disabled,
      loading,
      onClick,
      htmlType,
      href,
      title
    },
    children
  );
  const rightButton = /* @__PURE__ */ React393.createElement(button_default2, { type: type5, danger, icon });
  const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return /* @__PURE__ */ React393.createElement(space_default.Compact, { className: classes, size: compactSize, block: true, ...restProps }, leftButtonToRender, /* @__PURE__ */ React393.createElement(dropdown_default2, { ...dropdownProps }, rightButtonToRender));
}, "DropdownButton");
DropdownButton.__ANT_BUTTON = true;
var dropdown_button_default = DropdownButton;

// packages/ant-design/components/dropdown/index.ts
var Dropdown3 = dropdown_default2;
Dropdown3.Button = dropdown_button_default;
var dropdown_default3 = Dropdown3;

// packages/ant-design/components/flex/index.tsx
var import_classnames165 = __toESM(require_classnames());
import React394 from "react";

// packages/ant-design/components/flex/utils.ts
var import_classnames164 = __toESM(require_classnames());
var flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
var justifyContentValues = [
  "flex-start",
  "flex-end",
  "start",
  "end",
  "center",
  "space-between",
  "space-around",
  "space-evenly",
  "stretch",
  "normal",
  "left",
  "right"
];
var alignItemsValues = [
  "center",
  "start",
  "end",
  "flex-start",
  "flex-end",
  "self-start",
  "self-end",
  "baseline",
  "normal",
  "stretch"
];
var genClsWrap = /* @__PURE__ */ __name((prefixCls, props) => {
  const wrapCls = {};
  flexWrapValues.forEach((cssKey) => {
    wrapCls[`${prefixCls}-wrap-${cssKey}`] = props.wrap === cssKey;
  });
  return wrapCls;
}, "genClsWrap");
var genClsAlign = /* @__PURE__ */ __name((prefixCls, props) => {
  const alignCls = {};
  alignItemsValues.forEach((cssKey) => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
  return alignCls;
}, "genClsAlign");
var genClsJustify = /* @__PURE__ */ __name((prefixCls, props) => {
  const justifyCls = {};
  justifyContentValues.forEach((cssKey) => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
  });
  return justifyCls;
}, "genClsJustify");
function createFlexClassNames(prefixCls, props) {
  return (0, import_classnames164.default)({
    ...genClsWrap(prefixCls, props),
    ...genClsAlign(prefixCls, props),
    ...genClsJustify(prefixCls, props)
  });
}
__name(createFlexClassNames, "createFlexClassNames");
var utils_default = createFlexClassNames;

// packages/ant-design/components/flex/style/index.ts
var genFlexStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
}, "genFlexStyle");
var genFlexGapStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      "&-gap-small": {
        gap: token2.flexGapSM
      },
      "&-gap-middle": {
        gap: token2.flexGap
      },
      "&-gap-large": {
        gap: token2.flexGapLG
      }
    }
  };
}, "genFlexGapStyle");
var genFlexWrapStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const wrapStyle = {};
  flexWrapValues.forEach((value) => {
    wrapStyle[`${componentCls}-wrap-${value}`] = { flexWrap: value };
  });
  return wrapStyle;
}, "genFlexWrapStyle");
var genAlignItemsStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const alignStyle = {};
  alignItemsValues.forEach((value) => {
    alignStyle[`${componentCls}-align-${value}`] = { alignItems: value };
  });
  return alignStyle;
}, "genAlignItemsStyle");
var genJustifyContentStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const justifyStyle = {};
  justifyContentValues.forEach((value) => {
    justifyStyle[`${componentCls}-justify-${value}`] = { justifyContent: value };
  });
  return justifyStyle;
}, "genJustifyContentStyle");
var prepareComponentToken31 = /* @__PURE__ */ __name(() => ({}), "prepareComponentToken");
var style_default37 = genStyleHooks(
  "Flex",
  (token2) => {
    const { paddingXS, padding, paddingLG } = token2;
    const flexToken = merge2(token2, {
      flexGapSM: paddingXS,
      flexGap: padding,
      flexGapLG: paddingLG
    });
    return [
      genFlexStyle(flexToken),
      genFlexGapStyle(flexToken),
      genFlexWrapStyle(flexToken),
      genAlignItemsStyle(flexToken),
      genJustifyContentStyle(flexToken)
    ];
  },
  prepareComponentToken31,
  {
    // Flex component don't apply extra font style
    // https://github.com/ant-design/ant-design/issues/46403
    resetStyle: false
  }
);

// packages/ant-design/components/flex/index.tsx
var Flex = React394.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    rootClassName,
    className,
    style: style2,
    flex,
    gap,
    children,
    vertical = false,
    component: Component11 = "div",
    ...othersProps
  } = props;
  const {
    flex: ctxFlex,
    direction: ctxDirection,
    getPrefixCls
  } = React394.useContext(ConfigContext);
  const prefixCls = getPrefixCls("flex", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default37(prefixCls);
  const mergedVertical = vertical ?? ctxFlex?.vertical;
  const mergedCls = (0, import_classnames165.default)(
    className,
    rootClassName,
    ctxFlex?.className,
    prefixCls,
    hashId,
    cssVarCls,
    utils_default(prefixCls, props),
    {
      [`${prefixCls}-rtl`]: ctxDirection === "rtl",
      [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
      [`${prefixCls}-vertical`]: mergedVertical
    }
  );
  const mergedStyle = { ...ctxFlex?.style, ...style2 };
  if (flex) {
    mergedStyle.flex = flex;
  }
  if (gap && !isPresetSize(gap)) {
    mergedStyle.gap = gap;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React394.createElement(
      Component11,
      {
        ref,
        className: mergedCls,
        style: mergedStyle,
        ...omit(othersProps, ["justify", "wrap", "align"])
      },
      children
    )
  );
});
if (true) {
  Flex.displayName = "Flex";
}
var flex_default = Flex;

// packages/ant-design/components/float-button/BackTop.tsx
var import_VerticalAlignTopOutlined2 = __toESM(require_VerticalAlignTopOutlined3());
var import_classnames168 = __toESM(require_classnames());
import React398, { useContext as useContext159, useEffect as useEffect96, useState as useState88 } from "react";

// packages/ant-design/components/float-button/context.ts
import React395 from "react";
var FloatButtonGroupContext = React395.createContext(void 0);
var { Provider: FloatButtonGroupProvider } = FloatButtonGroupContext;
var context_default10 = FloatButtonGroupContext;

// packages/ant-design/components/float-button/FloatButton.tsx
var import_classnames167 = __toESM(require_classnames());
import React397, { useContext as useContext158, useMemo as useMemo120 } from "react";

// packages/ant-design/components/float-button/FloatButtonContent.tsx
var import_FileTextOutlined = __toESM(require_FileTextOutlined3());
var import_classnames166 = __toESM(require_classnames());
import React396, { memo as memo9 } from "react";
var FloatButtonContent = /* @__PURE__ */ __name((props) => {
  const { icon, description, prefixCls, className } = props;
  const defaultElement = /* @__PURE__ */ React396.createElement("div", { className: `${prefixCls}-icon` }, /* @__PURE__ */ React396.createElement(import_FileTextOutlined.default, null));
  return /* @__PURE__ */ React396.createElement(
    "div",
    {
      onClick: props.onClick,
      onFocus: props.onFocus,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      className: (0, import_classnames166.default)(className, `${prefixCls}-content`)
    },
    icon || description ? /* @__PURE__ */ React396.createElement(React396.Fragment, null, icon && /* @__PURE__ */ React396.createElement("div", { className: `${prefixCls}-icon` }, icon), description && /* @__PURE__ */ React396.createElement("div", { className: `${prefixCls}-description` }, description)) : defaultElement
  );
}, "FloatButtonContent");
var FloatButtonContent_default = memo9(FloatButtonContent);

// packages/ant-design/components/float-button/util.ts
var getOffset3 = /* @__PURE__ */ __name((radius) => {
  if (radius === 0) {
    return 0;
  }
  return radius - Math.sqrt(radius ** 2 / 2);
}, "getOffset");
var util_default = getOffset3;

// packages/ant-design/components/float-button/style/index.ts
var initFloatButtonGroupMotion = /* @__PURE__ */ __name((token2) => {
  const { componentCls, floatButtonSize, motionDurationSlow, motionEaseInOutCirc } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  const moveDownIn2 = new Keyframes_default("antFloatButtonMoveDownIn", {
    "0%": {
      transform: `translate3d(0, ${unit(floatButtonSize)}, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut2 = new Keyframes_default("antFloatButtonMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: `translate3d(0, ${unit(floatButtonSize)}, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  return [
    {
      [`${groupPrefixCls}-wrap`]: {
        ...initMotion(`${groupPrefixCls}-wrap`, moveDownIn2, moveDownOut2, motionDurationSlow, true)
      }
    },
    {
      [`${groupPrefixCls}-wrap`]: {
        [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
          opacity: 0,
          animationTimingFunction: motionEaseInOutCirc
        },
        [`&${groupPrefixCls}-wrap-leave`]: {
          animationTimingFunction: motionEaseInOutCirc
        }
      }
    }
  ];
}, "initFloatButtonGroupMotion");
var floatButtonGroupStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    floatButtonSize,
    margin,
    borderRadiusLG,
    borderRadiusSM,
    badgeOffset,
    floatButtonBodyPadding,
    calc
  } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: {
      ...resetComponent(token2),
      zIndex: 99,
      display: "block",
      border: "none",
      position: "fixed",
      width: floatButtonSize,
      height: "auto",
      boxShadow: "none",
      minHeight: floatButtonSize,
      insetInlineEnd: token2.floatButtonInsetInlineEnd,
      insetBlockEnd: token2.floatButtonInsetBlockEnd,
      borderRadius: borderRadiusLG,
      [`${groupPrefixCls}-wrap`]: {
        zIndex: -1,
        display: "block",
        position: "relative",
        marginBottom: margin
      },
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [componentCls]: {
        position: "static"
      }
    },
    [`${groupPrefixCls}-circle`]: {
      [`${componentCls}-circle:not(:last-child)`]: {
        marginBottom: token2.margin,
        [`${componentCls}-body`]: {
          width: floatButtonSize,
          height: floatButtonSize,
          borderRadius: "50%"
        }
      }
    },
    [`${groupPrefixCls}-square`]: {
      [`${componentCls}-square`]: {
        borderRadius: 0,
        padding: 0,
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderStartEndRadius: borderRadiusLG
        },
        "&:last-child": {
          borderEndStartRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        },
        "&:not(:last-child)": {
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        [`${antCls}-badge`]: {
          [`${antCls}-badge-count`]: {
            top: calc(calc(floatButtonBodyPadding).add(badgeOffset)).mul(-1).equal(),
            insetInlineEnd: calc(calc(floatButtonBodyPadding).add(badgeOffset)).mul(-1).equal()
          }
        }
      },
      [`${groupPrefixCls}-wrap`]: {
        display: "block",
        borderRadius: borderRadiusLG,
        boxShadow: token2.boxShadowSecondary,
        [`${componentCls}-square`]: {
          boxShadow: "none",
          marginTop: 0,
          borderRadius: 0,
          padding: floatButtonBodyPadding,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderStartEndRadius: borderRadiusLG
          },
          "&:last-child": {
            borderEndStartRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          },
          "&:not(:last-child)": {
            borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          },
          [`${componentCls}-body`]: {
            width: token2.floatButtonBodySize,
            height: token2.floatButtonBodySize
          }
        }
      }
    },
    [`${groupPrefixCls}-circle-shadow`]: {
      boxShadow: "none"
    },
    [`${groupPrefixCls}-square-shadow`]: {
      boxShadow: token2.boxShadowSecondary,
      [`${componentCls}-square`]: {
        boxShadow: "none",
        padding: floatButtonBodyPadding,
        [`${componentCls}-body`]: {
          width: token2.floatButtonBodySize,
          height: token2.floatButtonBodySize,
          borderRadius: borderRadiusSM
        }
      }
    }
  };
}, "floatButtonGroupStyle");
var sharedFloatButtonStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    floatButtonBodyPadding,
    floatButtonIconSize,
    floatButtonSize,
    borderRadiusLG,
    badgeOffset,
    dotOffsetInSquare,
    dotOffsetInCircle,
    calc
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      border: "none",
      position: "fixed",
      cursor: "pointer",
      zIndex: 99,
      // Do not remove the 'display: block' here.
      // Deleting it will cause marginBottom to become ineffective.
      // Ref: https://github.com/ant-design/ant-design/issues/44700
      display: "block",
      width: floatButtonSize,
      height: floatButtonSize,
      insetInlineEnd: token2.floatButtonInsetInlineEnd,
      insetBlockEnd: token2.floatButtonInsetBlockEnd,
      boxShadow: token2.boxShadowSecondary,
      // Pure Panel
      "&-pure": {
        position: "relative",
        inset: "auto"
      },
      "&:empty": {
        display: "none"
      },
      [`${antCls}-badge`]: {
        width: "100%",
        height: "100%",
        [`${antCls}-badge-count`]: {
          transform: "translate(0, 0)",
          transformOrigin: "center",
          top: calc(badgeOffset).mul(-1).equal(),
          insetInlineEnd: calc(badgeOffset).mul(-1).equal()
        }
      },
      [`${componentCls}-body`]: {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        transition: `all ${token2.motionDurationMid}`,
        [`${componentCls}-content`]: {
          overflow: "hidden",
          textAlign: "center",
          minHeight: floatButtonSize,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          padding: `${unit(calc(floatButtonBodyPadding).div(2).equal())} ${unit(
            floatButtonBodyPadding
          )}`,
          [`${componentCls}-icon`]: {
            textAlign: "center",
            margin: "auto",
            width: floatButtonIconSize,
            fontSize: floatButtonIconSize,
            lineHeight: 1
          }
        }
      }
    },
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-circle`]: {
      height: floatButtonSize,
      borderRadius: "50%",
      [`${antCls}-badge`]: {
        [`${antCls}-badge-dot`]: {
          top: dotOffsetInCircle,
          insetInlineEnd: dotOffsetInCircle
        }
      },
      [`${componentCls}-body`]: {
        borderRadius: "50%"
      }
    },
    [`${componentCls}-square`]: {
      height: "auto",
      minHeight: floatButtonSize,
      borderRadius: borderRadiusLG,
      [`${antCls}-badge`]: {
        [`${antCls}-badge-dot`]: {
          top: dotOffsetInSquare,
          insetInlineEnd: dotOffsetInSquare
        }
      },
      [`${componentCls}-body`]: {
        height: "auto",
        borderRadius: borderRadiusLG
      }
    },
    [`${componentCls}-default`]: {
      backgroundColor: token2.floatButtonBackgroundColor,
      transition: `background-color ${token2.motionDurationMid}`,
      [`${componentCls}-body`]: {
        backgroundColor: token2.floatButtonBackgroundColor,
        transition: `background-color ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.colorFillContent
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token2.colorText
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: unit(token2.fontSizeLG),
            color: token2.colorText,
            fontSize: token2.fontSizeSM
          }
        }
      }
    },
    [`${componentCls}-primary`]: {
      backgroundColor: token2.colorPrimary,
      [`${componentCls}-body`]: {
        backgroundColor: token2.colorPrimary,
        transition: `background-color ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.colorPrimaryHover
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token2.colorTextLightSolid
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: unit(token2.fontSizeLG),
            color: token2.colorTextLightSolid,
            fontSize: token2.fontSizeSM
          }
        }
      }
    }
  };
}, "sharedFloatButtonStyle");
var prepareComponentToken32 = /* @__PURE__ */ __name((token2) => ({
  dotOffsetInCircle: util_default(token2.controlHeightLG / 2),
  dotOffsetInSquare: util_default(token2.borderRadiusLG)
}), "prepareComponentToken");
var style_default38 = genStyleHooks(
  "FloatButton",
  (token2) => {
    const {
      colorTextLightSolid,
      colorBgElevated,
      controlHeightLG,
      marginXXL,
      marginLG,
      fontSize,
      fontSizeIcon,
      controlItemBgHover,
      paddingXXS,
      calc
    } = token2;
    const floatButtonToken = merge2(token2, {
      floatButtonBackgroundColor: colorBgElevated,
      floatButtonColor: colorTextLightSolid,
      floatButtonHoverBackgroundColor: controlItemBgHover,
      floatButtonFontSize: fontSize,
      floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
      floatButtonSize: controlHeightLG,
      floatButtonInsetBlockEnd: marginXXL,
      floatButtonInsetInlineEnd: marginLG,
      floatButtonBodySize: calc(controlHeightLG).sub(calc(paddingXXS).mul(2)).equal(),
      // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
      floatButtonBodyPadding: paddingXXS,
      badgeOffset: calc(paddingXXS).mul(1.5).equal()
    });
    return [
      floatButtonGroupStyle(floatButtonToken),
      sharedFloatButtonStyle(floatButtonToken),
      initFadeMotion(token2),
      initFloatButtonGroupMotion(floatButtonToken)
    ];
  },
  prepareComponentToken32
);

// packages/ant-design/components/float-button/FloatButton.tsx
var floatButtonPrefixCls = "float-btn";
var InternalFloatButton = React397.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    type: type5 = "default",
    shape = "circle",
    icon,
    description,
    tooltip,
    badge = {},
    ...restProps
  } = props;
  const { getPrefixCls, direction } = useContext158(ConfigContext);
  const groupShape = useContext158(context_default10);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default38(prefixCls, rootCls);
  const mergedShape = groupShape || shape;
  const classString = (0, import_classnames167.default)(
    hashId,
    cssVarCls,
    rootCls,
    prefixCls,
    className,
    rootClassName,
    `${prefixCls}-${type5}`,
    `${prefixCls}-${mergedShape}`,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }
  );
  const badgeProps = useMemo120(
    () => omit(badge, ["title", "children", "status", "text"]),
    [badge]
  );
  const contentProps = useMemo120(
    () => ({ prefixCls, description, icon, type: type5 }),
    [prefixCls, description, icon, type5]
  );
  let buttonNode = /* @__PURE__ */ React397.createElement("div", { className: `${prefixCls}-body` }, /* @__PURE__ */ React397.createElement(FloatButtonContent_default, { ...contentProps }));
  if ("badge" in props) {
    buttonNode = /* @__PURE__ */ React397.createElement(badge_default, { ...badgeProps }, buttonNode);
  }
  if ("tooltip" in props) {
    buttonNode = /* @__PURE__ */ React397.createElement(tooltip_default, { title: tooltip, placement: direction === "rtl" ? "right" : "left" }, buttonNode);
  }
  if (true) {
    const warning5 = devUseWarning("FloatButton");
    warning5(
      !(shape === "circle" && description),
      "usage",
      "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended."
    );
  }
  return wrapCSSVar(
    props.href ? /* @__PURE__ */ React397.createElement("a", { ref, ...restProps, className: classString }, buttonNode) : /* @__PURE__ */ React397.createElement("button", { ref, ...restProps, className: classString, type: "button" }, buttonNode)
  );
});
var FloatButton = InternalFloatButton;
if (true) {
  FloatButton.displayName = "FloatButton";
}
var FloatButton_default = FloatButton;

// packages/ant-design/components/float-button/BackTop.tsx
var BackTop2 = React398.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    type: type5 = "default",
    shape = "circle",
    visibilityHeight = 400,
    icon = /* @__PURE__ */ React398.createElement(import_VerticalAlignTopOutlined2.default, null),
    target,
    onClick,
    duration = 450,
    ...restProps
  } = props;
  const [visible, setVisible] = useState88(visibilityHeight === 0);
  const internalRef = React398.useRef(null);
  React398.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const getDefaultTarget2 = /* @__PURE__ */ __name(() => internalRef.current && internalRef.current.ownerDocument ? internalRef.current.ownerDocument : window, "getDefaultTarget");
  const handleScroll = throttleByAnimationFrame_default(
    (e3) => {
      const scrollTop = getScroll(e3.target, true);
      setVisible(scrollTop >= visibilityHeight);
    }
  );
  useEffect96(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({ target: container });
    container?.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container?.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = /* @__PURE__ */ __name((e3) => {
    scrollTo(0, { getContainer: target || getDefaultTarget2, duration });
    onClick?.(e3);
  }, "scrollToTop");
  const { getPrefixCls } = useContext159(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const groupShape = useContext159(context_default10);
  const mergedShape = groupShape || shape;
  const contentProps = {
    prefixCls,
    icon,
    type: type5,
    shape: mergedShape,
    ...restProps
  };
  return /* @__PURE__ */ React398.createElement(src_default2, { visible, motionName: `${rootPrefixCls}-fade` }, ({ className: motionClassName }) => /* @__PURE__ */ React398.createElement(
    FloatButton_default,
    {
      ref: internalRef,
      ...contentProps,
      onClick: scrollToTop,
      className: (0, import_classnames168.default)(className, motionClassName)
    }
  ));
});
if (true) {
  BackTop2.displayName = "BackTop";
}
var BackTop_default = BackTop2;

// packages/ant-design/components/float-button/FloatButtonGroup.tsx
var import_CloseOutlined9 = __toESM(require_CloseOutlined3());
var import_FileTextOutlined2 = __toESM(require_FileTextOutlined3());
var import_classnames169 = __toESM(require_classnames());
import React399, { memo as memo10, useCallback as useCallback33, useContext as useContext160, useEffect as useEffect97 } from "react";
var FloatButtonGroup = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    shape = "circle",
    type: type5 = "default",
    icon = /* @__PURE__ */ React399.createElement(import_FileTextOutlined2.default, null),
    closeIcon,
    description,
    trigger,
    children,
    onOpenChange,
    open: customOpen,
    ...floatButtonProps
  } = props;
  const { direction, getPrefixCls, floatButtonGroup } = useContext160(ConfigContext);
  const mergedCloseIcon = closeIcon ?? floatButtonGroup?.closeIcon ?? /* @__PURE__ */ React399.createElement(import_CloseOutlined9.default, null);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default38(prefixCls, rootCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const groupCls = (0, import_classnames169.default)(groupPrefixCls, hashId, cssVarCls, rootCls, className, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl",
    [`${groupPrefixCls}-${shape}`]: shape,
    [`${groupPrefixCls}-${shape}-shadow`]: !trigger
  });
  const wrapperCls = (0, import_classnames169.default)(hashId, `${groupPrefixCls}-wrap`);
  const [open3, setOpen] = useMergedState(false, { value: customOpen });
  const floatButtonGroupRef = React399.useRef(null);
  const floatButtonRef = React399.useRef(null);
  const hoverAction = React399.useMemo(() => {
    const hoverTypeAction = {
      onMouseEnter() {
        setOpen(true);
        onOpenChange?.(true);
      },
      onMouseLeave() {
        setOpen(false);
        onOpenChange?.(false);
      }
    };
    return trigger === "hover" ? hoverTypeAction : {};
  }, [trigger]);
  const handleOpenChange = /* @__PURE__ */ __name(() => {
    setOpen((prevState) => {
      onOpenChange?.(!prevState);
      return !prevState;
    });
  }, "handleOpenChange");
  const onClick = useCallback33(
    (e3) => {
      if (floatButtonGroupRef.current?.contains(e3.target)) {
        if (floatButtonRef.current?.contains(e3.target)) {
          handleOpenChange();
        }
        return;
      }
      setOpen(false);
      onOpenChange?.(false);
    },
    [trigger]
  );
  useEffect97(() => {
    if (trigger === "click") {
      document.addEventListener("click", onClick);
      return () => {
        document.removeEventListener("click", onClick);
      };
    }
  }, [trigger]);
  if (true) {
    const warning5 = devUseWarning("FloatButton.Group");
    warning5(
      !("open" in props) || !!trigger,
      "usage",
      "`open` need to be used together with `trigger`"
    );
  }
  return wrapCSSVar(
    /* @__PURE__ */ React399.createElement(FloatButtonGroupProvider, { value: shape }, /* @__PURE__ */ React399.createElement("div", { ref: floatButtonGroupRef, className: groupCls, style: style2, ...hoverAction }, trigger && ["click", "hover"].includes(trigger) ? /* @__PURE__ */ React399.createElement(React399.Fragment, null, /* @__PURE__ */ React399.createElement(src_default2, { visible: open3, motionName: `${groupPrefixCls}-wrap` }, ({ className: motionClassName }) => /* @__PURE__ */ React399.createElement("div", { className: (0, import_classnames169.default)(motionClassName, wrapperCls) }, children)), /* @__PURE__ */ React399.createElement(
      FloatButton_default,
      {
        ref: floatButtonRef,
        type: type5,
        shape,
        icon: open3 ? mergedCloseIcon : icon,
        description,
        "aria-label": props["aria-label"],
        ...floatButtonProps
      }
    )) : children))
  );
}, "FloatButtonGroup");
var FloatButtonGroup_default = memo10(FloatButtonGroup);

// packages/ant-design/components/float-button/PurePanel.tsx
var import_classnames170 = __toESM(require_classnames());
import * as React400 from "react";
var PureFloatButton = /* @__PURE__ */ __name(({ backTop, ...props }) => backTop ? /* @__PURE__ */ React400.createElement(BackTop_default, { ...props, visibilityHeight: 0 }) : /* @__PURE__ */ React400.createElement(FloatButton_default, { ...props }), "PureFloatButton");
var PurePanel12 = /* @__PURE__ */ __name(({ className, items, ...props }) => {
  const { prefixCls: customizePrefixCls } = props;
  const { getPrefixCls } = React400.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const pureCls = `${prefixCls}-pure`;
  if (items) {
    return /* @__PURE__ */ React400.createElement(FloatButtonGroup_default, { className: (0, import_classnames170.default)(className, pureCls), ...props }, items.map((item, index3) => /* @__PURE__ */ React400.createElement(PureFloatButton, { key: index3, ...item })));
  }
  return /* @__PURE__ */ React400.createElement(PureFloatButton, { className: (0, import_classnames170.default)(className, pureCls), ...props });
}, "PurePanel");
var PurePanel_default6 = PurePanel12;

// packages/ant-design/components/float-button/index.ts
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default6;
var float_button_default = FloatButton_default;

// packages/ant-design/components/form/ErrorList.tsx
var import_classnames171 = __toESM(require_classnames());
import * as React402 from "react";
import { useMemo as useMemo122 } from "react";

// packages/ant-design/components/form/hooks/useDebounce.ts
import * as React401 from "react";
function useDebounce(value) {
  const [cacheValue, setCacheValue] = React401.useState(value);
  React401.useEffect(() => {
    const timeout = setTimeout(
      () => {
        setCacheValue(value);
      },
      value.length ? 0 : 10
    );
    return () => {
      clearTimeout(timeout);
    };
  }, [value]);
  return cacheValue;
}
__name(useDebounce, "useDebounce");

// packages/ant-design/components/form/style/explain.ts
var genFormValidateMotionStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const helpCls = `${componentCls}-show-help`;
  const helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      // Explain holder
      transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: `translateY(-5px)`,
          opacity: 0,
          [`&-active`]: {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: `translateY(-5px)`
        }
      }
    }
  };
}, "genFormValidateMotionStyle");
var explain_default = genFormValidateMotionStyle;

// packages/ant-design/components/form/style/index.ts
var resetForm = /* @__PURE__ */ __name((token2) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token2.marginLG,
    padding: 0,
    color: token2.colorTextDescription,
    fontSize: token2.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
    outline: 0,
    boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight
  }
}), "resetForm");
var genFormSize = /* @__PURE__ */ __name((token2, height) => {
  const { formItemCls } = token2;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
}, "genFormSize");
var genFormStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [token2.componentCls]: {
      ...resetComponent(token2),
      ...resetForm(token2),
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token2.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": {
        ...genFormSize(token2, token2.controlHeightSM)
      },
      "&-large": {
        ...genFormSize(token2, token2.controlHeightLG)
      }
    }
  };
}, "genFormStyle");
var genFormItemStyle = /* @__PURE__ */ __name((token2) => {
  const {
    formItemCls,
    iconCls,
    componentCls,
    rootPrefixCls,
    labelRequiredMarkColor,
    labelColor,
    labelFontSize,
    labelHeight,
    labelColonMarginInlineStart,
    labelColonMarginInlineEnd,
    itemMarginBottom
  } = token2;
  return {
    [formItemCls]: {
      ...resetComponent(token2),
      marginBottom: itemMarginBottom,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token2.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token2.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${formItemCls}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: token2.lineHeight,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: labelHeight,
          color: labelColor,
          fontSize: labelFontSize,
          [`> ${iconCls}`]: {
            fontSize: token2.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: token2.marginXXS,
            color: labelRequiredMarkColor,
            fontSize: token2.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token2.marginXXS,
            color: token2.colorTextDescription,
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-tooltip`]: {
            color: token2.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token2.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: labelColonMarginInlineStart,
            marginInlineEnd: labelColonMarginInlineEnd
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${formItemCls}-control`]: {
        ["--ant-display"]: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token2.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [formItemCls]: {
        "&-explain, &-extra": {
          clear: "both",
          color: token2.colorTextDescription,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token2.controlHeightSM,
          transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token2.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token2.motionDurationMid,
        animationTimingFunction: token2.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token2.colorSuccess
        },
        "&-error": {
          color: token2.colorError
        },
        "&-warning": {
          color: token2.colorWarning
        },
        "&-validating": {
          color: token2.colorPrimary
        }
      }
    }
  };
}, "genFormItemStyle");
var genHorizontalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, formItemCls } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
        [`& + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      }
    }
  };
}, "genHorizontalStyle");
var genInlineStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, formItemCls } = token2;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [formItemCls]: {
        flex: "none",
        marginInlineEnd: token2.margin,
        marginBottom: 0,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, "genInlineStyle");
var makeVerticalLayoutLabel = /* @__PURE__ */ __name((token2) => ({
  padding: token2.verticalLabelPadding,
  margin: token2.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
}), "makeVerticalLayoutLabel");
var makeVerticalLayout = /* @__PURE__ */ __name((token2) => {
  const { componentCls, formItemCls, rootPrefixCls } = token2;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${componentCls}:not(${componentCls}-inline)`]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label, ${formItemCls}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
}, "makeVerticalLayout");
var genVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, formItemCls, rootPrefixCls } = token2;
  return {
    [`${componentCls}-vertical`]: {
      [formItemCls]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${componentCls}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [`@media (max-width: ${unit(token2.screenXSMax)})`]: [
      makeVerticalLayout(token2),
      {
        [componentCls]: {
          [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    ],
    [`@media (max-width: ${unit(token2.screenSMMax)})`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${unit(token2.screenMDMax)})`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${unit(token2.screenLGMax)})`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }
  };
}, "genVerticalStyle");
var prepareComponentToken33 = /* @__PURE__ */ __name((token2) => ({
  labelRequiredMarkColor: token2.colorError,
  labelColor: token2.colorTextHeading,
  labelFontSize: token2.fontSize,
  labelHeight: token2.controlHeight,
  labelColonMarginInlineStart: token2.marginXXS / 2,
  labelColonMarginInlineEnd: token2.marginXS,
  itemMarginBottom: token2.marginLG,
  verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
  verticalLabelMargin: 0
}), "prepareComponentToken");
var prepareToken4 = /* @__PURE__ */ __name((token2, rootPrefixCls) => {
  const formToken = merge2(token2, {
    formItemCls: `${token2.componentCls}-item`,
    rootPrefixCls
  });
  return formToken;
}, "prepareToken");
var style_default39 = genStyleHooks(
  "Form",
  (token2, { rootPrefixCls }) => {
    const formToken = prepareToken4(token2, rootPrefixCls);
    return [
      genFormStyle(formToken),
      genFormItemStyle(formToken),
      explain_default(formToken),
      genHorizontalStyle(formToken),
      genInlineStyle(formToken),
      genVerticalStyle(formToken),
      collapse_default(formToken),
      zoomIn
    ];
  },
  prepareComponentToken33,
  {
    // Let From style before the Grid
    // ref https://github.com/ant-design/ant-design/issues/44386
    order: -1e3
  }
);

// packages/ant-design/components/form/ErrorList.tsx
var EMPTY_LIST5 = [];
function toErrorEntity(error, prefix, errorStatus, index3 = 0) {
  return {
    key: typeof error === "string" ? error : `${prefix}-${index3}`,
    error,
    errorStatus
  };
}
__name(toErrorEntity, "toErrorEntity");
var ErrorList = /* @__PURE__ */ __name(({
  help,
  helpStatus,
  errors = EMPTY_LIST5,
  warnings = EMPTY_LIST5,
  className: rootClassName,
  fieldId,
  onVisibleChanged
}) => {
  const { prefixCls } = React402.useContext(FormItemPrefixContext);
  const baseClassName = `${prefixCls}-item-explain`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default39(prefixCls, rootCls);
  const collapseMotion = useMemo122(() => motion_default(prefixCls), [prefixCls]);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const fullKeyList = React402.useMemo(() => {
    if (help !== void 0 && help !== null) {
      return [toErrorEntity(help, "help", helpStatus)];
    }
    return [
      ...debounceErrors.map((error, index3) => toErrorEntity(error, "error", "error", index3)),
      ...debounceWarnings.map(
        (warning5, index3) => toErrorEntity(warning5, "warning", "warning", index3)
      )
    ];
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  const helpProps = {};
  if (fieldId) {
    helpProps.id = `${fieldId}_help`;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React402.createElement(
      src_default2,
      {
        motionDeadline: collapseMotion.motionDeadline,
        motionName: `${prefixCls}-show-help`,
        visible: !!fullKeyList.length,
        onVisibleChanged
      },
      (holderProps) => {
        const { className: holderClassName, style: holderStyle } = holderProps;
        return /* @__PURE__ */ React402.createElement(
          "div",
          {
            ...helpProps,
            className: (0, import_classnames171.default)(
              baseClassName,
              holderClassName,
              cssVarCls,
              rootCls,
              rootClassName,
              hashId
            ),
            style: holderStyle,
            role: "alert"
          },
          /* @__PURE__ */ React402.createElement(
            CSSMotionList_default,
            {
              keys: fullKeyList,
              ...motion_default(prefixCls),
              motionName: `${prefixCls}-show-help-item`,
              component: false
            },
            (itemProps) => {
              const {
                key,
                error,
                errorStatus,
                className: itemClassName,
                style: itemStyle
              } = itemProps;
              return /* @__PURE__ */ React402.createElement(
                "div",
                {
                  key,
                  className: (0, import_classnames171.default)(itemClassName, {
                    [`${baseClassName}-${errorStatus}`]: errorStatus
                  }),
                  style: itemStyle
                },
                error
              );
            }
          )
        );
      }
    )
  );
}, "ErrorList");
var ErrorList_default = ErrorList;

// packages/ant-design/components/form/Form.tsx
var import_classnames172 = __toESM(require_classnames());
import * as React404 from "react";
import { useMemo as useMemo124 } from "react";

// packages/ant-design/components/form/hooks/useForm.ts
import * as React403 from "react";

// packages/ant-design/components/form/util.ts
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray6(candidate) {
  if (candidate === void 0 || candidate === false)
    return [];
  return Array.isArray(candidate) ? candidate : [candidate];
}
__name(toArray6, "toArray");
function getFieldId(namePath, formName) {
  if (!namePath.length) {
    return void 0;
  }
  const mergedId = namePath.join("_");
  if (formName) {
    return `${formName}_${mergedId}`;
  }
  const isIllegalName = formItemNameBlackList.includes(mergedId);
  return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
__name(getFieldId, "getFieldId");
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
  let status = defaultValidateStatus;
  if (validateStatus !== void 0) {
    status = validateStatus;
  } else if (meta.validating) {
    status = "validating";
  } else if (errors.length) {
    status = "error";
  } else if (warnings.length) {
    status = "warning";
  } else if (meta.touched || hasFeedback && meta.validated) {
    status = "success";
  }
  return status;
}
__name(getStatus, "getStatus");

// packages/ant-design/components/form/hooks/useForm.ts
function toNamePathStr(name) {
  const namePath = toArray6(name);
  return namePath.join("_");
}
__name(toNamePathStr, "toNamePathStr");
function useForm2(form) {
  const [rcForm] = useForm_default();
  const itemsRef = React403.useRef({});
  const wrapForm = React403.useMemo(
    () => form ?? {
      ...rcForm,
      __INTERNAL__: {
        itemRef: (name) => (node2) => {
          const namePathStr = toNamePathStr(name);
          if (node2) {
            itemsRef.current[namePathStr] = node2;
          } else {
            delete itemsRef.current[namePathStr];
          }
        }
      },
      scrollToField: (name, options = {}) => {
        const namePath = toArray6(name);
        const fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
        const node2 = fieldId ? document.getElementById(fieldId) : null;
        if (node2) {
          e2(node2, {
            scrollMode: "if-needed",
            block: "nearest",
            ...options
          });
        }
      },
      getFieldInstance: (name) => {
        const namePathStr = toNamePathStr(name);
        return itemsRef.current[namePathStr];
      }
    },
    [form, rcForm]
  );
  return [wrapForm];
}
__name(useForm2, "useForm");

// packages/ant-design/components/form/hooks/useFormWarning.ts
import { useEffect as useEffect99 } from "react";
var names2 = {};
function useFormWarning({ name }) {
  const warning5 = devUseWarning("Form");
  useEffect99(() => {
    if (name) {
      names2[name] = (names2[name] || 0) + 1;
      warning5(names2[name] <= 1, "usage", "There exist multiple Form with same `name`.");
      return () => {
        names2[name] -= 1;
      };
    }
  }, [name]);
}
__name(useFormWarning, "useFormWarning");

// packages/ant-design/components/form/Form.tsx
var InternalForm2 = /* @__PURE__ */ __name((props, ref) => {
  const contextDisabled = React404.useContext(DisabledContext_default);
  const { getPrefixCls, direction, form: contextForm } = React404.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    size,
    disabled = contextDisabled,
    form,
    colon,
    labelAlign,
    labelWrap,
    labelCol,
    wrapperCol,
    hideRequiredMark,
    layout = "horizontal",
    scrollToFirstError,
    requiredMark,
    onFinishFailed,
    name,
    style: style2,
    feedbackIcons,
    variant,
    ...restFormProps
  } = props;
  const mergedSize = useSize_default(size);
  const contextValidateMessages = React404.useContext(validateMessagesContext_default);
  if (true) {
    useFormWarning(props);
  }
  const mergedRequiredMark = useMemo124(() => {
    if (requiredMark !== void 0) {
      return requiredMark;
    }
    if (hideRequiredMark) {
      return false;
    }
    if (contextForm && contextForm.requiredMark !== void 0) {
      return contextForm.requiredMark;
    }
    return true;
  }, [hideRequiredMark, requiredMark, contextForm]);
  const mergedColon = colon ?? contextForm?.colon;
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default39(prefixCls, rootCls);
  const formClassName = (0, import_classnames172.default)(
    prefixCls,
    `${prefixCls}-${layout}`,
    {
      [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${mergedSize}`]: mergedSize
    },
    cssVarCls,
    rootCls,
    hashId,
    contextForm?.className,
    className,
    rootClassName
  );
  const [wrapForm] = useForm2(form);
  const { __INTERNAL__ } = wrapForm;
  __INTERNAL__.name = name;
  const formContextValue = useMemo124(
    () => ({
      name,
      labelAlign,
      labelCol,
      labelWrap,
      wrapperCol,
      vertical: layout === "vertical",
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      itemRef: __INTERNAL__.itemRef,
      form: wrapForm,
      feedbackIcons
    }),
    [
      name,
      labelAlign,
      labelCol,
      wrapperCol,
      layout,
      mergedColon,
      mergedRequiredMark,
      wrapForm,
      feedbackIcons
    ]
  );
  React404.useImperativeHandle(ref, () => wrapForm);
  const scrollToField = /* @__PURE__ */ __name((options, fieldName) => {
    if (options) {
      let defaultScrollToFirstError = { block: "nearest" };
      if (typeof options === "object") {
        defaultScrollToFirstError = options;
      }
      wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
    }
  }, "scrollToField");
  const onInternalFinishFailed = /* @__PURE__ */ __name((errorInfo) => {
    onFinishFailed?.(errorInfo);
    if (errorInfo.errorFields.length) {
      const fieldName = errorInfo.errorFields[0].name;
      if (scrollToFirstError !== void 0) {
        scrollToField(scrollToFirstError, fieldName);
        return;
      }
      if (contextForm && contextForm.scrollToFirstError !== void 0) {
        scrollToField(contextForm.scrollToFirstError, fieldName);
      }
    }
  }, "onInternalFinishFailed");
  return wrapCSSVar(
    /* @__PURE__ */ React404.createElement(VariantContext.Provider, { value: variant }, /* @__PURE__ */ React404.createElement(DisabledContextProvider, { disabled }, /* @__PURE__ */ React404.createElement(SizeContext_default.Provider, { value: mergedSize }, /* @__PURE__ */ React404.createElement(
      FormProvider2,
      {
        ...{
          // This is not list in API, we pass with spread
          validateMessages: contextValidateMessages
        }
      },
      /* @__PURE__ */ React404.createElement(FormContext2.Provider, { value: formContextValue }, /* @__PURE__ */ React404.createElement(
        src_default4,
        {
          id: name,
          ...restFormProps,
          name,
          onFinishFailed: onInternalFinishFailed,
          form: wrapForm,
          style: { ...contextForm?.style, ...style2 },
          className: formClassName
        }
      ))
    ))))
  );
}, "InternalForm");
var Form2 = React404.forwardRef(InternalForm2);
if (true) {
  Form2.displayName = "Form";
}
var Form_default2 = Form2;

// packages/ant-design/components/form/FormItem/index.tsx
var import_classnames177 = __toESM(require_classnames());
import * as React411 from "react";

// packages/ant-design/components/form/hooks/useChildren.ts
function useChildren2(children) {
  if (typeof children === "function") {
    return children;
  }
  const childList = toArray(children);
  return childList.length <= 1 ? childList[0] : childList;
}
__name(useChildren2, "useChildren");

// packages/ant-design/components/form/hooks/useFormItemStatus.ts
import { useContext as useContext164 } from "react";
var useFormItemStatus = /* @__PURE__ */ __name(() => {
  const { status, errors = [], warnings = [] } = useContext164(FormItemInputContext);
  if (true) {
    const warning5 = devUseWarning("Form.Item");
    warning5(
      status !== void 0,
      "usage",
      "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus"
    );
  }
  return { status, errors, warnings };
}, "useFormItemStatus");
useFormItemStatus.Context = FormItemInputContext;
var useFormItemStatus_default = useFormItemStatus;

// packages/ant-design/components/form/hooks/useFrameState.ts
import * as React405 from "react";
import { useRef as useRef127 } from "react";
function useFrameState(defaultValue) {
  const [value, setValue] = React405.useState(defaultValue);
  const frameRef = useRef127(null);
  const batchRef = useRef127([]);
  const destroyRef = useRef127(false);
  React405.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
      raf_default.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = raf_default(() => {
        frameRef.current = null;
        setValue((prevValue) => {
          let current = prevValue;
          batchRef.current.forEach((func) => {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  __name(setFrameValue, "setFrameValue");
  return [value, setFrameValue];
}
__name(useFrameState, "useFrameState");

// packages/ant-design/components/form/hooks/useItemRef.ts
import * as React406 from "react";
function useItemRef() {
  const { itemRef } = React406.useContext(FormContext2);
  const cacheRef = React406.useRef({});
  function getRef(name, children) {
    const childrenRef = children && typeof children === "object" && children.ref;
    const nameStr = name.join("_");
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
    }
    return cacheRef.current.ref;
  }
  __name(getRef, "getRef");
  return getRef;
}
__name(useItemRef, "useItemRef");

// packages/ant-design/components/form/FormItem/ItemHolder.tsx
var import_classnames176 = __toESM(require_classnames());
import * as React410 from "react";

// packages/ant-design/components/form/FormItemInput.tsx
var import_classnames173 = __toESM(require_classnames());
import * as React407 from "react";

// packages/ant-design/components/form/style/fallbackCmp.ts
var genFallbackStyle = /* @__PURE__ */ __name((token2) => {
  const { formItemCls } = token2;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${formItemCls}-control`]: {
        display: "flex"
      }
    }
  };
}, "genFallbackStyle");
var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token2, { rootPrefixCls }) => {
  const formToken = prepareToken4(token2, rootPrefixCls);
  return [genFallbackStyle(formToken)];
});

// packages/ant-design/components/form/FormItemInput.tsx
var FormItemInput = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    status,
    wrapperCol,
    children,
    errors,
    warnings,
    _internalItemRender: formItemRender,
    extra,
    help,
    fieldId,
    marginBottom,
    onErrorVisibleChanged
  } = props;
  const baseClassName = `${prefixCls}-item`;
  const formContext = React407.useContext(FormContext2);
  const mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
  const className = (0, import_classnames173.default)(`${baseClassName}-control`, mergedWrapperCol.className);
  const subFormContext = React407.useMemo(() => ({ ...formContext }), [formContext]);
  delete subFormContext.labelCol;
  delete subFormContext.wrapperCol;
  const inputDom = /* @__PURE__ */ React407.createElement("div", { className: `${baseClassName}-control-input` }, /* @__PURE__ */ React407.createElement("div", { className: `${baseClassName}-control-input-content` }, children));
  const formItemContext = React407.useMemo(() => ({ prefixCls, status }), [prefixCls, status]);
  const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ React407.createElement("div", { style: { display: "flex", flexWrap: "nowrap" } }, /* @__PURE__ */ React407.createElement(FormItemPrefixContext.Provider, { value: formItemContext }, /* @__PURE__ */ React407.createElement(
    ErrorList_default,
    {
      fieldId,
      errors,
      warnings,
      help,
      helpStatus: status,
      className: `${baseClassName}-explain-connected`,
      onVisibleChanged: onErrorVisibleChanged
    }
  )), !!marginBottom && /* @__PURE__ */ React407.createElement("div", { style: { width: 0, height: marginBottom } })) : null;
  const extraProps = {};
  if (fieldId) {
    extraProps.id = `${fieldId}_extra`;
  }
  const extraDom = extra ? /* @__PURE__ */ React407.createElement("div", { ...extraProps, className: `${baseClassName}-extra` }, extra) : null;
  const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, { input: inputDom, errorList: errorListDom, extra: extraDom }) : /* @__PURE__ */ React407.createElement(React407.Fragment, null, inputDom, errorListDom, extraDom);
  return /* @__PURE__ */ React407.createElement(FormContext2.Provider, { value: subFormContext }, /* @__PURE__ */ React407.createElement(col_default, { ...mergedWrapperCol, className }, dom), /* @__PURE__ */ React407.createElement(fallbackCmp_default, { prefixCls }));
}, "FormItemInput");
var FormItemInput_default = FormItemInput;

// packages/ant-design/components/form/FormItemLabel.tsx
var import_QuestionCircleOutlined = __toESM(require_QuestionCircleOutlined3());
var import_classnames174 = __toESM(require_classnames());
import * as React408 from "react";
function toTooltipProps(tooltip) {
  if (!tooltip) {
    return null;
  }
  if (typeof tooltip === "object" && !React408.isValidElement(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
}
__name(toTooltipProps, "toTooltipProps");
var FormItemLabel = /* @__PURE__ */ __name(({
  prefixCls,
  label,
  htmlFor,
  labelCol,
  labelAlign,
  colon,
  required: required5,
  requiredMark,
  tooltip
}) => {
  const [formLocale] = useLocale_default("Form");
  const {
    vertical,
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon
  } = React408.useContext(FormContext2);
  if (!label) {
    return null;
  }
  const mergedLabelCol = labelCol || contextLabelCol || {};
  const mergedLabelAlign = labelAlign || contextLabelAlign;
  const labelClsBasic = `${prefixCls}-item-label`;
  const labelColClassName = (0, import_classnames174.default)(
    labelClsBasic,
    mergedLabelAlign === "left" && `${labelClsBasic}-left`,
    mergedLabelCol.className,
    {
      [`${labelClsBasic}-wrap`]: !!labelWrap
    }
  );
  let labelChildren = label;
  const computedColon = colon === true || contextColon !== false && colon !== false;
  const haveColon = computedColon && !vertical;
  if (haveColon && typeof label === "string" && label.trim() !== "") {
    labelChildren = label.replace(/[:|：]\s*$/, "");
  }
  const tooltipProps = toTooltipProps(tooltip);
  if (tooltipProps) {
    const { icon = /* @__PURE__ */ React408.createElement(import_QuestionCircleOutlined.default, null), ...restTooltipProps } = tooltipProps;
    const tooltipNode = /* @__PURE__ */ React408.createElement(tooltip_default, { ...restTooltipProps }, React408.cloneElement(icon, {
      className: `${prefixCls}-item-tooltip`,
      title: "",
      onClick: (e3) => {
        e3.preventDefault();
      },
      tabIndex: null
    }));
    labelChildren = /* @__PURE__ */ React408.createElement(React408.Fragment, null, labelChildren, tooltipNode);
  }
  const isOptionalMark = requiredMark === "optional";
  const isRenderMark = typeof requiredMark === "function";
  if (isRenderMark) {
    labelChildren = requiredMark(labelChildren, { required: !!required5 });
  } else if (isOptionalMark && !required5) {
    labelChildren = /* @__PURE__ */ React408.createElement(React408.Fragment, null, labelChildren, /* @__PURE__ */ React408.createElement("span", { className: `${prefixCls}-item-optional`, title: "" }, formLocale?.optional || en_US_default6.Form?.optional));
  }
  const labelClassName = (0, import_classnames174.default)({
    [`${prefixCls}-item-required`]: required5,
    [`${prefixCls}-item-required-mark-optional`]: isOptionalMark || isRenderMark,
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return /* @__PURE__ */ React408.createElement(col_default, { ...mergedLabelCol, className: labelColClassName }, /* @__PURE__ */ React408.createElement(
    "label",
    {
      htmlFor,
      className: labelClassName,
      title: typeof label === "string" ? label : ""
    },
    labelChildren
  ));
}, "FormItemLabel");
var FormItemLabel_default = FormItemLabel;

// packages/ant-design/components/form/FormItem/StatusProvider.tsx
var import_CheckCircleFilled5 = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled7 = __toESM(require_CloseCircleFilled3());
var import_ExclamationCircleFilled5 = __toESM(require_ExclamationCircleFilled3());
var import_LoadingOutlined5 = __toESM(require_LoadingOutlined3());
var import_classnames175 = __toESM(require_classnames());
import * as React409 from "react";
var iconMap = {
  success: import_CheckCircleFilled5.default,
  warning: import_ExclamationCircleFilled5.default,
  error: import_CloseCircleFilled7.default,
  validating: import_LoadingOutlined5.default
};
function StatusProvider({
  children,
  errors,
  warnings,
  hasFeedback,
  validateStatus,
  prefixCls,
  meta,
  noStyle
}) {
  const itemPrefixCls = `${prefixCls}-item`;
  const { feedbackIcons } = React409.useContext(FormContext2);
  const mergedValidateStatus = getStatus(
    errors,
    warnings,
    meta,
    null,
    !!hasFeedback,
    validateStatus
  );
  const {
    isFormItemInput: parentIsFormItemInput,
    status: parentStatus,
    hasFeedback: parentHasFeedback,
    feedbackIcon: parentFeedbackIcon
  } = React409.useContext(FormItemInputContext);
  const formItemStatusContext = React409.useMemo(() => {
    let feedbackIcon;
    if (hasFeedback) {
      const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
      const customIconNode = mergedValidateStatus && customIcons?.({ status: mergedValidateStatus, errors, warnings })?.[mergedValidateStatus];
      const IconNode2 = mergedValidateStatus && iconMap[mergedValidateStatus];
      feedbackIcon = customIconNode !== false && IconNode2 ? /* @__PURE__ */ React409.createElement(
        "span",
        {
          className: (0, import_classnames175.default)(
            `${itemPrefixCls}-feedback-icon`,
            `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`
          )
        },
        customIconNode || /* @__PURE__ */ React409.createElement(IconNode2, null)
      ) : null;
    }
    const context = {
      status: mergedValidateStatus || "",
      errors,
      warnings,
      hasFeedback: !!hasFeedback,
      feedbackIcon,
      isFormItemInput: true
    };
    if (noStyle) {
      context.status = (mergedValidateStatus ?? parentStatus) || "";
      context.isFormItemInput = parentIsFormItemInput;
      context.hasFeedback = !!(hasFeedback ?? parentHasFeedback);
      context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
    }
    return context;
  }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
  return /* @__PURE__ */ React409.createElement(FormItemInputContext.Provider, { value: formItemStatusContext }, children);
}
__name(StatusProvider, "StatusProvider");

// packages/ant-design/components/form/FormItem/ItemHolder.tsx
function ItemHolder(props) {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    help,
    errors,
    warnings,
    validateStatus,
    meta,
    hasFeedback,
    hidden,
    children,
    fieldId,
    required: required5,
    isRequired,
    onSubItemMetaChange,
    ...restProps
  } = props;
  const itemPrefixCls = `${prefixCls}-item`;
  const { requiredMark } = React410.useContext(FormContext2);
  const itemRef = React410.useRef(null);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const hasHelp = help !== void 0 && help !== null;
  const hasError = !!(hasHelp || errors.length || warnings.length);
  const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
  const [marginBottom, setMarginBottom] = React410.useState(null);
  useLayoutEffect_default(() => {
    if (hasError && itemRef.current) {
      const itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError, isOnScreen]);
  const onErrorVisibleChanged = /* @__PURE__ */ __name((nextVisible) => {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  }, "onErrorVisibleChanged");
  const getValidateState = /* @__PURE__ */ __name((isDebounce = false) => {
    const _errors = isDebounce ? debounceErrors : meta.errors;
    const _warnings = isDebounce ? debounceWarnings : meta.warnings;
    return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
  }, "getValidateState");
  const mergedValidateStatus = getValidateState();
  const itemClassName = (0, import_classnames176.default)(itemPrefixCls, className, rootClassName, {
    [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
    // Status
    [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
    [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
    [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
    [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
    [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
    [`${itemPrefixCls}-hidden`]: hidden
  });
  return /* @__PURE__ */ React410.createElement("div", { className: itemClassName, style: style2, ref: itemRef }, /* @__PURE__ */ React410.createElement(
    row_default,
    {
      className: `${itemPrefixCls}-row`,
      ...omit(restProps, [
        "_internalItemRender",
        "colon",
        "dependencies",
        "extra",
        "fieldKey",
        "getValueFromEvent",
        "getValueProps",
        "htmlFor",
        "id",
        // It is deprecated because `htmlFor` is its replacement.
        "initialValue",
        "isListField",
        "label",
        "labelAlign",
        "labelCol",
        "labelWrap",
        "messageVariables",
        "name",
        "normalize",
        "noStyle",
        "preserve",
        "requiredMark",
        "rules",
        "shouldUpdate",
        "trigger",
        "tooltip",
        "validateFirst",
        "validateTrigger",
        "valuePropName",
        "wrapperCol",
        "validateDebounce"
      ])
    },
    /* @__PURE__ */ React410.createElement(
      FormItemLabel_default,
      {
        htmlFor: fieldId,
        ...props,
        requiredMark,
        required: required5 ?? isRequired,
        prefixCls
      }
    ),
    /* @__PURE__ */ React410.createElement(
      FormItemInput_default,
      {
        ...props,
        ...meta,
        errors: debounceErrors,
        warnings: debounceWarnings,
        prefixCls,
        status: mergedValidateStatus,
        help,
        marginBottom,
        onErrorVisibleChanged
      },
      /* @__PURE__ */ React410.createElement(NoStyleItemContext.Provider, { value: onSubItemMetaChange }, /* @__PURE__ */ React410.createElement(
        StatusProvider,
        {
          prefixCls,
          meta,
          errors: meta.errors,
          warnings: meta.warnings,
          hasFeedback,
          validateStatus: mergedValidateStatus
        },
        children
      ))
    )
  ), !!marginBottom && /* @__PURE__ */ React410.createElement(
    "div",
    {
      className: `${itemPrefixCls}-margin-offset`,
      style: {
        marginBottom: -marginBottom
      }
    }
  ));
}
__name(ItemHolder, "ItemHolder");

// packages/ant-design/components/form/FormItem/index.tsx
var NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  return keysA.length === keysB.length && keysA.every((key) => {
    const propValueA = a[key];
    const propValueB = b[key];
    return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
  });
}
__name(isSimilarControl, "isSimilarControl");
var MemoInput = React411.memo(
  ({ children }) => children,
  (prev2, next2) => isSimilarControl(prev2.control, next2.control) && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index3) => value === next2.childProps[index3])
);
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: [],
    validated: false
  };
}
__name(genEmptyMeta, "genEmptyMeta");
function InternalFormItem(props) {
  const {
    name,
    noStyle,
    className,
    dependencies,
    prefixCls: customizePrefixCls,
    shouldUpdate,
    rules,
    children,
    required: required5,
    label,
    messageVariables,
    trigger = "onChange",
    validateTrigger,
    hidden,
    help
  } = props;
  const { getPrefixCls } = React411.useContext(ConfigContext);
  const { name: formName } = React411.useContext(FormContext2);
  const mergedChildren = useChildren2(children);
  const isRenderProps = typeof mergedChildren === "function";
  const notifyParentMetaChange = React411.useContext(NoStyleItemContext);
  const { validateTrigger: contextValidateTrigger } = React411.useContext(FieldContext_default);
  const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
  const hasName = !(name === void 0 || name === null);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default39(prefixCls, rootCls);
  const warning5 = devUseWarning("Form.Item");
  if (true) {
    warning5(name !== null, "usage", "`null` is passed as `name` property");
  }
  const listContext = React411.useContext(ListContext_default);
  const fieldKeyPathRef = React411.useRef();
  const [subFieldErrors, setSubFieldErrors] = useFrameState({});
  const [meta, setMeta] = useSafeState(() => genEmptyMeta());
  const onMetaChange = /* @__PURE__ */ __name((nextMeta) => {
    const keyInfo = listContext?.getKey(nextMeta.name);
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    if (noStyle && help !== false && notifyParentMetaChange) {
      let namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== void 0) {
          const [fieldKey, restPath] = keyInfo;
          namePath = [fieldKey, ...restPath];
          fieldKeyPathRef.current = namePath;
        }
      } else {
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  }, "onMetaChange");
  const onSubItemMetaChange = /* @__PURE__ */ __name((subMeta, uniqueKeys) => {
    setSubFieldErrors((prevSubFieldErrors) => {
      const clone = {
        ...prevSubFieldErrors
      };
      const mergedNamePath = [...subMeta.name.slice(0, -1), ...uniqueKeys];
      const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        delete clone[mergedNameKey];
      } else {
        clone[mergedNameKey] = subMeta;
      }
      return clone;
    });
  }, "onSubItemMetaChange");
  const [mergedErrors, mergedWarnings] = React411.useMemo(() => {
    const errorList = [...meta.errors];
    const warningList = [...meta.warnings];
    Object.values(subFieldErrors).forEach((subFieldError) => {
      errorList.push(...subFieldError.errors || []);
      warningList.push(...subFieldError.warnings || []);
    });
    return [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]);
  const getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return /* @__PURE__ */ React411.createElement(
        StatusProvider,
        {
          prefixCls,
          hasFeedback: props.hasFeedback,
          validateStatus: props.validateStatus,
          meta,
          errors: mergedErrors,
          warnings: mergedWarnings,
          noStyle: true
        },
        baseChildren
      );
    }
    return /* @__PURE__ */ React411.createElement(
      ItemHolder,
      {
        key: "row",
        ...props,
        className: (0, import_classnames177.default)(className, cssVarCls, rootCls, hashId),
        prefixCls,
        fieldId,
        isRequired,
        errors: mergedErrors,
        warnings: mergedWarnings,
        meta,
        onSubItemMetaChange
      },
      baseChildren
    );
  }
  __name(renderLayout, "renderLayout");
  if (!hasName && !isRenderProps && !dependencies) {
    return wrapCSSVar(renderLayout(mergedChildren));
  }
  let variables = {};
  if (typeof label === "string") {
    variables.label = label;
  } else if (name) {
    variables.label = String(name);
  }
  if (messageVariables) {
    variables = { ...variables, ...messageVariables };
  }
  return wrapCSSVar(
    /* @__PURE__ */ React411.createElement(
      Field_default,
      {
        ...props,
        messageVariables: variables,
        trigger,
        validateTrigger: mergedValidateTrigger,
        onMetaChange
      },
      (control, renderMeta, context) => {
        const mergedName = toArray6(name).length && renderMeta ? renderMeta.name : [];
        const fieldId = getFieldId(mergedName, formName);
        const isRequired = required5 !== void 0 ? required5 : !!(rules && rules.some((rule) => {
          if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
            return true;
          }
          if (typeof rule === "function") {
            const ruleEntity = rule(context);
            return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
          }
          return false;
        }));
        const mergedControl = {
          ...control
        };
        let childNode = null;
        warning5(
          !(shouldUpdate && dependencies),
          "usage",
          "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps."
        );
        if (Array.isArray(mergedChildren) && hasName) {
          warning5(
            false,
            "usage",
            "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item."
          );
          childNode = mergedChildren;
        } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
          warning5(
            !!(shouldUpdate || dependencies),
            "usage",
            "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`."
          );
          warning5(
            !hasName,
            "usage",
            "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop."
          );
        } else if (dependencies && !isRenderProps && !hasName) {
          warning5(
            false,
            "usage",
            "Must set `name` or use a render function when `dependencies` is set."
          );
        } else if (React411.isValidElement(mergedChildren)) {
          warning5(
            mergedChildren.props.defaultValue === void 0,
            "usage",
            "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead."
          );
          const childProps = { ...mergedChildren.props, ...mergedControl };
          if (!childProps.id) {
            childProps.id = fieldId;
          }
          if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
            const describedbyArr = [];
            if (help || mergedErrors.length > 0) {
              describedbyArr.push(`${fieldId}_help`);
            }
            if (props.extra) {
              describedbyArr.push(`${fieldId}_extra`);
            }
            childProps["aria-describedby"] = describedbyArr.join(" ");
          }
          if (mergedErrors.length > 0) {
            childProps["aria-invalid"] = "true";
          }
          if (isRequired) {
            childProps["aria-required"] = "true";
          }
          if (supportRef(mergedChildren)) {
            childProps.ref = getItemRef(mergedName, mergedChildren);
          }
          const triggers = /* @__PURE__ */ new Set([
            ...toArray6(trigger),
            ...toArray6(mergedValidateTrigger)
          ]);
          triggers.forEach((eventName) => {
            childProps[eventName] = (...args) => {
              mergedControl[eventName]?.(...args);
              mergedChildren.props[eventName]?.(...args);
            };
          });
          const watchingChildProps = [
            childProps["aria-required"],
            childProps["aria-invalid"],
            childProps["aria-describedby"]
          ];
          childNode = /* @__PURE__ */ React411.createElement(
            MemoInput,
            {
              control: mergedControl,
              update: mergedChildren,
              childProps: watchingChildProps
            },
            cloneElement3(mergedChildren, childProps)
          );
        } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
          childNode = mergedChildren(context);
        } else {
          warning5(
            !mergedName.length || !!noStyle,
            "usage",
            "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead."
          );
          childNode = mergedChildren;
        }
        return renderLayout(childNode, fieldId, isRequired);
      }
    )
  );
}
__name(InternalFormItem, "InternalFormItem");
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus_default;
var FormItem_default = FormItem;

// packages/ant-design/components/form/FormList.tsx
import * as React412 from "react";
var FormList = /* @__PURE__ */ __name(({
  prefixCls: customizePrefixCls,
  children,
  ...props
}) => {
  if (true) {
    const warning5 = devUseWarning("Form.List");
    warning5(
      typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name),
      "usage",
      "Miss `name` prop."
    );
  }
  const { getPrefixCls } = React412.useContext(ConfigContext);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const contextValue = React412.useMemo(
    () => ({
      prefixCls,
      status: "error"
    }),
    [prefixCls]
  );
  return /* @__PURE__ */ React412.createElement(List_default, { ...props }, (fields, operation, meta) => /* @__PURE__ */ React412.createElement(FormItemPrefixContext.Provider, { value: contextValue }, children(
    fields.map((field) => ({ ...field, fieldKey: field.key })),
    operation,
    {
      errors: meta.errors,
      warnings: meta.warnings
    }
  )));
}, "FormList");
var FormList_default = FormList;

// packages/ant-design/components/form/hooks/useFormInstance.ts
import { useContext as useContext172 } from "react";
function useFormInstance() {
  const { form } = useContext172(FormContext2);
  return form;
}
__name(useFormInstance, "useFormInstance");

// packages/ant-design/components/form/index.ts
var Form3 = Form_default2;
Form3.Item = FormItem_default;
Form3.List = FormList_default;
Form3.ErrorList = ErrorList_default;
Form3.useForm = useForm2;
Form3.useFormInstance = useFormInstance;
Form3.useWatch = useWatch_default;
Form3.Provider = FormProvider2;
Form3.create = () => {
  warning_default2(
    false,
    "Form",
    "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead."
  );
};
var form_default = Form3;

// packages/ant-design/components/image/index.tsx
var import_EyeOutlined2 = __toESM(require_EyeOutlined3());
var import_classnames182 = __toESM(require_classnames());
import * as React421 from "react";

// packages/image/src/Image.tsx
var import_classnames180 = __toESM(require_classnames());

// packages/util/src/Dom/css.js
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
__name(getClientSize, "getClientSize");
function getOffset4(node2) {
  const box2 = node2.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
__name(getOffset4, "getOffset");

// packages/image/src/Image.tsx
import * as React419 from "react";
import { useContext as useContext176, useMemo as useMemo131, useState as useState100 } from "react";

// packages/image/src/common.ts
var COMMON_PROPS = [
  "crossOrigin",
  "decoding",
  "draggable",
  "loading",
  "referrerPolicy",
  "sizes",
  "srcSet",
  "useMap",
  "alt"
];

// packages/image/src/context.ts
import * as React413 from "react";
var PreviewGroupContext = React413.createContext(null);

// packages/image/src/hooks/useRegisterImage.ts
import * as React414 from "react";
var uid = 0;
function useRegisterImage(canPreview, data) {
  const [id] = React414.useState(() => {
    uid += 1;
    return String(uid);
  });
  const groupContext = React414.useContext(PreviewGroupContext);
  const registerData = {
    data,
    canPreview
  };
  React414.useEffect(() => {
    if (groupContext) {
      return groupContext.register(id, registerData);
    }
  }, []);
  React414.useEffect(() => {
    if (groupContext) {
      groupContext.register(id, registerData);
    }
  }, [canPreview, data]);
  return id;
}
__name(useRegisterImage, "useRegisterImage");

// packages/image/src/hooks/useStatus.ts
import { useEffect as useEffect102, useRef as useRef131, useState as useState93 } from "react";

// packages/image/src/util.ts
function isImageValid(src) {
  return new Promise((resolve) => {
    const img = document.createElement("img");
    img.onerror = () => resolve(false);
    img.onload = () => resolve(true);
    img.src = src;
  });
}
__name(isImageValid, "isImageValid");

// packages/image/src/hooks/useStatus.ts
function useStatus2({
  src,
  isCustomPlaceholder,
  fallback
}) {
  const [status, setStatus] = useState93(isCustomPlaceholder ? "loading" : "normal");
  const isLoaded = useRef131(false);
  const isError = status === "error";
  useEffect102(() => {
    let isCurrentSrc = true;
    isImageValid(src).then((isValid) => {
      if (!isValid && isCurrentSrc) {
        setStatus("error");
      }
    });
    return () => {
      isCurrentSrc = false;
    };
  }, [src]);
  useEffect102(() => {
    if (isCustomPlaceholder && !isLoaded.current) {
      setStatus("loading");
    } else if (isError) {
      setStatus("normal");
    }
  }, [src]);
  const onLoad = /* @__PURE__ */ __name(() => {
    setStatus("normal");
  }, "onLoad");
  const getImgRef = /* @__PURE__ */ __name((img) => {
    isLoaded.current = false;
    if (status === "loading" && img?.complete && (img.naturalWidth || img.naturalHeight)) {
      isLoaded.current = true;
      onLoad();
    }
  }, "getImgRef");
  const srcAndOnload = isError && fallback ? { src: fallback } : { onLoad, src };
  return [getImgRef, srcAndOnload, status];
}
__name(useStatus2, "useStatus");

// packages/image/src/Preview.tsx
var import_classnames179 = __toESM(require_classnames());

// packages/util/src/Dom/addEventListener.js
import ReactDOM3 from "react-dom";
function addEventListenerWrap(target, eventType, cb, option) {
  const callback = ReactDOM3.unstable_batchedUpdates ? /* @__PURE__ */ __name(function run(e3) {
    ReactDOM3.unstable_batchedUpdates(cb, e3);
  }, "run") : cb;
  if (target?.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: () => {
      if (target?.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
__name(addEventListenerWrap, "addEventListenerWrap");

// packages/image/src/Preview.tsx
import React416, { useContext as useContext175, useEffect as useEffect106, useRef as useRef135, useState as useState97 } from "react";

// packages/image/src/hooks/useImageTransform.ts
import { useRef as useRef132, useState as useState94 } from "react";
var initialTransform = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: false,
  flipY: false
};
function useImageTransform(imgRef, minScale, maxScale, onTransform) {
  const frame = useRef132(null);
  const queue = useRef132([]);
  const [transform, setTransform] = useState94(initialTransform);
  const resetTransform = /* @__PURE__ */ __name((action) => {
    setTransform(initialTransform);
    if (onTransform && !isEqual_default(initialTransform, transform)) {
      onTransform({ transform: initialTransform, action });
    }
  }, "resetTransform");
  const updateTransform = /* @__PURE__ */ __name((newTransform, action) => {
    if (frame.current === null) {
      queue.current = [];
      frame.current = raf_default(() => {
        setTransform((preState) => {
          let memoState = preState;
          queue.current.forEach((queueState) => {
            memoState = { ...memoState, ...queueState };
          });
          frame.current = null;
          onTransform?.({ transform: memoState, action });
          return memoState;
        });
      });
    }
    queue.current.push({
      ...transform,
      ...newTransform
    });
  }, "updateTransform");
  const dispatchZoomChange = /* @__PURE__ */ __name((ratio, action, centerX, centerY, isTouch) => {
    const { width, height, offsetWidth, offsetHeight, offsetLeft, offsetTop } = imgRef.current;
    let newRatio = ratio;
    let newScale = transform.scale * ratio;
    if (newScale > maxScale) {
      newScale = maxScale;
      newRatio = maxScale / transform.scale;
    } else if (newScale < minScale) {
      newScale = isTouch ? newScale : minScale;
      newRatio = newScale / transform.scale;
    }
    const mergedCenterX = centerX ?? innerWidth / 2;
    const mergedCenterY = centerY ?? innerHeight / 2;
    const diffRatio = newRatio - 1;
    const diffImgX = diffRatio * width * 0.5;
    const diffImgY = diffRatio * height * 0.5;
    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);
    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);
    let newX = transform.x - (diffOffsetLeft - diffImgX);
    let newY = transform.y - (diffOffsetTop - diffImgY);
    if (ratio < 1 && newScale === 1) {
      const mergedWidth = offsetWidth * newScale;
      const mergedHeight = offsetHeight * newScale;
      const { width: clientWidth, height: clientHeight } = getClientSize();
      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
        newX = 0;
        newY = 0;
      }
    }
    updateTransform(
      {
        x: newX,
        y: newY,
        scale: newScale
      },
      action
    );
  }, "dispatchZoomChange");
  return {
    transform,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  };
}
__name(useImageTransform, "useImageTransform");

// packages/image/src/hooks/useMouseEvent.ts
import { useState as useState95, useRef as useRef133, useEffect as useEffect103 } from "react";
init_warning();

// packages/image/src/getFixScaleEleTransPosition.ts
function fixPoint(key, start, width, clientWidth) {
  const startAddWidth = start + width;
  const offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return {
        [key]: offsetStart
      };
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return {
        [key]: -offsetStart
      };
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return {
      [key]: start < 0 ? offsetStart : -offsetStart
    };
  }
  return {};
}
__name(fixPoint, "fixPoint");
function getFixScaleEleTransPosition(width, height, left, top) {
  const { width: clientWidth, height: clientHeight } = getClientSize();
  let fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = {
      ...fixPoint("x", left, width, clientWidth),
      ...fixPoint("y", top, height, clientHeight)
    };
  }
  return fixPos;
}
__name(getFixScaleEleTransPosition, "getFixScaleEleTransPosition");

// packages/image/src/previewConfig.ts
var BASE_SCALE_RATIO = 1;
var WHEEL_MAX_SCALE_RATIO = 1;

// packages/image/src/hooks/useMouseEvent.ts
function useMouseEvent(imgRef, movable, visible, scaleStep, transform, updateTransform, dispatchZoomChange) {
  const { rotate, scale, x, y } = transform;
  const [isMoving, setMoving] = useState95(false);
  const startPositionInfo = useRef133({
    diffX: 0,
    diffY: 0,
    transformX: 0,
    transformY: 0
  });
  const onMouseDown = /* @__PURE__ */ __name((event) => {
    if (!movable || event.button !== 0)
      return;
    event.preventDefault();
    event.stopPropagation();
    startPositionInfo.current = {
      diffX: event.pageX - x,
      diffY: event.pageY - y,
      transformX: x,
      transformY: y
    };
    setMoving(true);
  }, "onMouseDown");
  const onMouseMove = /* @__PURE__ */ __name((event) => {
    if (visible && isMoving) {
      updateTransform(
        {
          x: event.pageX - startPositionInfo.current.diffX,
          y: event.pageY - startPositionInfo.current.diffY
        },
        "move"
      );
    }
  }, "onMouseMove");
  const onMouseUp = /* @__PURE__ */ __name(() => {
    if (visible && isMoving) {
      setMoving(false);
      const { transformX, transformY } = startPositionInfo.current;
      const hasChangedPosition = x !== transformX && y !== transformY;
      if (!hasChangedPosition)
        return;
      const width = imgRef.current.offsetWidth * scale;
      const height = imgRef.current.offsetHeight * scale;
      const { left, top } = imgRef.current.getBoundingClientRect();
      const isRotate = rotate % 180 !== 0;
      const fixState = getFixScaleEleTransPosition(
        isRotate ? height : width,
        isRotate ? width : height,
        left,
        top
      );
      if (fixState) {
        updateTransform({ ...fixState }, "dragRebound");
      }
    }
  }, "onMouseUp");
  const onWheel = /* @__PURE__ */ __name((event) => {
    if (!visible || event.deltaY == 0)
      return;
    const scaleRatio = Math.abs(event.deltaY / 100);
    const mergedScaleRatio = Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO);
    let ratio = BASE_SCALE_RATIO + mergedScaleRatio * scaleStep;
    if (event.deltaY > 0) {
      ratio = BASE_SCALE_RATIO / ratio;
    }
    dispatchZoomChange(ratio, "wheel", event.clientX, event.clientY);
  }, "onWheel");
  useEffect103(() => {
    let onTopMouseUpListener;
    let onTopMouseMoveListener;
    let onMouseUpListener;
    let onMouseMoveListener;
    if (movable) {
      onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp, false);
      onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove, false);
      try {
        if (window.top !== window.self) {
          onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp, false);
          onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove, false);
        }
      } catch (error) {
        warning(false, `[rc-image] ${error}`);
      }
    }
    return () => {
      onMouseUpListener?.remove();
      onMouseMoveListener?.remove();
      onTopMouseUpListener?.remove();
      onTopMouseMoveListener?.remove();
    };
  }, [visible, isMoving, x, y, rotate, movable]);
  return {
    isMoving,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onWheel
  };
}
__name(useMouseEvent, "useMouseEvent");

// packages/image/src/hooks/useTouchEvent.ts
import { useState as useState96, useRef as useRef134, useEffect as useEffect104 } from "react";
function getDistance(a, b) {
  const x = a.x - b.x;
  const y = a.y - b.y;
  return Math.hypot(x, y);
}
__name(getDistance, "getDistance");
function getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {
  const distance1 = getDistance(oldPoint1, newPoint1);
  const distance2 = getDistance(oldPoint2, newPoint2);
  if (distance1 === 0 && distance2 === 0) {
    return [oldPoint1.x, oldPoint1.y];
  }
  const ratio = distance1 / (distance1 + distance2);
  const x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);
  const y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);
  return [x, y];
}
__name(getCenter, "getCenter");
function useTouchEvent(imgRef, movable, visible, minScale, transform, updateTransform, dispatchZoomChange) {
  const { rotate, scale, x, y } = transform;
  const [isTouching, setIsTouching] = useState96(false);
  const touchPointInfo = useRef134({
    point1: { x: 0, y: 0 },
    point2: { x: 0, y: 0 },
    eventType: "none"
  });
  const updateTouchPointInfo = /* @__PURE__ */ __name((values) => {
    touchPointInfo.current = {
      ...touchPointInfo.current,
      ...values
    };
  }, "updateTouchPointInfo");
  const onTouchStart = /* @__PURE__ */ __name((event) => {
    if (!movable)
      return;
    event.stopPropagation();
    setIsTouching(true);
    const { touches = [] } = event;
    if (touches.length > 1) {
      updateTouchPointInfo({
        point1: { x: touches[0].clientX, y: touches[0].clientY },
        point2: { x: touches[1].clientX, y: touches[1].clientY },
        eventType: "touchZoom"
      });
    } else {
      updateTouchPointInfo({
        point1: {
          x: touches[0].clientX - x,
          y: touches[0].clientY - y
        },
        eventType: "move"
      });
    }
  }, "onTouchStart");
  const onTouchMove = /* @__PURE__ */ __name((event) => {
    const { touches = [] } = event;
    const { point1, point2, eventType } = touchPointInfo.current;
    if (touches.length > 1 && eventType === "touchZoom") {
      const newPoint1 = {
        x: touches[0].clientX,
        y: touches[0].clientY
      };
      const newPoint2 = {
        x: touches[1].clientX,
        y: touches[1].clientY
      };
      const [centerX, centerY] = getCenter(point1, point2, newPoint1, newPoint2);
      const ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);
      dispatchZoomChange(ratio, "touchZoom", centerX, centerY, true);
      updateTouchPointInfo({
        point1: newPoint1,
        point2: newPoint2,
        eventType: "touchZoom"
      });
    } else if (eventType === "move") {
      updateTransform(
        {
          x: touches[0].clientX - point1.x,
          y: touches[0].clientY - point1.y
        },
        "move"
      );
      updateTouchPointInfo({ eventType: "move" });
    }
  }, "onTouchMove");
  const onTouchEnd = /* @__PURE__ */ __name(() => {
    if (!visible)
      return;
    if (isTouching) {
      setIsTouching(false);
    }
    updateTouchPointInfo({ eventType: "none" });
    if (minScale > scale) {
      return updateTransform({ x: 0, y: 0, scale: minScale }, "touchZoom");
    }
    const width = imgRef.current.offsetWidth * scale;
    const height = imgRef.current.offsetHeight * scale;
    const { left, top } = imgRef.current.getBoundingClientRect();
    const isRotate = rotate % 180 !== 0;
    const fixState = getFixScaleEleTransPosition(
      isRotate ? height : width,
      isRotate ? width : height,
      left,
      top
    );
    if (fixState) {
      updateTransform({ ...fixState }, "dragRebound");
    }
  }, "onTouchEnd");
  useEffect104(() => {
    let onTouchMoveListener;
    if (visible && movable) {
      onTouchMoveListener = addEventListenerWrap(window, "touchmove", (e3) => e3.preventDefault(), { passive: false });
    }
    return () => {
      onTouchMoveListener?.remove();
    };
  }, [visible, movable]);
  return {
    isTouching,
    onTouchStart,
    onTouchMove,
    onTouchEnd
  };
}
__name(useTouchEvent, "useTouchEvent");

// packages/image/src/Operations.tsx
var import_classnames178 = __toESM(require_classnames());
import * as React415 from "react";
import { useContext as useContext174 } from "react";
var Operations = /* @__PURE__ */ __name((props) => {
  const {
    visible,
    maskTransitionName,
    getContainer: getContainer2,
    prefixCls,
    rootClassName,
    icons: icons2,
    countRender,
    showSwitch,
    showProgress,
    current,
    transform,
    count,
    scale,
    minScale,
    maxScale,
    closeIcon,
    onSwitchLeft,
    onSwitchRight,
    onClose,
    onZoomIn,
    onZoomOut,
    onRotateRight,
    onRotateLeft,
    onFlipX,
    onFlipY,
    toolbarRender,
    zIndex
  } = props;
  const groupContext = useContext174(PreviewGroupContext);
  const { rotateLeft, rotateRight, zoomIn: zoomIn2, zoomOut: zoomOut2, close, left, right, flipX, flipY } = icons2;
  const toolClassName = `${prefixCls}-operations-operation`;
  React415.useEffect(() => {
    const onKeyDown2 = /* @__PURE__ */ __name((e3) => {
      if (e3.keyCode === KeyCode_default.ESC) {
        onClose();
      }
    }, "onKeyDown");
    if (visible) {
      window.addEventListener("keydown", onKeyDown2);
    }
    return () => {
      window.removeEventListener("keydown", onKeyDown2);
    };
  }, [visible]);
  const tools = [
    {
      icon: flipY,
      onClick: onFlipY,
      type: "flipY"
    },
    {
      icon: flipX,
      onClick: onFlipX,
      type: "flipX"
    },
    {
      icon: rotateLeft,
      onClick: onRotateLeft,
      type: "rotateLeft"
    },
    {
      icon: rotateRight,
      onClick: onRotateRight,
      type: "rotateRight"
    },
    {
      icon: zoomOut2,
      onClick: onZoomOut,
      type: "zoomOut",
      disabled: scale <= minScale
    },
    {
      icon: zoomIn2,
      onClick: onZoomIn,
      type: "zoomIn",
      disabled: scale === maxScale
    }
  ];
  const toolsNode = tools.map(({ icon, onClick, type: type5, disabled }) => /* @__PURE__ */ React415.createElement(
    "div",
    {
      className: (0, import_classnames178.default)(toolClassName, {
        [`${prefixCls}-operations-operation-${type5}`]: true,
        [`${prefixCls}-operations-operation-disabled`]: !!disabled
      }),
      onClick,
      key: type5
    },
    icon
  ));
  const toolbarNode = /* @__PURE__ */ React415.createElement("div", { className: `${prefixCls}-operations` }, toolsNode);
  return /* @__PURE__ */ React415.createElement(src_default2, { visible, motionName: maskTransitionName }, ({ className, style: style2 }) => /* @__PURE__ */ React415.createElement(es_default4, { open: true, getContainer: getContainer2 ?? document.body }, /* @__PURE__ */ React415.createElement(
    "div",
    {
      className: (0, import_classnames178.default)(`${prefixCls}-operations-wrapper`, className, rootClassName),
      style: {
        ...style2,
        zIndex
      }
    },
    closeIcon === null ? null : /* @__PURE__ */ React415.createElement("button", { className: `${prefixCls}-close`, onClick: onClose }, closeIcon || close),
    showSwitch && /* @__PURE__ */ React415.createElement(React415.Fragment, null, /* @__PURE__ */ React415.createElement(
      "div",
      {
        className: (0, import_classnames178.default)(`${prefixCls}-switch-left`, {
          [`${prefixCls}-switch-left-disabled`]: current === 0
        }),
        onClick: onSwitchLeft
      },
      left
    ), /* @__PURE__ */ React415.createElement(
      "div",
      {
        className: (0, import_classnames178.default)(`${prefixCls}-switch-right`, {
          [`${prefixCls}-switch-right-disabled`]: current === count - 1
        }),
        onClick: onSwitchRight
      },
      right
    )),
    /* @__PURE__ */ React415.createElement("div", { className: `${prefixCls}-footer` }, showProgress && /* @__PURE__ */ React415.createElement("div", { className: `${prefixCls}-progress` }, countRender ? countRender(current + 1, count) : `${current + 1} / ${count}`), toolbarRender ? toolbarRender(toolbarNode, {
      icons: {
        flipYIcon: toolsNode[0],
        flipXIcon: toolsNode[1],
        rotateLeftIcon: toolsNode[2],
        rotateRightIcon: toolsNode[3],
        zoomOutIcon: toolsNode[4],
        zoomInIcon: toolsNode[5]
      },
      actions: {
        onFlipY,
        onFlipX,
        onRotateLeft,
        onRotateRight,
        onZoomOut,
        onZoomIn
      },
      transform,
      ...groupContext ? { current, total: count } : {}
    }) : toolbarNode)
  )));
}, "Operations");
var Operations_default = Operations;

// packages/image/src/Preview.tsx
var PreviewImage = /* @__PURE__ */ __name(({ fallback, src, imgRef, ...props }) => {
  const [getImgRef, srcAndOnload] = useStatus2({
    src,
    fallback
  });
  return /* @__PURE__ */ React416.createElement(
    "img",
    {
      ref: (ref) => {
        imgRef.current = ref;
        getImgRef(ref);
      },
      ...props,
      ...srcAndOnload
    }
  );
}, "PreviewImage");
var Preview = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    src,
    alt,
    fallback,
    movable = true,
    onClose,
    visible,
    icons: icons2 = {},
    rootClassName,
    closeIcon,
    getContainer: getContainer2,
    current = 0,
    count = 1,
    countRender,
    scaleStep = 0.5,
    minScale = 1,
    maxScale = 50,
    transitionName = "zoom",
    maskTransitionName = "fade",
    imageRender,
    imgCommonProps,
    toolbarRender,
    onTransform,
    onChange,
    ...restProps
  } = props;
  const imgRef = useRef135();
  const groupContext = useContext175(PreviewGroupContext);
  const showLeftOrRightSwitches = groupContext && count > 1;
  const showOperationsProgress = groupContext && count >= 1;
  const [enableTransition, setEnableTransition] = useState97(true);
  const { transform, resetTransform, updateTransform, dispatchZoomChange } = useImageTransform(
    imgRef,
    minScale,
    maxScale,
    onTransform
  );
  const { isMoving, onMouseDown, onWheel } = useMouseEvent(
    imgRef,
    movable,
    visible,
    scaleStep,
    transform,
    updateTransform,
    dispatchZoomChange
  );
  const { isTouching, onTouchStart, onTouchMove, onTouchEnd } = useTouchEvent(
    imgRef,
    movable,
    visible,
    minScale,
    transform,
    updateTransform,
    dispatchZoomChange
  );
  const { rotate, scale } = transform;
  const wrapClassName = (0, import_classnames179.default)({
    [`${prefixCls}-moving`]: isMoving
  });
  useEffect106(() => {
    if (!enableTransition) {
      setEnableTransition(true);
    }
  }, [enableTransition]);
  const onAfterClose = /* @__PURE__ */ __name(() => {
    resetTransform("close");
  }, "onAfterClose");
  const onZoomIn = /* @__PURE__ */ __name(() => {
    dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "zoomIn");
  }, "onZoomIn");
  const onZoomOut = /* @__PURE__ */ __name(() => {
    dispatchZoomChange(BASE_SCALE_RATIO / (BASE_SCALE_RATIO + scaleStep), "zoomOut");
  }, "onZoomOut");
  const onRotateRight = /* @__PURE__ */ __name(() => {
    updateTransform({ rotate: rotate + 90 }, "rotateRight");
  }, "onRotateRight");
  const onRotateLeft = /* @__PURE__ */ __name(() => {
    updateTransform({ rotate: rotate - 90 }, "rotateLeft");
  }, "onRotateLeft");
  const onFlipX = /* @__PURE__ */ __name(() => {
    updateTransform({ flipX: !transform.flipX }, "flipX");
  }, "onFlipX");
  const onFlipY = /* @__PURE__ */ __name(() => {
    updateTransform({ flipY: !transform.flipY }, "flipY");
  }, "onFlipY");
  const onSwitchLeft = /* @__PURE__ */ __name((event) => {
    event?.preventDefault();
    event?.stopPropagation();
    if (current > 0) {
      setEnableTransition(false);
      resetTransform("prev");
      onChange?.(current - 1, current);
    }
  }, "onSwitchLeft");
  const onSwitchRight = /* @__PURE__ */ __name((event) => {
    event?.preventDefault();
    event?.stopPropagation();
    if (current < count - 1) {
      setEnableTransition(false);
      resetTransform("next");
      onChange?.(current + 1, current);
    }
  }, "onSwitchRight");
  const onKeyDown2 = /* @__PURE__ */ __name((event) => {
    if (!visible || !showLeftOrRightSwitches)
      return;
    if (event.keyCode === KeyCode_default.LEFT) {
      onSwitchLeft();
    } else if (event.keyCode === KeyCode_default.RIGHT) {
      onSwitchRight();
    }
  }, "onKeyDown");
  const onDoubleClick = /* @__PURE__ */ __name((event) => {
    if (visible) {
      if (scale !== 1) {
        updateTransform({ x: 0, y: 0, scale: 1 }, "doubleClick");
      } else {
        dispatchZoomChange(
          BASE_SCALE_RATIO + scaleStep,
          "doubleClick",
          event.clientX,
          event.clientY
        );
      }
    }
  }, "onDoubleClick");
  useEffect106(() => {
    const onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown2, false);
    return () => {
      onKeyDownListener.remove();
    };
  }, [visible, showLeftOrRightSwitches, current]);
  const imgNode = /* @__PURE__ */ React416.createElement(
    PreviewImage,
    {
      ...imgCommonProps,
      width: props.width,
      height: props.height,
      imgRef,
      className: `${prefixCls}-img`,
      alt,
      style: {
        transform: `translate3d(${transform.x}px, ${transform.y}px, 0) scale3d(${transform.flipX ? "-" : ""}${scale}, ${transform.flipY ? "-" : ""}${scale}, 1) rotate(${rotate}deg)`,
        transitionDuration: (!enableTransition || isTouching) && "0s"
      },
      fallback,
      src,
      onWheel,
      onMouseDown,
      onDoubleClick,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }
  );
  return /* @__PURE__ */ React416.createElement(React416.Fragment, null, /* @__PURE__ */ React416.createElement(
    src_default3,
    {
      transitionName,
      maskTransitionName,
      closable: false,
      keyboard: true,
      prefixCls,
      onClose,
      visible,
      classNames: {
        wrapper: wrapClassName
      },
      rootClassName,
      getContainer: getContainer2,
      ...restProps,
      afterClose: onAfterClose
    },
    /* @__PURE__ */ React416.createElement("div", { className: `${prefixCls}-img-wrapper` }, imageRender ? imageRender(imgNode, { transform, ...groupContext ? { current } : {} }) : imgNode)
  ), /* @__PURE__ */ React416.createElement(
    Operations_default,
    {
      visible,
      transform,
      maskTransitionName,
      closeIcon,
      getContainer: getContainer2,
      prefixCls,
      rootClassName,
      icons: icons2,
      countRender,
      showSwitch: showLeftOrRightSwitches,
      showProgress: showOperationsProgress,
      current,
      count,
      scale,
      minScale,
      maxScale,
      toolbarRender,
      onSwitchLeft,
      onSwitchRight,
      onZoomIn,
      onZoomOut,
      onRotateRight,
      onRotateLeft,
      onFlipX,
      onFlipY,
      onClose,
      zIndex: restProps.zIndex !== void 0 ? restProps.zIndex + 1 : void 0
    }
  ));
}, "Preview");
var Preview_default = Preview;

// packages/image/src/PreviewGroup.tsx
import * as React418 from "react";
import { useState as useState99 } from "react";

// packages/image/src/hooks/usePreviewItems.ts
import * as React417 from "react";
function usePreviewItems(items) {
  const [images, setImages] = React417.useState({});
  const registerImage = React417.useCallback((id, data) => {
    setImages((imgs) => ({
      ...imgs,
      [id]: data
    }));
    return () => {
      setImages((imgs) => {
        const cloneImgs = { ...imgs };
        delete cloneImgs[id];
        return cloneImgs;
      });
    };
  }, []);
  const mergedItems = React417.useMemo(() => {
    if (items) {
      return items.map((item) => {
        if (typeof item === "string") {
          return { data: { src: item } };
        }
        const data = {};
        Object.keys(item).forEach((key) => {
          if (["src", ...COMMON_PROPS].includes(key)) {
            data[key] = item[key];
          }
        });
        return { data };
      });
    }
    return Object.keys(images).reduce((total, id) => {
      const { canPreview, data } = images[id];
      if (canPreview) {
        total.push({ data, id });
      }
      return total;
    }, []);
  }, [items, images]);
  return [mergedItems, registerImage];
}
__name(usePreviewItems, "usePreviewItems");

// packages/image/src/PreviewGroup.tsx
var Group3 = /* @__PURE__ */ __name(({
  previewPrefixCls = "rc-image-preview",
  children,
  icons: icons2 = {},
  items,
  preview,
  fallback
}) => {
  const {
    visible: previewVisible,
    onVisibleChange,
    getContainer: getContainer2,
    current: currentIndex,
    movable,
    minScale,
    maxScale,
    countRender,
    closeIcon,
    onChange,
    onTransform,
    toolbarRender,
    imageRender,
    ...dialogProps
  } = typeof preview === "object" ? preview : {};
  const [mergedItems, register2] = usePreviewItems(items);
  const [current, setCurrent] = useMergedState(0, {
    value: currentIndex
  });
  const [keepOpenIndex, setKeepOpenIndex] = useState99(false);
  const { src, ...imgCommonProps } = mergedItems[current]?.data || {};
  const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: (val, prevVal) => {
      onVisibleChange?.(val, prevVal, current);
    }
  });
  const [mousePosition2, setMousePosition] = useState99(null);
  const onPreviewFromImage = React418.useCallback(
    (id, mouseX, mouseY) => {
      const index3 = mergedItems.findIndex((item) => item.id === id);
      setShowPreview(true);
      setMousePosition({ x: mouseX, y: mouseY });
      setCurrent(index3 < 0 ? 0 : index3);
      setKeepOpenIndex(true);
    },
    [mergedItems]
  );
  React418.useEffect(() => {
    if (isShowPreview) {
      if (!keepOpenIndex) {
        setCurrent(0);
      }
    } else {
      setKeepOpenIndex(false);
    }
  }, [isShowPreview]);
  const onInternalChange = /* @__PURE__ */ __name((next2, prev2) => {
    setCurrent(next2);
    onChange?.(next2, prev2);
  }, "onInternalChange");
  const onPreviewClose = /* @__PURE__ */ __name(() => {
    setShowPreview(false);
    setMousePosition(null);
  }, "onPreviewClose");
  const previewGroupContext = React418.useMemo(
    () => ({ register: register2, onPreview: onPreviewFromImage }),
    [register2, onPreviewFromImage]
  );
  return /* @__PURE__ */ React418.createElement(PreviewGroupContext.Provider, { value: previewGroupContext }, children, /* @__PURE__ */ React418.createElement(
    Preview_default,
    {
      "aria-hidden": !isShowPreview,
      movable,
      visible: isShowPreview,
      prefixCls: previewPrefixCls,
      closeIcon,
      onClose: onPreviewClose,
      mousePosition: mousePosition2,
      imgCommonProps,
      src,
      fallback,
      icons: icons2,
      minScale,
      maxScale,
      getContainer: getContainer2,
      current,
      count: mergedItems.length,
      countRender,
      onTransform,
      toolbarRender,
      imageRender,
      onChange: onInternalChange,
      ...dialogProps
    }
  ));
}, "Group");
var PreviewGroup_default = Group3;

// packages/image/src/Image.tsx
var ImageInternal = /* @__PURE__ */ __name((props) => {
  const {
    src: imgSrc,
    alt,
    onPreviewClose: onInitialPreviewClose,
    prefixCls = "rc-image",
    previewPrefixCls = `${prefixCls}-preview`,
    placeholder,
    fallback,
    width,
    height,
    style: style2,
    preview = true,
    className,
    onClick,
    onError,
    wrapperClassName,
    wrapperStyle,
    rootClassName,
    ...otherProps
  } = props;
  const isCustomPlaceholder = placeholder && placeholder !== true;
  const {
    src: previewSrc,
    visible: previewVisible = void 0,
    onVisibleChange: onPreviewVisibleChange = onInitialPreviewClose,
    getContainer: getPreviewContainer = void 0,
    mask: previewMask,
    maskClassName,
    movable,
    icons: icons2,
    scaleStep,
    minScale,
    maxScale,
    imageRender,
    toolbarRender,
    ...dialogProps
  } = typeof preview === "object" ? preview : {};
  const src = previewSrc ?? imgSrc;
  const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: onPreviewVisibleChange
  });
  const [getImgRef, srcAndOnload, status] = useStatus2({
    src: imgSrc,
    isCustomPlaceholder,
    fallback
  });
  const [mousePosition2, setMousePosition] = useState100(null);
  const groupContext = useContext176(PreviewGroupContext);
  const canPreview = !!preview;
  const onPreviewClose = /* @__PURE__ */ __name(() => {
    setShowPreview(false);
    setMousePosition(null);
  }, "onPreviewClose");
  const wrapperClass = (0, import_classnames180.default)(prefixCls, wrapperClassName, rootClassName, {
    [`${prefixCls}-error`]: status === "error"
  });
  const imgCommonProps = useMemo131(
    () => {
      const obj = {};
      COMMON_PROPS.forEach((prop) => {
        if (props[prop] !== void 0) {
          obj[prop] = props[prop];
        }
      });
      return obj;
    },
    COMMON_PROPS.map((prop) => props[prop])
  );
  const registerData = useMemo131(
    () => ({
      ...imgCommonProps,
      src
    }),
    [src, imgCommonProps]
  );
  const imageId = useRegisterImage(canPreview, registerData);
  const onPreview = /* @__PURE__ */ __name((e3) => {
    const { left, top } = getOffset4(e3.target);
    if (groupContext) {
      groupContext.onPreview(imageId, left, top);
    } else {
      setMousePosition({
        x: left,
        y: top
      });
      setShowPreview(true);
    }
    onClick?.(e3);
  }, "onPreview");
  return /* @__PURE__ */ React419.createElement(React419.Fragment, null, /* @__PURE__ */ React419.createElement(
    "div",
    {
      ...otherProps,
      className: wrapperClass,
      onClick: canPreview ? onPreview : onClick,
      style: {
        width,
        height,
        ...wrapperStyle
      }
    },
    /* @__PURE__ */ React419.createElement(
      "img",
      {
        ...imgCommonProps,
        className: (0, import_classnames180.default)(
          `${prefixCls}-img`,
          {
            [`${prefixCls}-img-placeholder`]: placeholder === true
          },
          className
        ),
        style: {
          height,
          ...style2
        },
        ref: getImgRef,
        ...srcAndOnload,
        width,
        height,
        onError
      }
    ),
    status === "loading" && /* @__PURE__ */ React419.createElement("div", { "aria-hidden": "true", className: `${prefixCls}-placeholder` }, placeholder),
    previewMask && canPreview && /* @__PURE__ */ React419.createElement(
      "div",
      {
        className: (0, import_classnames180.default)(`${prefixCls}-mask`, maskClassName),
        style: {
          display: style2?.display === "none" ? "none" : void 0
        }
      },
      previewMask
    )
  ), !groupContext && canPreview && /* @__PURE__ */ React419.createElement(
    Preview_default,
    {
      "aria-hidden": !isShowPreview,
      visible: isShowPreview,
      prefixCls: previewPrefixCls,
      onClose: onPreviewClose,
      mousePosition: mousePosition2,
      src,
      alt,
      fallback,
      getContainer: getPreviewContainer,
      icons: icons2,
      movable,
      scaleStep,
      minScale,
      maxScale,
      rootClassName,
      imageRender,
      imgCommonProps,
      toolbarRender,
      ...dialogProps
    }
  ));
}, "ImageInternal");
ImageInternal.PreviewGroup = PreviewGroup_default;
ImageInternal.displayName = "Image";
var Image_default2 = ImageInternal;

// packages/image/src/index.ts
var src_default21 = Image_default2;

// packages/ant-design/components/image/PreviewGroup.tsx
var import_CloseOutlined10 = __toESM(require_CloseOutlined3());
var import_LeftOutlined3 = __toESM(require_LeftOutlined3());
var import_RightOutlined5 = __toESM(require_RightOutlined3());
var import_RotateLeftOutlined = __toESM(require_RotateLeftOutlined3());
var import_RotateRightOutlined = __toESM(require_RotateRightOutlined3());
var import_SwapOutlined = __toESM(require_SwapOutlined3());
var import_ZoomInOutlined = __toESM(require_ZoomInOutlined3());
var import_ZoomOutOutlined = __toESM(require_ZoomOutOutlined3());
var import_classnames181 = __toESM(require_classnames());
import * as React420 from "react";

// packages/ant-design/components/image/style/index.ts
init_public_api();
var genBoxStyle = /* @__PURE__ */ __name((position2) => ({
  position: position2 || "absolute",
  inset: 0
}), "genBoxStyle");
var genImageMaskStyle = /* @__PURE__ */ __name((token2) => {
  const { iconCls, motionDurationSlow, paddingXXS, marginXXS, prefixCls, colorTextLightSolid } = token2;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: colorTextLightSolid,
    background: new TinyColor("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${motionDurationSlow}`,
    [`.${prefixCls}-mask-info`]: {
      ...textEllipsis,
      padding: `0 ${unit(paddingXXS)}`,
      [iconCls]: {
        marginInlineEnd: marginXXS,
        svg: {
          verticalAlign: "baseline"
        }
      }
    }
  };
}, "genImageMaskStyle");
var genPreviewOperationsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    previewCls,
    modalMaskBg,
    paddingSM,
    marginXL,
    margin,
    paddingLG,
    previewOperationColorDisabled,
    previewOperationHoverColor,
    motionDurationSlow,
    iconCls,
    colorTextLightSolid
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-footer`]: {
      position: "fixed",
      bottom: marginXL,
      left: {
        _skip_check_: true,
        value: 0
      },
      width: "100%",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      color: token2.previewOperationColor
    },
    [`${previewCls}-progress`]: {
      marginBottom: margin
    },
    [`${previewCls}-close`]: {
      position: "fixed",
      top: marginXL,
      right: {
        _skip_check_: true,
        value: marginXL
      },
      display: "flex",
      color: colorTextLightSolid,
      backgroundColor: operationBg.toRgbString(),
      borderRadius: "50%",
      padding: paddingSM,
      outline: 0,
      border: 0,
      cursor: "pointer",
      transition: `all ${motionDurationSlow}`,
      "&:hover": {
        backgroundColor: operationBgHover.toRgbString()
      },
      [`& > ${iconCls}`]: {
        fontSize: token2.previewOperationSize
      }
    },
    [`${previewCls}-operations`]: {
      display: "flex",
      alignItems: "center",
      padding: `0 ${unit(paddingLG)}`,
      backgroundColor: operationBg.toRgbString(),
      borderRadius: 100,
      "&-operation": {
        marginInlineStart: paddingSM,
        padding: paddingSM,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        userSelect: "none",
        [`&:not(${previewCls}-operations-operation-disabled):hover > ${iconCls}`]: {
          color: previewOperationHoverColor
        },
        "&-disabled": {
          color: previewOperationColorDisabled,
          cursor: "not-allowed"
        },
        "&:first-of-type": {
          marginInlineStart: 0
        },
        [`& > ${iconCls}`]: {
          fontSize: token2.previewOperationSize
        }
      }
    }
  };
}, "genPreviewOperationsStyle");
var genPreviewSwitchStyle = /* @__PURE__ */ __name((token2) => {
  const {
    modalMaskBg,
    iconCls,
    previewOperationColorDisabled,
    previewCls,
    zIndexPopup,
    motionDurationSlow
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-switch-left, ${previewCls}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: token2.calc(zIndexPopup).add(1).equal({ unit: false }),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: token2.imagePreviewSwitchSize,
      height: token2.imagePreviewSwitchSize,
      marginTop: token2.calc(token2.imagePreviewSwitchSize).mul(-1).div(2).equal(),
      color: token2.previewOperationColor,
      background: operationBg.toRgbString(),
      borderRadius: "50%",
      transform: `translateY(-50%)`,
      cursor: "pointer",
      transition: `all ${motionDurationSlow}`,
      userSelect: "none",
      "&:hover": {
        background: operationBgHover.toRgbString()
      },
      [`&-disabled`]: {
        "&, &:hover": {
          color: previewOperationColorDisabled,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${iconCls}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${iconCls}`]: {
        fontSize: token2.previewOperationSize
      }
    },
    [`${previewCls}-switch-left`]: {
      insetInlineStart: token2.marginSM
    },
    [`${previewCls}-switch-right`]: {
      insetInlineEnd: token2.marginSM
    }
  };
}, "genPreviewSwitchStyle");
var genImagePreviewStyle = /* @__PURE__ */ __name((token2) => {
  const { motionEaseOut, previewCls, motionDurationSlow, componentCls } = token2;
  return [
    {
      [`${componentCls}-preview-root`]: {
        [previewCls]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${previewCls}-body`]: {
          ...genBoxStyle(),
          overflow: "hidden"
        },
        [`${previewCls}-img`]: {
          maxWidth: "100%",
          maxHeight: "70%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
          userSelect: "none",
          "&-wrapper": {
            ...genBoxStyle(),
            transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "& > *": {
              pointerEvents: "auto"
            },
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          }
        },
        [`${previewCls}-moving`]: {
          [`${previewCls}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${componentCls}-preview-root`]: {
        [`${previewCls}-wrap`]: {
          zIndex: token2.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${componentCls}-preview-operations-wrapper`]: {
        position: "fixed",
        zIndex: token2.calc(token2.zIndexPopup).add(1).equal({ unit: false })
      },
      "&": [genPreviewOperationsStyle(token2), genPreviewSwitchStyle(token2)]
    }
  ];
}, "genImagePreviewStyle");
var genImageStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    // ============================== image ==============================
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-mask`]: {
        ...genImageMaskStyle(token2)
      },
      [`${componentCls}-mask:hover`]: {
        opacity: 1
      },
      [`${componentCls}-placeholder`]: {
        ...genBoxStyle()
      }
    }
  };
}, "genImageStyle");
var genPreviewMotion = /* @__PURE__ */ __name((token2) => {
  const { previewCls } = token2;
  return {
    [`${previewCls}-root`]: initZoomMotion(token2, "zoom"),
    [`&`]: initFadeMotion(token2, true)
  };
}, "genPreviewMotion");
var prepareComponentToken34 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 80,
  previewOperationColor: new TinyColor(token2.colorTextLightSolid).setAlpha(0.65).toRgbString(),
  previewOperationHoverColor: new TinyColor(token2.colorTextLightSolid).setAlpha(0.85).toRgbString(),
  previewOperationColorDisabled: new TinyColor(token2.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: token2.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
}), "prepareComponentToken");
var style_default40 = genStyleHooks(
  "Image",
  (token2) => {
    const previewCls = `${token2.componentCls}-preview`;
    const imageToken = merge2(token2, {
      previewCls,
      modalMaskBg: new TinyColor("#000").setAlpha(0.45).toRgbString(),
      // FIXME: Shared Token
      imagePreviewSwitchSize: token2.controlHeightLG
    });
    return [
      genImageStyle(imageToken),
      genImagePreviewStyle(imageToken),
      genModalMaskStyle(merge2(imageToken, { componentCls: previewCls })),
      genPreviewMotion(imageToken)
    ];
  },
  prepareComponentToken34
);

// packages/ant-design/components/image/PreviewGroup.tsx
var icons = {
  rotateLeft: /* @__PURE__ */ React420.createElement(import_RotateLeftOutlined.default, null),
  rotateRight: /* @__PURE__ */ React420.createElement(import_RotateRightOutlined.default, null),
  zoomIn: /* @__PURE__ */ React420.createElement(import_ZoomInOutlined.default, null),
  zoomOut: /* @__PURE__ */ React420.createElement(import_ZoomOutOutlined.default, null),
  close: /* @__PURE__ */ React420.createElement(import_CloseOutlined10.default, null),
  left: /* @__PURE__ */ React420.createElement(import_LeftOutlined3.default, null),
  right: /* @__PURE__ */ React420.createElement(import_RightOutlined5.default, null),
  flipX: /* @__PURE__ */ React420.createElement(import_SwapOutlined.default, null),
  flipY: /* @__PURE__ */ React420.createElement(import_SwapOutlined.default, { rotate: 90 })
};
var InternalPreviewGroup = /* @__PURE__ */ __name(({
  previewPrefixCls: customizePrefixCls,
  preview,
  ...otherProps
}) => {
  const { getPrefixCls } = React420.useContext(ConfigContext);
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const previewPrefixCls = `${prefixCls}-preview`;
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default40(prefixCls, rootCls);
  const [zIndex] = useZIndex(
    "ImagePreview",
    typeof preview === "object" ? preview.zIndex : void 0
  );
  const mergedPreview = React420.useMemo(() => {
    if (preview === false) {
      return preview;
    }
    const _preview = typeof preview === "object" ? preview : {};
    const mergedRootClassName = (0, import_classnames181.default)(
      hashId,
      cssVarCls,
      rootCls,
      _preview.rootClassName ?? ""
    );
    return {
      ..._preview,
      transitionName: getTransitionName2(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName2(rootPrefixCls, "fade", _preview.maskTransitionName),
      rootClassName: mergedRootClassName,
      zIndex
    };
  }, [preview]);
  return wrapCSSVar(
    /* @__PURE__ */ React420.createElement(
      src_default21.PreviewGroup,
      {
        preview: mergedPreview,
        previewPrefixCls,
        icons,
        ...otherProps
      }
    )
  );
}, "InternalPreviewGroup");
var PreviewGroup_default2 = InternalPreviewGroup;

// packages/ant-design/components/image/index.tsx
var Image2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    preview,
    className,
    rootClassName,
    style: style2,
    ...otherProps
  } = props;
  const {
    getPrefixCls,
    locale: contextLocale = en_US_default6,
    getPopupContainer: getContextPopupContainer,
    image
  } = React421.useContext(ConfigContext);
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const imageLocale = contextLocale.Image || en_US_default6.Image;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default40(prefixCls, rootCls);
  const mergedRootClassName = (0, import_classnames182.default)(rootClassName, hashId, cssVarCls, rootCls);
  const mergedClassName = (0, import_classnames182.default)(className, hashId, image?.className);
  const [zIndex] = useZIndex(
    "ImagePreview",
    typeof preview === "object" ? preview.zIndex : void 0
  );
  const mergedPreview = React421.useMemo(() => {
    if (preview === false) {
      return preview;
    }
    const _preview = typeof preview === "object" ? preview : {};
    const { getContainer: getContainer2, closeIcon, ...restPreviewProps } = _preview;
    return {
      mask: /* @__PURE__ */ React421.createElement("div", { className: `${prefixCls}-mask-info` }, /* @__PURE__ */ React421.createElement(import_EyeOutlined2.default, null), imageLocale?.preview),
      icons,
      ...restPreviewProps,
      getContainer: getContainer2 ?? getContextPopupContainer,
      transitionName: getTransitionName2(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName2(rootPrefixCls, "fade", _preview.maskTransitionName),
      zIndex,
      closeIcon: closeIcon ?? image?.preview?.closeIcon
    };
  }, [preview, imageLocale, image?.preview?.closeIcon]);
  const mergedStyle = { ...image?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React421.createElement(
      src_default21,
      {
        prefixCls,
        preview: mergedPreview,
        rootClassName: mergedRootClassName,
        className: mergedClassName,
        style: mergedStyle,
        ...otherProps
      }
    )
  );
}, "Image");
Image2.PreviewGroup = PreviewGroup_default2;
if (true) {
  Image2.displayName = "Image";
}
var image_default = Image2;

// packages/ant-design/components/layout/layout.tsx
var import_classnames183 = __toESM(require_classnames());
import * as React422 from "react";

// packages/ant-design/components/layout/hooks/useHasSider.ts
function useHasSider(siders, children, hasSider) {
  if (typeof hasSider === "boolean") {
    return hasSider;
  }
  if (siders.length) {
    return true;
  }
  const childNodes = toArray(children);
  return childNodes.some((node2) => node2.type === Sider_default);
}
__name(useHasSider, "useHasSider");

// packages/ant-design/components/layout/style/light.ts
var genLayoutLightStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, bodyBg, lightSiderBg, lightTriggerBg, lightTriggerColor } = token2;
  return {
    [`${componentCls}-sider-light`]: {
      background: lightSiderBg,
      [`${componentCls}-sider-trigger`]: {
        color: lightTriggerColor,
        background: lightTriggerBg
      },
      [`${componentCls}-sider-zero-width-trigger`]: {
        color: lightTriggerColor,
        background: lightTriggerBg,
        border: `1px solid ${bodyBg}`,
        // Safe to modify to any other color
        borderInlineStart: 0
      }
    }
  };
}, "genLayoutLightStyle");
var light_default = genLayoutLightStyle;

// packages/ant-design/components/layout/style/index.ts
var genLayoutStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    triggerColor,
    footerBg,
    triggerBg,
    headerHeight,
    headerPadding,
    headerColor,
    footerPadding,
    triggerHeight,
    zeroTriggerHeight,
    zeroTriggerWidth,
    motionDurationMid,
    motionDurationSlow,
    fontSize,
    borderRadius,
    bodyBg,
    headerBg,
    siderBg
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: bodyBg,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      [`${componentCls}-sider`]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: siderBg,
        transition: `all ${motionDurationMid}, background 0s`,
        "&-children": {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: triggerHeight
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: triggerHeight,
          color: triggerColor,
          lineHeight: unit(triggerHeight),
          textAlign: "center",
          background: triggerBg,
          cursor: "pointer",
          transition: `all ${motionDurationMid}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: headerHeight,
            insetInlineEnd: token2.calc(zeroTriggerWidth).mul(-1).equal(),
            zIndex: 1,
            width: zeroTriggerWidth,
            height: zeroTriggerHeight,
            color: triggerColor,
            fontSize: token2.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: siderBg,
            borderStartStartRadius: 0,
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${motionDurationSlow}`,
              content: '""'
            },
            "&:hover::after": {
              background: `rgba(255, 255, 255, 0.2)`
            },
            "&-right": {
              insetInlineStart: token2.calc(zeroTriggerWidth).mul(-1).equal(),
              borderStartStartRadius: borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: borderRadius
            }
          }
        }
      },
      // Light
      ...light_default(token2),
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // ==================== Header ====================
    [`${componentCls}-header`]: {
      height: headerHeight,
      padding: headerPadding,
      color: headerColor,
      lineHeight: unit(headerHeight),
      background: headerBg,
      // Other components/menu/style/index.less line:686
      // Integration with header element so menu items have the same height
      [`${antCls}-menu`]: {
        lineHeight: "inherit"
      }
    },
    // ==================== Footer ====================
    [`${componentCls}-footer`]: {
      padding: footerPadding,
      color: colorText,
      fontSize,
      background: footerBg
    },
    // =================== Content ====================
    [`${componentCls}-content`]: {
      flex: "auto",
      color: colorText,
      // fix firefox can't set height smaller than content on flex item
      minHeight: 0
    }
  };
}, "genLayoutStyle");
var prepareComponentToken35 = /* @__PURE__ */ __name((token2) => {
  const {
    colorBgLayout,
    controlHeight,
    controlHeightLG,
    colorText,
    controlHeightSM,
    marginXXS,
    colorTextLightSolid,
    colorBgContainer
  } = token2;
  const paddingInline = controlHeightLG * 1.25;
  return {
    // Deprecated
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140",
    bodyBg: colorBgLayout,
    headerBg: "#001529",
    headerHeight: controlHeight * 2,
    headerPadding: `0 ${paddingInline}px`,
    headerColor: colorText,
    footerPadding: `${controlHeightSM}px ${paddingInline}px`,
    footerBg: colorBgLayout,
    siderBg: "#001529",
    triggerHeight: controlHeightLG + marginXXS * 2,
    triggerBg: "#002140",
    triggerColor: colorTextLightSolid,
    zeroTriggerWidth: controlHeightLG,
    zeroTriggerHeight: controlHeightLG,
    lightSiderBg: colorBgContainer,
    lightTriggerBg: colorBgContainer,
    lightTriggerColor: colorText
  };
}, "prepareComponentToken");
var style_default41 = genStyleHooks("Layout", (token2) => [genLayoutStyle(token2)], prepareComponentToken35, {
  deprecatedTokens: [
    ["colorBgBody", "bodyBg"],
    ["colorBgHeader", "headerBg"],
    ["colorBgTrigger", "triggerBg"]
  ]
});

// packages/ant-design/components/layout/layout.tsx
function generator({ suffixCls, tagName, displayName }) {
  return (BasicComponent) => {
    const Adapter = React422.forwardRef((props, ref) => /* @__PURE__ */ React422.createElement(BasicComponent, { ref, suffixCls, tagName, ...props }));
    if (true) {
      Adapter.displayName = displayName;
    }
    return Adapter;
  };
}
__name(generator, "generator");
var Basic = React422.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    suffixCls,
    className,
    tagName: TagName,
    ...others
  } = props;
  const { getPrefixCls } = React422.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const [wrapSSR, hashId, cssVarCls] = style_default41(prefixCls);
  const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
  return wrapSSR(
    /* @__PURE__ */ React422.createElement(
      TagName,
      {
        className: (0, import_classnames183.default)(
          customizePrefixCls || prefixWithSuffixCls,
          className,
          hashId,
          cssVarCls
        ),
        ref,
        ...others
      }
    )
  );
});
var BasicLayout = React422.forwardRef((props, ref) => {
  const { direction } = React422.useContext(ConfigContext);
  const [siders, setSiders] = React422.useState([]);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    hasSider,
    tagName: Tag2,
    style: style2,
    ...others
  } = props;
  const passedProps = omit(others, ["suffixCls"]);
  const { getPrefixCls, layout } = React422.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const mergedHasSider = useHasSider(siders, children, hasSider);
  const [wrapCSSVar, hashId, cssVarCls] = style_default41(prefixCls);
  const classString = (0, import_classnames183.default)(
    prefixCls,
    {
      [`${prefixCls}-has-sider`]: mergedHasSider,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    layout?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const contextValue = React422.useMemo(
    () => ({
      siderHook: {
        addSider: (id) => {
          setSiders((prev2) => [...prev2, id]);
        },
        removeSider: (id) => {
          setSiders((prev2) => prev2.filter((currentId) => currentId !== id));
        }
      }
    }),
    []
  );
  return wrapCSSVar(
    /* @__PURE__ */ React422.createElement(LayoutContext.Provider, { value: contextValue }, /* @__PURE__ */ React422.createElement(
      Tag2,
      {
        ref,
        className: classString,
        style: { ...layout?.style, ...style2 },
        ...passedProps
      },
      children
    ))
  );
});
var Layout = generator({
  tagName: "div",
  displayName: "Layout"
})(BasicLayout);
var Header = generator({
  suffixCls: "header",
  tagName: "header",
  displayName: "Header"
})(Basic);
var Footer3 = generator({
  suffixCls: "footer",
  tagName: "footer",
  displayName: "Footer"
})(Basic);
var Content2 = generator({
  suffixCls: "content",
  tagName: "main",
  displayName: "Content"
})(Basic);
var layout_default = Layout;

// packages/ant-design/components/layout/index.ts
var Layout2 = layout_default;
Layout2.Header = Header;
Layout2.Footer = Footer3;
Layout2.Content = Content2;
Layout2.Sider = Sider_default;
Layout2._InternalSiderContext = SiderContext;
var layout_default2 = Layout2;

// packages/ant-design/components/list/index.tsx
var import_classnames189 = __toESM(require_classnames());
import * as React431 from "react";

// packages/ant-design/components/_util/extendsObject.ts
var extendsObject = /* @__PURE__ */ __name((...list) => {
  const result = { ...list[0] };
  for (let i = 1; i < list.length; i++) {
    const obj = list[i];
    if (obj) {
      Object.keys(obj).forEach((key) => {
        const val = obj[key];
        if (val !== void 0) {
          result[key] = val;
        }
      });
    }
  }
  return result;
}, "extendsObject");
var extendsObject_default = extendsObject;

// packages/ant-design/components/pagination/Pagination.tsx
var import_DoubleLeftOutlined = __toESM(require_DoubleLeftOutlined3());
var import_DoubleRightOutlined = __toESM(require_DoubleRightOutlined3());
var import_LeftOutlined4 = __toESM(require_LeftOutlined3());
var import_RightOutlined6 = __toESM(require_RightOutlined3());
var import_classnames186 = __toESM(require_classnames());
import * as React427 from "react";

// packages/pagination/src/Pagination.tsx
var import_classnames185 = __toESM(require_classnames());
init_warning();
import React425, { useEffect as useEffect108 } from "react";

// packages/pagination/src/locale/zh_CN.ts
var locale5 = {
  // Options
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  // Pagination
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875",
  page_size: "\u9875\u7801"
};
var zh_CN_default = locale5;

// packages/pagination/src/Options.tsx
import React423 from "react";
var defaultPageSizeOptions = ["10", "20", "50", "100"];
var Options = /* @__PURE__ */ __name((props) => {
  const {
    pageSizeOptions = defaultPageSizeOptions,
    locale: locale6,
    changeSize,
    pageSize,
    goButton,
    quickGo,
    rootPrefixCls,
    selectComponentClass: Select3,
    selectPrefixCls,
    disabled,
    buildOptionText
  } = props;
  const [goInputText, setGoInputText] = React423.useState("");
  const getValidValue = /* @__PURE__ */ __name(() => {
    return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
  }, "getValidValue");
  const mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : (value) => `${value} ${locale6.items_per_page}`;
  const changeSizeHandle = /* @__PURE__ */ __name((value) => {
    changeSize?.(Number(value));
  }, "changeSizeHandle");
  const handleChange = /* @__PURE__ */ __name((e3) => {
    setGoInputText(e3.target.value);
  }, "handleChange");
  const handleBlur = /* @__PURE__ */ __name((e3) => {
    if (goButton || goInputText === "") {
      return;
    }
    setGoInputText("");
    if (e3.relatedTarget && (e3.relatedTarget.className.indexOf(`${rootPrefixCls}-item-link`) >= 0 || e3.relatedTarget.className.indexOf(`${rootPrefixCls}-item`) >= 0)) {
      return;
    }
    quickGo?.(getValidValue());
  }, "handleBlur");
  const go = /* @__PURE__ */ __name((e3) => {
    if (goInputText === "") {
      return;
    }
    if (e3.keyCode === KeyCode_default.ENTER || e3.type === "click") {
      setGoInputText("");
      quickGo?.(getValidValue());
    }
  }, "go");
  const getPageSizeOptions = /* @__PURE__ */ __name(() => {
    if (pageSizeOptions.some(
      (option) => option.toString() === pageSize.toString()
    )) {
      return pageSizeOptions;
    }
    return pageSizeOptions.concat([pageSize.toString()]).sort((a, b) => {
      const numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
      const numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
      return numberA - numberB;
    });
  }, "getPageSizeOptions");
  const prefixCls = `${rootPrefixCls}-options`;
  if (!changeSize && !quickGo) {
    return null;
  }
  let changeSelect = null;
  let goInput = null;
  let gotoButton = null;
  if (changeSize && Select3) {
    const options = getPageSizeOptions().map((opt, i) => /* @__PURE__ */ React423.createElement(Select3.Option, { key: i, value: opt.toString() }, mergeBuildOptionText(opt)));
    changeSelect = /* @__PURE__ */ React423.createElement(
      Select3,
      {
        disabled,
        prefixCls: selectPrefixCls,
        showSearch: false,
        className: `${prefixCls}-size-changer`,
        optionLabelProp: "children",
        popupMatchSelectWidth: false,
        value: (pageSize || pageSizeOptions[0]).toString(),
        onChange: changeSizeHandle,
        getPopupContainer: (triggerNode) => triggerNode.parentNode,
        "aria-label": locale6.page_size,
        defaultOpen: false
      },
      options
    );
  }
  if (quickGo) {
    if (goButton) {
      gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React423.createElement(
        "button",
        {
          type: "button",
          onClick: go,
          onKeyUp: go,
          disabled,
          className: `${prefixCls}-quick-jumper-button`
        },
        locale6.jump_to_confirm
      ) : /* @__PURE__ */ React423.createElement("span", { onClick: go, onKeyUp: go }, goButton);
    }
    goInput = /* @__PURE__ */ React423.createElement("div", { className: `${prefixCls}-quick-jumper` }, locale6.jump_to, /* @__PURE__ */ React423.createElement(
      "input",
      {
        disabled,
        type: "text",
        value: goInputText,
        onChange: handleChange,
        onKeyUp: go,
        onBlur: handleBlur,
        "aria-label": locale6.page
      }
    ), locale6.page, gotoButton);
  }
  return /* @__PURE__ */ React423.createElement("li", { className: prefixCls }, changeSelect, goInput);
}, "Options");
if (true) {
  Options.displayName = "Options";
}
var Options_default = Options;

// packages/pagination/src/Pager.tsx
var import_classnames184 = __toESM(require_classnames());
import React424 from "react";
var Pager = /* @__PURE__ */ __name((props) => {
  const {
    rootPrefixCls,
    page,
    active,
    className,
    showTitle,
    onClick,
    onKeyPress,
    itemRender
  } = props;
  const prefixCls = `${rootPrefixCls}-item`;
  const cls5 = (0, import_classnames184.default)(
    prefixCls,
    `${prefixCls}-${page}`,
    {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-disabled`]: !page
    },
    className
  );
  const handleClick = /* @__PURE__ */ __name(() => {
    onClick(page);
  }, "handleClick");
  const handleKeyPress = /* @__PURE__ */ __name((e3) => {
    onKeyPress(e3, onClick, page);
  }, "handleKeyPress");
  const pager = itemRender(page, "page", /* @__PURE__ */ React424.createElement("a", { rel: "nofollow" }, page));
  return pager ? /* @__PURE__ */ React424.createElement(
    "li",
    {
      title: showTitle ? String(page) : null,
      className: cls5,
      onClick: handleClick,
      onKeyDown: handleKeyPress,
      tabIndex: 0
    },
    pager
  ) : null;
}, "Pager");
if (true) {
  Pager.displayName = "Pager";
}
var Pager_default = Pager;

// packages/pagination/src/Pagination.tsx
var defaultItemRender = /* @__PURE__ */ __name((page, type5, element) => element, "defaultItemRender");
function noop4() {
}
__name(noop4, "noop");
function isInteger(v) {
  const value = Number(v);
  return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
__name(isInteger, "isInteger");
function calculatePage(p, pageSize, total) {
  const _pageSize = typeof p === "undefined" ? pageSize : p;
  return Math.floor((total - 1) / _pageSize) + 1;
}
__name(calculatePage, "calculatePage");
var Pagination = /* @__PURE__ */ __name((props) => {
  const {
    // cls
    prefixCls = "rc-pagination",
    selectPrefixCls = "rc-select",
    className,
    selectComponentClass,
    // control
    current: currentProp,
    defaultCurrent = 1,
    total = 0,
    pageSize: pageSizeProp,
    defaultPageSize = 10,
    onChange = noop4,
    // config
    hideOnSinglePage,
    showPrevNextJumpers = true,
    showQuickJumper,
    showLessItems,
    showTitle = true,
    onShowSizeChange = noop4,
    locale: locale6 = zh_CN_default,
    style: style2,
    totalBoundaryShowSizeChanger = 50,
    disabled,
    simple,
    showTotal,
    showSizeChanger: showSizeChangerProp,
    pageSizeOptions,
    // render
    itemRender = defaultItemRender,
    jumpPrevIcon,
    jumpNextIcon,
    prevIcon,
    nextIcon
  } = props;
  const paginationRef = React425.useRef(null);
  const [pageSize, setPageSize] = useMergedState(10, {
    value: pageSizeProp,
    defaultValue: defaultPageSize
  });
  const [current, setCurrent] = useMergedState(1, {
    value: currentProp,
    defaultValue: defaultCurrent,
    postState: (c) => Math.max(1, Math.min(c, calculatePage(void 0, pageSize, total)))
  });
  const [internalInputVal, setInternalInputVal] = React425.useState(current);
  useEffect108(() => {
    setInternalInputVal(current);
  }, [current]);
  const hasOnChange = onChange !== noop4;
  const hasCurrent = "current" in props;
  if (true) {
    warning_default(
      hasCurrent ? hasOnChange : true,
      "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component."
    );
  }
  const jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
  const jumpNextPage = Math.min(
    calculatePage(void 0, pageSize, total),
    current + (showLessItems ? 3 : 5)
  );
  function getItemIcon(icon, label) {
    let iconNode = icon || /* @__PURE__ */ React425.createElement(
      "button",
      {
        type: "button",
        "aria-label": label,
        className: `${prefixCls}-item-link`
      }
    );
    if (typeof icon === "function") {
      iconNode = React425.createElement(icon, { ...props });
    }
    return iconNode;
  }
  __name(getItemIcon, "getItemIcon");
  function getValidValue(e3) {
    const inputValue = e3.target.value;
    const allPages2 = calculatePage(void 0, pageSize, total);
    let value;
    if (inputValue === "") {
      value = inputValue;
    } else if (Number.isNaN(Number(inputValue))) {
      value = internalInputVal;
    } else if (inputValue >= allPages2) {
      value = allPages2;
    } else {
      value = Number(inputValue);
    }
    return value;
  }
  __name(getValidValue, "getValidValue");
  function isValid(page) {
    return isInteger(page) && page !== current && isInteger(total) && total > 0;
  }
  __name(isValid, "isValid");
  const shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
  function handleKeyDown(event) {
    if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) {
      event.preventDefault();
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleKeyUp(event) {
    const value = getValidValue(event);
    if (value !== internalInputVal) {
      setInternalInputVal(value);
    }
    switch (event.keyCode) {
      case KeyCode_default.ENTER:
        handleChange(value);
        break;
      case KeyCode_default.UP:
        handleChange(value - 1);
        break;
      case KeyCode_default.DOWN:
        handleChange(value + 1);
        break;
      default:
        break;
    }
  }
  __name(handleKeyUp, "handleKeyUp");
  function handleBlur(event) {
    handleChange(getValidValue(event));
  }
  __name(handleBlur, "handleBlur");
  function changePageSize(size) {
    const newCurrent = calculatePage(size, pageSize, total);
    const nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
    setPageSize(size);
    setInternalInputVal(nextCurrent);
    onShowSizeChange?.(current, size);
    setCurrent(nextCurrent);
    onChange?.(nextCurrent, size);
  }
  __name(changePageSize, "changePageSize");
  function handleChange(page) {
    if (isValid(page) && !disabled) {
      const currentPage = calculatePage(void 0, pageSize, total);
      let newPage = page;
      if (page > currentPage) {
        newPage = currentPage;
      } else if (page < 1) {
        newPage = 1;
      }
      if (newPage !== internalInputVal) {
        setInternalInputVal(newPage);
      }
      setCurrent(newPage);
      onChange?.(newPage, pageSize);
      return newPage;
    }
    return current;
  }
  __name(handleChange, "handleChange");
  const hasPrev = current > 1;
  const hasNext = current < calculatePage(void 0, pageSize, total);
  const showSizeChanger = showSizeChangerProp ?? total > totalBoundaryShowSizeChanger;
  function prevHandle() {
    if (hasPrev)
      handleChange(current - 1);
  }
  __name(prevHandle, "prevHandle");
  function nextHandle() {
    if (hasNext)
      handleChange(current + 1);
  }
  __name(nextHandle, "nextHandle");
  function jumpPrevHandle() {
    handleChange(jumpPrevPage);
  }
  __name(jumpPrevHandle, "jumpPrevHandle");
  function jumpNextHandle() {
    handleChange(jumpNextPage);
  }
  __name(jumpNextHandle, "jumpNextHandle");
  function runIfEnter(event, callback, ...restParams) {
    if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) {
      callback(...restParams);
    }
  }
  __name(runIfEnter, "runIfEnter");
  function runIfEnterPrev(event) {
    runIfEnter(event, prevHandle);
  }
  __name(runIfEnterPrev, "runIfEnterPrev");
  function runIfEnterNext(event) {
    runIfEnter(event, nextHandle);
  }
  __name(runIfEnterNext, "runIfEnterNext");
  function runIfEnterJumpPrev(event) {
    runIfEnter(event, jumpPrevHandle);
  }
  __name(runIfEnterJumpPrev, "runIfEnterJumpPrev");
  function runIfEnterJumpNext(event) {
    runIfEnter(event, jumpNextHandle);
  }
  __name(runIfEnterJumpNext, "runIfEnterJumpNext");
  function renderPrev(prevPage2) {
    const prevButton = itemRender(
      prevPage2,
      "prev",
      getItemIcon(prevIcon, "prev page")
    );
    return React425.isValidElement(prevButton) ? React425.cloneElement(prevButton, { disabled: !hasPrev }) : prevButton;
  }
  __name(renderPrev, "renderPrev");
  function renderNext(nextPage2) {
    const nextButton = itemRender(
      nextPage2,
      "next",
      getItemIcon(nextIcon, "next page")
    );
    return React425.isValidElement(nextButton) ? React425.cloneElement(nextButton, { disabled: !hasNext }) : nextButton;
  }
  __name(renderNext, "renderNext");
  function handleGoTO(event) {
    if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) {
      handleChange(internalInputVal);
    }
  }
  __name(handleGoTO, "handleGoTO");
  let jumpPrev = null;
  const dataOrAriaAttributeProps = pickAttrs(props, {
    aria: true,
    data: true
  });
  const totalText = showTotal && /* @__PURE__ */ React425.createElement("li", { className: `${prefixCls}-total-text` }, showTotal(total, [
    total === 0 ? 0 : (current - 1) * pageSize + 1,
    current * pageSize > total ? total : current * pageSize
  ]));
  let jumpNext = null;
  const allPages = calculatePage(void 0, pageSize, total);
  if (hideOnSinglePage && total <= pageSize) {
    return null;
  }
  const pagerList = [];
  const pagerProps = {
    rootPrefixCls: prefixCls,
    onClick: handleChange,
    onKeyPress: runIfEnter,
    showTitle,
    itemRender,
    page: -1
  };
  const prevPage = current - 1 > 0 ? current - 1 : 0;
  const nextPage = current + 1 < allPages ? current + 1 : allPages;
  const goButton = showQuickJumper && showQuickJumper.goButton;
  let gotoButton = goButton;
  let simplePager = null;
  if (simple) {
    if (goButton) {
      if (typeof goButton === "boolean") {
        gotoButton = /* @__PURE__ */ React425.createElement("button", { type: "button", onClick: handleGoTO, onKeyUp: handleGoTO }, locale6.jump_to_confirm);
      } else {
        gotoButton = /* @__PURE__ */ React425.createElement("span", { onClick: handleGoTO, onKeyUp: handleGoTO }, goButton);
      }
      gotoButton = /* @__PURE__ */ React425.createElement(
        "li",
        {
          title: showTitle ? `${locale6.jump_to}${current}/${allPages}` : null,
          className: `${prefixCls}-simple-pager`
        },
        gotoButton
      );
    }
    simplePager = /* @__PURE__ */ React425.createElement(
      "li",
      {
        title: showTitle ? `${current}/${allPages}` : null,
        className: `${prefixCls}-simple-pager`
      },
      /* @__PURE__ */ React425.createElement(
        "input",
        {
          type: "text",
          value: internalInputVal,
          disabled,
          onKeyDown: handleKeyDown,
          onKeyUp: handleKeyUp,
          onChange: handleKeyUp,
          onBlur: handleBlur,
          size: 3
        }
      ),
      /* @__PURE__ */ React425.createElement("span", { className: `${prefixCls}-slash` }, "/"),
      allPages
    );
  }
  const pageBufferSize = showLessItems ? 1 : 2;
  if (allPages <= 3 + pageBufferSize * 2) {
    if (!allPages) {
      pagerList.push(
        /* @__PURE__ */ React425.createElement(
          Pager_default,
          {
            ...pagerProps,
            key: "noPager",
            page: 1,
            className: `${prefixCls}-item-disabled`
          }
        )
      );
    }
    for (let i = 1; i <= allPages; i += 1) {
      pagerList.push(
        /* @__PURE__ */ React425.createElement(Pager_default, { ...pagerProps, key: i, page: i, active: current === i })
      );
    }
  } else {
    const prevItemTitle = showLessItems ? locale6.prev_3 : locale6.prev_5;
    const nextItemTitle = showLessItems ? locale6.next_3 : locale6.next_5;
    const jumpPrevContent = itemRender(
      jumpPrevPage,
      "jump-prev",
      getItemIcon(jumpPrevIcon, "prev page")
    );
    const jumpNextContent = itemRender(
      jumpNextPage,
      "jump-next",
      getItemIcon(jumpNextIcon, "next page")
    );
    if (showPrevNextJumpers) {
      jumpPrev = jumpPrevContent ? /* @__PURE__ */ React425.createElement(
        "li",
        {
          title: showTitle ? prevItemTitle : null,
          key: "prev",
          onClick: jumpPrevHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpPrev,
          className: (0, import_classnames185.default)(`${prefixCls}-jump-prev`, {
            [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
          })
        },
        jumpPrevContent
      ) : null;
      jumpNext = jumpNextContent ? /* @__PURE__ */ React425.createElement(
        "li",
        {
          title: showTitle ? nextItemTitle : null,
          key: "next",
          onClick: jumpNextHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpNext,
          className: (0, import_classnames185.default)(`${prefixCls}-jump-next`, {
            [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
          })
        },
        jumpNextContent
      ) : null;
    }
    let left = Math.max(1, current - pageBufferSize);
    let right = Math.min(current + pageBufferSize, allPages);
    if (current - 1 <= pageBufferSize) {
      right = 1 + pageBufferSize * 2;
    }
    if (allPages - current <= pageBufferSize) {
      left = allPages - pageBufferSize * 2;
    }
    for (let i = left; i <= right; i += 1) {
      pagerList.push(
        /* @__PURE__ */ React425.createElement(Pager_default, { ...pagerProps, key: i, page: i, active: current === i })
      );
    }
    if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
      pagerList[0] = React425.cloneElement(pagerList[0], {
        className: (0, import_classnames185.default)(
          `${prefixCls}-item-after-jump-prev`,
          pagerList[0].props.className
        )
      });
      pagerList.unshift(jumpPrev);
    }
    if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
      const lastOne = pagerList[pagerList.length - 1];
      pagerList[pagerList.length - 1] = React425.cloneElement(lastOne, {
        className: (0, import_classnames185.default)(
          `${prefixCls}-item-before-jump-next`,
          lastOne.props.className
        )
      });
      pagerList.push(jumpNext);
    }
    if (left !== 1) {
      pagerList.unshift(/* @__PURE__ */ React425.createElement(Pager_default, { ...pagerProps, key: 1, page: 1 }));
    }
    if (right !== allPages) {
      pagerList.push(/* @__PURE__ */ React425.createElement(Pager_default, { ...pagerProps, key: allPages, page: allPages }));
    }
  }
  let prev2 = renderPrev(prevPage);
  if (prev2) {
    const prevDisabled = !hasPrev || !allPages;
    prev2 = /* @__PURE__ */ React425.createElement(
      "li",
      {
        title: showTitle ? locale6.prev_page : null,
        onClick: prevHandle,
        tabIndex: prevDisabled ? null : 0,
        onKeyDown: runIfEnterPrev,
        className: (0, import_classnames185.default)(`${prefixCls}-prev`, {
          [`${prefixCls}-disabled`]: prevDisabled
        }),
        "aria-disabled": prevDisabled
      },
      prev2
    );
  }
  let next2 = renderNext(nextPage);
  if (next2) {
    let nextDisabled, nextTabIndex;
    if (simple) {
      nextDisabled = !hasNext;
      nextTabIndex = hasPrev ? 0 : null;
    } else {
      nextDisabled = !hasNext || !allPages;
      nextTabIndex = nextDisabled ? null : 0;
    }
    next2 = /* @__PURE__ */ React425.createElement(
      "li",
      {
        title: showTitle ? locale6.next_page : null,
        onClick: nextHandle,
        tabIndex: nextTabIndex,
        onKeyDown: runIfEnterNext,
        className: (0, import_classnames185.default)(`${prefixCls}-next`, {
          [`${prefixCls}-disabled`]: nextDisabled
        }),
        "aria-disabled": nextDisabled
      },
      next2
    );
  }
  const cls5 = (0, import_classnames185.default)(prefixCls, className, {
    [`${prefixCls}-simple`]: simple,
    [`${prefixCls}-disabled`]: disabled
  });
  return /* @__PURE__ */ React425.createElement(
    "ul",
    {
      className: cls5,
      style: style2,
      ref: paginationRef,
      ...dataOrAriaAttributeProps
    },
    totalText,
    prev2,
    simple ? simplePager : pagerList,
    next2,
    /* @__PURE__ */ React425.createElement(
      Options_default,
      {
        locale: locale6,
        rootPrefixCls: prefixCls,
        disabled,
        selectComponentClass,
        selectPrefixCls,
        changeSize: showSizeChanger ? changePageSize : null,
        pageSize,
        pageSizeOptions,
        quickGo: shouldDisplayQuickJumper ? handleChange : null,
        goButton: gotoButton
      }
    )
  );
}, "Pagination");
if (true) {
  Pagination.displayName = "Pagination";
}
var Pagination_default = Pagination;

// packages/ant-design/components/pagination/Select.tsx
import * as React426 from "react";
var MiniSelect = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React426.createElement(select_default, { ...props, showSearch: true, size: "small" }), "MiniSelect");
var MiddleSelect = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React426.createElement(select_default, { ...props, showSearch: true, size: "middle" }), "MiddleSelect");
MiniSelect.Option = select_default.Option;
MiddleSelect.Option = select_default.Option;

// packages/ant-design/components/pagination/style/index.ts
var genPaginationDisabledStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token2.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token2.colorBorder,
          backgroundColor: token2.itemActiveBgDisabled,
          "&:hover, &:active": {
            backgroundColor: token2.itemActiveBgDisabled
          },
          a: {
            color: token2.itemActiveColorDisabled
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        color: token2.colorTextDisabled
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        [`${componentCls}-item-link-icon`]: {
          opacity: 0
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${componentCls}-simple`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&${componentCls}-disabled ${componentCls}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
}, "genPaginationDisabledStyle");
var genPaginationMiniStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token2.itemSizeSM,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit(token2.calc(token2.itemSizeSM).sub(2).equal())
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled) ${componentCls}-item:not(${componentCls}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      }
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM)
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token2.itemSizeSM,
      marginInlineEnd: 0,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
      [`&-size-changer`]: {
        top: token2.miniOptionsSizeChangerTop
      },
      [`&-quick-jumper`]: {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM),
        input: {
          ...genInputSmallStyle(token2),
          width: token2.paginationMiniQuickJumperInputWidth,
          height: token2.controlHeightSM
        }
      }
    }
  };
}, "genPaginationMiniStyle");
var genPaginationSimpleStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
      height: token2.itemSizeSM,
      lineHeight: unit(token2.itemSizeSM),
      verticalAlign: "top",
      [`${componentCls}-item-link`]: {
        height: token2.itemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        },
        "&::after": {
          height: token2.itemSizeSM,
          lineHeight: unit(token2.itemSizeSM)
        }
      }
    },
    [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
      display: "inline-block",
      height: token2.itemSizeSM,
      marginInlineEnd: token2.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: token2.marginXS,
        padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
        textAlign: "center",
        backgroundColor: token2.itemInputBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `border-color ${token2.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: token2.colorPrimary
        },
        "&:focus": {
          borderColor: token2.colorPrimaryHover,
          boxShadow: `${unit(token2.inputOutlineOffset)} 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
}, "genPaginationSimpleStyle");
var genPaginationJumpStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token2.colorPrimary,
          fontSize: token2.fontSizeSM,
          opacity: 0,
          transition: `all ${token2.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token2.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: token2.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token2.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token2.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      color: token2.colorText,
      fontFamily: token2.fontFamily,
      lineHeight: `${unit(token2.itemSize)}`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token2.borderRadius,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: token2.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token2.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `all ${token2.motionDurationMid}`
      },
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token2.paginationSlashMarginInlineEnd,
      marginInlineStart: token2.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token2.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token2.controlHeight,
        marginInlineStart: token2.marginXS,
        lineHeight: unit(token2.controlHeight),
        verticalAlign: "top",
        input: {
          ...genBasicInputStyle(token2),
          ...genBaseOutlinedStyle2(token2, {
            borderColor: token2.colorBorder,
            hoverBorderColor: token2.colorPrimaryHover,
            activeBorderColor: token2.colorPrimary,
            activeShadow: token2.activeShadow
          }),
          "&[disabled]": {
            ...genDisabledStyle2(token2)
          },
          width: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
          height: token2.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token2.marginXS,
          marginInlineEnd: token2.marginXS
        }
      }
    }
  };
}, "genPaginationJumpStyle");
var genPaginationItemStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-item`]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      marginInlineEnd: token2.marginXS,
      fontFamily: token2.fontFamily,
      lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
      borderRadius: token2.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
        color: token2.colorText,
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token2.motionDurationMid}`,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      },
      "&-active": {
        fontWeight: token2.fontWeightStrong,
        backgroundColor: token2.itemActiveBg,
        borderColor: token2.colorPrimary,
        a: {
          color: token2.colorPrimary
        },
        "&:hover": {
          borderColor: token2.colorPrimaryHover
        },
        "&:hover a": {
          color: token2.colorPrimaryHover
        }
      }
    }
  };
}, "genPaginationItemStyle");
var genPaginationStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token2.itemSize,
        marginInlineEnd: token2.marginXS,
        lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
        verticalAlign: "middle"
      },
      // item style
      ...genPaginationItemStyle(token2),
      // jump btn style
      ...genPaginationJumpStyle(token2),
      // simple style
      ...genPaginationSimpleStyle(token2),
      // mini style
      ...genPaginationMiniStyle(token2),
      // disabled style
      ...genPaginationDisabledStyle(token2),
      // media query style
      [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    },
    // rtl style
    [`&${token2.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genPaginationStyle");
var genPaginationFocusStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled)`]: {
      [`${componentCls}-item`]: {
        ...genFocusStyle(token2)
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        "&:focus-visible": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          },
          ...genFocusOutline(token2)
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:focus-visible ${componentCls}-item-link`]: {
          ...genFocusOutline(token2)
        }
      }
    }
  };
}, "genPaginationFocusStyle");
var prepareComponentToken36 = /* @__PURE__ */ __name((token2) => ({
  itemBg: token2.colorBgContainer,
  itemSize: token2.controlHeight,
  itemSizeSM: token2.controlHeightSM,
  itemActiveBg: token2.colorBgContainer,
  itemLinkBg: token2.colorBgContainer,
  itemActiveColorDisabled: token2.colorTextDisabled,
  itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
  itemInputBg: token2.colorBgContainer,
  miniOptionsSizeChangerTop: 0,
  ...initComponentToken(token2)
}), "prepareComponentToken");
var prepareToken5 = /* @__PURE__ */ __name((token2) => merge2(
  token2,
  {
    inputOutlineOffset: 0,
    paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
    paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
    paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
    paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
    paginationSlashMarginInlineStart: token2.marginXXS,
    paginationSlashMarginInlineEnd: token2.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  },
  initInputToken(token2)
), "prepareToken");
var style_default42 = genStyleHooks(
  "Pagination",
  (token2) => {
    const paginationToken = prepareToken5(token2);
    return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
  },
  prepareComponentToken36
);

// packages/ant-design/components/pagination/style/bordered.ts
var genBorderedStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          a: {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token2.itemActiveBgDisabled
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          color: token2.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder
        }
      }
    },
    [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token2.colorPrimaryHover,
          backgroundColor: token2.itemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.itemLinkBg,
          borderColor: token2.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          color: token2.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token2.itemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          a: {
            color: token2.colorPrimary
          }
        },
        "&-active": {
          borderColor: token2.colorPrimary
        }
      }
    }
  };
}, "genBorderedStyle");
var bordered_default = genSubStyleComponent(
  ["Pagination", "bordered"],
  (token2) => {
    const paginationToken = prepareToken5(token2);
    return [genBorderedStyle2(paginationToken)];
  },
  prepareComponentToken36
);

// packages/ant-design/components/pagination/Pagination.tsx
var Pagination2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    selectPrefixCls: customizeSelectPrefixCls,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    locale: customLocale,
    selectComponentClass,
    responsive,
    showSizeChanger,
    ...restProps
  } = props;
  const { xs } = useBreakpoint_default(responsive);
  const [, token2] = useToken();
  const { getPrefixCls, direction, pagination = {} } = React427.useContext(ConfigContext);
  const prefixCls = getPrefixCls("pagination", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default42(prefixCls);
  const mergedShowSizeChanger = showSizeChanger ?? pagination.showSizeChanger;
  const iconsProps = React427.useMemo(() => {
    const ellipsis = /* @__PURE__ */ React427.createElement("span", { className: `${prefixCls}-item-ellipsis` }, "\u2022\u2022\u2022");
    const prevIcon = /* @__PURE__ */ React427.createElement("button", { className: `${prefixCls}-item-link`, type: "button", tabIndex: -1 }, direction === "rtl" ? /* @__PURE__ */ React427.createElement(import_RightOutlined6.default, null) : /* @__PURE__ */ React427.createElement(import_LeftOutlined4.default, null));
    const nextIcon = /* @__PURE__ */ React427.createElement("button", { className: `${prefixCls}-item-link`, type: "button", tabIndex: -1 }, direction === "rtl" ? /* @__PURE__ */ React427.createElement(import_LeftOutlined4.default, null) : /* @__PURE__ */ React427.createElement(import_RightOutlined6.default, null));
    const jumpPrevIcon = /* @__PURE__ */ React427.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ React427.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ React427.createElement(import_DoubleRightOutlined.default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ React427.createElement(import_DoubleLeftOutlined.default, { className: `${prefixCls}-item-link-icon` }), ellipsis));
    const jumpNextIcon = /* @__PURE__ */ React427.createElement("a", { className: `${prefixCls}-item-link` }, /* @__PURE__ */ React427.createElement("div", { className: `${prefixCls}-item-container` }, direction === "rtl" ? /* @__PURE__ */ React427.createElement(import_DoubleLeftOutlined.default, { className: `${prefixCls}-item-link-icon` }) : /* @__PURE__ */ React427.createElement(import_DoubleRightOutlined.default, { className: `${prefixCls}-item-link-icon` }), ellipsis));
    return { prevIcon, nextIcon, jumpPrevIcon, jumpNextIcon };
  }, [direction, prefixCls]);
  const [contextLocale] = useLocale_default("Pagination", en_US_default);
  const locale6 = { ...contextLocale, ...customLocale };
  const mergedSize = useSize_default(customizeSize);
  const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
  const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
  const extendedClassName = (0, import_classnames186.default)(
    {
      [`${prefixCls}-mini`]: isSmall,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-bordered`]: token2.wireframe
    },
    pagination?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...pagination?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React427.createElement(React427.Fragment, null, token2.wireframe && /* @__PURE__ */ React427.createElement(bordered_default, { prefixCls }), /* @__PURE__ */ React427.createElement(
      Pagination_default,
      {
        ...iconsProps,
        ...restProps,
        style: mergedStyle,
        prefixCls,
        selectPrefixCls,
        className: extendedClassName,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
        locale: locale6,
        showSizeChanger: mergedShowSizeChanger
      }
    ))
  );
}, "Pagination");
if (true) {
  Pagination2.displayName = "Pagination";
}
var Pagination_default2 = Pagination2;

// packages/ant-design/components/pagination/index.ts
var pagination_default = Pagination_default2;

// packages/ant-design/components/spin/index.tsx
var import_classnames187 = __toESM(require_classnames());
import * as React428 from "react";

// packages/ant-design/components/spin/style/index.ts
var antSpinMove = new Keyframes_default("antSpinMove", {
  to: { opacity: 1 }
});
var antRotate = new Keyframes_default("antRotate", {
  to: { transform: "rotate(405deg)" }
});
var genSpinStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, calc } = token2;
  return {
    [`${componentCls}`]: {
      ...resetComponent(token2),
      position: "absolute",
      display: "none",
      color: token2.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "static",
        display: "inline-block",
        opacity: 1
      },
      [`${componentCls}-text`]: {
        fontSize: token2.fontSize,
        paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
      },
      "&-fullscreen": {
        position: "fixed",
        width: "100vw",
        height: "100vh",
        backgroundColor: token2.colorBgMask,
        zIndex: token2.zIndexPopupBase,
        inset: 0,
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        opacity: 0,
        visibility: "hidden",
        transition: `all ${token2.motionDurationMid}`,
        "&-show": {
          opacity: 1,
          visibility: "visible"
        },
        [`${componentCls}-dot ${componentCls}-dot-item`]: {
          backgroundColor: token2.colorWhite
        },
        [`${componentCls}-text`]: {
          color: token2.colorTextLightSolid
        }
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token2.contentHeight,
          [`${componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: calc(token2.dotSize).mul(-1).div(2).equal()
          },
          [`${componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            textShadow: `0 1px 2px ${token2.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${componentCls}-show-text ${componentCls}-dot`]: {
            marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
          },
          "&-sm": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          "&-lg": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          [`&::after`]: {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      [`&-tip`]: {
        color: token2.spinDotDefault
      },
      // dots
      // ------------------------------
      [`${componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token2.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          backgroundColor: token2.colorPrimary,
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0,
            animationDelay: "0s"
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      // small
      [`&-sm ${componentCls}-dot`]: {
        fontSize: token2.dotSizeSM,
        i: {
          width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
          height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${componentCls}-dot`]: {
        fontSize: token2.dotSizeLG,
        i: {
          width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
          height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
        }
      },
      [`&${componentCls}-show-text ${componentCls}-text`]: {
        display: "block"
      }
    }
  };
}, "genSpinStyle");
var prepareComponentToken37 = /* @__PURE__ */ __name((token2) => {
  const { controlHeightLG, controlHeight } = token2;
  return {
    contentHeight: 400,
    dotSize: controlHeightLG / 2,
    dotSizeSM: controlHeightLG * 0.35,
    dotSizeLG: controlHeight
  };
}, "prepareComponentToken");
var style_default43 = genStyleHooks(
  "Spin",
  (token2) => {
    const spinToken = merge2(token2, {
      spinDotDefault: token2.colorTextDescription
    });
    return [genSpinStyle(spinToken)];
  },
  prepareComponentToken37
);

// packages/ant-design/components/spin/index.tsx
var defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  const { indicator } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator === null) {
    return null;
  }
  if (React428.isValidElement(indicator)) {
    return cloneElement3(indicator, {
      className: (0, import_classnames187.default)(indicator.props.className, dotClassName)
    });
  }
  if (React428.isValidElement(defaultIndicator)) {
    return cloneElement3(defaultIndicator, {
      className: (0, import_classnames187.default)(defaultIndicator.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ React428.createElement("span", { className: (0, import_classnames187.default)(dotClassName, `${prefixCls}-dot-spin`) }, /* @__PURE__ */ React428.createElement("i", { className: `${prefixCls}-dot-item`, key: 1 }), /* @__PURE__ */ React428.createElement("i", { className: `${prefixCls}-dot-item`, key: 2 }), /* @__PURE__ */ React428.createElement("i", { className: `${prefixCls}-dot-item`, key: 3 }), /* @__PURE__ */ React428.createElement("i", { className: `${prefixCls}-dot-item`, key: 4 }));
}
__name(renderIndicator, "renderIndicator");
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
__name(shouldDelay, "shouldDelay");
var Spin = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    fullscreen = false,
    ...restProps
  } = props;
  const { getPrefixCls } = React428.useContext(ConfigContext);
  const prefixCls = getPrefixCls("spin", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default43(prefixCls);
  const [spinning, setSpinning] = React428.useState(
    () => customSpinning && !shouldDelay(customSpinning, delay)
  );
  React428.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        showSpinning?.cancel?.();
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = React428.useMemo(
    () => typeof children !== "undefined" && !fullscreen,
    [children, fullscreen]
  );
  if (true) {
    const warning5 = devUseWarning("Spin");
    warning5(
      !tip || isNestedPattern || fullscreen,
      "usage",
      "`tip` only work in nest or fullscreen pattern."
    );
  }
  const { direction, spin } = React428.useContext(ConfigContext);
  const spinClassName = (0, import_classnames187.default)(
    prefixCls,
    spin?.className,
    {
      [`${prefixCls}-sm`]: size === "small",
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-spinning`]: spinning,
      [`${prefixCls}-show-text`]: !!tip,
      [`${prefixCls}-fullscreen`]: fullscreen,
      [`${prefixCls}-fullscreen-show`]: fullscreen && spinning,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const containerClassName = (0, import_classnames187.default)(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const divProps = omit(restProps, ["indicator"]);
  const mergedStyle = { ...spin?.style, ...style2 };
  const spinElement = /* @__PURE__ */ React428.createElement(
    "div",
    {
      ...divProps,
      style: mergedStyle,
      className: spinClassName,
      "aria-live": "polite",
      "aria-busy": spinning
    },
    renderIndicator(prefixCls, props),
    tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ React428.createElement("div", { className: `${prefixCls}-text` }, tip) : null
  );
  if (isNestedPattern) {
    return wrapCSSVar(
      /* @__PURE__ */ React428.createElement(
        "div",
        {
          ...divProps,
          className: (0, import_classnames187.default)(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls)
        },
        spinning && /* @__PURE__ */ React428.createElement("div", { key: "loading" }, spinElement),
        /* @__PURE__ */ React428.createElement("div", { className: containerClassName, key: "container" }, children)
      )
    );
  }
  return wrapCSSVar(spinElement);
}, "Spin");
Spin.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
if (true) {
  Spin.displayName = "Spin";
}
var spin_default = Spin;

// packages/ant-design/components/list/context.ts
import React429 from "react";
var ListContext2 = React429.createContext({});
var ListConsumer = ListContext2.Consumer;

// packages/ant-design/components/list/Item.tsx
var import_classnames188 = __toESM(require_classnames());
import React430, { Children as Children6, useContext as useContext182 } from "react";
var Meta2 = /* @__PURE__ */ __name(({
  prefixCls: customizePrefixCls,
  className,
  avatar,
  title,
  description,
  ...others
}) => {
  const { getPrefixCls } = useContext182(ConfigContext);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const classString = (0, import_classnames188.default)(`${prefixCls}-item-meta`, className);
  const content = /* @__PURE__ */ React430.createElement("div", { className: `${prefixCls}-item-meta-content` }, title && /* @__PURE__ */ React430.createElement("h4", { className: `${prefixCls}-item-meta-title` }, title), description && /* @__PURE__ */ React430.createElement("div", { className: `${prefixCls}-item-meta-description` }, description));
  return /* @__PURE__ */ React430.createElement("div", { ...others, className: classString }, avatar && /* @__PURE__ */ React430.createElement("div", { className: `${prefixCls}-item-meta-avatar` }, avatar), (title || description) && content);
}, "Meta");
var InternalItem2 = React430.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    actions,
    extra,
    className,
    colStyle,
    ...others
  } = props;
  const { grid, itemLayout } = useContext182(ListContext2);
  const { getPrefixCls } = useContext182(ConfigContext);
  const isItemContainsTextNodeAndNotSingular = /* @__PURE__ */ __name(() => {
    let result;
    Children6.forEach(children, (element) => {
      if (typeof element === "string") {
        result = true;
      }
    });
    return result && Children6.count(children) > 1;
  }, "isItemContainsTextNodeAndNotSingular");
  const isFlexMode = /* @__PURE__ */ __name(() => {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  }, "isFlexMode");
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const actionsContent = actions && actions.length > 0 && /* @__PURE__ */ React430.createElement("ul", { className: `${prefixCls}-item-action`, key: "actions" }, actions.map((action, i) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ React430.createElement("li", { key: `${prefixCls}-item-action-${i}` }, action, i !== actions.length - 1 && /* @__PURE__ */ React430.createElement("em", { className: `${prefixCls}-item-action-split` }))
  )));
  const Element3 = grid ? "div" : "li";
  const itemChildren = /* @__PURE__ */ React430.createElement(
    Element3,
    {
      ...others,
      ...!grid ? { ref } : {},
      className: (0, import_classnames188.default)(
        `${prefixCls}-item`,
        {
          [`${prefixCls}-item-no-flex`]: !isFlexMode()
        },
        className
      )
    },
    itemLayout === "vertical" && extra ? [
      /* @__PURE__ */ React430.createElement("div", { className: `${prefixCls}-item-main`, key: "content" }, children, actionsContent),
      /* @__PURE__ */ React430.createElement("div", { className: `${prefixCls}-item-extra`, key: "extra" }, extra)
    ] : [children, actionsContent, cloneElement3(extra, { key: "extra" })]
  );
  return grid ? /* @__PURE__ */ React430.createElement(col_default, { ref, flex: 1, style: colStyle }, itemChildren) : itemChildren;
});
var Item4 = InternalItem2;
Item4.Meta = Meta2;
var Item_default4 = Item4;

// packages/ant-design/components/list/style/index.ts
var genBorderedStyle3 = /* @__PURE__ */ __name((token2) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    itemPaddingSM,
    itemPaddingLG,
    marginLG,
    borderRadiusLG
  } = token2;
  return {
    [`${listBorderedCls}`]: {
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${unit(margin)} ${unit(marginLG)}`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingLG
      }
    }
  };
}, "genBorderedStyle");
var genResponsiveStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, screenSM, screenMD, marginLG, marginSM, margin } = token2;
  return {
    [`@media screen and (max-width:${screenMD}px)`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM}px)`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token2.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${unit(margin)}`
          }
        }
      }
    }
  };
}, "genResponsiveStyle");
var genBaseStyle10 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    itemPadding,
    colorPrimary,
    itemPaddingSM,
    itemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth,
    headerBg,
    footerBg,
    emptyTextPadding,
    metaMarginBottom,
    avatarMarginRight,
    titleMarginBottom,
    descriptionFontSize
  } = token2;
  const alignCls = {};
  ["start", "center", "end"].forEach((item) => {
    alignCls[`&-align-${item}`] = {
      textAlign: item
    };
  });
  return {
    [`${componentCls}`]: {
      ...resetComponent(token2),
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${componentCls}-header`]: {
        background: headerBg
      },
      [`${componentCls}-footer`]: {
        background: footerBg
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: {
        marginBlockStart: marginLG,
        ...alignCls,
        // https://github.com/ant-design/ant-design/issues/20037
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: itemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: avatarMarginRight
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            margin: `0 0 ${unit(token2.marginXXS)} 0`,
            color: colorText,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              [`&:hover`]: {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: descriptionFontSize,
            lineHeight: token2.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token2.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          [`& > li`]: {
            position: "relative",
            display: "inline-block",
            padding: `0 ${unit(paddingXS)}`,
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            textAlign: "center",
            [`&:first-child`]: {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: token2.calc(token2.fontHeight).sub(token2.calc(token2.marginXXS).mul(2)).equal(),
            transform: "translateY(-50%)",
            backgroundColor: token2.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${unit(padding)} 0`,
        color: colorTextDescription,
        fontSize: token2.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding: emptyTextPadding,
        color: token2.colorTextDisabled,
        fontSize: token2.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    },
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: metaMarginBottom,
        [`${componentCls}-item-meta-title`]: {
          marginBlockStart: 0,
          marginBlockEnd: titleMarginBottom,
          color: colorText,
          fontSize: token2.fontSizeLG,
          lineHeight: token2.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${unit(padding)}`,
          [`&:first-child`]: {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
      [`&:last-child`]: {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: itemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: itemPaddingSM
    },
    // Horizontal
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
}, "genBaseStyle");
var prepareComponentToken38 = /* @__PURE__ */ __name((token2) => ({
  contentWidth: 220,
  itemPadding: `${unit(token2.paddingContentVertical)} 0`,
  itemPaddingSM: `${unit(token2.paddingContentVerticalSM)} ${unit(token2.paddingContentHorizontal)}`,
  itemPaddingLG: `${unit(token2.paddingContentVerticalLG)} ${unit(
    token2.paddingContentHorizontalLG
  )}`,
  headerBg: "transparent",
  footerBg: "transparent",
  emptyTextPadding: token2.padding,
  metaMarginBottom: token2.padding,
  avatarMarginRight: token2.padding,
  titleMarginBottom: token2.paddingSM,
  descriptionFontSize: token2.fontSize
}), "prepareComponentToken");
var style_default44 = genStyleHooks(
  "List",
  (token2) => {
    const listToken = merge2(token2, {
      listBorderedCls: `${token2.componentCls}-bordered`,
      minHeight: token2.controlHeightLG
    });
    return [genBaseStyle10(listToken), genBorderedStyle3(listToken), genResponsiveStyle(listToken)];
  },
  prepareComponentToken38
);

// packages/ant-design/components/list/index.tsx
function List3({
  pagination = false,
  prefixCls: customizePrefixCls,
  bordered = false,
  split = true,
  className,
  rootClassName,
  style: style2,
  children,
  itemLayout,
  loadMore,
  grid,
  dataSource = [],
  size: customizeSize,
  header,
  footer,
  loading = false,
  rowKey,
  renderItem: renderItem2,
  locale: locale6,
  ...rest
}) {
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  const [paginationCurrent, setPaginationCurrent] = React431.useState(
    paginationObj.defaultCurrent || 1
  );
  const [paginationSize, setPaginationSize] = React431.useState(paginationObj.defaultPageSize || 10);
  const { getPrefixCls, renderEmpty, direction, list } = React431.useContext(ConfigContext);
  const defaultPaginationProps = {
    current: 1,
    total: 0
  };
  const triggerPaginationEvent = /* @__PURE__ */ __name((eventName) => (page, pageSize) => {
    setPaginationCurrent(page);
    setPaginationSize(pageSize);
    if (pagination && pagination[eventName]) {
      pagination?.[eventName]?.(page, pageSize);
    }
  }, "triggerPaginationEvent");
  const onPaginationChange = triggerPaginationEvent("onChange");
  const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  const renderInnerItem = /* @__PURE__ */ __name((item, index3) => {
    if (!renderItem2)
      return null;
    let key;
    if (typeof rowKey === "function") {
      key = rowKey(item);
    } else if (rowKey) {
      key = item[rowKey];
    } else {
      key = item.key;
    }
    if (!key) {
      key = `list-item-${index3}`;
    }
    return /* @__PURE__ */ React431.createElement(React431.Fragment, { key }, renderItem2(item, index3));
  }, "renderInnerItem");
  const isSomethingAfterLastItem = /* @__PURE__ */ __name(() => !!(loadMore || pagination || footer), "isSomethingAfterLastItem");
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default44(prefixCls);
  let loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  const isLoading = loadingProp && loadingProp.spinning;
  const mergedSize = useSize_default(customizeSize);
  let sizeCls = "";
  switch (mergedSize) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
    default:
      break;
  }
  const classString = (0, import_classnames189.default)(
    prefixCls,
    {
      [`${prefixCls}-vertical`]: itemLayout === "vertical",
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-split`]: split,
      [`${prefixCls}-bordered`]: bordered,
      [`${prefixCls}-loading`]: isLoading,
      [`${prefixCls}-grid`]: !!grid,
      [`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem(),
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    list?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const paginationProps = extendsObject_default(
    defaultPaginationProps,
    {
      total: dataSource.length,
      current: paginationCurrent,
      pageSize: paginationSize
    },
    pagination || {}
  );
  const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  if (paginationProps.current > largestPage) {
    paginationProps.current = largestPage;
  }
  const paginationContent = pagination ? /* @__PURE__ */ React431.createElement(
    "div",
    {
      className: (0, import_classnames189.default)(
        `${prefixCls}-pagination`,
        `${prefixCls}-pagination-align-${paginationProps?.align ?? "end"}`
      )
    },
    /* @__PURE__ */ React431.createElement(
      pagination_default,
      {
        ...paginationProps,
        onChange: onPaginationChange,
        onShowSizeChange: onPaginationShowSizeChange
      }
    )
  ) : null;
  let splitDataSource = [...dataSource];
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = [...dataSource].splice(
        (paginationProps.current - 1) * paginationProps.pageSize,
        paginationProps.pageSize
      );
    }
  }
  const needResponsive = Object.keys(grid || {}).some(
    (key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key)
  );
  const screens = useBreakpoint_default(needResponsive);
  const currentBreakpoint = React431.useMemo(() => {
    for (let i = 0; i < responsiveArray.length; i += 1) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens]);
  const colStyle = React431.useMemo(() => {
    if (!grid) {
      return void 0;
    }
    const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: `${100 / columnCount}%`,
        maxWidth: `${100 / columnCount}%`
      };
    }
  }, [grid?.column, currentBreakpoint]);
  let childrenContent = isLoading && /* @__PURE__ */ React431.createElement("div", { style: { minHeight: 53 } });
  if (splitDataSource.length > 0) {
    const items = splitDataSource.map((item, index3) => renderInnerItem(item, index3));
    childrenContent = grid ? /* @__PURE__ */ React431.createElement(row_default, { gutter: grid.gutter }, React431.Children.map(items, (child) => /* @__PURE__ */ React431.createElement("div", { key: child?.key, style: colStyle }, child))) : /* @__PURE__ */ React431.createElement("ul", { className: `${prefixCls}-items` }, items);
  } else if (!children && !isLoading) {
    childrenContent = /* @__PURE__ */ React431.createElement("div", { className: `${prefixCls}-empty-text` }, locale6 && locale6.emptyText || renderEmpty?.("List") || /* @__PURE__ */ React431.createElement(defaultRenderEmpty_default, { componentName: "List" }));
  }
  const paginationPosition = paginationProps.position || "bottom";
  const contextValue = React431.useMemo(
    () => ({ grid, itemLayout }),
    [JSON.stringify(grid), itemLayout]
  );
  return wrapCSSVar(
    /* @__PURE__ */ React431.createElement(ListContext2.Provider, { value: contextValue }, /* @__PURE__ */ React431.createElement("div", { style: { ...list?.style, ...style2 }, className: classString, ...rest }, (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ React431.createElement("div", { className: `${prefixCls}-header` }, header), /* @__PURE__ */ React431.createElement(spin_default, { ...loadingProp }, childrenContent, children), footer && /* @__PURE__ */ React431.createElement("div", { className: `${prefixCls}-footer` }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent))
  );
}
__name(List3, "List");
if (true) {
  List3.displayName = "List";
}
List3.Item = Item_default4;
var list_default = List3;

// packages/ant-design/components/mentions/index.tsx
var import_classnames191 = __toESM(require_classnames());
import * as React436 from "react";

// packages/mentions/src/Mentions.tsx
var import_classnames190 = __toESM(require_classnames());
init_warning();
import React435, { forwardRef as forwardRef95, useEffect as useEffect111, useMemo as useMemo139, useRef as useRef136, useState as useState105 } from "react";

// packages/mentions/src/hooks/useEffectState.ts
import { useState as useState104, useCallback as useCallback36, useEffect as useEffect110 } from "react";
function useEffectState2() {
  const [effectId, setEffectId] = useState104({
    id: 0,
    callback: null
  });
  const update = useCallback36((callback) => {
    setEffectId(({ id }) => ({
      id: id + 1,
      callback
    }));
  }, []);
  useEffect110(() => {
    effectId.callback?.();
  }, [effectId]);
  return update;
}
__name(useEffectState2, "useEffectState");

// packages/mentions/src/KeywordTrigger.tsx
import * as React434 from "react";
import { useMemo as useMemo138 } from "react";

// packages/mentions/src/DropdownMenu.tsx
import * as React433 from "react";

// packages/mentions/src/MentionsContext.ts
import * as React432 from "react";
var MentionsContext = React432.createContext(null);
var MentionsContext_default = MentionsContext;

// packages/mentions/src/DropdownMenu.tsx
function DropdownMenu(props) {
  const {
    notFoundContent,
    activeIndex,
    setActiveIndex,
    selectOption,
    onFocus,
    onBlur
  } = React433.useContext(MentionsContext_default);
  const { prefixCls, options } = props;
  const activeOption = options[activeIndex] || {};
  return /* @__PURE__ */ React433.createElement(
    src_default9,
    {
      prefixCls: `${prefixCls}-menu`,
      activeKey: activeOption.key,
      onSelect: ({ key }) => {
        const option = options.find(({ key: optionKey }) => optionKey === key);
        selectOption(option);
      },
      onFocus,
      onBlur
    },
    options.map((option, index3) => {
      const { key, disabled, className, style: style2, label } = option;
      return /* @__PURE__ */ React433.createElement(
        MenuItem_default,
        {
          key,
          disabled,
          className,
          style: style2,
          onMouseEnter: () => {
            setActiveIndex(index3);
          }
        },
        label
      );
    }),
    !options.length && /* @__PURE__ */ React433.createElement(MenuItem_default, { disabled: true }, notFoundContent)
  );
}
__name(DropdownMenu, "DropdownMenu");
var DropdownMenu_default = DropdownMenu;

// packages/mentions/src/KeywordTrigger.tsx
var BUILT_IN_PLACEMENTS2 = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
var KeywordTrigger = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    options,
    children,
    visible,
    transitionName,
    getPopupContainer,
    dropdownClassName,
    direction,
    placement
  } = props;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const dropdownElement = /* @__PURE__ */ React434.createElement(DropdownMenu_default, { prefixCls: dropdownPrefix, options });
  const dropdownPlacement = useMemo138(() => {
    let popupPlacement;
    if (direction === "rtl") {
      popupPlacement = placement === "top" ? "topLeft" : "bottomLeft";
    } else {
      popupPlacement = placement === "top" ? "topRight" : "bottomRight";
    }
    return popupPlacement;
  }, [direction, placement]);
  return /* @__PURE__ */ React434.createElement(
    src_default5,
    {
      prefixCls: dropdownPrefix,
      popupVisible: visible,
      popup: dropdownElement,
      popupPlacement: dropdownPlacement,
      popupTransitionName: transitionName,
      builtinPlacements: BUILT_IN_PLACEMENTS2,
      getPopupContainer,
      popupClassName: dropdownClassName
    },
    children
  );
}, "KeywordTrigger");
var KeywordTrigger_default = KeywordTrigger;

// packages/mentions/src/Option.tsx
var Option3 = /* @__PURE__ */ __name(() => null, "Option");
var Option_default2 = Option3;

// packages/mentions/src/util.ts
function getBeforeSelectionText(input) {
  const { selectionStart } = input;
  return input.value.slice(0, selectionStart);
}
__name(getBeforeSelectionText, "getBeforeSelectionText");
function getLastMeasureIndex(text, prefix) {
  return prefix.reduce(
    (lastMatch, prefixStr) => {
      const lastIndex = text.lastIndexOf(prefixStr);
      if (lastIndex > lastMatch.location) {
        return {
          location: lastIndex,
          prefix: prefixStr
        };
      }
      return lastMatch;
    },
    { location: -1, prefix: "" }
  );
}
__name(getLastMeasureIndex, "getLastMeasureIndex");
function lower(char2) {
  return (char2 || "").toLowerCase();
}
__name(lower, "lower");
function reduceText(text, targetText, split) {
  const firstChar = text[0];
  if (!firstChar || firstChar === split) {
    return text;
  }
  let restText = text;
  const targetTextLen = targetText.length;
  for (let i = 0; i < targetTextLen; i += 1) {
    if (lower(restText[i]) !== lower(targetText[i])) {
      restText = restText.slice(i);
      break;
    } else if (i === targetTextLen - 1) {
      restText = restText.slice(targetTextLen);
    }
  }
  return restText;
}
__name(reduceText, "reduceText");
function replaceWithMeasure(text, measureConfig) {
  const { measureLocation, prefix, targetText, selectionStart, split } = measureConfig;
  let beforeMeasureText = text.slice(0, measureLocation);
  if (beforeMeasureText[beforeMeasureText.length - split.length] === split) {
    beforeMeasureText = beforeMeasureText.slice(
      0,
      beforeMeasureText.length - split.length
    );
  }
  if (beforeMeasureText) {
    beforeMeasureText = `${beforeMeasureText}${split}`;
  }
  let restText = reduceText(
    text.slice(selectionStart),
    targetText.slice(selectionStart - measureLocation - prefix.length),
    split
  );
  if (restText.slice(0, split.length) === split) {
    restText = restText.slice(split.length);
  }
  const connectedStartText = `${beforeMeasureText}${prefix}${targetText}${split}`;
  return {
    text: `${connectedStartText}${restText}`,
    selectionLocation: connectedStartText.length
  };
}
__name(replaceWithMeasure, "replaceWithMeasure");
function setInputSelection(input, location) {
  input.setSelectionRange(location, location);
  input.blur();
  input.focus();
}
__name(setInputSelection, "setInputSelection");
function validateSearch(text, split) {
  return !split || text.indexOf(split) === -1;
}
__name(validateSearch, "validateSearch");
function filterOption(input, { value = "" }) {
  const lowerCase = input.toLowerCase();
  return value.toLowerCase().indexOf(lowerCase) !== -1;
}
__name(filterOption, "filterOption");

// packages/mentions/src/Mentions.tsx
var InternalMentions = forwardRef95(
  (props, ref) => {
    const {
      // Style
      prefixCls,
      className,
      style: style2,
      // Misc
      prefix = "@",
      split = " ",
      notFoundContent = "Not Found",
      value,
      defaultValue,
      children,
      options,
      open: open3,
      allowClear,
      // Events
      validateSearch: validateSearch2 = validateSearch,
      filterOption: filterOption2 = filterOption,
      onChange,
      onKeyDown: onKeyDown2,
      onKeyUp,
      onPressEnter,
      onSearch,
      onSelect,
      onFocus,
      onBlur,
      // Dropdown
      transitionName,
      placement,
      direction,
      getPopupContainer,
      dropdownClassName,
      rows = 1,
      // Rest
      ...restProps
    } = props;
    const mergedPrefix = useMemo139(
      () => Array.isArray(prefix) ? prefix : [prefix],
      [prefix]
    );
    const textareaRef = useRef136(null);
    const measureRef = useRef136(null);
    const getTextArea = /* @__PURE__ */ __name(() => textareaRef.current?.resizableTextArea?.textArea, "getTextArea");
    React435.useImperativeHandle(ref, () => ({
      focus: () => textareaRef.current?.focus(),
      blur: () => textareaRef.current?.blur(),
      textarea: textareaRef.current?.resizableTextArea?.textArea
    }));
    const [measuring, setMeasuring] = useState105(false);
    const [measureText, setMeasureText] = useState105("");
    const [measurePrefix, setMeasurePrefix] = useState105("");
    const [measureLocation, setMeasureLocation] = useState105(0);
    const [activeIndex, setActiveIndex] = useState105(0);
    const [isFocus, setIsFocus] = useState105(false);
    const [mergedValue, setMergedValue] = useMergedState("", {
      defaultValue,
      value
    });
    useEffect111(() => {
      if (measuring && measureRef.current) {
        measureRef.current.scrollTop = getTextArea().scrollTop;
      }
    }, [measuring]);
    const [
      mergedMeasuring,
      mergedMeasureText,
      mergedMeasurePrefix,
      mergedMeasureLocation
    ] = React435.useMemo(() => {
      if (open3) {
        if (true) {
          warning_default(
            false,
            "`open` of Mentions is only used for debug usage. Do not use in you production."
          );
        }
        for (let i = 0; i < mergedPrefix.length; i += 1) {
          const curPrefix = mergedPrefix[i];
          const index3 = mergedValue.lastIndexOf(curPrefix);
          if (index3 >= 0) {
            return [true, "", curPrefix, index3];
          }
        }
      }
      return [measuring, measureText, measurePrefix, measureLocation];
    }, [
      open3,
      measuring,
      mergedPrefix,
      mergedValue,
      measureText,
      measurePrefix,
      measureLocation
    ]);
    const getOptions = React435.useCallback(
      (targetMeasureText) => {
        let list;
        if (options && options.length > 0) {
          list = options.map((item) => ({
            ...item,
            key: item?.key ?? item.value
          }));
        } else {
          list = toArray(children).map(
            ({
              props: optionProps,
              key
            }) => ({
              ...optionProps,
              label: optionProps.children,
              key: key || optionProps.value
            })
          );
        }
        return list.filter((option) => {
          if (filterOption2 === false) {
            return true;
          }
          return filterOption2(targetMeasureText, option);
        });
      },
      [children, options, filterOption2]
    );
    const mergedOptions = React435.useMemo(
      () => getOptions(mergedMeasureText),
      [getOptions, mergedMeasureText]
    );
    const onSelectionEffect = useEffectState2();
    const startMeasure = /* @__PURE__ */ __name((nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {
      setMeasuring(true);
      setMeasureText(nextMeasureText);
      setMeasurePrefix(nextMeasurePrefix);
      setMeasureLocation(nextMeasureLocation);
      setActiveIndex(0);
    }, "startMeasure");
    const stopMeasure = /* @__PURE__ */ __name((callback) => {
      setMeasuring(false);
      setMeasureLocation(0);
      setMeasureText("");
      onSelectionEffect(callback);
    }, "stopMeasure");
    const triggerChange = /* @__PURE__ */ __name((nextValue) => {
      setMergedValue(nextValue);
      onChange?.(nextValue);
    }, "triggerChange");
    const onInternalChange = /* @__PURE__ */ __name(({
      target: { value: nextValue }
    }) => {
      triggerChange(nextValue);
    }, "onInternalChange");
    const selectOption = /* @__PURE__ */ __name((option) => {
      const { value: mentionValue = "" } = option;
      const { text, selectionLocation } = replaceWithMeasure(mergedValue, {
        measureLocation: mergedMeasureLocation,
        targetText: mentionValue,
        prefix: mergedMeasurePrefix,
        selectionStart: getTextArea()?.selectionStart,
        split
      });
      triggerChange(text);
      stopMeasure(() => {
        setInputSelection(getTextArea(), selectionLocation);
      });
      onSelect?.(option, mergedMeasurePrefix);
    }, "selectOption");
    const onInternalKeyDown = /* @__PURE__ */ __name((event) => {
      const { which } = event;
      onKeyDown2?.(event);
      if (!mergedMeasuring) {
        return;
      }
      if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
        const optionLen = mergedOptions.length;
        const offset3 = which === KeyCode_default.UP ? -1 : 1;
        const newActiveIndex = (activeIndex + offset3 + optionLen) % optionLen;
        setActiveIndex(newActiveIndex);
        event.preventDefault();
      } else if (which === KeyCode_default.ESC) {
        stopMeasure();
      } else if (which === KeyCode_default.ENTER) {
        event.preventDefault();
        if (!mergedOptions.length) {
          stopMeasure();
          return;
        }
        const option = mergedOptions[activeIndex];
        selectOption(option);
      }
    }, "onInternalKeyDown");
    const onInternalKeyUp = /* @__PURE__ */ __name((event) => {
      const { key, which } = event;
      const target = event.target;
      const selectionStartText = getBeforeSelectionText(target);
      const { location: measureIndex, prefix: nextMeasurePrefix } = getLastMeasureIndex(selectionStartText, mergedPrefix);
      onKeyUp?.(event);
      if ([KeyCode_default.ESC, KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.ENTER].indexOf(
        which
      ) !== -1) {
        return;
      }
      if (measureIndex !== -1) {
        const nextMeasureText = selectionStartText.slice(
          measureIndex + nextMeasurePrefix.length
        );
        const validateMeasure = validateSearch2(nextMeasureText, split);
        const matchOption = !!getOptions(nextMeasureText).length;
        if (validateMeasure) {
          if (key === nextMeasurePrefix || key === "Shift" || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) {
            startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);
          }
        } else if (mergedMeasuring) {
          stopMeasure();
        }
        if (onSearch && validateMeasure) {
          onSearch(nextMeasureText, nextMeasurePrefix);
        }
      } else if (mergedMeasuring) {
        stopMeasure();
      }
    }, "onInternalKeyUp");
    const onInternalPressEnter = /* @__PURE__ */ __name((event) => {
      if (!mergedMeasuring && onPressEnter) {
        onPressEnter(event);
      }
    }, "onInternalPressEnter");
    const focusRef = useRef136();
    const onInternalFocus = /* @__PURE__ */ __name((event) => {
      window.clearTimeout(focusRef.current);
      if (!isFocus && event && onFocus) {
        onFocus(event);
      }
      setIsFocus(true);
    }, "onInternalFocus");
    const onInternalBlur = /* @__PURE__ */ __name((event) => {
      focusRef.current = window.setTimeout(() => {
        setIsFocus(false);
        stopMeasure();
        onBlur?.(event);
      }, 0);
    }, "onInternalBlur");
    const onDropdownFocus = /* @__PURE__ */ __name(() => {
      onInternalFocus();
    }, "onDropdownFocus");
    const onDropdownBlur = /* @__PURE__ */ __name(() => {
      onInternalBlur();
    }, "onDropdownBlur");
    return /* @__PURE__ */ React435.createElement("div", { className: (0, import_classnames190.default)(prefixCls, className), style: style2 }, /* @__PURE__ */ React435.createElement(
      src_default19,
      {
        ref: textareaRef,
        value: mergedValue,
        ...restProps,
        rows,
        onChange: onInternalChange,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onPressEnter: onInternalPressEnter,
        onFocus: onInternalFocus,
        onBlur: onInternalBlur
      }
    ), mergedMeasuring && /* @__PURE__ */ React435.createElement("div", { ref: measureRef, className: `${prefixCls}-measure` }, mergedValue.slice(0, mergedMeasureLocation), /* @__PURE__ */ React435.createElement(
      MentionsContext_default.Provider,
      {
        value: {
          notFoundContent,
          activeIndex,
          setActiveIndex,
          selectOption,
          onFocus: onDropdownFocus,
          onBlur: onDropdownBlur
        }
      },
      /* @__PURE__ */ React435.createElement(
        KeywordTrigger_default,
        {
          prefixCls,
          transitionName,
          placement,
          direction,
          options: mergedOptions,
          visible: true,
          getPopupContainer,
          dropdownClassName
        },
        /* @__PURE__ */ React435.createElement("span", null, mergedMeasurePrefix)
      )
    ), mergedValue.slice(
      mergedMeasureLocation + mergedMeasurePrefix.length
    )));
  }
);
var Mentions = forwardRef95(
  ({
    suffix,
    prefixCls = "rc-mentions",
    defaultValue,
    value: customValue,
    allowClear,
    onChange,
    classNames: classes,
    className,
    disabled,
    ...rest
  }, ref) => {
    const [mergedValue, setMergedValue] = useMergedState("", {
      defaultValue,
      value: customValue
    });
    const triggerChange = /* @__PURE__ */ __name((currentValue) => {
      setMergedValue(currentValue);
      onChange?.(currentValue);
    }, "triggerChange");
    const handleReset = /* @__PURE__ */ __name(() => {
      triggerChange("");
    }, "handleReset");
    return /* @__PURE__ */ React435.createElement(
      BaseInput_default,
      {
        suffix,
        prefixCls,
        value: mergedValue,
        allowClear,
        handleReset,
        className,
        classNames: classes,
        disabled
      },
      /* @__PURE__ */ React435.createElement(
        InternalMentions,
        {
          className: classes?.mentions,
          prefixCls,
          ref,
          onChange: triggerChange,
          ...rest
        }
      )
    );
  }
);
Mentions.Option = Option_default2;
var Mentions_default = Mentions;

// packages/mentions/src/index.ts
var src_default22 = Mentions_default;

// packages/ant-design/components/mentions/style/index.ts
var genMentionsStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorTextDisabled,
    controlItemBgHover,
    controlPaddingHorizontal,
    colorText,
    motionDurationSlow,
    lineHeight,
    controlHeight,
    paddingInline,
    paddingBlock,
    fontSize,
    fontSizeIcon,
    colorTextTertiary,
    colorTextQuaternary,
    colorBgElevated,
    paddingXXS,
    paddingLG,
    borderRadius,
    borderRadiusLG,
    boxShadowSecondary,
    itemPaddingVertical,
    calc
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBasicInputStyle(token2),
      position: "relative",
      display: "inline-block",
      height: "auto",
      padding: 0,
      overflow: "hidden",
      lineHeight,
      whiteSpace: "pre-wrap",
      verticalAlign: "bottom",
      // Variants
      ...genOutlinedStyle2(token2),
      ...genFilledStyle2(token2),
      ...genBorderlessStyle2(token2),
      "&-affix-wrapper": {
        ...genBasicInputStyle(token2),
        display: "inline-flex",
        padding: 0,
        "&::before": {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [`${componentCls}-suffix`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: paddingInline,
          bottom: 0,
          zIndex: 1,
          display: "inline-flex",
          alignItems: "center",
          margin: "auto"
        },
        [`&:has(${componentCls}-suffix) > ${componentCls} > textarea`]: {
          paddingInlineEnd: paddingLG
        },
        [`${componentCls}-clear-icon`]: {
          position: "absolute",
          insetInlineEnd: 0,
          insetBlockStart: calc(fontSize).mul(lineHeight).mul(0.5).add(paddingBlock).equal(),
          transform: `translateY(-50%)`,
          margin: 0,
          color: colorTextQuaternary,
          fontSize: fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: "pointer",
          transition: `color ${motionDurationSlow}`,
          "&:hover": {
            color: colorTextTertiary
          },
          "&:active": {
            color: colorText
          },
          "&-hidden": {
            visibility: "hidden"
          }
        }
      },
      "&-disabled": {
        "> textarea": {
          ...genDisabledStyle2(token2)
        }
      },
      // ================= Input Area =================
      [`&, &-affix-wrapper > ${componentCls}`]: {
        [`> textarea, ${componentCls}-measure`]: {
          color: colorText,
          boxSizing: "border-box",
          minHeight: token2.calc(controlHeight).sub(2),
          margin: 0,
          padding: `${unit(paddingBlock)} ${unit(paddingInline)}`,
          overflow: "inherit",
          overflowX: "hidden",
          overflowY: "auto",
          fontWeight: "inherit",
          fontSize: "inherit",
          fontFamily: "inherit",
          fontStyle: "inherit",
          fontVariant: "inherit",
          fontSizeAdjust: "inherit",
          fontStretch: "inherit",
          lineHeight: "inherit",
          direction: "inherit",
          letterSpacing: "inherit",
          whiteSpace: "inherit",
          textAlign: "inherit",
          verticalAlign: "top",
          wordWrap: "break-word",
          wordBreak: "inherit",
          tabSize: "inherit"
        },
        "> textarea": {
          width: "100%",
          border: "none",
          outline: "none",
          resize: "none",
          backgroundColor: "transparent",
          ...genPlaceholderStyle(token2.colorTextPlaceholder)
        },
        [`${componentCls}-measure`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: -1,
          color: "transparent",
          pointerEvents: "none",
          "> span": {
            display: "inline-block",
            minHeight: "1em"
          }
        }
      },
      // ================== Dropdown ==================
      "&-dropdown": {
        // Ref select dropdown style
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        fontSize,
        fontVariant: "initial",
        padding: paddingXXS,
        backgroundColor: colorBgElevated,
        borderRadius: borderRadiusLG,
        outline: "none",
        boxShadow: boxShadowSecondary,
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token2.dropdownHeight,
          margin: 0,
          paddingInlineStart: 0,
          // Override default ul/ol
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            minWidth: token2.controlItemWidth,
            padding: `${unit(itemPaddingVertical)} ${unit(controlPaddingHorizontal)}`,
            color: colorText,
            borderRadius,
            fontWeight: "normal",
            lineHeight,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&:hover": {
              backgroundColor: controlItemBgHover
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: controlItemBgHover,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: colorText,
              fontWeight: token2.fontWeightStrong,
              backgroundColor: controlItemBgHover
            },
            "&-active": {
              backgroundColor: controlItemBgHover
            }
          }
        }
      }
    }
  };
}, "genMentionsStyle");
var prepareComponentToken39 = /* @__PURE__ */ __name((token2) => ({
  ...initComponentToken(token2),
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: token2.zIndexPopupBase + 50,
  itemPaddingVertical: (token2.controlHeight - token2.fontHeight) / 2
}), "prepareComponentToken");
var style_default45 = genStyleHooks(
  "Mentions",
  (token2) => {
    const mentionsToken = merge2(token2, initInputToken(token2));
    return [genMentionsStyle(mentionsToken)];
  },
  prepareComponentToken39
);

// packages/ant-design/components/mentions/index.tsx
var { Option: Option4 } = src_default22;
function loadingFilterOption() {
  return true;
}
__name(loadingFilterOption, "loadingFilterOption");
var InternalMentions2 = React436.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    disabled,
    loading,
    filterOption: filterOption2,
    children,
    notFoundContent,
    options,
    status: customStatus,
    allowClear = false,
    popupClassName,
    style: style2,
    variant: customVariant,
    ...restProps
  } = props;
  const [focused, setFocused] = React436.useState(false);
  const innerRef = React436.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  if (true) {
    const warning5 = devUseWarning("Mentions");
    warning5.deprecated(!children, "Mentions.Option", "options");
  }
  const {
    getPrefixCls,
    renderEmpty,
    direction,
    mentions: contextMentions
  } = React436.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React436.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const onFocus = /* @__PURE__ */ __name((...args) => {
    if (restProps.onFocus) {
      restProps.onFocus(...args);
    }
    setFocused(true);
  }, "onFocus");
  const onBlur = /* @__PURE__ */ __name((...args) => {
    if (restProps.onBlur) {
      restProps.onBlur(...args);
    }
    setFocused(false);
  }, "onBlur");
  const notFoundContentEle = React436.useMemo(() => {
    if (notFoundContent !== void 0) {
      return notFoundContent;
    }
    return renderEmpty?.("Select") || /* @__PURE__ */ React436.createElement(defaultRenderEmpty_default, { componentName: "Select" });
  }, [notFoundContent, renderEmpty]);
  const mentionOptions = React436.useMemo(() => {
    if (loading) {
      return /* @__PURE__ */ React436.createElement(Option4, { value: "ANTD_SEARCHING", disabled: true }, /* @__PURE__ */ React436.createElement(spin_default, { size: "small" }));
    }
    return children;
  }, [loading, children]);
  const mergedOptions = loading ? [
    {
      value: "ANTD_SEARCHING",
      disabled: true,
      label: /* @__PURE__ */ React436.createElement(spin_default, { size: "small" })
    }
  ] : options;
  const mentionsfilterOption = loading ? loadingFilterOption : filterOption2;
  const prefixCls = getPrefixCls("mentions", customizePrefixCls);
  const mergedAllowClear = getAllowClear_default(allowClear);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default45(prefixCls, rootCls);
  const [variant, enableVariantCls] = useVariants_default(customVariant);
  const suffixNode = hasFeedback && /* @__PURE__ */ React436.createElement(React436.Fragment, null, feedbackIcon);
  const mergedClassName = (0, import_classnames191.default)(
    contextMentions?.className,
    className,
    rootClassName,
    cssVarCls,
    rootCls
  );
  const mentions = /* @__PURE__ */ React436.createElement(
    src_default22,
    {
      prefixCls,
      notFoundContent: notFoundContentEle,
      className: mergedClassName,
      disabled,
      allowClear: mergedAllowClear,
      direction,
      style: { ...contextMentions?.style, ...style2 },
      ...restProps,
      filterOption: mentionsfilterOption,
      onFocus,
      onBlur,
      dropdownClassName: (0, import_classnames191.default)(popupClassName, rootClassName, hashId, cssVarCls, rootCls),
      ref: mergedRef,
      options: mergedOptions,
      suffix: suffixNode,
      classNames: {
        mentions: (0, import_classnames191.default)(
          {
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-focused`]: focused,
            [`${prefixCls}-rtl`]: direction === "rtl"
          },
          hashId
        ),
        variant: (0, import_classnames191.default)(
          {
            [`${prefixCls}-${variant}`]: enableVariantCls
          },
          getStatusClassNames(prefixCls, mergedStatus)
        ),
        affixWrapper: hashId
      }
    },
    mentionOptions
  );
  return wrapCSSVar(mentions);
});
var Mentions2 = InternalMentions2;
if (true) {
  Mentions2.displayName = "Mentions";
}
Mentions2.Option = Option4;
var PurePanel13 = PurePanel_default3(Mentions2, "mentions");
Mentions2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel13;
Mentions2.getMentions = (value = "", config = {}) => {
  const { prefix = "@", split = " " } = config;
  const prefixList = Array.isArray(prefix) ? prefix : [prefix];
  return value.split(split).map((str = "") => {
    let hitPrefix = null;
    prefixList.some((prefixStr) => {
      const startStr = str.slice(0, prefixStr.length);
      if (startStr === prefixStr) {
        hitPrefix = prefixStr;
        return true;
      }
      return false;
    });
    if (hitPrefix !== null) {
      return {
        prefix: hitPrefix,
        value: str.slice(hitPrefix.length)
      };
    }
    return null;
  }).filter((entity) => !!entity && !!entity.value);
};
var mentions_default = Mentions2;

// packages/ant-design/components/message/index.tsx
import React437, { useContext as useContext186 } from "react";
var message = null;
var act = /* @__PURE__ */ __name((callback) => callback(), "act");
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
  const { getContainer: getContainer2, duration, rtl, maxCount, top } = defaultGlobalConfig;
  const mergedContainer = getContainer2?.() || document.body;
  return { getContainer: () => mergedContainer, duration, rtl, maxCount, top };
}
__name(getGlobalContext, "getGlobalContext");
var GlobalHolder = React437.forwardRef((props, ref) => {
  const { messageConfig, sync } = props;
  const { getPrefixCls } = useContext186(ConfigContext);
  const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
  const appConfig = useContext186(AppConfigContext);
  const [api, holder] = useInternalMessage({ ...messageConfig, prefixCls, ...appConfig.message });
  React437.useImperativeHandle(ref, () => {
    const instance = { ...api };
    Object.keys(instance).forEach((method4) => {
      instance[method4] = (...args) => {
        sync();
        return api[method4](...args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper = React437.forwardRef((_, ref) => {
  const [messageConfig, setMessageConfig] = React437.useState(getGlobalContext);
  const sync = /* @__PURE__ */ __name(() => {
    setMessageConfig(getGlobalContext);
  }, "sync");
  React437.useEffect(sync, []);
  const global2 = globalConfig();
  const rootPrefixCls = global2.getRootPrefixCls();
  const rootIconPrefixCls = global2.getIconPrefixCls();
  const theme = global2.getTheme();
  const dom = /* @__PURE__ */ React437.createElement(GlobalHolder, { ref, sync, messageConfig });
  return /* @__PURE__ */ React437.createElement(config_provider_default, { prefixCls: rootPrefixCls, iconPrefixCls: rootIconPrefixCls, theme }, global2.holderRender ? global2.holderRender(dom) : dom);
});
function flushNotice() {
  if (!message) {
    const holderFragment = document.createDocumentFragment();
    const newMessage = {
      fragment: holderFragment
    };
    message = newMessage;
    act(() => {
      render(
        /* @__PURE__ */ React437.createElement(
          GlobalHolderWrapper,
          {
            ref: (node2) => {
              const { instance, sync } = node2 || {};
              Promise.resolve().then(() => {
                if (!newMessage.instance && instance) {
                  newMessage.instance = instance;
                  newMessage.sync = sync;
                  flushNotice();
                }
              });
            }
          }
        ),
        holderFragment
      );
    });
    return;
  }
  if (!message.instance) {
    return;
  }
  taskQueue.forEach((task) => {
    const { type: type5, skipped } = task;
    if (!skipped) {
      switch (type5) {
        case "open": {
          act(() => {
            const closeFn = message.instance.open({
              ...defaultGlobalConfig,
              ...task.config
            });
            closeFn?.then(task.resolve);
            task.setCloseFn(closeFn);
          });
          break;
        }
        case "destroy":
          act(() => {
            message?.instance.destroy(task.key);
          });
          break;
        default: {
          act(() => {
            const closeFn = message.instance[type5](...task.args);
            closeFn?.then(task.resolve);
            task.setCloseFn(closeFn);
          });
        }
      }
    }
  });
  taskQueue = [];
}
__name(flushNotice, "flushNotice");
function setMessageGlobalConfig(config) {
  defaultGlobalConfig = {
    ...defaultGlobalConfig,
    ...config
  };
  act(() => {
    message?.sync?.();
  });
}
__name(setMessageGlobalConfig, "setMessageGlobalConfig");
function open(config) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: "open",
      config,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushNotice();
  return result;
}
__name(open, "open");
function typeOpen(type5, args) {
  const global2 = globalConfig();
  if (!global2.holderRender) {
    warnContext("message");
  }
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: type5,
      args,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushNotice();
  return result;
}
__name(typeOpen, "typeOpen");
var destroy = /* @__PURE__ */ __name((key) => {
  taskQueue.push({
    type: "destroy",
    key
  });
  flushNotice();
}, "destroy");
var methods = ["success", "info", "warning", "error", "loading"];
var baseStaticMethods = {
  open,
  destroy,
  config: setMessageGlobalConfig,
  useMessage,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default
};
var staticMethods = baseStaticMethods;
methods.forEach((type5) => {
  staticMethods[type5] = (...args) => typeOpen(type5, args);
});
if (false) {
  actWrapper = /* @__PURE__ */ __name((wrapper) => {
    act = wrapper;
  }, "actWrapper");
}
if (false) {
  actDestroy = /* @__PURE__ */ __name(() => {
    message = null;
  }, "actDestroy");
}
var message_default = staticMethods;

// packages/ant-design/components/modal/PurePanel.tsx
var import_classnames192 = __toESM(require_classnames());
import * as React438 from "react";
var PurePanel14 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    closeIcon,
    closable,
    type: type5,
    title,
    children,
    footer,
    ...restProps
  } = props;
  const { getPrefixCls } = React438.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const prefixCls = customizePrefixCls || getPrefixCls("modal");
  const rootCls = useCSSVarCls_default(rootPrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default8(prefixCls, rootCls);
  const confirmPrefixCls = `${prefixCls}-confirm`;
  let additionalProps = {};
  if (type5) {
    additionalProps = {
      closable: closable ?? false,
      title: "",
      footer: "",
      children: /* @__PURE__ */ React438.createElement(
        ConfirmContent,
        {
          ...props,
          prefixCls,
          confirmPrefixCls,
          rootPrefixCls,
          content: children
        }
      )
    };
  } else {
    additionalProps = {
      closable: closable ?? true,
      title,
      footer: footer !== null && /* @__PURE__ */ React438.createElement(Footer, { ...props }),
      children
    };
  }
  return wrapCSSVar(
    /* @__PURE__ */ React438.createElement(
      Panel_default,
      {
        prefixCls,
        className: (0, import_classnames192.default)(
          hashId,
          `${prefixCls}-pure-panel`,
          type5 && confirmPrefixCls,
          type5 && `${confirmPrefixCls}-${type5}`,
          className,
          cssVarCls,
          rootCls
        ),
        ...restProps,
        closeIcon: renderCloseIcon(prefixCls, closeIcon),
        closable,
        ...additionalProps
      }
    )
  );
}, "PurePanel");
var PurePanel_default7 = withPureRenderTheme(PurePanel14);

// packages/ant-design/components/modal/index.ts
function modalWarn(props) {
  return confirm(withWarn(props));
}
__name(modalWarn, "modalWarn");
var Modal2 = Modal_default;
Modal2.useModal = useModal_default;
Modal2.info = /* @__PURE__ */ __name(function infoFn(props) {
  return confirm(withInfo(props));
}, "infoFn");
Modal2.success = /* @__PURE__ */ __name(function successFn(props) {
  return confirm(withSuccess(props));
}, "successFn");
Modal2.error = /* @__PURE__ */ __name(function errorFn(props) {
  return confirm(withError(props));
}, "errorFn");
Modal2.warning = modalWarn;
Modal2.warn = modalWarn;
Modal2.confirm = /* @__PURE__ */ __name(function confirmFn(props) {
  return confirm(withConfirm(props));
}, "confirmFn");
Modal2.destroyAll = /* @__PURE__ */ __name(function destroyAllFn() {
  while (destroyFns_default.length) {
    const close = destroyFns_default.pop();
    if (close) {
      close();
    }
  }
}, "destroyAllFn");
Modal2.config = modalGlobalConfig;
Modal2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default7;
if (true) {
  Modal2.displayName = "Modal";
}
var modal_default = Modal2;

// packages/ant-design/components/notification/index.tsx
import React439, { useContext as useContext188 } from "react";
var notification = null;
var act2 = /* @__PURE__ */ __name((callback) => callback(), "act");
var taskQueue2 = [];
var defaultGlobalConfig2 = {};
function getGlobalContext2() {
  const { getContainer: getContainer2, rtl, maxCount, top, bottom } = defaultGlobalConfig2;
  const mergedContainer = getContainer2?.() || document.body;
  return { getContainer: () => mergedContainer, rtl, maxCount, top, bottom };
}
__name(getGlobalContext2, "getGlobalContext");
var GlobalHolder2 = React439.forwardRef((props, ref) => {
  const { notificationConfig, sync } = props;
  const { getPrefixCls } = useContext188(ConfigContext);
  const prefixCls = defaultGlobalConfig2.prefixCls || getPrefixCls("notification");
  const appConfig = useContext188(AppConfigContext);
  const [api, holder] = useInternalNotification({
    ...notificationConfig,
    prefixCls,
    ...appConfig.notification
  });
  React439.useEffect(sync, []);
  React439.useImperativeHandle(ref, () => {
    const instance = { ...api };
    Object.keys(instance).forEach((method4) => {
      instance[method4] = (...args) => {
        sync();
        return api[method4](...args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper2 = React439.forwardRef((_, ref) => {
  const [notificationConfig, setNotificationConfig] = React439.useState(getGlobalContext2);
  const sync = /* @__PURE__ */ __name(() => {
    setNotificationConfig(getGlobalContext2);
  }, "sync");
  React439.useEffect(sync, []);
  const global2 = globalConfig();
  const rootPrefixCls = global2.getRootPrefixCls();
  const rootIconPrefixCls = global2.getIconPrefixCls();
  const theme = global2.getTheme();
  const dom = /* @__PURE__ */ React439.createElement(GlobalHolder2, { ref, sync, notificationConfig });
  return /* @__PURE__ */ React439.createElement(config_provider_default, { prefixCls: rootPrefixCls, iconPrefixCls: rootIconPrefixCls, theme }, global2.holderRender ? global2.holderRender(dom) : dom);
});
function flushNotice2() {
  if (!notification) {
    const holderFragment = document.createDocumentFragment();
    const newNotification = {
      fragment: holderFragment
    };
    notification = newNotification;
    act2(() => {
      render(
        /* @__PURE__ */ React439.createElement(
          GlobalHolderWrapper2,
          {
            ref: (node2) => {
              const { instance, sync } = node2 || {};
              Promise.resolve().then(() => {
                if (!newNotification.instance && instance) {
                  newNotification.instance = instance;
                  newNotification.sync = sync;
                  flushNotice2();
                }
              });
            }
          }
        ),
        holderFragment
      );
    });
    return;
  }
  if (!notification.instance) {
    return;
  }
  taskQueue2.forEach((task) => {
    switch (task.type) {
      case "open": {
        act2(() => {
          notification.instance.open({
            ...defaultGlobalConfig2,
            ...task.config
          });
        });
        break;
      }
      case "destroy":
        act2(() => {
          notification?.instance.destroy(task.key);
        });
        break;
    }
  });
  taskQueue2 = [];
}
__name(flushNotice2, "flushNotice");
function setNotificationGlobalConfig(config) {
  defaultGlobalConfig2 = {
    ...defaultGlobalConfig2,
    ...config
  };
  act2(() => {
    notification?.sync?.();
  });
}
__name(setNotificationGlobalConfig, "setNotificationGlobalConfig");
function open2(config) {
  const global2 = globalConfig();
  if (!global2.holderRender) {
    warnContext("notification");
  }
  taskQueue2.push({
    type: "open",
    config
  });
  flushNotice2();
}
__name(open2, "open");
var destroy2 = /* @__PURE__ */ __name((key) => {
  taskQueue2.push({
    type: "destroy",
    key
  });
  flushNotice2();
}, "destroy");
var methods2 = ["success", "info", "warning", "error"];
var baseStaticMethods2 = {
  open: open2,
  destroy: destroy2,
  config: setNotificationGlobalConfig,
  useNotification: useNotification2,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default2
};
var staticMethods2 = baseStaticMethods2;
methods2.forEach((type5) => {
  staticMethods2[type5] = (config) => open2({ ...config, type: type5 });
});
if (false) {
  actWrapper = /* @__PURE__ */ __name((wrapper) => {
    act2 = wrapper;
  }, "actWrapper");
}
if (false) {
  actDestroy = /* @__PURE__ */ __name(() => {
    notification = null;
  }, "actDestroy");
}
var notification_default = staticMethods2;

// packages/ant-design/components/popconfirm/index.tsx
var import_ExclamationCircleFilled7 = __toESM(require_ExclamationCircleFilled3());
var import_classnames194 = __toESM(require_classnames());
import * as React441 from "react";

// packages/ant-design/components/popconfirm/PurePanel.tsx
var import_ExclamationCircleFilled6 = __toESM(require_ExclamationCircleFilled3());
var import_classnames193 = __toESM(require_classnames());
import * as React440 from "react";

// packages/ant-design/components/popconfirm/style/index.ts
var genBaseStyle11 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    zIndexPopup,
    colorText,
    colorWarning,
    marginXXS,
    marginXS,
    fontSize,
    fontWeightStrong,
    colorTextHeading
  } = token2;
  return {
    [componentCls]: {
      zIndex: zIndexPopup,
      [`&${antCls}-popover`]: {
        fontSize
      },
      [`${componentCls}-message`]: {
        marginBottom: marginXS,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${componentCls}-message-icon ${iconCls}`]: {
          color: colorWarning,
          fontSize,
          lineHeight: 1,
          marginInlineEnd: marginXS
        },
        [`${componentCls}-title`]: {
          fontWeight: fontWeightStrong,
          color: colorTextHeading,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${componentCls}-description`]: {
          marginTop: marginXXS,
          color: colorText
        }
      },
      [`${componentCls}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: marginXS
        }
      }
    }
  };
}, "genBaseStyle");
var prepareComponentToken40 = /* @__PURE__ */ __name((token2) => {
  const { zIndexPopupBase } = token2;
  return {
    zIndexPopup: zIndexPopupBase + 60
  };
}, "prepareComponentToken");
var style_default46 = genStyleHooks("Popconfirm", (token2) => genBaseStyle11(token2), prepareComponentToken40, {
  resetStyle: false
});

// packages/ant-design/components/popconfirm/PurePanel.tsx
var Overlay3 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    okButtonProps,
    cancelButtonProps,
    title,
    description,
    cancelText,
    okText,
    okType = "primary",
    icon = /* @__PURE__ */ React440.createElement(import_ExclamationCircleFilled6.default, null),
    showCancel = true,
    close,
    onConfirm,
    onCancel,
    onPopupClick
  } = props;
  const { getPrefixCls } = React440.useContext(ConfigContext);
  const [contextLocale] = useLocale_default("Popconfirm", en_US_default6.Popconfirm);
  const theTitle = getRenderPropValue(title);
  const theDescription = getRenderPropValue(description);
  return /* @__PURE__ */ React440.createElement("div", { className: `${prefixCls}-inner-content`, onClick: onPopupClick }, /* @__PURE__ */ React440.createElement("div", { className: `${prefixCls}-message` }, icon && /* @__PURE__ */ React440.createElement("span", { className: `${prefixCls}-message-icon` }, icon), /* @__PURE__ */ React440.createElement("div", { className: `${prefixCls}-message-text` }, theTitle && /* @__PURE__ */ React440.createElement("div", { className: (0, import_classnames193.default)(`${prefixCls}-title`) }, theTitle), theDescription && /* @__PURE__ */ React440.createElement("div", { className: `${prefixCls}-description` }, theDescription))), /* @__PURE__ */ React440.createElement("div", { className: `${prefixCls}-buttons` }, showCancel && /* @__PURE__ */ React440.createElement(button_default2, { onClick: onCancel, size: "small", ...cancelButtonProps }, cancelText || contextLocale?.cancelText), /* @__PURE__ */ React440.createElement(
    ActionButton_default,
    {
      buttonProps: {
        size: "small",
        ...convertLegacyProps(okType),
        ...okButtonProps
      },
      actionFn: onConfirm,
      close,
      prefixCls: getPrefixCls("btn"),
      quitOnNullishReturnValue: true,
      emitEvent: true
    },
    okText || contextLocale?.okText
  )));
}, "Overlay");
var PurePanel15 = /* @__PURE__ */ __name((props) => {
  const { prefixCls: customizePrefixCls, placement, className, style: style2, ...restProps } = props;
  const { getPrefixCls } = React440.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  const [wrapCSSVar] = style_default46(prefixCls);
  return wrapCSSVar(
    /* @__PURE__ */ React440.createElement(
      PurePanel_default5,
      {
        placement,
        className: (0, import_classnames193.default)(prefixCls, className),
        style: style2,
        content: /* @__PURE__ */ React440.createElement(Overlay3, { prefixCls, ...restProps })
      }
    )
  );
}, "PurePanel");
var PurePanel_default8 = PurePanel15;

// packages/ant-design/components/popconfirm/index.tsx
var InternalPopconfirm = React441.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    placement = "top",
    trigger = "click",
    okType = "primary",
    icon = /* @__PURE__ */ React441.createElement(import_ExclamationCircleFilled7.default, null),
    children,
    overlayClassName,
    onOpenChange,
    onVisibleChange,
    ...restProps
  } = props;
  const { getPrefixCls } = React441.useContext(ConfigContext);
  const [open3, setOpen] = useMergedState(false, {
    value: props.open ?? props.visible,
    defaultValue: props.defaultOpen ?? props.defaultVisible
  });
  const settingOpen = /* @__PURE__ */ __name((value, e3) => {
    setOpen(value, true);
    onVisibleChange?.(value);
    onOpenChange?.(value, e3);
  }, "settingOpen");
  const close = /* @__PURE__ */ __name((e3) => {
    settingOpen(false, e3);
  }, "close");
  const onConfirm = /* @__PURE__ */ __name((e3) => props.onConfirm?.call(void 0, e3), "onConfirm");
  const onCancel = /* @__PURE__ */ __name((e3) => {
    settingOpen(false, e3);
    props.onCancel?.call(void 0, e3);
  }, "onCancel");
  const onInternalOpenChange = /* @__PURE__ */ __name((value, e3) => {
    const { disabled = false } = props;
    if (disabled) {
      return;
    }
    settingOpen(value, e3);
  }, "onInternalOpenChange");
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  const overlayClassNames = (0, import_classnames194.default)(prefixCls, overlayClassName);
  const [wrapCSSVar] = style_default46(prefixCls);
  return wrapCSSVar(
    /* @__PURE__ */ React441.createElement(
      popover_default,
      {
        ...omit(restProps, ["title"]),
        trigger,
        placement,
        onOpenChange: onInternalOpenChange,
        open: open3,
        ref,
        overlayClassName: overlayClassNames,
        content: /* @__PURE__ */ React441.createElement(
          Overlay3,
          {
            okType,
            icon,
            ...props,
            prefixCls,
            close,
            onConfirm,
            onCancel
          }
        ),
        "data-popover-inject": true
      },
      children
    )
  );
});
var Popconfirm = InternalPopconfirm;
Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default8;
if (true) {
  Popconfirm.displayName = "Popconfirm";
}
var popconfirm_default = Popconfirm;

// packages/ant-design/components/progress/progress.tsx
var import_CheckCircleFilled6 = __toESM(require_CheckCircleFilled3());
var import_CheckOutlined2 = __toESM(require_CheckOutlined3());
var import_CloseCircleFilled8 = __toESM(require_CloseCircleFilled3());
var import_CloseOutlined11 = __toESM(require_CloseOutlined3());
var import_classnames199 = __toESM(require_classnames());
import * as React449 from "react";

// packages/ant-design/components/progress/Circle.tsx
var import_classnames197 = __toESM(require_classnames());
import * as React446 from "react";

// packages/progress/src/Line.tsx
var import_classnames195 = __toESM(require_classnames());
import * as React442 from "react";

// packages/progress/src/common.ts
import { useRef as useRef138, useEffect as useEffect112 } from "react";
var defaultProps2 = {
  percent: 0,
  prefixCls: "rc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1,
  gapPosition: "bottom"
};
var useTransitionDuration = /* @__PURE__ */ __name(() => {
  const pathsRef = useRef138([]);
  const prevTimeStamp = useRef138(null);
  useEffect112(() => {
    const now2 = Date.now();
    let updated = false;
    pathsRef.current.forEach((path2) => {
      if (!path2) {
        return;
      }
      updated = true;
      const pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated) {
      prevTimeStamp.current = Date.now();
    }
  });
  return pathsRef.current;
}, "useTransitionDuration");

// packages/progress/src/Line.tsx
var Line = /* @__PURE__ */ __name((props) => {
  const {
    className,
    percent,
    prefixCls,
    strokeColor,
    strokeLinecap,
    strokeWidth,
    style: style2,
    trailColor,
    trailWidth,
    transition,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  delete restProps.gapPosition;
  const percentList = Array.isArray(percent) ? percent : [percent];
  const strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
  const paths = useTransitionDuration();
  const center = strokeWidth / 2;
  const right = 100 - strokeWidth / 2;
  const pathString = `M ${strokeLinecap === "round" ? center : 0},${center}
         L ${strokeLinecap === "round" ? right : 100},${center}`;
  const viewBoxString = `0 0 100 ${strokeWidth}`;
  let stackPtg = 0;
  return /* @__PURE__ */ React442.createElement(
    "svg",
    {
      className: (0, import_classnames195.default)(`${prefixCls}-line`, className),
      viewBox: viewBoxString,
      preserveAspectRatio: "none",
      style: style2,
      ...restProps
    },
    /* @__PURE__ */ React442.createElement(
      "path",
      {
        className: `${prefixCls}-line-trail`,
        d: pathString,
        strokeLinecap,
        stroke: trailColor,
        strokeWidth: trailWidth || strokeWidth,
        fillOpacity: "0"
      }
    ),
    percentList.map((ptg, index3) => {
      let dashPercent = 1;
      switch (strokeLinecap) {
        case "round":
          dashPercent = 1 - strokeWidth / 100;
          break;
        case "square":
          dashPercent = 1 - strokeWidth / 2 / 100;
          break;
        default:
          dashPercent = 1;
          break;
      }
      const pathStyle = {
        strokeDasharray: `${ptg * dashPercent}px, 100px`,
        strokeDashoffset: `-${stackPtg}px`,
        transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear"
      };
      const color = strokeColorList[index3] || strokeColorList[strokeColorList.length - 1];
      stackPtg += ptg;
      return /* @__PURE__ */ React442.createElement(
        "path",
        {
          key: index3,
          className: `${prefixCls}-line-path`,
          d: pathString,
          strokeLinecap,
          stroke: color,
          strokeWidth,
          fillOpacity: "0",
          ref: (elem) => {
            paths[index3] = elem;
          },
          style: pathStyle
        }
      );
    })
  );
}, "Line");
if (true) {
  Line.displayName = "Line";
}

// packages/progress/src/Circle/index.tsx
var import_classnames196 = __toESM(require_classnames());
import * as React445 from "react";

// packages/progress/src/hooks/useId.ts
init_canUseDom();
import * as React443 from "react";
var uuid8 = 0;
var isBrowserClient3 = canUseDom();
function getUUID2() {
  let retId;
  if (isBrowserClient3) {
    retId = uuid8;
    uuid8 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
__name(getUUID2, "getUUID");
var useId_default2 = /* @__PURE__ */ __name((id) => {
  const [innerId, setInnerId] = React443.useState();
  React443.useEffect(() => {
    setInnerId(`rc_progress_${getUUID2()}`);
  }, []);
  return id || innerId;
}, "default");

// packages/progress/src/Circle/PtgCircle.tsx
import * as React444 from "react";
var Block = /* @__PURE__ */ __name(({ bg, children }) => /* @__PURE__ */ React444.createElement("div", { style: { width: "100%", height: "100%", background: bg } }, children), "Block");
function getPtgColors(color, scale) {
  return Object.keys(color).map((key) => {
    const parsedKey = parseFloat(key);
    const ptgKey = `${Math.floor(parsedKey * scale)}%`;
    return `${color[key]} ${ptgKey}`;
  });
}
__name(getPtgColors, "getPtgColors");
var PtgCircle = React444.forwardRef((props, ref) => {
  const {
    prefixCls,
    color,
    gradientId,
    radius,
    style: circleStyleForStack,
    ptg,
    strokeLinecap,
    strokeWidth,
    size,
    gapDegree
  } = props;
  const isGradient = color && typeof color === "object";
  const stroke = isGradient ? `#FFF` : void 0;
  const halfSize = size / 2;
  const circleNode = /* @__PURE__ */ React444.createElement(
    "circle",
    {
      className: `${prefixCls}-circle-path`,
      r: radius,
      cx: halfSize,
      cy: halfSize,
      stroke,
      strokeLinecap,
      strokeWidth,
      opacity: ptg === 0 ? 0 : 1,
      style: circleStyleForStack,
      ref
    }
  );
  if (!isGradient) {
    return circleNode;
  }
  const maskId = `${gradientId}-conic`;
  const fromDeg = gapDegree ? `${180 + gapDegree / 2}deg` : "0deg";
  const conicColors = getPtgColors(color, (360 - gapDegree) / 360);
  const linearColors = getPtgColors(color, 1);
  const conicColorBg = `conic-gradient(from ${fromDeg}, ${conicColors.join(", ")})`;
  const linearColorBg = `linear-gradient(to ${gapDegree ? "bottom" : "top"}, ${linearColors.join(
    ", "
  )})`;
  return /* @__PURE__ */ React444.createElement(React444.Fragment, null, /* @__PURE__ */ React444.createElement("mask", { id: maskId }, circleNode), /* @__PURE__ */ React444.createElement("foreignObject", { x: 0, y: 0, width: size, height: size, mask: `url(#${maskId})` }, /* @__PURE__ */ React444.createElement(Block, { bg: linearColorBg }, /* @__PURE__ */ React444.createElement(Block, { bg: conicColorBg }))));
});
if (true) {
  PtgCircle.displayName = "PtgCircle";
}
var PtgCircle_default = PtgCircle;

// packages/progress/src/Circle/util.ts
var VIEW_BOX_SIZE = 100;
var getCircleStyle = /* @__PURE__ */ __name((perimeter, perimeterWithoutGap, offset3, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth, stepSpace = 0) => {
  const offsetDeg = offset3 / 100 * 360 * ((360 - gapDegree) / 360);
  const positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition];
  let strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  if (strokeLinecap === "round" && percent !== 100) {
    strokeDashoffset += strokeWidth / 2;
    if (strokeDashoffset >= perimeterWithoutGap) {
      strokeDashoffset = perimeterWithoutGap - 0.01;
    }
  }
  const halfSize = VIEW_BOX_SIZE / 2;
  return {
    stroke: typeof strokeColor === "string" ? strokeColor : void 0,
    strokeDasharray: `${perimeterWithoutGap}px ${perimeter}`,
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: `rotate(${rotateDeg + offsetDeg + positionDeg}deg)`,
    transformOrigin: `${halfSize}px ${halfSize}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
    fillOpacity: 0
  };
}, "getCircleStyle");

// packages/progress/src/Circle/index.tsx
function toArray7(value) {
  const mergedValue = value ?? [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
__name(toArray7, "toArray");
var Circle = /* @__PURE__ */ __name((props) => {
  const {
    id,
    prefixCls,
    steps,
    strokeWidth,
    trailWidth,
    gapDegree = 0,
    gapPosition,
    trailColor,
    strokeLinecap,
    style: style2,
    className,
    strokeColor,
    percent,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  const halfSize = VIEW_BOX_SIZE / 2;
  const mergedId = useId_default2(id);
  const gradientId = `${mergedId}-gradient`;
  const radius = halfSize - strokeWidth / 2;
  const perimeter = Math.PI * 2 * radius;
  const rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
  const perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
  const { count: stepCount, gap: stepGap } = typeof steps === "object" ? steps : { count: steps, gap: 2 };
  const percentList = toArray7(percent);
  const strokeColorList = toArray7(strokeColor);
  const gradient = strokeColorList.find((color) => color && typeof color === "object");
  const isConicGradient = gradient && typeof gradient === "object";
  const mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap;
  const circleStyle = getCircleStyle(
    perimeter,
    perimeterWithoutGap,
    0,
    100,
    rotateDeg,
    gapDegree,
    gapPosition,
    trailColor,
    mergedStrokeLinecap,
    strokeWidth
  );
  const paths = useTransitionDuration();
  const getStokeList = /* @__PURE__ */ __name(() => {
    let stackPtg = 0;
    return percentList.map((ptg, index3) => {
      const color = strokeColorList[index3] || strokeColorList[strokeColorList.length - 1];
      const circleStyleForStack = getCircleStyle(
        perimeter,
        perimeterWithoutGap,
        stackPtg,
        ptg,
        rotateDeg,
        gapDegree,
        gapPosition,
        color,
        mergedStrokeLinecap,
        strokeWidth
      );
      stackPtg += ptg;
      return /* @__PURE__ */ React445.createElement(
        PtgCircle_default,
        {
          key: index3,
          color,
          ptg,
          radius,
          prefixCls,
          gradientId,
          style: circleStyleForStack,
          strokeLinecap: mergedStrokeLinecap,
          strokeWidth,
          gapDegree,
          ref: (elem) => {
            paths[index3] = elem;
          },
          size: VIEW_BOX_SIZE
        }
      );
    }).reverse();
  }, "getStokeList");
  const getStepStokeList = /* @__PURE__ */ __name(() => {
    const current = Math.round(stepCount * (percentList[0] / 100));
    const stepPtg = 100 / stepCount;
    let stackPtg = 0;
    return new Array(stepCount).fill(null).map((_, index3) => {
      const color = index3 <= current - 1 ? strokeColorList[0] : trailColor;
      const stroke = color && typeof color === "object" ? `url(#${gradientId})` : void 0;
      const circleStyleForStack = getCircleStyle(
        perimeter,
        perimeterWithoutGap,
        stackPtg,
        stepPtg,
        rotateDeg,
        gapDegree,
        gapPosition,
        color,
        "butt",
        strokeWidth,
        stepGap
      );
      stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
      return /* @__PURE__ */ React445.createElement(
        "circle",
        {
          key: index3,
          className: `${prefixCls}-circle-path`,
          r: radius,
          cx: halfSize,
          cy: halfSize,
          stroke,
          strokeWidth,
          opacity: 1,
          style: circleStyleForStack,
          ref: (elem) => {
            paths[index3] = elem;
          }
        }
      );
    });
  }, "getStepStokeList");
  return /* @__PURE__ */ React445.createElement(
    "svg",
    {
      className: (0, import_classnames196.default)(`${prefixCls}-circle`, className),
      viewBox: `0 0 ${VIEW_BOX_SIZE} ${VIEW_BOX_SIZE}`,
      style: style2,
      id,
      role: "presentation",
      ...restProps
    },
    !stepCount && /* @__PURE__ */ React445.createElement(
      "circle",
      {
        className: `${prefixCls}-circle-trail`,
        r: radius,
        cx: halfSize,
        cy: halfSize,
        stroke: trailColor,
        strokeLinecap: mergedStrokeLinecap,
        strokeWidth: trailWidth || strokeWidth,
        style: circleStyle
      }
    ),
    stepCount ? getStepStokeList() : getStokeList()
  );
}, "Circle");
if (true) {
  Circle.displayName = "Circle";
}
var Circle_default = Circle;

// packages/ant-design/components/progress/utils.ts
init_src();
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
__name(validProgress, "validProgress");
function getSuccessPercent({ success, successPercent }) {
  let percent = successPercent;
  if (success && "progress" in success) {
    percent = success.progress;
  }
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
__name(getSuccessPercent, "getSuccessPercent");
var getPercentage = /* @__PURE__ */ __name(({ percent, success, successPercent }) => {
  const realSuccessPercent = validProgress(getSuccessPercent({ success, successPercent }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}, "getPercentage");
var getStrokeColor = /* @__PURE__ */ __name(({
  success = {},
  strokeColor
}) => {
  const { strokeColor: successColor } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}, "getStrokeColor");
var getSize2 = /* @__PURE__ */ __name((size, type5, extra) => {
  let width = -1;
  let height = -1;
  if (type5 === "step") {
    const steps = extra.steps;
    const strokeWidth = extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      width = size === "small" ? 2 : 14;
      height = strokeWidth ?? 8;
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = 14, height = 8] = size;
    }
    width *= steps;
  } else if (type5 === "line") {
    const strokeWidth = extra?.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      height = strokeWidth || (size === "small" ? 6 : 8);
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = -1, height = 8] = size;
    }
  } else if (type5 === "circle" || type5 === "dashboard") {
    if (typeof size === "string" || typeof size === "undefined") {
      [width, height] = size === "small" ? [60, 60] : [120, 120];
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      width = size[0] ?? size[1] ?? 120;
      height = size[0] ?? size[1] ?? 120;
    }
  }
  return [width, height];
}, "getSize");

// packages/ant-design/components/progress/Circle.tsx
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = /* @__PURE__ */ __name((width) => CIRCLE_MIN_STROKE_WIDTH / width * 100, "getMinPercent");
var Circle2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    trailColor = null,
    strokeLinecap = "round",
    gapPosition,
    gapDegree,
    width: originWidth = 120,
    type: type5,
    children,
    success,
    size = originWidth,
    steps
  } = props;
  const [width, height] = getSize2(size, "circle");
  let { strokeWidth } = props;
  if (strokeWidth === void 0) {
    strokeWidth = Math.max(getMinPercent(width), 6);
  }
  const circleStyle = { width, height, fontSize: width * 0.15 + 6 };
  const realGapDegree = React446.useMemo(() => {
    if (gapDegree || gapDegree === 0) {
      return gapDegree;
    }
    if (type5 === "dashboard") {
      return 75;
    }
    return void 0;
  }, [gapDegree, type5]);
  const percentArray = getPercentage(props);
  const gapPos = gapPosition || type5 === "dashboard" && "bottom" || void 0;
  const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
  const strokeColor = getStrokeColor({ success, strokeColor: props.strokeColor });
  const wrapperClassName = (0, import_classnames197.default)(`${prefixCls}-inner`, {
    [`${prefixCls}-circle-gradient`]: isGradient
  });
  const circleContent = /* @__PURE__ */ React446.createElement(
    Circle_default,
    {
      steps,
      percent: steps ? percentArray[1] : percentArray,
      strokeWidth,
      trailWidth: strokeWidth,
      strokeColor: steps ? strokeColor[1] : strokeColor,
      strokeLinecap,
      trailColor,
      prefixCls,
      gapDegree: realGapDegree,
      gapPosition: gapPos
    }
  );
  return /* @__PURE__ */ React446.createElement("div", { className: wrapperClassName, style: circleStyle }, width <= 20 ? /* @__PURE__ */ React446.createElement(tooltip_default, { title: children }, /* @__PURE__ */ React446.createElement("span", null, circleContent)) : /* @__PURE__ */ React446.createElement(React446.Fragment, null, circleContent, children));
}, "Circle");
var Circle_default2 = Circle2;

// packages/ant-design/components/progress/Line.tsx
init_src();
import * as React447 from "react";

// packages/ant-design/components/progress/style/index.ts
var LineStrokeColorVar = "--progress-line-stroke-color";
var Percent = "--progress-percent";
var genAntProgressActive = /* @__PURE__ */ __name((isRtl) => {
  const direction = isRtl ? "100%" : "-100%";
  return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
    "0%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.1
    },
    "20%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.5
    },
    to: {
      transform: "translateX(0) scaleX(1)",
      opacity: 0
    }
  });
}, "genAntProgressActive");
var genBaseStyle12 = /* @__PURE__ */ __name((token2) => {
  const { componentCls: progressCls, iconCls: iconPrefixCls } = token2;
  return {
    [progressCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: token2.fontSize
      },
      [`${progressCls}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${progressCls}-show-info`]: {
        [`${progressCls}-outer`]: {
          marginInlineEnd: `calc(-2em - ${unit(token2.marginXS)})`,
          paddingInlineEnd: `calc(2em + ${unit(token2.paddingXS)})`
        }
      },
      [`${progressCls}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: token2.remainingColor,
        borderRadius: token2.lineBorderRadius
      },
      [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.defaultColor
        }
      },
      [`${progressCls}-success-bg, ${progressCls}-bg`]: {
        position: "relative",
        background: token2.defaultColor,
        borderRadius: token2.lineBorderRadius,
        transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
      },
      [`${progressCls}-bg`]: {
        overflow: "hidden",
        "&::after": {
          content: '""',
          background: {
            _multi_value_: true,
            value: ["inherit", `var(${LineStrokeColorVar})`]
          },
          height: "100%",
          width: `calc(1 / var(${Percent}) * 100%)`,
          display: "block"
        }
      },
      [`${progressCls}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: token2.colorSuccess
      },
      [`${progressCls}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: token2.marginXS,
        color: token2.colorText,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token2.fontSize
        }
      },
      [`&${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: token2.colorBgContainer,
          borderRadius: token2.lineBorderRadius,
          opacity: 0,
          animationName: genAntProgressActive(),
          animationDuration: token2.progressActiveMotionDuration,
          animationTimingFunction: token2.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${progressCls}-rtl${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          animationName: genAntProgressActive(true)
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorError
        },
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      },
      [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorSuccess
        }
      }
    }
  };
}, "genBaseStyle");
var genCircleStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls: progressCls, iconCls: iconPrefixCls } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-circle-trail`]: {
        stroke: token2.remainingColor
      },
      [`&${progressCls}-circle ${progressCls}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${progressCls}-circle ${progressCls}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token2.circleTextColor,
        fontSize: token2.circleTextFontSize,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: token2.circleIconFontSize
        }
      },
      [`${progressCls}-circle&-status-exception`]: {
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`${progressCls}-circle&-status-success`]: {
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, "genCircleStyle");
var genStepStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls: progressCls } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token2.progressStepMinWidth,
          marginInlineEnd: token2.progressStepMarginInlineEnd,
          backgroundColor: token2.remainingColor,
          transition: `all ${token2.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token2.defaultColor
          }
        }
      }
    }
  };
}, "genStepStyle");
var genSmallLine = /* @__PURE__ */ __name((token2) => {
  const { componentCls: progressCls, iconCls: iconPrefixCls } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
        fontSize: token2.fontSizeSM
      }
    }
  };
}, "genSmallLine");
var prepareComponentToken41 = /* @__PURE__ */ __name((token2) => ({
  circleTextColor: token2.colorText,
  defaultColor: token2.colorInfo,
  remainingColor: token2.colorFillSecondary,
  lineBorderRadius: 100,
  // magic for capsule shape, should be a very large number
  circleTextFontSize: "1em",
  circleIconFontSize: `${token2.fontSize / token2.fontSizeSM}em`
}), "prepareComponentToken");
var style_default47 = genStyleHooks(
  "Progress",
  (token2) => {
    const progressStepMarginInlineEnd = token2.calc(token2.marginXXS).div(2).equal();
    const progressToken = merge2(token2, {
      progressStepMarginInlineEnd,
      progressStepMinWidth: progressStepMarginInlineEnd,
      progressActiveMotionDuration: "2.4s"
    });
    return [
      genBaseStyle12(progressToken),
      genCircleStyle(progressToken),
      genStepStyle(progressToken),
      genSmallLine(progressToken)
    ];
  },
  prepareComponentToken41
);

// packages/ant-design/components/progress/Line.tsx
var sortGradient = /* @__PURE__ */ __name((gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const formattedKey = parseFloat(key.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort((a, b) => a.key - b.key);
  return tempArr.map(({ key, value }) => `${value} ${key}%`).join(", ");
}, "sortGradient");
var handleGradient = /* @__PURE__ */ __name((strokeColor, directionConfig) => {
  const {
    from: from2 = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right",
    ...rest
  } = strokeColor;
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest);
    const background2 = `linear-gradient(${direction}, ${sortedGradients})`;
    return { background: background2, [LineStrokeColorVar]: background2 };
  }
  const background = `linear-gradient(${direction}, ${from2}, ${to})`;
  return { background, [LineStrokeColorVar]: background };
}, "handleGradient");
var Line2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    direction: directionConfig,
    percent,
    size,
    strokeWidth,
    strokeColor,
    strokeLinecap = "round",
    children,
    trailColor = null,
    success
  } = props;
  const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : { [LineStrokeColorVar]: strokeColor, background: strokeColor };
  const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
  const mergedSize = size ?? [-1, strokeWidth || (size === "small" ? 6 : 8)];
  const [width, height] = getSize2(mergedSize, "line", { strokeWidth });
  if (true) {
    const warning5 = devUseWarning("Progress");
    warning5.deprecated(!("strokeWidth" in props), "strokeWidth", "size");
  }
  const trailStyle = {
    backgroundColor: trailColor || void 0,
    borderRadius
  };
  const percentStyle = {
    width: `${validProgress(percent)}%`,
    height,
    borderRadius,
    ...backgroundProps,
    [Percent]: validProgress(percent) / 100
  };
  const successPercent = getSuccessPercent(props);
  const successPercentStyle = {
    width: `${validProgress(successPercent)}%`,
    height,
    borderRadius,
    backgroundColor: success?.strokeColor
  };
  const outerStyle = {
    width: width < 0 ? "100%" : width,
    height
  };
  return /* @__PURE__ */ React447.createElement(React447.Fragment, null, /* @__PURE__ */ React447.createElement("div", { className: `${prefixCls}-outer`, style: outerStyle }, /* @__PURE__ */ React447.createElement("div", { className: `${prefixCls}-inner`, style: trailStyle }, /* @__PURE__ */ React447.createElement("div", { className: `${prefixCls}-bg`, style: percentStyle }), successPercent !== void 0 ? /* @__PURE__ */ React447.createElement("div", { className: `${prefixCls}-success-bg`, style: successPercentStyle }) : null)), children);
}, "Line");
var Line_default2 = Line2;

// packages/ant-design/components/progress/Steps.tsx
var import_classnames198 = __toESM(require_classnames());
import * as React448 from "react";
var Steps = /* @__PURE__ */ __name((props) => {
  const {
    size,
    steps,
    percent = 0,
    strokeWidth = 8,
    strokeColor,
    trailColor = null,
    prefixCls,
    children
  } = props;
  const current = Math.round(steps * (percent / 100));
  const stepWidth = size === "small" ? 2 : 14;
  const mergedSize = size ?? [stepWidth, strokeWidth];
  const [width, height] = getSize2(mergedSize, "step", { steps, strokeWidth });
  const unitWidth = width / steps;
  const styledSteps = new Array(steps);
  for (let i = 0; i < steps; i++) {
    const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] = /* @__PURE__ */ React448.createElement(
      "div",
      {
        key: i,
        className: (0, import_classnames198.default)(`${prefixCls}-steps-item`, {
          [`${prefixCls}-steps-item-active`]: i <= current - 1
        }),
        style: {
          backgroundColor: i <= current - 1 ? color : trailColor,
          width: unitWidth,
          height
        }
      }
    );
  }
  return /* @__PURE__ */ React448.createElement("div", { className: `${prefixCls}-steps-outer` }, styledSteps, children);
}, "Steps");
var Steps_default = Steps;

// packages/ant-design/components/progress/progress.tsx
var ProgressStatuses = ["normal", "exception", "active", "success"];
var Progress = React449.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    steps,
    strokeColor,
    percent = 0,
    size = "default",
    showInfo = true,
    type: type5 = "line",
    status,
    format: format2,
    style: style2,
    ...restProps
  } = props;
  const percentNumber = React449.useMemo(() => {
    const successPercent = getSuccessPercent(props);
    return parseInt(
      successPercent !== void 0 ? (successPercent ?? 0)?.toString() : (percent ?? 0)?.toString(),
      10
    );
  }, [percent, props.success, props.successPercent]);
  const progressStatus = React449.useMemo(() => {
    if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
      return "success";
    }
    return status || "normal";
  }, [status, percentNumber]);
  const {
    getPrefixCls,
    direction,
    progress: progressStyle
  } = React449.useContext(ConfigContext);
  const prefixCls = getPrefixCls("progress", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default47(prefixCls);
  const progressInfo = React449.useMemo(() => {
    if (!showInfo) {
      return null;
    }
    const successPercent = getSuccessPercent(props);
    let text;
    const textFormatter = format2 || ((number4) => `${number4}%`);
    const isLineType = type5 === "line";
    if (format2 || progressStatus !== "exception" && progressStatus !== "success") {
      text = textFormatter(validProgress(percent), validProgress(successPercent));
    } else if (progressStatus === "exception") {
      text = isLineType ? /* @__PURE__ */ React449.createElement(import_CloseCircleFilled8.default, null) : /* @__PURE__ */ React449.createElement(import_CloseOutlined11.default, null);
    } else if (progressStatus === "success") {
      text = isLineType ? /* @__PURE__ */ React449.createElement(import_CheckCircleFilled6.default, null) : /* @__PURE__ */ React449.createElement(import_CheckOutlined2.default, null);
    }
    return /* @__PURE__ */ React449.createElement("span", { className: `${prefixCls}-text`, title: typeof text === "string" ? text : void 0 }, text);
  }, [showInfo, percent, percentNumber, progressStatus, type5, prefixCls, format2]);
  if (true) {
    const warning5 = devUseWarning("Progress");
    warning5.deprecated(!("successPercent" in props), "successPercent", "success.percent");
    warning5.deprecated(!("width" in props), "width", "size");
    if ((type5 === "circle" || type5 === "dashboard") && Array.isArray(size)) {
      warning5(
        false,
        "usage",
        'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.'
      );
    }
    if (props.success && "progress" in props.success) {
      warning5.deprecated(false, "success.progress", "success.percent");
    }
  }
  const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
  const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
  let progress;
  if (type5 === "line") {
    progress = steps ? /* @__PURE__ */ React449.createElement(
      Steps_default,
      {
        ...props,
        strokeColor: strokeColorNotGradient,
        prefixCls,
        steps: typeof steps === "object" ? steps.count : steps
      },
      progressInfo
    ) : /* @__PURE__ */ React449.createElement(
      Line_default2,
      {
        ...props,
        strokeColor: strokeColorNotArray,
        prefixCls,
        direction
      },
      progressInfo
    );
  } else if (type5 === "circle" || type5 === "dashboard") {
    progress = /* @__PURE__ */ React449.createElement(
      Circle_default2,
      {
        ...props,
        strokeColor: strokeColorNotArray,
        prefixCls,
        progressStatus
      },
      progressInfo
    );
  }
  const classString = (0, import_classnames199.default)(
    prefixCls,
    `${prefixCls}-status-${progressStatus}`,
    {
      [`${prefixCls}-${type5 === "dashboard" && "circle" || type5}`]: type5 !== "line",
      [`${prefixCls}-inline-circle`]: type5 === "circle" && getSize2(size, "circle")[0] <= 20,
      [`${prefixCls}-line`]: !steps && type5 === "line",
      [`${prefixCls}-steps`]: steps,
      [`${prefixCls}-show-info`]: showInfo,
      [`${prefixCls}-${size}`]: typeof size === "string",
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    progressStyle?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React449.createElement(
      "div",
      {
        ref,
        style: { ...progressStyle?.style, ...style2 },
        className: classString,
        role: "progressbar",
        "aria-valuenow": percentNumber,
        ...omit(restProps, [
          "trailColor",
          "strokeWidth",
          "width",
          "gapDegree",
          "gapPosition",
          "strokeLinecap",
          "success",
          "successPercent"
        ])
      },
      progress
    )
  );
});
if (true) {
  Progress.displayName = "Progress";
}
var progress_default = Progress;

// packages/ant-design/components/progress/index.ts
var progress_default2 = progress_default;

// packages/ant-design/components/qr-code/index.tsx
var import_ReloadOutlined = __toESM(require_ReloadOutlined3());
var import_classnames200 = __toESM(require_classnames());
import React451, { useContext as useContext192 } from "react";

// node_modules/.pnpm/qrcode.react@3.1.0_react@18.2.0/node_modules/qrcode.react/lib/esm/index.js
import React450, { useRef as useRef139, useEffect as useEffect114, useState as useState108 } from "react";
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __spreadValues = /* @__PURE__ */ __name((a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
}, "__spreadValues");
var __objRest = /* @__PURE__ */ __name((source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
}, "__objRest");
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class {
    static {
      __name(this, "_QrCode");
    }
    constructor(version3, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version3;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version3 < _QrCode.MIN_VERSION || version3 > _QrCode.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version3 * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return _QrCode.encodeSegments(segs, ecl);
    }
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode.encodeSegments([seg], ecl);
    }
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)
        throw new RangeError("Invalid value");
      let version3;
      let dataUsedBits;
      for (version3 = minVersion; ; version3++) {
        const dataCapacityBits2 = _QrCode.getNumDataCodewords(version3, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version3);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version3 >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version3, newEcl) * 8)
          ecl = newEcl;
      }
      let bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version3), bb);
        for (const b of seg.getData())
          bb.push(b);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = _QrCode.getNumDataCodewords(version3, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length)
        dataCodewords.push(0);
      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
      return new _QrCode(version3, ecl, dataCodewords, mask);
    }
    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    getModules() {
      return this.modules;
    }
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j = 0; j < numAlign; j++) {
          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color = getBit(bits, i);
        const a = this.size - 11 + i % 3;
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    drawFinderPattern(x, y) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    drawAlignmentPattern(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k = 0; i < numBlocks; i++) {
        let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j) => {
          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j = 0; j < 2; j++) {
            const x = right - j;
            const upward = (right + 1 & 2) == 0;
            const y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    applyMask(mask) {
      if (mask < 0 || mask > 7)
        throw new RangeError("Mask value out of range");
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert)
            this.modules[y][x] = !this.modules[y][x];
        }
      }
    }
    getPenaltyScore() {
      let result = 0;
      for (let y = 0; y < this.size; y++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y = 0; y < this.size; y++) {
          if (this.modules[y][x] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let y = 0; y < this.size - 1; y++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color = this.modules[y][x];
          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
            result += _QrCode.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules)
        dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * _QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    static getNumRawDataModules(ver) {
      if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root = 1;
      for (let i = 0; i < degree; i++) {
        for (let j = 0; j < result.length; j++) {
          result[j] = _QrCode.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length)
            result[j] ^= result[j + 1];
        }
        root = _QrCode.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map((_) => 0);
      for (const b of data) {
        const factor = b ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    static reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
    finderPenaltyCountPatterns(runHistory) {
      const n2 = runHistory[1];
      assert(n2 <= this.size * 3);
      const core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
      return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
    }
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  let QrCode = _QrCode;
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  ];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  ];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb.push(val >>> i & 1);
  }
  __name(appendBits, "appendBits");
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  __name(getBit, "getBit");
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  __name(assert, "assert");
  const _QrSegment = class {
    static {
      __name(this, "_QrSegment");
    }
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    static makeBytes(data) {
      let bb = [];
      for (const b of data)
        appendBits(b, 8, bb);
      return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);
    }
    static makeNumeric(digits) {
      if (!_QrSegment.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb = [];
      for (let i = 0; i < digits.length; ) {
        const n2 = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substr(i, n2), 10), n2 * 3 + 1, bb);
        i += n2;
      }
      return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);
    }
    static makeAlphanumeric(text) {
      if (!_QrSegment.isAlphanumeric(text))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb = [];
      let i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length)
        appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);
    }
    static makeSegments(text) {
      if (text == "")
        return [];
      else if (_QrSegment.isNumeric(text))
        return [_QrSegment.makeNumeric(text)];
      else if (_QrSegment.isAlphanumeric(text))
        return [_QrSegment.makeAlphanumeric(text)];
      else
        return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];
    }
    static makeEci(assignVal) {
      let bb = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);
    }
    static isNumeric(text) {
      return _QrSegment.NUMERIC_REGEX.test(text);
    }
    static isAlphanumeric(text) {
      return _QrSegment.ALPHANUMERIC_REGEX.test(text);
    }
    getData() {
      return this.bitData.slice();
    }
    static getTotalBits(segs, version3) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version3);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substr(i + 1, 2), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  let QrSegment = _QrSegment;
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  let QrCode;
  ((QrCode2) => {
    const _Ecc = class {
      static {
        __name(this, "_Ecc");
      }
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    let Ecc = _Ecc;
    Ecc.LOW = new _Ecc(0, 1);
    Ecc.MEDIUM = new _Ecc(1, 0);
    Ecc.QUARTILE = new _Ecc(2, 3);
    Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = Ecc;
  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  let QrSegment;
  ((QrSegment2) => {
    const _Mode = class {
      static {
        __name(this, "_Mode");
      }
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    let Mode = _Mode;
    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    Mode.BYTE = new _Mode(4, [8, 16, 16]);
    Mode.KANJI = new _Mode(8, [8, 10, 12]);
    Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = Mode;
  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE3 = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var MARGIN_SIZE = 4;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y) {
    let start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
__name(generatePath, "generatePath");
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y) => {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
__name(excavateModules, "excavateModules");
function getImageSettings(cells, size, includeMargin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale = numCells / size;
  const w = (imageSettings.width || defaultSize) * scale;
  const h = (imageSettings.height || defaultSize) * scale;
  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x);
    let floorY = Math.floor(y);
    let ceilW = Math.ceil(w + x - floorX);
    let ceilH = Math.ceil(h + y - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  return { x, y, h, w, excavation };
}
__name(getImageSettings, "getImageSettings");
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e3) {
    return false;
  }
  return true;
}();
function QRCodeCanvas(props) {
  const _a = props, {
    value,
    size = DEFAULT_SIZE3,
    level = DEFAULT_LEVEL,
    bgColor = DEFAULT_BGCOLOR,
    fgColor = DEFAULT_FGCOLOR,
    includeMargin = DEFAULT_INCLUDEMARGIN,
    style: style2,
    imageSettings
  } = _a, otherProps = __objRest(_a, [
    "value",
    "size",
    "level",
    "bgColor",
    "fgColor",
    "includeMargin",
    "style",
    "imageSettings"
  ]);
  const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
  const _canvas = useRef139(null);
  const _image = useRef139(null);
  const [isImgLoaded, setIsImageLoaded] = useState108(false);
  useEffect114(() => {
    if (_canvas.current != null) {
      const canvas = _canvas.current;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      const margin = includeMargin ? MARGIN_SIZE : 0;
      const numCells = cells.length + margin * 2;
      const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
      const image = _image.current;
      const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
      if (haveImageToRender) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
      }
      const pixelRatio = window.devicePixelRatio || 1;
      canvas.height = canvas.width = size * pixelRatio;
      const scale = size / numCells * pixelRatio;
      ctx.scale(scale, scale);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = fgColor;
      if (SUPPORTS_PATH2D) {
        ctx.fill(new Path2D(generatePath(cells, margin)));
      } else {
        cells.forEach(function(row, rdx) {
          row.forEach(function(cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
      if (haveImageToRender) {
        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
      }
    }
  });
  useEffect114(() => {
    setIsImageLoaded(false);
  }, [imgSrc]);
  const canvasStyle = __spreadValues({ height: size, width: size }, style2);
  let img = null;
  if (imgSrc != null) {
    img = /* @__PURE__ */ React450.createElement("img", {
      src: imgSrc,
      key: imgSrc,
      style: { display: "none" },
      onLoad: () => {
        setIsImageLoaded(true);
      },
      ref: _image
    });
  }
  return /* @__PURE__ */ React450.createElement(React450.Fragment, null, /* @__PURE__ */ React450.createElement("canvas", __spreadValues({
    style: canvasStyle,
    height: size,
    width: size,
    ref: _canvas
  }, otherProps)), img);
}
__name(QRCodeCanvas, "QRCodeCanvas");
function QRCodeSVG(props) {
  const _a = props, {
    value,
    size = DEFAULT_SIZE3,
    level = DEFAULT_LEVEL,
    bgColor = DEFAULT_BGCOLOR,
    fgColor = DEFAULT_FGCOLOR,
    includeMargin = DEFAULT_INCLUDEMARGIN,
    imageSettings
  } = _a, otherProps = __objRest(_a, [
    "value",
    "size",
    "level",
    "bgColor",
    "fgColor",
    "includeMargin",
    "imageSettings"
  ]);
  let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
  let image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cells = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image = /* @__PURE__ */ React450.createElement("image", {
      xlinkHref: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none"
    });
  }
  const fgPath = generatePath(cells, margin);
  return /* @__PURE__ */ React450.createElement("svg", __spreadValues({
    height: size,
    width: size,
    viewBox: `0 0 ${numCells} ${numCells}`
  }, otherProps), /* @__PURE__ */ React450.createElement("path", {
    fill: bgColor,
    d: `M0,0 h${numCells}v${numCells}H0z`,
    shapeRendering: "crispEdges"
  }), /* @__PURE__ */ React450.createElement("path", {
    fill: fgColor,
    d: fgPath,
    shapeRendering: "crispEdges"
  }), image);
}
__name(QRCodeSVG, "QRCodeSVG");

// packages/ant-design/components/qr-code/style/index.ts
init_public_api();
var genQRCodeStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, lineWidth, lineType, colorSplit } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: token2.paddingSM,
      backgroundColor: token2.colorWhite,
      borderRadius: token2.borderRadiusLG,
      border: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      [`& > ${componentCls}-mask`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: token2.colorText,
        lineHeight: token2.lineHeight,
        background: token2.QRCodeMaskBackgroundColor,
        textAlign: "center",
        [`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: {
          color: token2.QRCodeTextColor
        }
      },
      "> canvas": {
        alignSelf: "stretch",
        flex: "auto",
        minWidth: 0
      },
      "&-icon": {
        marginBlockEnd: token2.marginXS,
        fontSize: token2.controlHeight
      }
    },
    [`${componentCls}-borderless`]: {
      borderColor: "transparent"
    }
  };
}, "genQRCodeStyle");
var prepareComponentToken42 = /* @__PURE__ */ __name((token2) => ({
  QRCodeMaskBackgroundColor: new TinyColor(token2.colorBgContainer).setAlpha(0.96).toRgbString()
}), "prepareComponentToken");
var style_default48 = genStyleHooks(
  "QRCode",
  (token2) => {
    const mergedToken = merge2(token2, {
      QRCodeTextColor: token2.colorText
    });
    return genQRCodeStyle(mergedToken);
  },
  prepareComponentToken42
);

// packages/ant-design/components/qr-code/index.tsx
var QRCode = /* @__PURE__ */ __name((props) => {
  const [, token2] = useToken();
  const {
    value,
    type: type5 = "canvas",
    icon = "",
    size = 160,
    iconSize = 40,
    color = token2.colorText,
    errorLevel = "M",
    status = "active",
    bordered = true,
    onRefresh,
    style: style2,
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    bgColor = "transparent"
  } = props;
  const { getPrefixCls } = useContext192(ConfigContext);
  const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default48(prefixCls);
  const imageSettings = {
    src: icon,
    x: void 0,
    y: void 0,
    height: iconSize,
    width: iconSize,
    excavate: true
  };
  const qrCodeProps = {
    value,
    size,
    level: errorLevel,
    bgColor,
    fgColor: color,
    style: { width: void 0, height: void 0 },
    imageSettings: icon ? imageSettings : void 0
  };
  const [locale6] = useLocale_default("QRCode");
  if (true) {
    const warning5 = devUseWarning("QRCode");
    warning5(!!value, "usage", "need to receive `value` props");
    warning5(
      !(icon && errorLevel === "L"),
      "usage",
      "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level."
    );
  }
  if (!value) {
    return null;
  }
  const mergedCls = (0, import_classnames200.default)(prefixCls, className, rootClassName, hashId, cssVarCls, {
    [`${prefixCls}-borderless`]: !bordered
  });
  const mergedStyle = {
    width: size,
    height: size,
    backgroundColor: bgColor,
    ...style2
  };
  return wrapCSSVar(
    /* @__PURE__ */ React451.createElement("div", { className: mergedCls, style: mergedStyle }, status !== "active" && /* @__PURE__ */ React451.createElement("div", { className: `${prefixCls}-mask` }, status === "loading" && /* @__PURE__ */ React451.createElement(spin_default, null), status === "expired" && /* @__PURE__ */ React451.createElement(React451.Fragment, null, /* @__PURE__ */ React451.createElement("p", { className: `${prefixCls}-expired` }, locale6?.expired), onRefresh && /* @__PURE__ */ React451.createElement(button_default2, { type: "link", icon: /* @__PURE__ */ React451.createElement(import_ReloadOutlined.default, null), onClick: onRefresh }, locale6?.refresh)), status === "scanned" && /* @__PURE__ */ React451.createElement("p", { className: `${prefixCls}-scanned` }, locale6?.scanned)), type5 === "canvas" ? /* @__PURE__ */ React451.createElement(QRCodeCanvas, { ...qrCodeProps }) : /* @__PURE__ */ React451.createElement(QRCodeSVG, { ...qrCodeProps }))
  );
}, "QRCode");
if (true) {
  QRCode.displayName = "QRCode";
}
var qr_code_default = QRCode;

// packages/ant-design/components/rate/index.tsx
var import_StarFilled = __toESM(require_StarFilled3());
var import_classnames203 = __toESM(require_classnames());
import * as React455 from "react";

// packages/rate/src/Rate.tsx
var import_classnames202 = __toESM(require_classnames());
import React454 from "react";

// packages/rate/src/Star.tsx
import React452 from "react";
var import_classnames201 = __toESM(require_classnames());
function Star(props, ref) {
  const {
    disabled,
    prefixCls,
    character: character2,
    characterRender,
    index: index3,
    count,
    value,
    allowHalf,
    focused,
    onHover,
    onClick
  } = props;
  const onInternalHover = /* @__PURE__ */ __name((e3) => {
    onHover(e3, index3);
  }, "onInternalHover");
  const onInternalClick = /* @__PURE__ */ __name((e3) => {
    onClick(e3, index3);
  }, "onInternalClick");
  const onInternalKeyDown = /* @__PURE__ */ __name((e3) => {
    if (e3.keyCode === KeyCode_default.ENTER) {
      onClick(e3, index3);
    }
  }, "onInternalKeyDown");
  const starValue = index3 + 1;
  const classNameList = /* @__PURE__ */ new Set([prefixCls]);
  if (value === 0 && index3 === 0 && focused) {
    classNameList.add(`${prefixCls}-focused`);
  } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
    classNameList.add(`${prefixCls}-half`);
    classNameList.add(`${prefixCls}-active`);
    if (focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  } else {
    if (starValue <= value) {
      classNameList.add(`${prefixCls}-full`);
    } else {
      classNameList.add(`${prefixCls}-zero`);
    }
    if (starValue === value && focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  }
  const characterNode = typeof character2 === "function" ? character2(props) : character2;
  let start = /* @__PURE__ */ React452.createElement("li", { className: (0, import_classnames201.default)(Array.from(classNameList)), ref }, /* @__PURE__ */ React452.createElement(
    "div",
    {
      onClick: disabled ? null : onInternalClick,
      onKeyDown: disabled ? null : onInternalKeyDown,
      onMouseMove: disabled ? null : onInternalHover,
      role: "radio",
      "aria-checked": value > index3 ? "true" : "false",
      "aria-posinset": index3 + 1,
      "aria-setsize": count,
      tabIndex: disabled ? -1 : 0
    },
    /* @__PURE__ */ React452.createElement("div", { className: `${prefixCls}-first` }, characterNode),
    /* @__PURE__ */ React452.createElement("div", { className: `${prefixCls}-second` }, characterNode)
  ));
  if (characterRender) {
    start = characterRender(start, props);
  }
  return start;
}
__name(Star, "Star");
var Star_default = React452.forwardRef(Star);

// packages/rate/src/useRefs.ts
import * as React453 from "react";
function useRefs() {
  const nodeRef = React453.useRef({});
  function getRef(index3) {
    return nodeRef.current[index3];
  }
  __name(getRef, "getRef");
  function setRef(index3) {
    return (node2) => {
      nodeRef.current[index3] = node2;
    };
  }
  __name(setRef, "setRef");
  return [getRef, setRef];
}
__name(useRefs, "useRefs");

// packages/rate/src/util.ts
function getScroll3(w) {
  let ret = w.pageXOffset;
  const method4 = "scrollLeft";
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d.body[method4];
    }
  }
  return ret;
}
__name(getScroll3, "getScroll");
function getClientPosition(elem) {
  let x;
  let y;
  const doc = elem.ownerDocument;
  const { body } = doc;
  const docElem = doc && doc.documentElement;
  const box2 = elem.getBoundingClientRect();
  x = box2.left;
  y = box2.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
__name(getClientPosition, "getClientPosition");
function getOffsetLeft(el) {
  const pos = getClientPosition(el);
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll3(w);
  return pos.left;
}
__name(getOffsetLeft, "getOffsetLeft");

// packages/rate/src/Rate.tsx
function Rate(props, ref) {
  const {
    // Base
    prefixCls = "rc-rate",
    className,
    // Value
    defaultValue,
    value: propValue,
    count = 5,
    allowHalf = false,
    allowClear = true,
    // Display
    character: character2 = "\u2605",
    characterRender,
    // Meta
    disabled,
    direction = "ltr",
    tabIndex = 0,
    autoFocus,
    // Events
    onHoverChange,
    onChange,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onMouseLeave,
    ...restProps
  } = props;
  const [getStarRef, setStarRef] = useRefs();
  const rateRef = React454.useRef(null);
  const triggerFocus3 = /* @__PURE__ */ __name(() => {
    if (!disabled) {
      rateRef.current?.focus();
    }
  }, "triggerFocus");
  React454.useImperativeHandle(ref, () => ({
    focus: triggerFocus3,
    blur: () => {
      if (!disabled) {
        rateRef.current?.blur();
      }
    }
  }));
  const [value, setValue] = useMergedState(defaultValue || 0, {
    value: propValue
  });
  const [cleanedValue, setCleanedValue] = useMergedState(null);
  const getStarValue = /* @__PURE__ */ __name((index3, x) => {
    const reverse = direction === "rtl";
    let starValue = index3 + 1;
    if (allowHalf) {
      const starEle = getStarRef(index3);
      const leftDis = getOffsetLeft(starEle);
      const width = starEle.clientWidth;
      if (reverse && x - leftDis > width / 2) {
        starValue -= 0.5;
      } else if (!reverse && x - leftDis < width / 2) {
        starValue -= 0.5;
      }
    }
    return starValue;
  }, "getStarValue");
  const changeValue = /* @__PURE__ */ __name((nextValue) => {
    setValue(nextValue);
    onChange?.(nextValue);
  }, "changeValue");
  const [focused, setFocused] = React454.useState(false);
  const onInternalFocus = /* @__PURE__ */ __name(() => {
    setFocused(true);
    onFocus?.();
  }, "onInternalFocus");
  const onInternalBlur = /* @__PURE__ */ __name(() => {
    setFocused(false);
    onBlur?.();
  }, "onInternalBlur");
  const [hoverValue, setHoverValue] = React454.useState(null);
  const onHover = /* @__PURE__ */ __name((event, index3) => {
    const nextHoverValue = getStarValue(index3, event.pageX);
    if (nextHoverValue !== cleanedValue) {
      setHoverValue(nextHoverValue);
      setCleanedValue(null);
    }
    onHoverChange?.(nextHoverValue);
  }, "onHover");
  const onMouseLeaveCallback = /* @__PURE__ */ __name((event) => {
    if (!disabled) {
      setHoverValue(null);
      setCleanedValue(null);
      onHoverChange?.(void 0);
    }
    if (event) {
      onMouseLeave?.(event);
    }
  }, "onMouseLeaveCallback");
  const onClick = /* @__PURE__ */ __name((event, index3) => {
    const newValue = getStarValue(index3, event.pageX);
    let isReset = false;
    if (allowClear) {
      isReset = newValue === value;
    }
    onMouseLeaveCallback();
    changeValue(isReset ? 0 : newValue);
    setCleanedValue(isReset ? newValue : null);
  }, "onClick");
  const onInternalKeyDown = /* @__PURE__ */ __name((event) => {
    const { keyCode } = event;
    const reverse = direction === "rtl";
    let nextValue = value;
    if (keyCode === KeyCode_default.RIGHT && nextValue < count && !reverse) {
      if (allowHalf) {
        nextValue += 0.5;
      } else {
        nextValue += 1;
      }
      changeValue(nextValue);
      event.preventDefault();
    } else if (keyCode === KeyCode_default.LEFT && nextValue > 0 && !reverse) {
      if (allowHalf) {
        nextValue -= 0.5;
      } else {
        nextValue -= 1;
      }
      changeValue(nextValue);
      event.preventDefault();
    } else if (keyCode === KeyCode_default.RIGHT && nextValue > 0 && reverse) {
      if (allowHalf) {
        nextValue -= 0.5;
      } else {
        nextValue -= 1;
      }
      changeValue(nextValue);
      event.preventDefault();
    } else if (keyCode === KeyCode_default.LEFT && nextValue < count && reverse) {
      if (allowHalf) {
        nextValue += 0.5;
      } else {
        nextValue += 1;
      }
      changeValue(nextValue);
      event.preventDefault();
    }
    onKeyDown2?.(event);
  }, "onInternalKeyDown");
  React454.useEffect(() => {
    if (autoFocus && !disabled) {
      triggerFocus3();
    }
  }, []);
  const starNodes = new Array(count).fill(0).map((item, index3) => /* @__PURE__ */ React454.createElement(
    Star_default,
    {
      ref: setStarRef(index3),
      index: index3,
      count,
      disabled,
      prefixCls: `${prefixCls}-star`,
      allowHalf,
      value: hoverValue === null ? value : hoverValue,
      onClick,
      onHover,
      key: item || index3,
      character: character2,
      characterRender,
      focused
    }
  ));
  const classString = (0, import_classnames202.default)(prefixCls, className, {
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  return /* @__PURE__ */ React454.createElement(
    "ul",
    {
      className: classString,
      onMouseLeave: onMouseLeaveCallback,
      tabIndex: disabled ? -1 : tabIndex,
      onFocus: disabled ? null : onInternalFocus,
      onBlur: disabled ? null : onInternalBlur,
      onKeyDown: disabled ? null : onInternalKeyDown,
      ref: rateRef,
      role: "radiogroup",
      ...pickAttrs(restProps, { aria: true, data: true, attr: true })
    },
    starNodes
  );
}
__name(Rate, "Rate");
var Rate_default = React454.forwardRef(Rate);

// packages/rate/src/index.tsx
var src_default23 = Rate_default;

// packages/ant-design/components/rate/style/index.ts
var genRateStarStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: token2.marginXS
      },
      "> div": {
        transition: `all ${token2.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: token2.starHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${unit(token2.lineWidth)} dashed ${token2.starColor}`,
          transform: token2.starHoverScale
        }
      },
      "&-first, &-second": {
        color: token2.starBg,
        transition: `all ${token2.motionDurationMid}`,
        userSelect: "none"
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: {
        opacity: 1
      },
      [`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: {
        color: "inherit"
      }
    }
  };
}, "genRateStarStyle");
var genRateRtlStyle = /* @__PURE__ */ __name((token2) => ({
  [`&-rtl${token2.componentCls}`]: {
    direction: "rtl"
  }
}), "genRateRtlStyle");
var genRateStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: token2.starColor,
      fontSize: token2.starSize,
      lineHeight: 1,
      listStyle: "none",
      outline: "none",
      // disable styles
      [`&-disabled${componentCls} ${componentCls}-star`]: {
        cursor: "default",
        "> div:hover": {
          transform: "scale(1)"
        }
      },
      // star styles
      ...genRateStarStyle(token2),
      // rtl styles
      ...genRateRtlStyle(token2)
    }
  };
}, "genRateStyle");
var prepareComponentToken43 = /* @__PURE__ */ __name((token2) => ({
  starColor: token2.yellow6,
  starSize: token2.controlHeightLG * 0.5,
  starHoverScale: "scale(1.1)",
  starBg: token2.colorFillContent
}), "prepareComponentToken");
var style_default49 = genStyleHooks(
  "Rate",
  (token2) => {
    const rateToken = merge2(token2, {});
    return [genRateStyle(rateToken)];
  },
  prepareComponentToken43
);

// packages/ant-design/components/rate/index.tsx
var Rate2 = React455.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    tooltips,
    character: character2 = /* @__PURE__ */ React455.createElement(import_StarFilled.default, null),
    ...rest
  } = props;
  const characterRender = /* @__PURE__ */ __name((node2, { index: index3 }) => {
    if (!tooltips) {
      return node2;
    }
    return /* @__PURE__ */ React455.createElement(tooltip_default, { title: tooltips[index3] }, node2);
  }, "characterRender");
  const { getPrefixCls, direction, rate } = React455.useContext(ConfigContext);
  const ratePrefixCls = getPrefixCls("rate", prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default49(ratePrefixCls);
  const mergedStyle = { ...rate?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React455.createElement(
      src_default23,
      {
        ref,
        character: character2,
        characterRender,
        ...rest,
        className: (0, import_classnames203.default)(className, rootClassName, hashId, cssVarCls, rate?.className),
        style: mergedStyle,
        prefixCls: ratePrefixCls,
        direction
      }
    )
  );
});
if (true) {
  Rate2.displayName = "Rate";
}
var rate_default = Rate2;

// packages/ant-design/components/result/index.tsx
var import_CheckCircleFilled7 = __toESM(require_CheckCircleFilled3());
var import_CloseCircleFilled9 = __toESM(require_CloseCircleFilled3());
var import_ExclamationCircleFilled8 = __toESM(require_ExclamationCircleFilled3());
var import_WarningFilled = __toESM(require_WarningFilled3());
var import_classnames204 = __toESM(require_classnames());
import * as React459 from "react";

// packages/ant-design/components/result/noFound.tsx
import * as React456 from "react";
var NoFound = /* @__PURE__ */ __name(() => /* @__PURE__ */ React456.createElement("svg", { width: "252", height: "294" }, /* @__PURE__ */ React456.createElement("defs", null, /* @__PURE__ */ React456.createElement("path", { d: "M0 .387h251.772v251.772H0z" })), /* @__PURE__ */ React456.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ React456.createElement("g", { transform: "translate(0 .012)" }, /* @__PURE__ */ React456.createElement("mask", { fill: "#fff" }), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    fill: "#E4EBF7",
    mask: "url(#b)"
  }
)), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    stroke: "#FFF",
    strokeWidth: "2",
    d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    fill: "#1677ff"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    fill: "#FFB594"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    fill: "#7BB2F9"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M107.275 222.1s2.773-1.11 6.102-3.884",
    stroke: "#648BD8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    fill: "#192064"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    fill: "#FFF"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    fill: "#192064"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    fill: "#520038"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    fill: "#552950"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M110.846 74.481s1.79-.716 2.506.537",
    stroke: "#5C2552",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M103.287 72.93s1.83 1.113 4.137.954",
    stroke: "#5C2552",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M119.306 107.329s.452 4.366-2.127 32.062",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    fill: "#F2D7AD"
  }
), /* @__PURE__ */ React456.createElement("path", { d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92", fill: "#F4D19D" }), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    fill: "#F2D7AD"
  }
), /* @__PURE__ */ React456.createElement("path", { fill: "#CC9B6E", d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z" }), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    fill: "#F4D19D"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    fill: "#CC9B6E",
    d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    fill: "#CC9B6E",
    d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    fill: "#5BA02E"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    fill: "#92C110"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    fill: "#F2D7AD"
  }
), /* @__PURE__ */ React456.createElement(
  "path",
  {
    d: "M88.979 89.48s7.776 5.384 16.6 2.842",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
))), "NoFound");
var noFound_default = NoFound;

// packages/ant-design/components/result/serverError.tsx
import * as React457 from "react";
var ServerError = /* @__PURE__ */ __name(() => /* @__PURE__ */ React457.createElement("svg", { width: "254", height: "294" }, /* @__PURE__ */ React457.createElement("defs", null, /* @__PURE__ */ React457.createElement("path", { d: "M0 .335h253.49v253.49H0z" }), /* @__PURE__ */ React457.createElement("path", { d: "M0 293.665h253.49V.401H0z" })), /* @__PURE__ */ React457.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ React457.createElement("g", { transform: "translate(0 .067)" }, /* @__PURE__ */ React457.createElement("mask", { fill: "#fff" }), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    fill: "#E4EBF7",
    mask: "url(#b)"
  }
)), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    fill: "#FF603B"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    fill: "#FFB594"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    fill: "#FFB594"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    fill: "#520038"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    fill: "#552950"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    stroke: "#DB836E",
    strokeWidth: "1.063",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M99.926 73.284s1.8-.72 2.52.54",
    stroke: "#5C2552",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    stroke: "#DB836E",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M92.326 71.724s1.84 1.12 4.16.96",
    stroke: "#5C2552",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    stroke: "#DB836E",
    strokeWidth: "1.063",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    stroke: "#E4EBF7",
    strokeWidth: "1.136",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    fill: "#7BB2F9"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M96.973 219.373s2.882-1.153 6.34-4.034",
    stroke: "#648BD8",
    strokeWidth: "1.032",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    fill: "#192064"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    fill: "#FFF"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    fill: "#192064"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    stroke: "#DB836E",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M109.278 112.533s3.38-3.613 7.575-4.662",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M107.375 123.006s9.697-2.745 11.445-.88",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    stroke: "#BFCDDD",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    fill: "#A3B4C6"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    fill: "#A3B4C6"
  }
), /* @__PURE__ */ React457.createElement("mask", { fill: "#fff" }), /* @__PURE__ */ React457.createElement("path", { fill: "#A3B4C6", mask: "url(#d)", d: "M154.098 190.096h70.513v-84.617h-70.513z" }), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    fill: "#FFF",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    stroke: "#7C90A5",
    strokeWidth: "1.124",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    fill: "#FFF",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M177.259 207.217v11.52M201.05 207.217v11.52",
    stroke: "#A3B4C6",
    strokeWidth: "1.124",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    fill: "#5BA02E",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    fill: "#92C110",
    mask: "url(#d)"
  }
), /* @__PURE__ */ React457.createElement(
  "path",
  {
    d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    fill: "#F2D7AD",
    mask: "url(#d)"
  }
))), "ServerError");
var serverError_default = ServerError;

// packages/ant-design/components/result/style/index.ts
var genBaseStyle13 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineHeightHeading3,
    iconCls,
    padding,
    paddingXL,
    paddingXS,
    paddingLG,
    marginXS,
    lineHeight
  } = token2;
  return {
    // Result
    [componentCls]: {
      padding: `${unit(token2.calc(paddingLG).mul(2).equal())} ${unit(paddingXL)}`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${componentCls} ${componentCls}-image`]: {
      width: token2.imageWidth,
      height: token2.imageHeight,
      margin: "auto"
    },
    [`${componentCls} ${componentCls}-icon`]: {
      marginBottom: paddingLG,
      textAlign: "center",
      [`& > ${iconCls}`]: {
        fontSize: token2.iconFontSize
      }
    },
    [`${componentCls} ${componentCls}-title`]: {
      color: token2.colorTextHeading,
      fontSize: token2.titleFontSize,
      lineHeight: lineHeightHeading3,
      marginBlock: marginXS,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-subtitle`]: {
      color: token2.colorTextDescription,
      fontSize: token2.subtitleFontSize,
      lineHeight,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-content`]: {
      marginTop: paddingLG,
      padding: `${unit(paddingLG)} ${unit(token2.calc(padding).mul(2.5).equal())}`,
      backgroundColor: token2.colorFillAlter
    },
    [`${componentCls} ${componentCls}-extra`]: {
      margin: token2.extraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: paddingXS,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
}, "genBaseStyle");
var genStatusIconStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls } = token2;
  return {
    [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultSuccessIconColor
    },
    [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultErrorIconColor
    },
    [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultInfoIconColor
    },
    [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultWarningIconColor
    }
  };
}, "genStatusIconStyle");
var genResultStyle = /* @__PURE__ */ __name((token2) => [
  genBaseStyle13(token2),
  genStatusIconStyle(token2)
], "genResultStyle");
var getStyle3 = /* @__PURE__ */ __name((token2) => genResultStyle(token2), "getStyle");
var prepareComponentToken44 = /* @__PURE__ */ __name((token2) => ({
  titleFontSize: token2.fontSizeHeading3,
  subtitleFontSize: token2.fontSize,
  iconFontSize: token2.fontSizeHeading3 * 3,
  extraMargin: `${token2.paddingLG}px 0 0 0`
}), "prepareComponentToken");
var style_default50 = genStyleHooks(
  "Result",
  (token2) => {
    const resultInfoIconColor = token2.colorInfo;
    const resultErrorIconColor = token2.colorError;
    const resultSuccessIconColor = token2.colorSuccess;
    const resultWarningIconColor = token2.colorWarning;
    const resultToken = merge2(token2, {
      resultInfoIconColor,
      resultErrorIconColor,
      resultSuccessIconColor,
      resultWarningIconColor,
      imageWidth: 250,
      imageHeight: 295
    });
    return [getStyle3(resultToken)];
  },
  prepareComponentToken44
);

// packages/ant-design/components/result/unauthorized.tsx
import * as React458 from "react";
var Unauthorized = /* @__PURE__ */ __name(() => /* @__PURE__ */ React458.createElement("svg", { width: "251", height: "294" }, /* @__PURE__ */ React458.createElement("g", { fill: "none", fillRule: "evenodd" }, /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    fill: "#E4EBF7"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    stroke: "#FFF",
    strokeWidth: "2"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    stroke: "#FFF",
    strokeWidth: "2",
    d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    fill: "#A26EF4"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    fill: "#5BA02E"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    fill: "#92C110"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    fill: "#F2D7AD"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    fill: "#FFB594"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M78.18 94.656s.911 7.41-4.914 13.078",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    stroke: "#E4EBF7",
    strokeWidth: ".932",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    fill: "#FFB594"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    fill: "#5C2552"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    fill: "#552950"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M91.132 86.786s5.269 4.957 12.679 2.327",
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    fill: "#DB836E"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    stroke: "#5C2552",
    strokeWidth: "1.526",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
    stroke: "#E4EBF7",
    strokeWidth: "1.114",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M128.31 87.934s3.013 4.121 4.06 11.785",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
    stroke: "#DB836E",
    strokeWidth: ".795",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    fill: "#FFC6A0"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M130.532 85.488s4.588 5.757 11.619 6.214",
    stroke: "#DB836E",
    strokeWidth: ".75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M121.708 105.73s-.393 8.564-1.34 13.612",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    fill: "#CBD1D1"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    fill: "#2B0849"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    fill: "#A4AABA"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    fill: "#7BB2F9"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M108.459 220.905s2.759-1.104 6.07-3.863",
    stroke: "#648BD8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    fill: "#192064"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    fill: "#FFF"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    fill: "#192064"
  }
), /* @__PURE__ */ React458.createElement(
  "path",
  {
    d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
))), "Unauthorized");
var unauthorized_default = Unauthorized;

// packages/ant-design/components/result/index.tsx
var IconMap = {
  success: import_CheckCircleFilled7.default,
  error: import_CloseCircleFilled9.default,
  info: import_ExclamationCircleFilled8.default,
  warning: import_WarningFilled.default
};
var ExceptionMap = {
  "404": noFound_default,
  "500": serverError_default,
  "403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon3 = /* @__PURE__ */ __name(({ prefixCls, icon, status }) => {
  const className = (0, import_classnames204.default)(`${prefixCls}-icon`);
  if (true) {
    const warning5 = devUseWarning("Result");
    warning5(
      !(typeof icon === "string" && icon.length > 2),
      "breaking",
      `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`
    );
  }
  if (ExceptionStatus.includes(`${status}`)) {
    const SVGComponent = ExceptionMap[status];
    return /* @__PURE__ */ React459.createElement("div", { className: `${className} ${prefixCls}-image` }, /* @__PURE__ */ React459.createElement(SVGComponent, null));
  }
  const iconNode = React459.createElement(
    IconMap[status]
  );
  if (icon === null || icon === false) {
    return null;
  }
  return /* @__PURE__ */ React459.createElement("div", { className }, icon || iconNode);
}, "Icon");
var Extra = /* @__PURE__ */ __name(({ prefixCls, extra }) => {
  if (!extra) {
    return null;
  }
  return /* @__PURE__ */ React459.createElement("div", { className: `${prefixCls}-extra` }, extra);
}, "Extra");
var Result = /* @__PURE__ */ __name(({
  prefixCls: customizePrefixCls,
  className: customizeClassName,
  rootClassName,
  subTitle,
  title,
  style: style2,
  children,
  status = "info",
  icon,
  extra
}) => {
  const { getPrefixCls, direction, result } = React459.useContext(ConfigContext);
  const prefixCls = getPrefixCls("result", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default50(prefixCls);
  const className = (0, import_classnames204.default)(
    prefixCls,
    `${prefixCls}-${status}`,
    customizeClassName,
    result?.className,
    rootClassName,
    { [`${prefixCls}-rtl`]: direction === "rtl" },
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...result?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React459.createElement("div", { className, style: mergedStyle }, /* @__PURE__ */ React459.createElement(Icon3, { prefixCls, status, icon }), /* @__PURE__ */ React459.createElement("div", { className: `${prefixCls}-title` }, title), subTitle && /* @__PURE__ */ React459.createElement("div", { className: `${prefixCls}-subtitle` }, subTitle), /* @__PURE__ */ React459.createElement(Extra, { prefixCls, extra }), children && /* @__PURE__ */ React459.createElement("div", { className: `${prefixCls}-content` }, children))
  );
}, "Result");
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
if (true) {
  Result.displayName = "Result";
}
var result_default = Result;

// packages/ant-design/components/row/index.ts
var row_default2 = row_default;

// packages/ant-design/components/segmented/index.tsx
var import_classnames207 = __toESM(require_classnames());
import * as React462 from "react";

// packages/segmented/src/index.tsx
var import_classnames206 = __toESM(require_classnames());
import * as React461 from "react";

// packages/segmented/src/MotionThumb.tsx
var import_classnames205 = __toESM(require_classnames());
import * as React460 from "react";
var calcThumbStyle = /* @__PURE__ */ __name((targetElement) => targetElement ? {
  left: targetElement.offsetLeft,
  right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
  width: targetElement.clientWidth
} : null, "calcThumbStyle");
var toPX = /* @__PURE__ */ __name((value) => value !== void 0 ? `${value}px` : void 0, "toPX");
function MotionThumb(props) {
  const {
    prefixCls,
    containerRef,
    value,
    getValueIndex,
    motionName,
    onMotionStart,
    onMotionEnd,
    direction
  } = props;
  const thumbRef = React460.useRef(null);
  const [prevValue, setPrevValue] = React460.useState(value);
  const findValueElement = /* @__PURE__ */ __name((val) => {
    const index3 = getValueIndex(val);
    const ele = containerRef.current?.querySelectorAll(
      `.${prefixCls}-item`
    )[index3];
    return ele?.offsetParent && ele;
  }, "findValueElement");
  const [prevStyle, setPrevStyle] = React460.useState(null);
  const [nextStyle, setNextStyle] = React460.useState(null);
  useLayoutEffect_default(() => {
    if (prevValue !== value) {
      const prev2 = findValueElement(prevValue);
      const next2 = findValueElement(value);
      const calcPrevStyle = calcThumbStyle(prev2);
      const calcNextStyle = calcThumbStyle(next2);
      setPrevValue(value);
      setPrevStyle(calcPrevStyle);
      setNextStyle(calcNextStyle);
      if (prev2 && next2) {
        onMotionStart();
      } else {
        onMotionEnd();
      }
    }
  }, [value]);
  const thumbStart = React460.useMemo(
    () => direction === "rtl" ? toPX(-prevStyle?.right) : toPX(prevStyle?.left),
    [direction, prevStyle]
  );
  const thumbActive = React460.useMemo(
    () => direction === "rtl" ? toPX(-nextStyle?.right) : toPX(nextStyle?.left),
    [direction, nextStyle]
  );
  const onAppearStart = /* @__PURE__ */ __name(() => {
    return {
      transform: `translateX(var(--thumb-start-left))`,
      width: `var(--thumb-start-width)`
    };
  }, "onAppearStart");
  const onAppearActive = /* @__PURE__ */ __name(() => {
    return {
      transform: `translateX(var(--thumb-active-left))`,
      width: `var(--thumb-active-width)`
    };
  }, "onAppearActive");
  const onVisibleChanged = /* @__PURE__ */ __name(() => {
    setPrevStyle(null);
    setNextStyle(null);
    onMotionEnd();
  }, "onVisibleChanged");
  if (!prevStyle || !nextStyle) {
    return null;
  }
  return /* @__PURE__ */ React460.createElement(
    src_default2,
    {
      visible: true,
      motionName,
      motionAppear: true,
      onAppearStart,
      onAppearActive,
      onVisibleChanged
    },
    ({ className: motionClassName, style: motionStyle }, ref) => {
      const mergedStyle = {
        ...motionStyle,
        "--thumb-start-left": thumbStart,
        "--thumb-start-width": toPX(prevStyle?.width),
        "--thumb-active-left": thumbActive,
        "--thumb-active-width": toPX(nextStyle?.width)
      };
      const motionProps = {
        ref: composeRef(thumbRef, ref),
        style: mergedStyle,
        className: (0, import_classnames205.default)(`${prefixCls}-thumb`, motionClassName)
      };
      if (false) {
        motionProps["data-test-style"] = JSON.stringify(mergedStyle);
      }
      return /* @__PURE__ */ React460.createElement("div", { ...motionProps });
    }
  );
}
__name(MotionThumb, "MotionThumb");

// packages/segmented/src/index.tsx
function getValidTitle(option) {
  if (typeof option.title !== "undefined") {
    return option.title;
  }
  if (typeof option.label !== "object") {
    return option.label?.toString();
  }
}
__name(getValidTitle, "getValidTitle");
function normalizeOptions(options) {
  return options.map((option) => {
    if (typeof option === "object" && option !== null) {
      const validTitle = getValidTitle(option);
      return {
        ...option,
        title: validTitle
      };
    }
    return {
      label: option?.toString(),
      title: option?.toString(),
      value: option
    };
  });
}
__name(normalizeOptions, "normalizeOptions");
var InternalSegmentedOption = /* @__PURE__ */ __name(({
  prefixCls,
  className,
  disabled,
  checked,
  label,
  title,
  value,
  onChange
}) => {
  const handleChange = /* @__PURE__ */ __name((event) => {
    if (disabled) {
      return;
    }
    onChange(event, value);
  }, "handleChange");
  return /* @__PURE__ */ React461.createElement(
    "label",
    {
      className: (0, import_classnames206.default)(className, {
        [`${prefixCls}-item-disabled`]: disabled
      })
    },
    /* @__PURE__ */ React461.createElement(
      "input",
      {
        className: `${prefixCls}-item-input`,
        type: "radio",
        disabled,
        checked,
        onChange: handleChange
      }
    ),
    /* @__PURE__ */ React461.createElement("div", { className: `${prefixCls}-item-label`, title }, label)
  );
}, "InternalSegmentedOption");
var Segmented = React461.forwardRef(
  (props, ref) => {
    const {
      prefixCls = "rc-segmented",
      direction,
      options = [],
      disabled,
      defaultValue,
      value,
      onChange,
      className = "",
      motionName = "thumb-motion",
      ...restProps
    } = props;
    const containerRef = React461.useRef(null);
    const mergedRef = React461.useMemo(
      () => composeRef(containerRef, ref),
      [containerRef, ref]
    );
    const segmentedOptions = React461.useMemo(() => {
      return normalizeOptions(options);
    }, [options]);
    const [rawValue, setRawValue] = useMergedState(segmentedOptions[0]?.value, {
      value,
      defaultValue
    });
    const [thumbShow, setThumbShow] = React461.useState(false);
    const handleChange = /* @__PURE__ */ __name((event, val) => {
      if (disabled) {
        return;
      }
      setRawValue(val);
      onChange?.(val);
    }, "handleChange");
    const divProps = omit(restProps, ["children"]);
    return /* @__PURE__ */ React461.createElement(
      "div",
      {
        ...divProps,
        className: (0, import_classnames206.default)(
          prefixCls,
          {
            [`${prefixCls}-rtl`]: direction === "rtl",
            [`${prefixCls}-disabled`]: disabled
          },
          className
        ),
        ref: mergedRef
      },
      /* @__PURE__ */ React461.createElement("div", { className: `${prefixCls}-group` }, /* @__PURE__ */ React461.createElement(
        MotionThumb,
        {
          prefixCls,
          value: rawValue,
          containerRef,
          motionName: `${prefixCls}-${motionName}`,
          direction,
          getValueIndex: (val) => segmentedOptions.findIndex((n2) => n2.value === val),
          onMotionStart: () => {
            setThumbShow(true);
          },
          onMotionEnd: () => {
            setThumbShow(false);
          }
        }
      ), segmentedOptions.map((segmentedOption) => /* @__PURE__ */ React461.createElement(
        InternalSegmentedOption,
        {
          ...segmentedOption,
          key: segmentedOption.value,
          prefixCls,
          className: (0, import_classnames206.default)(
            segmentedOption.className,
            `${prefixCls}-item`,
            {
              [`${prefixCls}-item-selected`]: segmentedOption.value === rawValue && !thumbShow
            }
          ),
          checked: segmentedOption.value === rawValue,
          onChange: handleChange,
          disabled: !!disabled || !!segmentedOption.disabled
        }
      )))
    );
  }
);
if (true) {
  Segmented.displayName = "Segmented";
}
var TypedSegmented = Segmented;
var src_default24 = TypedSegmented;

// packages/ant-design/components/segmented/style/index.ts
function getItemDisabledStyle(cls5, token2) {
  return {
    [`${cls5}, ${cls5}:hover, ${cls5}:focus`]: {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
__name(getItemDisabledStyle, "getItemDisabledStyle");
function getItemSelectedStyle(token2) {
  return {
    backgroundColor: token2.itemSelectedBg,
    boxShadow: token2.boxShadowTertiary
  };
}
__name(getItemSelectedStyle, "getItemSelectedStyle");
var segmentedTextEllipsisCss = {
  overflow: "hidden",
  // handle text ellipsis
  ...textEllipsis
};
var genSegmentedStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const labelHeight = token2.calc(token2.controlHeight).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightLG = token2.calc(token2.controlHeightLG).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightSM = token2.calc(token2.controlHeightSM).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      padding: token2.trackPadding,
      color: token2.itemColor,
      background: token2.trackBg,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      [`${componentCls}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        width: "100%"
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: "flex"
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        borderRadius: token2.borderRadiusSM,
        // Fix Safari render bug
        // https://github.com/ant-design/ant-design/issues/45250
        transform: "translateZ(0)",
        "&-selected": {
          ...getItemSelectedStyle(token2),
          color: token2.itemSelectedColor
        },
        "&::after": {
          content: '""',
          position: "absolute",
          zIndex: -1,
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          transition: `background-color ${token2.motionDurationMid}`,
          // This is mandatory to make it not clickable or hoverable
          // Ref: https://github.com/ant-design/ant-design/issues/40888
          pointerEvents: "none"
        },
        [`&:hover:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token2.itemHoverColor,
          "&::after": {
            backgroundColor: token2.itemHoverBg
          }
        },
        [`&:active:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token2.itemHoverColor,
          "&::after": {
            backgroundColor: token2.itemActiveBg
          }
        },
        "&-label": {
          minHeight: labelHeight,
          lineHeight: unit(labelHeight),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          ...segmentedTextEllipsisCss
        },
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: token2.calc(token2.marginSM).div(2).equal()
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: {
        ...getItemSelectedStyle(token2),
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${unit(token2.paddingXXS)} 0`,
        borderRadius: token2.borderRadiusSM,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      },
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token2.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightLG,
          lineHeight: unit(labelHeightLG),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          fontSize: token2.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token2.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightSM,
          lineHeight: unit(labelHeightSM),
          padding: `0 ${unit(token2.segmentedPaddingHorizontalSM)}`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadiusXS
        }
      },
      // disabled styles
      ...getItemDisabledStyle(`&-disabled ${componentCls}-item`, token2),
      ...getItemDisabledStyle(`${componentCls}-item-disabled`, token2),
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOut}, width ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        willChange: "transform, width"
      }
    }
  };
}, "genSegmentedStyle");
var prepareComponentToken45 = /* @__PURE__ */ __name((token2) => {
  const {
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgElevated,
    colorFill,
    lineWidthBold,
    colorBgLayout
  } = token2;
  return {
    trackPadding: lineWidthBold,
    trackBg: colorBgLayout,
    itemColor: colorTextLabel,
    itemHoverColor: colorText,
    itemHoverBg: colorFillSecondary,
    itemSelectedBg: colorBgElevated,
    itemActiveBg: colorFill,
    itemSelectedColor: colorText
  };
}, "prepareComponentToken");
var style_default51 = genStyleHooks(
  "Segmented",
  (token2) => {
    const { lineWidth, calc } = token2;
    const segmentedToken = merge2(token2, {
      segmentedPaddingHorizontal: calc(token2.controlPaddingHorizontal).sub(lineWidth).equal(),
      segmentedPaddingHorizontalSM: calc(token2.controlPaddingHorizontalSM).sub(lineWidth).equal()
    });
    return [genSegmentedStyle(segmentedToken)];
  },
  prepareComponentToken45
);

// packages/ant-design/components/segmented/index.tsx
function isSegmentedLabeledOptionWithIcon(option) {
  return typeof option === "object" && !!option?.icon;
}
__name(isSegmentedLabeledOptionWithIcon, "isSegmentedLabeledOptionWithIcon");
var InternalSegmented = React462.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    block,
    options = [],
    size: customSize = "middle",
    style: style2,
    ...restProps
  } = props;
  const { getPrefixCls, direction, segmented } = React462.useContext(ConfigContext);
  const prefixCls = getPrefixCls("segmented", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default51(prefixCls);
  const mergedSize = useSize_default(customSize);
  const extendedOptions = React462.useMemo(
    () => options.map((option) => {
      if (isSegmentedLabeledOptionWithIcon(option)) {
        const { icon, label, ...restOption } = option;
        return {
          ...restOption,
          label: /* @__PURE__ */ React462.createElement(React462.Fragment, null, /* @__PURE__ */ React462.createElement("span", { className: `${prefixCls}-item-icon` }, icon), label && /* @__PURE__ */ React462.createElement("span", null, label))
        };
      }
      return option;
    }),
    [options, prefixCls]
  );
  const cls5 = (0, import_classnames207.default)(
    className,
    rootClassName,
    segmented?.className,
    {
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large"
    },
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...segmented?.style, ...style2 };
  return wrapCSSVar(
    /* @__PURE__ */ React462.createElement(
      src_default24,
      {
        ...restProps,
        className: cls5,
        style: mergedStyle,
        options: extendedOptions,
        ref,
        prefixCls,
        direction
      }
    )
  );
});
var Segmented2 = InternalSegmented;
if (true) {
  Segmented2.displayName = "Segmented";
}
var segmented_default = Segmented2;

// packages/ant-design/components/slider/index.tsx
var import_classnames214 = __toESM(require_classnames());
import React477 from "react";

// packages/slider/src/Slider.tsx
var import_classnames213 = __toESM(require_classnames());
init_warning();
import * as React474 from "react";

// packages/slider/src/Handles/index.tsx
import * as React465 from "react";

// packages/slider/src/util.ts
function getOffset5(value, min, max) {
  return (value - min) / (max - min);
}
__name(getOffset5, "getOffset");
function getDirectionStyle(direction, value, min, max) {
  const offset3 = getOffset5(value, min, max);
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offset3 * 100}%`;
      positionStyle.transform = "translateX(50%)";
      break;
    case "btt":
      positionStyle.bottom = `${offset3 * 100}%`;
      positionStyle.transform = "translateY(50%)";
      break;
    case "ttb":
      positionStyle.top = `${offset3 * 100}%`;
      positionStyle.transform = "translateY(-50%)";
      break;
    default:
      positionStyle.left = `${offset3 * 100}%`;
      positionStyle.transform = "translateX(-50%)";
      break;
  }
  return positionStyle;
}
__name(getDirectionStyle, "getDirectionStyle");
function getIndex(value, index3) {
  return Array.isArray(value) ? value[index3] : value;
}
__name(getIndex, "getIndex");

// packages/slider/src/Handles/Handle.tsx
var import_classnames208 = __toESM(require_classnames());
import * as React464 from "react";

// packages/slider/src/context.ts
import * as React463 from "react";
var SliderContext = React463.createContext({
  min: 0,
  max: 0,
  direction: "ltr",
  step: 1,
  includedStart: 0,
  includedEnd: 0,
  tabIndex: 0,
  keyboard: true,
  styles: {},
  classNames: {}
});
var context_default11 = SliderContext;

// packages/slider/src/Handles/Handle.tsx
var Handle = React464.forwardRef((props, ref) => {
  const {
    prefixCls,
    value,
    valueIndex,
    onStartMove,
    style: style2,
    render: render2,
    dragging,
    onOffsetChange,
    onChangeComplete,
    onFocus,
    onMouseEnter,
    ...restProps
  } = props;
  const {
    min,
    max,
    direction,
    disabled,
    keyboard,
    range: range3,
    tabIndex,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaValueTextFormatterForHandle,
    styles,
    classNames: classNames253
  } = React464.useContext(context_default11);
  const handlePrefixCls = `${prefixCls}-handle`;
  const onInternalStartMove = /* @__PURE__ */ __name((e3) => {
    if (!disabled) {
      onStartMove(e3, valueIndex);
    }
  }, "onInternalStartMove");
  const onInternalFocus = /* @__PURE__ */ __name((e3) => {
    onFocus?.(e3, valueIndex);
  }, "onInternalFocus");
  const onInternalMouseEnter = /* @__PURE__ */ __name((e3) => {
    onMouseEnter(e3, valueIndex);
  }, "onInternalMouseEnter");
  const onKeyDown2 = /* @__PURE__ */ __name((e3) => {
    if (!disabled && keyboard) {
      let offset3 = null;
      switch (e3.which || e3.keyCode) {
        case KeyCode_default.LEFT:
          offset3 = direction === "ltr" || direction === "btt" ? -1 : 1;
          break;
        case KeyCode_default.RIGHT:
          offset3 = direction === "ltr" || direction === "btt" ? 1 : -1;
          break;
        case KeyCode_default.UP:
          offset3 = direction !== "ttb" ? 1 : -1;
          break;
        case KeyCode_default.DOWN:
          offset3 = direction !== "ttb" ? -1 : 1;
          break;
        case KeyCode_default.HOME:
          offset3 = "min";
          break;
        case KeyCode_default.END:
          offset3 = "max";
          break;
        case KeyCode_default.PAGE_UP:
          offset3 = 2;
          break;
        case KeyCode_default.PAGE_DOWN:
          offset3 = -2;
          break;
      }
      if (offset3 !== null) {
        e3.preventDefault();
        onOffsetChange(offset3, valueIndex);
      }
    }
  }, "onKeyDown");
  const handleKeyUp = /* @__PURE__ */ __name((e3) => {
    switch (e3.which || e3.keyCode) {
      case KeyCode_default.LEFT:
      case KeyCode_default.RIGHT:
      case KeyCode_default.UP:
      case KeyCode_default.DOWN:
      case KeyCode_default.HOME:
      case KeyCode_default.END:
      case KeyCode_default.PAGE_UP:
      case KeyCode_default.PAGE_DOWN:
        onChangeComplete?.();
        break;
    }
  }, "handleKeyUp");
  const positionStyle = getDirectionStyle(direction, value, min, max);
  let divProps = {};
  if (valueIndex !== null) {
    divProps = {
      tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
      role: "slider",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value,
      "aria-disabled": disabled,
      "aria-label": getIndex(ariaLabelForHandle, valueIndex),
      "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
      "aria-valuetext": getIndex(ariaValueTextFormatterForHandle, valueIndex)?.(value),
      "aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
      onMouseDown: onInternalStartMove,
      onTouchStart: onInternalStartMove,
      onFocus: onInternalFocus,
      onMouseEnter: onInternalMouseEnter,
      onKeyDown: onKeyDown2,
      onKeyUp: handleKeyUp
    };
  }
  let handleNode = /* @__PURE__ */ React464.createElement(
    "div",
    {
      ref,
      className: (0, import_classnames208.default)(
        handlePrefixCls,
        {
          [`${handlePrefixCls}-${valueIndex + 1}`]: valueIndex !== null && range3,
          [`${handlePrefixCls}-dragging`]: dragging
        },
        classNames253.handle
      ),
      style: {
        ...positionStyle,
        ...style2,
        ...styles.handle
      },
      ...divProps,
      ...restProps
    }
  );
  if (render2) {
    handleNode = render2(handleNode, {
      index: valueIndex,
      prefixCls,
      value,
      dragging
    });
  }
  return handleNode;
});
if (true) {
  Handle.displayName = "Handle";
}
var Handle_default = Handle;

// packages/slider/src/Handles/index.tsx
var Handles = React465.forwardRef((props, ref) => {
  const {
    prefixCls,
    style: style2,
    onStartMove,
    onOffsetChange,
    values,
    handleRender,
    activeHandleRender,
    draggingIndex,
    onFocus,
    ...restProps
  } = props;
  const handlesRef = React465.useRef({});
  React465.useImperativeHandle(ref, () => ({
    focus: (index3) => {
      handlesRef.current[index3]?.focus();
    }
  }));
  const [activeIndex, setActiveIndex] = React465.useState(-1);
  const onHandleFocus = /* @__PURE__ */ __name((e3, index3) => {
    setActiveIndex(index3);
    onFocus?.(e3);
  }, "onHandleFocus");
  const onHandleMouseEnter = /* @__PURE__ */ __name((e3, index3) => {
    setActiveIndex(index3);
  }, "onHandleMouseEnter");
  const handleProps = {
    prefixCls,
    onStartMove,
    onOffsetChange,
    render: handleRender,
    onFocus: onHandleFocus,
    onMouseEnter: onHandleMouseEnter,
    ...restProps
  };
  return /* @__PURE__ */ React465.createElement(React465.Fragment, null, values.map((value, index3) => /* @__PURE__ */ React465.createElement(
    Handle_default,
    {
      ref: (node2) => {
        if (!node2) {
          delete handlesRef.current[index3];
        } else {
          handlesRef.current[index3] = node2;
        }
      },
      dragging: draggingIndex === index3,
      style: getIndex(style2, index3),
      key: index3,
      value,
      valueIndex: index3,
      ...handleProps
    }
  )), activeHandleRender && /* @__PURE__ */ React465.createElement(
    Handle_default,
    {
      key: "a11y",
      ...handleProps,
      value: values[activeIndex],
      valueIndex: null,
      dragging: draggingIndex !== -1,
      render: activeHandleRender,
      style: { pointerEvents: "none" },
      tabIndex: null,
      "aria-hidden": true
    }
  ));
});
if (true) {
  Handles.displayName = "Handles";
}
var Handles_default = Handles;

// packages/slider/src/Marks/index.tsx
import * as React467 from "react";

// packages/slider/src/Marks/Mark.tsx
var import_classnames209 = __toESM(require_classnames());
import * as React466 from "react";
var Mark = /* @__PURE__ */ __name((props) => {
  const { prefixCls, style: style2, children, value, onClick } = props;
  const { min, max, direction, includedStart, includedEnd, included } = React466.useContext(context_default11);
  const textCls = `${prefixCls}-text`;
  const positionStyle = getDirectionStyle(direction, value, min, max);
  return /* @__PURE__ */ React466.createElement(
    "span",
    {
      className: (0, import_classnames209.default)(textCls, {
        [`${textCls}-active`]: included && includedStart <= value && value <= includedEnd
      }),
      style: { ...positionStyle, ...style2 },
      onMouseDown: (e3) => {
        e3.stopPropagation();
      },
      onClick: () => {
        onClick(value);
      }
    },
    children
  );
}, "Mark");
var Mark_default = Mark;

// packages/slider/src/Marks/index.tsx
var Marks = /* @__PURE__ */ __name((props) => {
  const { prefixCls, marks, onClick } = props;
  const markPrefixCls = `${prefixCls}-mark`;
  if (!marks.length) {
    return null;
  }
  return /* @__PURE__ */ React467.createElement("div", { className: markPrefixCls }, marks.map(({ value, style: style2, label }) => /* @__PURE__ */ React467.createElement(Mark_default, { key: value, prefixCls: markPrefixCls, style: style2, value, onClick }, label)));
}, "Marks");
var Marks_default = Marks;

// packages/slider/src/Steps/index.tsx
import * as React469 from "react";

// packages/slider/src/Steps/Dot.tsx
var import_classnames210 = __toESM(require_classnames());
import * as React468 from "react";
var Dot = /* @__PURE__ */ __name((props) => {
  const { prefixCls, value, style: style2, activeStyle } = props;
  const { min, max, direction, included, includedStart, includedEnd } = React468.useContext(context_default11);
  const dotClassName = `${prefixCls}-dot`;
  const active = included && includedStart <= value && value <= includedEnd;
  let mergedStyle = {
    ...getDirectionStyle(direction, value, min, max),
    ...typeof style2 === "function" ? style2(value) : style2
  };
  if (active) {
    mergedStyle = {
      ...mergedStyle,
      ...typeof activeStyle === "function" ? activeStyle(value) : activeStyle
    };
  }
  return /* @__PURE__ */ React468.createElement(
    "span",
    {
      className: (0, import_classnames210.default)(dotClassName, { [`${dotClassName}-active`]: active }),
      style: mergedStyle
    }
  );
}, "Dot");
var Dot_default = Dot;

// packages/slider/src/Steps/index.tsx
var Steps2 = /* @__PURE__ */ __name((props) => {
  const { prefixCls, marks, dots, style: style2, activeStyle } = props;
  const { min, max, step } = React469.useContext(context_default11);
  const stepDots = React469.useMemo(() => {
    const dotSet = /* @__PURE__ */ new Set();
    marks.forEach((mark) => {
      dotSet.add(mark.value);
    });
    if (dots && step !== null) {
      let current = min;
      while (current <= max) {
        dotSet.add(current);
        current += step;
      }
    }
    return Array.from(dotSet);
  }, [min, max, step, dots, marks]);
  return /* @__PURE__ */ React469.createElement("div", { className: `${prefixCls}-step` }, stepDots.map((dotValue) => /* @__PURE__ */ React469.createElement(
    Dot_default,
    {
      prefixCls,
      key: dotValue,
      value: dotValue,
      style: style2,
      activeStyle
    }
  )));
}, "Steps");
var Steps_default2 = Steps2;

// packages/slider/src/Tracks/index.tsx
var import_classnames212 = __toESM(require_classnames());
import * as React471 from "react";

// packages/slider/src/Tracks/Track.tsx
var import_classnames211 = __toESM(require_classnames());
import * as React470 from "react";
var Track2 = /* @__PURE__ */ __name((props) => {
  const { prefixCls, style: style2, start, end, index: index3, onStartMove, replaceCls } = props;
  const { direction, min, max, disabled, range: range3, classNames: classNames253 } = React470.useContext(context_default11);
  const trackPrefixCls = `${prefixCls}-track`;
  const offsetStart = getOffset5(start, min, max);
  const offsetEnd = getOffset5(end, min, max);
  const onInternalStartMove = /* @__PURE__ */ __name((e3) => {
    if (!disabled && onStartMove) {
      onStartMove(e3, -1);
    }
  }, "onInternalStartMove");
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "btt":
      positionStyle.bottom = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "ttb":
      positionStyle.top = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    default:
      positionStyle.left = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
  }
  const className = replaceCls || (0, import_classnames211.default)(
    trackPrefixCls,
    {
      [`${trackPrefixCls}-${index3 + 1}`]: index3 !== null && range3,
      [`${prefixCls}-track-draggable`]: onStartMove
    },
    classNames253.track
  );
  return /* @__PURE__ */ React470.createElement(
    "div",
    {
      className,
      style: { ...positionStyle, ...style2 },
      onMouseDown: onInternalStartMove,
      onTouchStart: onInternalStartMove
    }
  );
}, "Track");
var Track_default = Track2;

// packages/slider/src/Tracks/index.tsx
var Tracks = /* @__PURE__ */ __name((props) => {
  const { prefixCls, style: style2, values, startPoint, onStartMove } = props;
  const { included, range: range3, min, styles, classNames: classNames253 } = React471.useContext(context_default11);
  const trackList = React471.useMemo(() => {
    if (!range3) {
      if (values.length === 0) {
        return [];
      }
      const startValue = startPoint ?? min;
      const endValue = values[0];
      return [{ start: Math.min(startValue, endValue), end: Math.max(startValue, endValue) }];
    }
    const list = [];
    for (let i = 0; i < values.length - 1; i += 1) {
      list.push({ start: values[i], end: values[i + 1] });
    }
    return list;
  }, [values, range3, startPoint, min]);
  if (!included) {
    return null;
  }
  const tracksNode = classNames253.tracks || styles.tracks ? /* @__PURE__ */ React471.createElement(
    Track_default,
    {
      index: null,
      prefixCls,
      start: trackList[0].start,
      end: trackList[trackList.length - 1].end,
      replaceCls: (0, import_classnames212.default)(classNames253.tracks, `${prefixCls}-tracks`),
      style: styles.tracks
    }
  ) : null;
  return /* @__PURE__ */ React471.createElement(React471.Fragment, null, tracksNode, trackList.map(({ start, end }, index3) => /* @__PURE__ */ React471.createElement(
    Track_default,
    {
      index: index3,
      prefixCls,
      style: { ...getIndex(style2, index3), ...styles.track },
      start,
      end,
      key: index3,
      onStartMove
    }
  )));
}, "Tracks");
var Tracks_default = Tracks;

// packages/slider/src/hooks/useDrag.ts
import * as React472 from "react";
function getPosition3(e3) {
  const obj = "touches" in e3 ? e3.touches[0] : e3;
  return { pageX: obj.pageX, pageY: obj.pageY };
}
__name(getPosition3, "getPosition");
function useDrag(containerRef, direction, rawValues, min, max, formatValue2, triggerChange, finishChange, offsetValues) {
  const [draggingValue, setDraggingValue] = React472.useState(null);
  const [draggingIndex, setDraggingIndex] = React472.useState(-1);
  const [cacheValues, setCacheValues] = React472.useState(rawValues);
  const [originValues, setOriginValues] = React472.useState(rawValues);
  const mouseMoveEventRef = React472.useRef(null);
  const mouseUpEventRef = React472.useRef(null);
  React472.useLayoutEffect(() => {
    if (draggingIndex === -1) {
      setCacheValues(rawValues);
    }
  }, [rawValues, draggingIndex]);
  React472.useEffect(
    () => () => {
      document.removeEventListener("mousemove", mouseMoveEventRef.current);
      document.removeEventListener("mouseup", mouseUpEventRef.current);
      document.removeEventListener("touchmove", mouseMoveEventRef.current);
      document.removeEventListener("touchend", mouseUpEventRef.current);
    },
    []
  );
  const flushValues = /* @__PURE__ */ __name((nextValues, nextValue) => {
    if (cacheValues.some((val, i) => val !== nextValues[i])) {
      if (nextValue !== void 0) {
        setDraggingValue(nextValue);
      }
      setCacheValues(nextValues);
      triggerChange(nextValues);
    }
  }, "flushValues");
  const updateCacheValue = useEvent((valueIndex, offsetPercent) => {
    if (valueIndex === -1) {
      const startValue = originValues[0];
      const endValue = originValues[originValues.length - 1];
      const maxStartOffset = min - startValue;
      const maxEndOffset = max - endValue;
      let offset3 = offsetPercent * (max - min);
      offset3 = Math.max(offset3, maxStartOffset);
      offset3 = Math.min(offset3, maxEndOffset);
      const formatStartValue = formatValue2(startValue + offset3);
      offset3 = formatStartValue - startValue;
      const cloneCacheValues = originValues.map((val) => val + offset3);
      flushValues(cloneCacheValues);
    } else {
      const offsetDist = (max - min) * offsetPercent;
      const cloneValues = [...cacheValues];
      cloneValues[valueIndex] = originValues[valueIndex];
      const next2 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
      flushValues(next2.values, next2.value);
    }
  });
  const onStartMove = /* @__PURE__ */ __name((e3, valueIndex, startValues) => {
    e3.stopPropagation();
    const initialValues = startValues || rawValues;
    const originValue = initialValues[valueIndex];
    setDraggingIndex(valueIndex);
    setDraggingValue(originValue);
    setOriginValues(initialValues);
    const { pageX: startX, pageY: startY } = getPosition3(e3);
    const onMouseMove = /* @__PURE__ */ __name((event) => {
      event.preventDefault();
      const { pageX: moveX, pageY: moveY } = getPosition3(event);
      const offsetX = moveX - startX;
      const offsetY = moveY - startY;
      const { width, height } = containerRef.current.getBoundingClientRect();
      let offSetPercent;
      switch (direction) {
        case "btt":
          offSetPercent = -offsetY / height;
          break;
        case "ttb":
          offSetPercent = offsetY / height;
          break;
        case "rtl":
          offSetPercent = -offsetX / width;
          break;
        default:
          offSetPercent = offsetX / width;
      }
      updateCacheValue(valueIndex, offSetPercent);
    }, "onMouseMove");
    const onMouseUp = /* @__PURE__ */ __name((event) => {
      event.preventDefault();
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("touchend", onMouseUp);
      document.removeEventListener("touchmove", onMouseMove);
      mouseMoveEventRef.current = null;
      mouseUpEventRef.current = null;
      setDraggingIndex(-1);
      finishChange();
    }, "onMouseUp");
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("touchend", onMouseUp);
    document.addEventListener("touchmove", onMouseMove);
    mouseMoveEventRef.current = onMouseMove;
    mouseUpEventRef.current = onMouseUp;
  }, "onStartMove");
  const returnValues = React472.useMemo(() => {
    const sourceValues = [...rawValues].sort((a, b) => a - b);
    const targetValues = [...cacheValues].sort((a, b) => a - b);
    return sourceValues.every((val, index3) => val === targetValues[index3]) ? cacheValues : rawValues;
  }, [rawValues, cacheValues]);
  return [draggingIndex, draggingValue, returnValues, onStartMove];
}
__name(useDrag, "useDrag");
var useDrag_default = useDrag;

// packages/slider/src/hooks/useOffset.ts
import * as React473 from "react";
function useOffset(min, max, step, markList, allowCross, pushable) {
  const formatRangeValue = React473.useCallback(
    (val) => Math.max(min, Math.min(max, val)),
    [min, max]
  );
  const formatStepValue = React473.useCallback(
    (val) => {
      if (step !== null) {
        const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
        const getDecimal = /* @__PURE__ */ __name((num) => (String(num).split(".")[1] || "").length, "getDecimal");
        const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
        const fixedValue = Number(stepValue.toFixed(maxDecimal));
        return min <= fixedValue && fixedValue <= max ? fixedValue : null;
      }
      return null;
    },
    [step, min, max, formatRangeValue]
  );
  const formatValue2 = React473.useCallback(
    (val) => {
      const formatNextValue = formatRangeValue(val);
      const alignValues = markList.map((mark) => mark.value);
      if (step !== null) {
        alignValues.push(formatStepValue(val));
      }
      alignValues.push(min, max);
      let closeValue = alignValues[0];
      let closeDist = max - min;
      alignValues.forEach((alignValue) => {
        const dist = Math.abs(formatNextValue - alignValue);
        if (dist <= closeDist) {
          closeValue = alignValue;
          closeDist = dist;
        }
      });
      return closeValue;
    },
    [min, max, markList, step, formatRangeValue, formatStepValue]
  );
  const offsetValue = /* @__PURE__ */ __name((values, offset3, valueIndex, mode = "unit") => {
    if (typeof offset3 === "number") {
      let nextValue;
      const originValue = values[valueIndex];
      const targetDistValue = originValue + offset3;
      let potentialValues = [];
      markList.forEach((mark) => {
        potentialValues.push(mark.value);
      });
      potentialValues.push(min, max);
      potentialValues.push(formatStepValue(originValue));
      const sign = offset3 > 0 ? 1 : -1;
      if (mode === "unit") {
        potentialValues.push(formatStepValue(originValue + sign * step));
      } else {
        potentialValues.push(formatStepValue(targetDistValue));
      }
      potentialValues = potentialValues.filter((val) => val !== null).filter((val) => offset3 < 0 ? val <= originValue : val >= originValue);
      if (mode === "unit") {
        potentialValues = potentialValues.filter((val) => val !== originValue);
      }
      const compareValue = mode === "unit" ? originValue : targetDistValue;
      nextValue = potentialValues[0];
      let valueDist = Math.abs(nextValue - compareValue);
      potentialValues.forEach((potentialValue) => {
        const dist = Math.abs(potentialValue - compareValue);
        if (dist < valueDist) {
          nextValue = potentialValue;
          valueDist = dist;
        }
      });
      if (nextValue === void 0) {
        return offset3 < 0 ? min : max;
      }
      if (mode === "dist") {
        return nextValue;
      }
      if (Math.abs(offset3) > 1) {
        const cloneValues = [...values];
        cloneValues[valueIndex] = nextValue;
        return offsetValue(cloneValues, offset3 - sign, valueIndex, mode);
      }
      return nextValue;
    } else if (offset3 === "min") {
      return min;
    } else if (offset3 === "max") {
      return max;
    }
  }, "offsetValue");
  const offsetChangedValue = /* @__PURE__ */ __name((values, offset3, valueIndex, mode = "unit") => {
    const originValue = values[valueIndex];
    const nextValue = offsetValue(values, offset3, valueIndex, mode);
    return {
      value: nextValue,
      changed: nextValue !== originValue
    };
  }, "offsetChangedValue");
  const needPush = /* @__PURE__ */ __name((dist) => {
    return pushable === null && dist === 0 || typeof pushable === "number" && dist < pushable;
  }, "needPush");
  const offsetValues = /* @__PURE__ */ __name((values, offset3, valueIndex, mode = "unit") => {
    const nextValues = values.map(formatValue2);
    const originValue = nextValues[valueIndex];
    const nextValue = offsetValue(nextValues, offset3, valueIndex, mode);
    nextValues[valueIndex] = nextValue;
    if (allowCross === false) {
      const pushNum = pushable || 0;
      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {
        nextValues[valueIndex] = Math.max(
          nextValues[valueIndex],
          nextValues[valueIndex - 1] + pushNum
        );
      }
      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {
        nextValues[valueIndex] = Math.min(
          nextValues[valueIndex],
          nextValues[valueIndex + 1] - pushNum
        );
      }
    } else if (typeof pushable === "number" || pushable === null) {
      for (let i = valueIndex + 1; i < nextValues.length; i += 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({ value: nextValues[i], changed } = offsetChangedValue(nextValues, 1, i));
        }
      }
      for (let i = valueIndex; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({ value: nextValues[i - 1], changed } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = nextValues.length - 1; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({ value: nextValues[i - 1], changed } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = 0; i < nextValues.length - 1; i += 1) {
        let changed = true;
        while (needPush(nextValues[i + 1] - nextValues[i]) && changed) {
          ({ value: nextValues[i + 1], changed } = offsetChangedValue(nextValues, 1, i + 1));
        }
      }
    }
    return {
      value: nextValues[valueIndex],
      values: nextValues
    };
  }, "offsetValues");
  return [formatValue2, offsetValues];
}
__name(useOffset, "useOffset");

// packages/slider/src/Slider.tsx
var Slider3 = React474.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-slider",
    className,
    style: style2,
    classNames: classNames253,
    styles,
    // Status
    disabled = false,
    keyboard = true,
    autoFocus,
    onFocus,
    onBlur,
    // Value
    min = 0,
    max = 100,
    step = 1,
    value,
    defaultValue,
    range: range3,
    count,
    onChange,
    onBeforeChange,
    onAfterChange,
    onChangeComplete,
    // Cross
    allowCross = true,
    pushable = false,
    draggableTrack,
    // Direction
    reverse,
    vertical,
    // Style
    included = true,
    startPoint,
    trackStyle,
    handleStyle,
    railStyle,
    dotStyle,
    activeDotStyle,
    // Decorations
    marks,
    dots,
    // Components
    handleRender,
    activeHandleRender,
    // Accessibility
    tabIndex = 0,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaValueTextFormatterForHandle
  } = props;
  const handlesRef = React474.useRef(null);
  const containerRef = React474.useRef(null);
  const direction = React474.useMemo(() => {
    if (vertical) {
      return reverse ? "ttb" : "btt";
    }
    return reverse ? "rtl" : "ltr";
  }, [reverse, vertical]);
  const mergedMin = React474.useMemo(() => isFinite(min) ? min : 0, [min]);
  const mergedMax = React474.useMemo(() => isFinite(max) ? max : 100, [max]);
  const mergedStep = React474.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);
  const mergedPush = React474.useMemo(() => {
    if (typeof pushable === "boolean") {
      return pushable ? mergedStep : false;
    }
    return pushable >= 0 ? pushable : false;
  }, [pushable, mergedStep]);
  const markList = React474.useMemo(() => {
    return Object.keys(marks || {}).map((key) => {
      const mark = marks[key];
      const markObj = {
        value: Number(key)
      };
      if (mark && typeof mark === "object" && !React474.isValidElement(mark) && ("label" in mark || "style" in mark)) {
        markObj.style = mark.style;
        markObj.label = mark.label;
      } else {
        markObj.label = mark;
      }
      return markObj;
    }).filter(({ label }) => label || typeof label === "number").sort((a, b) => a.value - b.value);
  }, [marks]);
  const [formatValue2, offsetValues] = useOffset(
    mergedMin,
    mergedMax,
    mergedStep,
    markList,
    allowCross,
    mergedPush
  );
  const [mergedValue, setValue] = useMergedState(defaultValue, {
    value
  });
  const rawValues = React474.useMemo(() => {
    const valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    const [val0 = mergedMin] = valueList;
    let returnValues = mergedValue === null ? [] : [val0];
    if (range3) {
      returnValues = [...valueList];
      if (count || mergedValue === void 0) {
        const pointCount = count >= 0 ? count + 1 : 2;
        returnValues = returnValues.slice(0, pointCount);
        while (returnValues.length < pointCount) {
          returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);
        }
      }
      returnValues.sort((a, b) => a - b);
    }
    returnValues.forEach((val, index3) => {
      returnValues[index3] = formatValue2(val);
    });
    return returnValues;
  }, [mergedValue, range3, mergedMin, count, formatValue2]);
  const rawValuesRef = React474.useRef(rawValues);
  rawValuesRef.current = rawValues;
  const getTriggerValue = /* @__PURE__ */ __name((triggerValues) => range3 ? triggerValues : triggerValues[0], "getTriggerValue");
  const triggerChange = /* @__PURE__ */ __name((nextValues) => {
    const cloneNextValues = [...nextValues].sort((a, b) => a - b);
    if (onChange && !isEqual_default(cloneNextValues, rawValuesRef.current, true)) {
      onChange(getTriggerValue(cloneNextValues));
    }
    setValue(cloneNextValues);
  }, "triggerChange");
  const finishChange = /* @__PURE__ */ __name(() => {
    const finishValue = getTriggerValue(rawValuesRef.current);
    onAfterChange?.(finishValue);
    warning_default(
      !onAfterChange,
      "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead."
    );
    onChangeComplete?.(finishValue);
  }, "finishChange");
  const [draggingIndex, draggingValue, cacheValues, onStartDrag] = useDrag_default(
    containerRef,
    direction,
    rawValues,
    mergedMin,
    mergedMax,
    formatValue2,
    triggerChange,
    finishChange,
    offsetValues
  );
  const changeToCloseValue = /* @__PURE__ */ __name((newValue, e3) => {
    if (!disabled) {
      let valueIndex = 0;
      let valueDist = mergedMax - mergedMin;
      rawValues.forEach((val, index3) => {
        const dist = Math.abs(newValue - val);
        if (dist <= valueDist) {
          valueDist = dist;
          valueIndex = index3;
        }
      });
      const cloneNextValues = [...rawValues];
      cloneNextValues[valueIndex] = newValue;
      if (range3 && !rawValues.length && count === void 0) {
        cloneNextValues.push(newValue);
      }
      onBeforeChange?.(getTriggerValue(cloneNextValues));
      triggerChange(cloneNextValues);
      if (e3) {
        document.activeElement?.blur?.();
        handlesRef.current.focus(valueIndex);
        onStartDrag(e3, valueIndex, cloneNextValues);
      }
    }
  }, "changeToCloseValue");
  const onSliderMouseDown = /* @__PURE__ */ __name((e3) => {
    e3.preventDefault();
    const { width, height, left, top, bottom, right } = containerRef.current.getBoundingClientRect();
    const { clientX, clientY } = e3;
    let percent;
    switch (direction) {
      case "btt":
        percent = (bottom - clientY) / height;
        break;
      case "ttb":
        percent = (clientY - top) / height;
        break;
      case "rtl":
        percent = (right - clientX) / width;
        break;
      default:
        percent = (clientX - left) / width;
    }
    const nextValue = mergedMin + percent * (mergedMax - mergedMin);
    changeToCloseValue(formatValue2(nextValue), e3);
  }, "onSliderMouseDown");
  const [keyboardValue, setKeyboardValue] = React474.useState(null);
  const onHandleOffsetChange = /* @__PURE__ */ __name((offset3, valueIndex) => {
    if (!disabled) {
      const next2 = offsetValues(rawValues, offset3, valueIndex);
      onBeforeChange?.(getTriggerValue(rawValues));
      triggerChange(next2.values);
      setKeyboardValue(next2.value);
    }
  }, "onHandleOffsetChange");
  React474.useEffect(() => {
    if (keyboardValue !== null) {
      const valueIndex = rawValues.indexOf(keyboardValue);
      if (valueIndex >= 0) {
        handlesRef.current.focus(valueIndex);
      }
    }
    setKeyboardValue(null);
  }, [keyboardValue]);
  const mergedDraggableTrack = React474.useMemo(() => {
    if (draggableTrack && mergedStep === null) {
      if (true) {
        warning_default(false, "`draggableTrack` is not supported when `step` is `null`.");
      }
      return false;
    }
    return draggableTrack;
  }, [draggableTrack, mergedStep]);
  const onStartMove = /* @__PURE__ */ __name((e3, valueIndex) => {
    onStartDrag(e3, valueIndex);
    onBeforeChange?.(getTriggerValue(rawValuesRef.current));
  }, "onStartMove");
  const dragging = draggingIndex !== -1;
  React474.useEffect(() => {
    if (!dragging) {
      const valueIndex = rawValues.lastIndexOf(draggingValue);
      handlesRef.current.focus(valueIndex);
    }
  }, [dragging]);
  const sortedCacheValues = React474.useMemo(
    () => [...cacheValues].sort((a, b) => a - b),
    [cacheValues]
  );
  const [includedStart, includedEnd] = React474.useMemo(() => {
    if (!range3) {
      return [mergedMin, sortedCacheValues[0]];
    }
    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
  }, [sortedCacheValues, range3, mergedMin]);
  React474.useImperativeHandle(ref, () => ({
    focus: () => {
      handlesRef.current.focus(0);
    },
    blur: () => {
      const { activeElement } = document;
      if (containerRef.current?.contains(activeElement)) {
        activeElement?.blur();
      }
    }
  }));
  React474.useEffect(() => {
    if (autoFocus) {
      handlesRef.current.focus(0);
    }
  }, []);
  const context = React474.useMemo(
    () => ({
      min: mergedMin,
      max: mergedMax,
      direction,
      disabled,
      keyboard,
      step: mergedStep,
      included,
      includedStart,
      includedEnd,
      range: range3,
      tabIndex,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaValueTextFormatterForHandle,
      styles: styles || {},
      classNames: classNames253 || {}
    }),
    [
      mergedMin,
      mergedMax,
      direction,
      disabled,
      keyboard,
      mergedStep,
      included,
      includedStart,
      includedEnd,
      range3,
      tabIndex,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaValueTextFormatterForHandle,
      styles,
      classNames253
    ]
  );
  return /* @__PURE__ */ React474.createElement(context_default11.Provider, { value: context }, /* @__PURE__ */ React474.createElement(
    "div",
    {
      ref: containerRef,
      className: (0, import_classnames213.default)(prefixCls, className, {
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-vertical`]: vertical,
        [`${prefixCls}-horizontal`]: !vertical,
        [`${prefixCls}-with-marks`]: markList.length
      }),
      style: style2,
      onMouseDown: onSliderMouseDown
    },
    /* @__PURE__ */ React474.createElement(
      "div",
      {
        className: (0, import_classnames213.default)(`${prefixCls}-rail`, classNames253?.rail),
        style: { ...railStyle, ...styles?.rail }
      }
    ),
    /* @__PURE__ */ React474.createElement(
      Tracks_default,
      {
        prefixCls,
        style: trackStyle,
        values: sortedCacheValues,
        startPoint,
        onStartMove: mergedDraggableTrack ? onStartMove : void 0
      }
    ),
    /* @__PURE__ */ React474.createElement(
      Steps_default2,
      {
        prefixCls,
        marks: markList,
        dots,
        style: dotStyle,
        activeStyle: activeDotStyle
      }
    ),
    /* @__PURE__ */ React474.createElement(
      Handles_default,
      {
        ref: handlesRef,
        prefixCls,
        style: handleStyle,
        values: cacheValues,
        draggingIndex,
        onStartMove,
        onOffsetChange: onHandleOffsetChange,
        onFocus,
        onBlur,
        handleRender,
        activeHandleRender,
        onChangeComplete: finishChange
      }
    ),
    /* @__PURE__ */ React474.createElement(Marks_default, { prefixCls, marks: markList, onClick: changeToCloseValue })
  ));
});
if (true) {
  Slider3.displayName = "Slider";
}
var Slider_default2 = Slider3;

// packages/slider/src/index.tsx
var src_default25 = Slider_default2;

// packages/ant-design/components/slider/SliderTooltip.tsx
import * as React475 from "react";
import { useRef as useRef146 } from "react";
var SliderTooltip = React475.forwardRef((props, ref) => {
  const { open: open3 } = props;
  const innerRef = useRef146(null);
  const rafRef = useRef146(null);
  function cancelKeepAlign() {
    raf_default.cancel(rafRef.current);
    rafRef.current = null;
  }
  __name(cancelKeepAlign, "cancelKeepAlign");
  function keepAlign() {
    rafRef.current = raf_default(() => {
      innerRef.current?.forceAlign();
      rafRef.current = null;
    });
  }
  __name(keepAlign, "keepAlign");
  React475.useEffect(() => {
    if (open3) {
      keepAlign();
    } else {
      cancelKeepAlign();
    }
    return cancelKeepAlign;
  }, [open3, props.title]);
  return /* @__PURE__ */ React475.createElement(tooltip_default, { ref: composeRef(innerRef, ref), ...props });
});
if (true) {
  SliderTooltip.displayName = "SliderTooltip";
}
var SliderTooltip_default = SliderTooltip;

// packages/ant-design/components/slider/style/index.ts
init_public_api();
var genBaseStyle14 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    controlSize,
    dotSize,
    marginFull,
    marginPart,
    colorFillContentHover,
    handleColorDisabled,
    calc
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      height: controlSize,
      margin: `${unit(marginPart)} ${unit(marginFull)}`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      [`&-vertical`]: {
        margin: `${unit(marginFull)} ${unit(marginPart)}`
      },
      [`${componentCls}-rail`]: {
        position: "absolute",
        backgroundColor: token2.railBg,
        borderRadius: token2.borderRadiusXS,
        transition: `background-color ${token2.motionDurationMid}`
      },
      [`${componentCls}-track,${componentCls}-tracks`]: {
        position: "absolute",
        transition: `background-color ${token2.motionDurationMid}`
      },
      [`${componentCls}-track`]: {
        backgroundColor: token2.trackBg,
        borderRadius: token2.borderRadiusXS
      },
      [`${componentCls}-track-draggable`]: {
        boxSizing: "content-box",
        backgroundClip: "content-box",
        border: "solid rgba(0,0,0,0)"
      },
      "&:hover": {
        [`${componentCls}-rail`]: {
          backgroundColor: token2.railHoverBg
        },
        [`${componentCls}-track`]: {
          backgroundColor: token2.trackHoverBg
        },
        [`${componentCls}-dot`]: {
          borderColor: colorFillContentHover
        },
        [`${componentCls}-handle::after`]: {
          boxShadow: `0 0 0 ${unit(token2.handleLineWidth)} ${token2.colorPrimaryBorderHover}`
        },
        [`${componentCls}-dot-active`]: {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`${componentCls}-handle`]: {
        position: "absolute",
        width: token2.handleSize,
        height: token2.handleSize,
        outline: "none",
        // 扩大选区
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: calc(token2.handleLineWidth).mul(-1).equal(),
          insetBlockStart: calc(token2.handleLineWidth).mul(-1).equal(),
          width: calc(token2.handleSize).add(calc(token2.handleLineWidth).mul(2)).equal(),
          height: calc(token2.handleSize).add(calc(token2.handleLineWidth).mul(2)).equal(),
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: token2.handleSize,
          height: token2.handleSize,
          backgroundColor: token2.colorBgElevated,
          boxShadow: `0 0 0 ${unit(token2.handleLineWidth)} ${token2.handleColor}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${token2.motionDurationMid},
            inset-block-start ${token2.motionDurationMid},
            width ${token2.motionDurationMid},
            height ${token2.motionDurationMid},
            box-shadow ${token2.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            // -(
            //   (token.handleSizeHover - token.handleSize) / 2 +
            //   token.handleLineWidthHover
            // ),
            insetInlineStart: calc(token2.handleSizeHover).sub(token2.handleSize).div(2).add(token2.handleLineWidthHover).mul(-1).equal(),
            insetBlockStart: calc(token2.handleSizeHover).sub(token2.handleSize).div(2).add(token2.handleLineWidthHover).mul(-1).equal(),
            width: calc(token2.handleSizeHover).add(calc(token2.handleLineWidthHover).mul(2)).equal(),
            height: calc(token2.handleSizeHover).add(calc(token2.handleLineWidthHover).mul(2)).equal()
          },
          "&::after": {
            boxShadow: `0 0 0 ${unit(token2.handleLineWidthHover)} ${token2.handleActiveColor}`,
            width: token2.handleSizeHover,
            height: token2.handleSizeHover,
            insetInlineStart: token2.calc(token2.handleSize).sub(token2.handleSizeHover).div(2).equal(),
            insetBlockStart: token2.calc(token2.handleSize).sub(token2.handleSizeHover).div(2).equal()
          }
        }
      },
      [`&-lock ${componentCls}-handle`]: {
        [`&::before, &::after`]: {
          transition: "none"
        }
      },
      [`${componentCls}-mark`]: {
        position: "absolute",
        fontSize: token2.fontSize
      },
      [`${componentCls}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: token2.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: token2.colorText
        }
      },
      [`${componentCls}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        width: dotSize,
        height: dotSize,
        backgroundColor: token2.colorBgElevated,
        border: `${unit(token2.handleLineWidth)} solid ${token2.dotBorderColor}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        pointerEvents: "auto",
        "&-active": {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-rail`]: {
          backgroundColor: `${token2.railBg} !important`
        },
        [`${componentCls}-track`]: {
          backgroundColor: `${token2.trackBgDisabled} !important`
        },
        [`
          ${componentCls}-dot
        `]: {
          backgroundColor: token2.colorBgElevated,
          borderColor: token2.trackBgDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${componentCls}-handle::after`]: {
          backgroundColor: token2.colorBgElevated,
          cursor: "not-allowed",
          width: token2.handleSize,
          height: token2.handleSize,
          boxShadow: `0 0 0 ${unit(token2.handleLineWidth)} ${handleColorDisabled}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
          cursor: `not-allowed !important`
        }
      },
      [`&-tooltip ${antCls}-tooltip-inner`]: {
        minWidth: "unset"
      }
    }
  };
}, "genBaseStyle");
var genDirectionStyle = /* @__PURE__ */ __name((token2, horizontal) => {
  const { componentCls, railSize, handleSize, dotSize, marginFull, calc } = token2;
  const railPadding = horizontal ? "paddingBlock" : "paddingInline";
  const full = horizontal ? "width" : "height";
  const part = horizontal ? "height" : "width";
  const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
  const markInset = horizontal ? "top" : "insetInlineStart";
  const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
  const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
  const draggableBorder = horizontal ? {
    borderWidth: `${unit(draggableBorderSize)} 0`,
    transform: `translateY(${unit(calc(draggableBorderSize).mul(-1).equal())})`
  } : {
    borderWidth: `0 ${unit(draggableBorderSize)}`,
    transform: `translateX(${unit(token2.calc(draggableBorderSize).mul(-1).equal())})`
  };
  return {
    [railPadding]: railSize,
    [part]: calc(railSize).mul(3).equal(),
    [`${componentCls}-rail`]: {
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-track,${componentCls}-tracks`]: {
      [part]: railSize
    },
    [`${componentCls}-track-draggable`]: {
      ...draggableBorder
    },
    [`${componentCls}-handle`]: {
      [handlePos]: handlePosSize
    },
    [`${componentCls}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      // https://github.com/ant-design/ant-design/issues/43731
      [markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
      [full]: "100%"
    },
    [`${componentCls}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: railSize,
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-dot`]: {
      position: "absolute",
      [handlePos]: calc(railSize).sub(dotSize).div(2).equal()
    }
  };
}, "genDirectionStyle");
var genHorizontalStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, marginPartWithMark } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      ...genDirectionStyle(token2, true),
      [`&${componentCls}-with-marks`]: {
        marginBottom: marginPartWithMark
      }
    }
  };
}, "genHorizontalStyle");
var genVerticalStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-vertical`]: {
      ...genDirectionStyle(token2, false),
      height: "100%"
    }
  };
}, "genVerticalStyle");
var prepareComponentToken46 = /* @__PURE__ */ __name((token2) => {
  const increaseHandleWidth = 1;
  const controlSize = token2.controlHeightLG / 4;
  const controlSizeHover = token2.controlHeightSM / 2;
  const handleLineWidth = token2.lineWidth + increaseHandleWidth;
  const handleLineWidthHover = token2.lineWidth + increaseHandleWidth * 3;
  return {
    controlSize,
    railSize: 4,
    handleSize: controlSize,
    handleSizeHover: controlSizeHover,
    dotSize: 8,
    handleLineWidth,
    handleLineWidthHover,
    railBg: token2.colorFillTertiary,
    railHoverBg: token2.colorFillSecondary,
    trackBg: token2.colorPrimaryBorder,
    trackHoverBg: token2.colorPrimaryBorderHover,
    handleColor: token2.colorPrimaryBorder,
    handleActiveColor: token2.colorPrimary,
    handleColorDisabled: new TinyColor(token2.colorTextDisabled).onBackground(token2.colorBgContainer).toHexShortString(),
    dotBorderColor: token2.colorBorderSecondary,
    dotActiveBorderColor: token2.colorPrimaryBorder,
    trackBgDisabled: token2.colorBgContainerDisabled
  };
}, "prepareComponentToken");
var style_default52 = genStyleHooks(
  "Slider",
  (token2) => {
    const sliderToken = merge2(token2, {
      marginPart: token2.calc(token2.controlHeight).sub(token2.controlSize).div(2).equal(),
      marginFull: token2.calc(token2.controlSize).div(2).equal(),
      marginPartWithMark: token2.calc(token2.controlHeightLG).sub(token2.controlSize).equal()
    });
    return [
      genBaseStyle14(sliderToken),
      genHorizontalStyle2(sliderToken),
      genVerticalStyle2(sliderToken)
    ];
  },
  prepareComponentToken46
);

// packages/ant-design/components/slider/useRafLock.ts
import * as React476 from "react";
function useRafLock() {
  const [state, setState] = React476.useState(false);
  const rafRef = React476.useRef();
  const cleanup2 = /* @__PURE__ */ __name(() => {
    raf_default.cancel(rafRef.current);
  }, "cleanup");
  const setDelayState = /* @__PURE__ */ __name((nextState) => {
    cleanup2();
    if (nextState) {
      setState(nextState);
    } else {
      rafRef.current = raf_default(() => {
        setState(nextState);
      });
    }
  }, "setDelayState");
  React476.useEffect(() => cleanup2, []);
  return [state, setDelayState];
}
__name(useRafLock, "useRafLock");

// packages/ant-design/components/slider/index.tsx
function getTipFormatter(tipFormatter, legacyTipFormatter) {
  if (tipFormatter || tipFormatter === null) {
    return tipFormatter;
  }
  if (legacyTipFormatter || legacyTipFormatter === null) {
    return legacyTipFormatter;
  }
  return (val) => typeof val === "number" ? val.toString() : "";
}
__name(getTipFormatter, "getTipFormatter");
var Slider4 = React477.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    range: range3,
    className,
    rootClassName,
    style: style2,
    disabled,
    // Deprecated Props
    tooltipPrefixCls: legacyTooltipPrefixCls,
    tipFormatter: legacyTipFormatter,
    tooltipVisible: legacyTooltipVisible,
    getTooltipPopupContainer: legacyGetTooltipPopupContainer,
    tooltipPlacement: legacyTooltipPlacement,
    tooltip = {},
    onChangeComplete,
    ...restProps
  } = props;
  const { vertical } = props;
  const { direction, slider, getPrefixCls, getPopupContainer } = React477.useContext(ConfigContext);
  const contextDisabled = React477.useContext(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const [hoverOpen, setHoverOpen] = useRafLock();
  const [focusOpen, setFocusOpen] = useRafLock();
  const activeOpen = hoverOpen || focusOpen;
  const tooltipProps = {
    ...tooltip
  };
  const {
    open: tooltipOpen,
    placement: tooltipPlacement,
    getPopupContainer: getTooltipPopupContainer,
    prefixCls: customizeTooltipPrefixCls,
    formatter: tipFormatter
  } = tooltipProps;
  const lockOpen = tooltipOpen ?? legacyTooltipVisible;
  const mergedTipFormatter = getTipFormatter(tipFormatter, legacyTipFormatter);
  const [dragging, setDragging] = useRafLock();
  const onInternalChangeComplete = /* @__PURE__ */ __name((nextValues) => {
    onChangeComplete?.(nextValues);
    setDragging(false);
  }, "onInternalChangeComplete");
  const getTooltipPlacement = /* @__PURE__ */ __name((placement, vert) => {
    if (placement) {
      return placement;
    }
    if (!vert) {
      return "top";
    }
    return direction === "rtl" ? "left" : "right";
  }, "getTooltipPlacement");
  const prefixCls = getPrefixCls("slider", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default52(prefixCls);
  const cls5 = (0, import_classnames214.default)(
    className,
    slider?.className,
    rootClassName,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-lock`]: dragging
    },
    hashId,
    cssVarCls
  );
  if (direction === "rtl" && !restProps.vertical) {
    restProps.reverse = !restProps.reverse;
  }
  const [mergedRange, draggableTrack] = React477.useMemo(() => {
    if (!range3) {
      return [false];
    }
    return typeof range3 === "object" ? [true, range3.draggableTrack] : [true, false];
  }, [range3]);
  if (true) {
    const warning5 = devUseWarning("Slider");
    [
      ["tooltipPrefixCls", "prefixCls"],
      ["getTooltipPopupContainer", "getPopupContainer"],
      ["tipFormatter", "formatter"],
      ["tooltipPlacement", "placement"],
      ["tooltipVisible", "open"]
    ].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, `tooltip.${newName}`);
    });
  }
  React477.useEffect(() => {
    const onMouseUp = /* @__PURE__ */ __name(() => {
      raf_default(() => {
        setFocusOpen(false);
      }, 1);
    }, "onMouseUp");
    document.addEventListener("mouseup", onMouseUp);
    return () => {
      document.removeEventListener("mouseup", onMouseUp);
    };
  }, []);
  const useActiveTooltipHandle = mergedRange && !lockOpen;
  const handleRender = /* @__PURE__ */ __name((node2, info) => {
    const { index: index3 } = info;
    const nodeProps = node2.props;
    const passedProps = {
      ...nodeProps,
      onMouseEnter: (e3) => {
        setHoverOpen(true);
        nodeProps.onMouseEnter?.(e3);
      },
      onMouseLeave: (e3) => {
        setHoverOpen(false);
        nodeProps.onMouseLeave?.(e3);
      },
      onMouseDown: (e3) => {
        setFocusOpen(true);
        setDragging(true);
        nodeProps.onMouseDown?.(e3);
      },
      onFocus: (e3) => {
        setFocusOpen(true);
        restProps.onFocus?.(e3);
        nodeProps.onFocus?.(e3);
      },
      onBlur: (e3) => {
        setFocusOpen(false);
        restProps.onBlur?.(e3);
        nodeProps.onBlur?.(e3);
      }
    };
    const cloneNode = React477.cloneElement(node2, passedProps);
    if (!useActiveTooltipHandle) {
      return /* @__PURE__ */ React477.createElement(
        SliderTooltip_default,
        {
          ...tooltipProps,
          prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls ?? legacyTooltipPrefixCls),
          title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
          open: !!lockOpen || activeOpen,
          placement: getTooltipPlacement(tooltipPlacement ?? legacyTooltipPlacement, vertical),
          key: index3,
          overlayClassName: `${prefixCls}-tooltip`,
          getPopupContainer: getTooltipPopupContainer || legacyGetTooltipPopupContainer || getPopupContainer
        },
        cloneNode
      );
    }
    return cloneNode;
  }, "handleRender");
  const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
    const cloneNode = React477.cloneElement(handle, {
      style: {
        ...handle.props.style,
        visibility: "hidden"
      }
    });
    return /* @__PURE__ */ React477.createElement(
      SliderTooltip_default,
      {
        ...tooltipProps,
        prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls ?? legacyTooltipPrefixCls),
        title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
        open: activeOpen,
        placement: getTooltipPlacement(tooltipPlacement ?? legacyTooltipPlacement, vertical),
        key: "tooltip",
        overlayClassName: `${prefixCls}-tooltip`,
        getPopupContainer: getTooltipPopupContainer || legacyGetTooltipPopupContainer || getPopupContainer
      },
      cloneNode
    );
  } : void 0;
  const mergedStyle = { ...slider?.style, ...style2 };
  return wrapCSSVar(
    // @ts-ignore
    /* @__PURE__ */ React477.createElement(
      src_default25,
      {
        ...restProps,
        step: restProps.step,
        range: mergedRange,
        draggableTrack,
        className: cls5,
        style: mergedStyle,
        disabled: mergedDisabled,
        ref,
        prefixCls,
        handleRender,
        activeHandleRender,
        onChangeComplete: onInternalChangeComplete
      }
    )
  );
});
if (true) {
  Slider4.displayName = "Slider";
}
var slider_default = Slider4;

// packages/ant-design/components/statistic/Countdown.tsx
import * as React480 from "react";

// packages/ant-design/components/statistic/Statistic.tsx
var import_classnames215 = __toESM(require_classnames());
import * as React479 from "react";

// packages/ant-design/components/statistic/Number.tsx
import * as React478 from "react";
var StatisticNumber = /* @__PURE__ */ __name((props) => {
  const { value, formatter, precision, decimalSeparator, groupSeparator = "", prefixCls } = props;
  let valueNode;
  if (typeof formatter === "function") {
    valueNode = formatter(value);
  } else {
    const val = String(value);
    const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!cells || val === "-") {
      valueNode = val;
    } else {
      const negative = cells[1];
      let int = cells[2] || "0";
      let decimal = cells[4] || "";
      int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      if (typeof precision === "number") {
        decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
      }
      if (decimal) {
        decimal = `${decimalSeparator}${decimal}`;
      }
      valueNode = [
        /* @__PURE__ */ React478.createElement("span", { key: "int", className: `${prefixCls}-content-value-int` }, negative, int),
        decimal && /* @__PURE__ */ React478.createElement("span", { key: "decimal", className: `${prefixCls}-content-value-decimal` }, decimal)
      ];
    }
  }
  return /* @__PURE__ */ React478.createElement("span", { className: `${prefixCls}-content-value` }, valueNode);
}, "StatisticNumber");
var Number_default = StatisticNumber;

// packages/ant-design/components/statistic/style/index.ts
var genStatisticStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    marginXXS,
    padding,
    colorTextDescription,
    titleFontSize,
    colorTextHeading,
    contentFontSize,
    fontFamily
  } = token2;
  return {
    [`${componentCls}`]: {
      ...resetComponent(token2),
      [`${componentCls}-title`]: {
        marginBottom: marginXXS,
        color: colorTextDescription,
        fontSize: titleFontSize
      },
      [`${componentCls}-skeleton`]: {
        paddingTop: padding
      },
      [`${componentCls}-content`]: {
        color: colorTextHeading,
        fontSize: contentFontSize,
        fontFamily,
        [`${componentCls}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: {
          display: "inline-block"
        },
        [`${componentCls}-content-prefix`]: {
          marginInlineEnd: marginXXS
        },
        [`${componentCls}-content-suffix`]: {
          marginInlineStart: marginXXS
        }
      }
    }
  };
}, "genStatisticStyle");
var prepareComponentToken47 = /* @__PURE__ */ __name((token2) => {
  const { fontSizeHeading3, fontSize } = token2;
  return {
    titleFontSize: fontSize,
    contentFontSize: fontSizeHeading3
  };
}, "prepareComponentToken");
var style_default53 = genStyleHooks(
  "Statistic",
  (token2) => {
    const statisticToken2 = merge2(token2, {});
    return [genStatisticStyle(statisticToken2)];
  },
  prepareComponentToken47
);

// packages/ant-design/components/statistic/Statistic.tsx
var Statistic = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    valueStyle,
    value = 0,
    title,
    valueRender,
    prefix,
    suffix,
    loading = false,
    /* --- FormatConfig starts --- */
    formatter,
    precision,
    decimalSeparator = ".",
    groupSeparator = ",",
    /* --- FormatConfig starts --- */
    onMouseEnter,
    onMouseLeave,
    ...rest
  } = props;
  const { getPrefixCls, direction, statistic: statistic2 } = React479.useContext(ConfigContext);
  const prefixCls = getPrefixCls("statistic", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default53(prefixCls);
  const valueNode = /* @__PURE__ */ React479.createElement(
    Number_default,
    {
      decimalSeparator,
      groupSeparator,
      prefixCls,
      formatter,
      precision,
      value
    }
  );
  const cls5 = (0, import_classnames215.default)(
    prefixCls,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    statistic2?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const restProps = pickAttrs(rest, { aria: true, data: true });
  return wrapCSSVar(
    /* @__PURE__ */ React479.createElement(
      "div",
      {
        ...restProps,
        className: cls5,
        style: { ...statistic2?.style, ...style2 },
        onMouseEnter,
        onMouseLeave
      },
      title && /* @__PURE__ */ React479.createElement("div", { className: `${prefixCls}-title` }, title),
      /* @__PURE__ */ React479.createElement(skeleton_default, { paragraph: false, loading, className: `${prefixCls}-skeleton` }, /* @__PURE__ */ React479.createElement("div", { style: valueStyle, className: `${prefixCls}-content` }, prefix && /* @__PURE__ */ React479.createElement("span", { className: `${prefixCls}-content-prefix` }, prefix), valueRender ? valueRender(valueNode) : valueNode, suffix && /* @__PURE__ */ React479.createElement("span", { className: `${prefixCls}-content-suffix` }, suffix)))
    )
  );
}, "Statistic");
if (true) {
  Statistic.displayName = "Statistic";
}
var Statistic_default = Statistic;

// packages/ant-design/components/statistic/utils.ts
var timeUnits = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  // years
  ["M", 1e3 * 60 * 60 * 24 * 30],
  // months
  ["D", 1e3 * 60 * 60 * 24],
  // days
  ["H", 1e3 * 60 * 60],
  // hours
  ["m", 1e3 * 60],
  // minutes
  ["s", 1e3],
  // seconds
  ["S", 1]
  // million seconds
];
function formatTimeStr(duration, format2) {
  let leftDuration = duration;
  const escapeRegex = /\[[^\]]*]/g;
  const keepList = (format2.match(escapeRegex) || []).map((str) => str.slice(1, -1));
  const templateText = format2.replace(escapeRegex, "[]");
  const replacedText = timeUnits.reduce((current, [name, unit3]) => {
    if (current.includes(name)) {
      const value = Math.floor(leftDuration / unit3);
      leftDuration -= value * unit3;
      return current.replace(new RegExp(`${name}+`, "g"), (match2) => {
        const len = match2.length;
        return value.toString().padStart(len, "0");
      });
    }
    return current;
  }, templateText);
  let index3 = 0;
  return replacedText.replace(escapeRegex, () => {
    const match2 = keepList[index3];
    index3 += 1;
    return match2;
  });
}
__name(formatTimeStr, "formatTimeStr");
function formatCountdown(value, config) {
  const { format: format2 = "" } = config;
  const target = new Date(value).getTime();
  const current = Date.now();
  const diff = Math.max(target - current, 0);
  return formatTimeStr(diff, format2);
}
__name(formatCountdown, "formatCountdown");

// packages/ant-design/components/statistic/Countdown.tsx
var REFRESH_INTERVAL2 = 1e3 / 30;
function getTime(value) {
  return new Date(value).getTime();
}
__name(getTime, "getTime");
var Countdown = /* @__PURE__ */ __name((props) => {
  const { value, format: format2 = "HH:mm:ss", onChange, onFinish, ...rest } = props;
  const forceUpdate = useForceUpdate();
  const countdown = React480.useRef(null);
  const stopTimer = /* @__PURE__ */ __name(() => {
    onFinish?.();
    if (countdown.current) {
      clearInterval(countdown.current);
      countdown.current = null;
    }
  }, "stopTimer");
  const syncTimer = /* @__PURE__ */ __name(() => {
    const timestamp = getTime(value);
    if (timestamp >= Date.now()) {
      countdown.current = setInterval(() => {
        forceUpdate();
        onChange?.(timestamp - Date.now());
        if (timestamp < Date.now()) {
          stopTimer();
        }
      }, REFRESH_INTERVAL2);
    }
  }, "syncTimer");
  React480.useEffect(() => {
    syncTimer();
    return () => {
      if (countdown.current) {
        clearInterval(countdown.current);
        countdown.current = null;
      }
    };
  }, [value]);
  const formatter = /* @__PURE__ */ __name((formatValue2, config) => formatCountdown(formatValue2, { ...config, format: format2 }), "formatter");
  const valueRender = /* @__PURE__ */ __name((node2) => cloneElement3(node2, { title: void 0 }), "valueRender");
  return /* @__PURE__ */ React480.createElement(Statistic_default, { ...rest, value, valueRender, formatter });
}, "Countdown");
var Countdown_default = React480.memo(Countdown);

// packages/ant-design/components/statistic/index.ts
Statistic_default.Countdown = Countdown_default;
var statistic_default2 = Statistic_default;

// packages/ant-design/components/steps/index.tsx
var import_CheckOutlined3 = __toESM(require_CheckOutlined3());
var import_CloseOutlined12 = __toESM(require_CloseOutlined3());
var import_classnames218 = __toESM(require_classnames());
import * as React484 from "react";

// packages/steps/src/Steps.tsx
var import_classnames217 = __toESM(require_classnames());
import React482 from "react";

// packages/steps/src/Step.tsx
var import_classnames216 = __toESM(require_classnames());
import * as React481 from "react";
function isString2(str) {
  return typeof str === "string";
}
__name(isString2, "isString");
var Step = /* @__PURE__ */ __name((props) => {
  const {
    className,
    prefixCls,
    style: style2,
    active,
    status,
    iconPrefix,
    icon,
    wrapperStyle,
    stepNumber,
    disabled,
    description,
    title,
    subTitle,
    progressDot,
    stepIcon,
    tailContent,
    icons: icons2,
    stepIndex,
    onStepClick,
    onClick,
    render: render2,
    ...restProps
  } = props;
  const clickable = !!onStepClick && !disabled;
  const accessibilityProps = {};
  if (clickable) {
    accessibilityProps.role = "button";
    accessibilityProps.tabIndex = 0;
    accessibilityProps.onClick = (e3) => {
      onClick?.(e3);
      onStepClick(stepIndex);
    };
    accessibilityProps.onKeyDown = (e3) => {
      const { which } = e3;
      if (which === KeyCode_default.ENTER || which === KeyCode_default.SPACE) {
        onStepClick(stepIndex);
      }
    };
  }
  const renderIconNode = /* @__PURE__ */ __name(() => {
    let iconNode;
    const iconClassName = (0, import_classnames216.default)(`${prefixCls}-icon`, `${iconPrefix}icon`, {
      [`${iconPrefix}icon-${icon}`]: icon && isString2(icon),
      [`${iconPrefix}icon-check`]: !icon && status === "finish" && (icons2 && !icons2.finish || !icons2),
      [`${iconPrefix}icon-cross`]: !icon && status === "error" && (icons2 && !icons2.error || !icons2)
    });
    const iconDot = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon-dot` });
    if (progressDot) {
      if (typeof progressDot === "function") {
        iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, progressDot(iconDot, {
          index: stepNumber - 1,
          status,
          title,
          description
        }));
      } else {
        iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, iconDot);
      }
    } else if (icon && !isString2(icon)) {
      iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, icon);
    } else if (icons2 && icons2.finish && status === "finish") {
      iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, icons2.finish);
    } else if (icons2 && icons2.error && status === "error") {
      iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, icons2.error);
    } else if (icon || status === "finish" || status === "error") {
      iconNode = /* @__PURE__ */ React481.createElement("span", { className: iconClassName });
    } else {
      iconNode = /* @__PURE__ */ React481.createElement("span", { className: `${prefixCls}-icon` }, stepNumber);
    }
    if (stepIcon) {
      iconNode = stepIcon({
        index: stepNumber - 1,
        status,
        title,
        description,
        node: iconNode
      });
    }
    return iconNode;
  }, "renderIconNode");
  const mergedStatus = status || "wait";
  const classString = (0, import_classnames216.default)(
    `${prefixCls}-item`,
    `${prefixCls}-item-${mergedStatus}`,
    className,
    {
      [`${prefixCls}-item-custom`]: icon,
      [`${prefixCls}-item-active`]: active,
      [`${prefixCls}-item-disabled`]: disabled === true
    }
  );
  const stepItemStyle = { ...style2 };
  let stepNode = /* @__PURE__ */ React481.createElement("div", { ...restProps, className: classString, style: stepItemStyle }, /* @__PURE__ */ React481.createElement("div", { onClick, ...accessibilityProps, className: `${prefixCls}-item-container` }, /* @__PURE__ */ React481.createElement("div", { className: `${prefixCls}-item-tail` }, tailContent), /* @__PURE__ */ React481.createElement("div", { className: `${prefixCls}-item-icon` }, renderIconNode()), /* @__PURE__ */ React481.createElement("div", { className: `${prefixCls}-item-content` }, /* @__PURE__ */ React481.createElement("div", { className: `${prefixCls}-item-title` }, title, subTitle && /* @__PURE__ */ React481.createElement(
    "div",
    {
      title: typeof subTitle === "string" ? subTitle : void 0,
      className: `${prefixCls}-item-subtitle`
    },
    subTitle
  )), description && /* @__PURE__ */ React481.createElement("div", { className: `${prefixCls}-item-description` }, description))));
  if (render2) {
    stepNode = render2(stepNode) || null;
  }
  return stepNode;
}, "Step");
if (true) {
  Step.displayName = "rc-step";
}
var Step_default = Step;

// packages/steps/src/Steps.tsx
var Steps3 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls = "rc-steps",
    style: style2 = {},
    className,
    children,
    direction = "horizontal",
    type: type5 = "default",
    labelPlacement = "horizontal",
    iconPrefix = "rc",
    status = "process",
    size,
    current = 0,
    progressDot = false,
    stepIcon,
    initial = 0,
    icons: icons2,
    onChange,
    itemRender,
    items = [],
    ...restProps
  } = props;
  const isNav = type5 === "navigation";
  const isInline = type5 === "inline";
  const mergedProgressDot = isInline || progressDot;
  const mergedDirection = isInline ? "horizontal" : direction;
  const mergedSize = isInline ? void 0 : size;
  const adjustedLabelPlacement = mergedProgressDot ? "vertical" : labelPlacement;
  const classString = (0, import_classnames217.default)(prefixCls, `${prefixCls}-${mergedDirection}`, className, {
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-label-${adjustedLabelPlacement}`]: mergedDirection === "horizontal",
    [`${prefixCls}-dot`]: !!mergedProgressDot,
    [`${prefixCls}-navigation`]: isNav,
    [`${prefixCls}-inline`]: isInline
  });
  const onStepClick = /* @__PURE__ */ __name((next2) => {
    if (onChange && current !== next2) {
      onChange(next2);
    }
  }, "onStepClick");
  const renderStep = /* @__PURE__ */ __name((item, index3) => {
    const mergedItem = { ...item };
    const stepNumber = initial + index3;
    if (status === "error" && index3 === current - 1) {
      mergedItem.className = `${prefixCls}-next-error`;
    }
    if (!mergedItem.status) {
      if (stepNumber === current) {
        mergedItem.status = status;
      } else if (stepNumber < current) {
        mergedItem.status = "finish";
      } else {
        mergedItem.status = "wait";
      }
    }
    if (isInline) {
      mergedItem.icon = void 0;
      mergedItem.subTitle = void 0;
    }
    if (!mergedItem.render && itemRender) {
      mergedItem.render = (stepItem) => itemRender(mergedItem, stepItem);
    }
    return /* @__PURE__ */ React482.createElement(
      Step_default,
      {
        ...mergedItem,
        active: stepNumber === current,
        stepNumber: stepNumber + 1,
        stepIndex: stepNumber,
        key: stepNumber,
        prefixCls,
        iconPrefix,
        wrapperStyle: style2,
        progressDot: mergedProgressDot,
        stepIcon,
        icons: icons2,
        onStepClick: onChange && onStepClick
      }
    );
  }, "renderStep");
  return /* @__PURE__ */ React482.createElement("div", { className: classString, style: style2, ...restProps }, items.filter(Boolean).map(renderStep));
}, "Steps");
Steps3.Step = Step_default;
if (true) {
  Steps3.displayName = "rc-steps";
}
var Steps_default3 = Steps3;

// packages/steps/src/index.ts
var src_default26 = Steps_default3;

// packages/ant-design/components/steps/style/custom-icon.ts
var genStepsCustomIconStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, customIconTop, customIconSize, customIconFontSize } = token2;
  return {
    [`${componentCls}-item-custom`]: {
      [`> ${componentCls}-item-container > ${componentCls}-item-icon`]: {
        height: "auto",
        background: "none",
        border: 0,
        [`> ${componentCls}-icon`]: {
          top: customIconTop,
          width: customIconSize,
          height: customIconSize,
          fontSize: customIconFontSize,
          lineHeight: `${unit(customIconFontSize)}`
        }
      }
    },
    // Only adjust horizontal customize icon width
    [`&:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-custom`]: {
        [`${componentCls}-item-icon`]: {
          width: "auto",
          background: "none"
        }
      }
    }
  };
}, "genStepsCustomIconStyle");
var custom_icon_default = genStepsCustomIconStyle;

// packages/ant-design/components/steps/style/horizontal.ts
var genHorizontalStyle3 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const stepsItemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-horizontal`]: {
      [`${stepsItemCls}-tail`]: {
        transform: "translateY(-50%)"
      }
    }
  };
}, "genHorizontalStyle");
var horizontal_default2 = genHorizontalStyle3;

// packages/ant-design/components/steps/style/inline.ts
var genStepsInlineStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, inlineDotSize, inlineTitleColor, inlineTailColor } = token2;
  const containerPaddingTop = token2.calc(token2.paddingXS).add(token2.lineWidth).equal();
  const titleStyle = {
    [`${componentCls}-item-container ${componentCls}-item-content ${componentCls}-item-title`]: {
      color: inlineTitleColor
    }
  };
  return {
    [`&${componentCls}-inline`]: {
      width: "auto",
      display: "inline-flex",
      [`${componentCls}-item`]: {
        flex: "none",
        "&-container": {
          padding: `${unit(containerPaddingTop)} ${unit(token2.paddingXXS)} 0`,
          margin: `0 ${unit(token2.calc(token2.marginXXS).div(2).equal())}`,
          borderRadius: token2.borderRadiusSM,
          cursor: "pointer",
          transition: `background-color ${token2.motionDurationMid}`,
          "&:hover": {
            background: token2.controlItemBgHover
          },
          [`&[role='button']:hover`]: {
            opacity: 1
          }
        },
        "&-icon": {
          width: inlineDotSize,
          height: inlineDotSize,
          marginInlineStart: `calc(50% - ${unit(token2.calc(inlineDotSize).div(2).equal())})`,
          [`> ${componentCls}-icon`]: {
            top: 0
          },
          [`${componentCls}-icon-dot`]: {
            borderRadius: token2.calc(token2.fontSizeSM).div(4).equal(),
            "&::after": {
              display: "none"
            }
          }
        },
        "&-content": {
          width: "auto",
          marginTop: token2.calc(token2.marginXS).sub(token2.lineWidth).equal()
        },
        "&-title": {
          color: inlineTitleColor,
          fontSize: token2.fontSizeSM,
          lineHeight: token2.lineHeightSM,
          fontWeight: "normal",
          marginBottom: token2.calc(token2.marginXXS).div(2).equal()
        },
        "&-description": {
          display: "none"
        },
        "&-tail": {
          marginInlineStart: 0,
          top: token2.calc(inlineDotSize).div(2).add(containerPaddingTop).equal(),
          transform: `translateY(-50%)`,
          "&:after": {
            width: "100%",
            height: token2.lineWidth,
            borderRadius: 0,
            marginInlineStart: 0,
            background: inlineTailColor
          }
        },
        [`&:first-child ${componentCls}-item-tail`]: {
          width: "50%",
          marginInlineStart: "50%"
        },
        [`&:last-child ${componentCls}-item-tail`]: {
          display: "block",
          width: "50%"
        },
        "&-wait": {
          [`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
            backgroundColor: token2.colorBorderBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${inlineTailColor}`
          },
          ...titleStyle
        },
        "&-finish": {
          [`${componentCls}-item-tail::after`]: {
            backgroundColor: inlineTailColor
          },
          [`${componentCls}-item-icon ${componentCls}-icon ${componentCls}-icon-dot`]: {
            backgroundColor: inlineTailColor,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${inlineTailColor}`
          },
          ...titleStyle
        },
        "&-error": titleStyle,
        "&-active, &-process": {
          [`${componentCls}-item-icon`]: {
            width: inlineDotSize,
            height: inlineDotSize,
            marginInlineStart: `calc(50% - ${unit(token2.calc(inlineDotSize).div(2).equal())})`,
            top: 0
          },
          ...titleStyle
        },
        [`&:not(${componentCls}-item-active) > ${componentCls}-item-container[role='button']:hover`]: {
          [`${componentCls}-item-title`]: {
            color: inlineTitleColor
          }
        }
      }
    }
  };
}, "genStepsInlineStyle");
var inline_default = genStepsInlineStyle;

// packages/ant-design/components/steps/style/label-placement.ts
var genStepsLabelPlacementStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconSize, lineHeight, iconSizeSM } = token2;
  return {
    [`&${componentCls}-label-vertical`]: {
      [`${componentCls}-item`]: {
        overflow: "visible",
        "&-tail": {
          marginInlineStart: token2.calc(iconSize).div(2).add(token2.controlHeightLG).equal(),
          padding: `0 ${unit(token2.paddingLG)}`
        },
        "&-content": {
          display: "block",
          width: token2.calc(iconSize).div(2).add(token2.controlHeightLG).mul(2).equal(),
          marginTop: token2.marginSM,
          textAlign: "center"
        },
        "&-icon": {
          display: "inline-block",
          marginInlineStart: token2.controlHeightLG
        },
        "&-title": {
          paddingInlineEnd: 0,
          paddingInlineStart: 0,
          "&::after": {
            display: "none"
          }
        },
        "&-subtitle": {
          display: "block",
          marginBottom: token2.marginXXS,
          marginInlineStart: 0,
          lineHeight
        }
      },
      [`&${componentCls}-small:not(${componentCls}-dot)`]: {
        [`${componentCls}-item`]: {
          "&-icon": {
            marginInlineStart: token2.calc(iconSize).sub(iconSizeSM).div(2).add(token2.controlHeightLG).equal()
          }
        }
      }
    }
  };
}, "genStepsLabelPlacementStyle");
var label_placement_default = genStepsLabelPlacementStyle;

// packages/ant-design/components/steps/style/nav.ts
var genStepsNavStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    navContentMaxWidth,
    navArrowColor,
    stepsNavActiveColor,
    motionDurationSlow
  } = token2;
  return {
    [`&${componentCls}-navigation`]: {
      paddingTop: token2.paddingSM,
      [`&${componentCls}-small`]: {
        [`${componentCls}-item`]: {
          "&-container": {
            marginInlineStart: token2.calc(token2.marginSM).mul(-1).equal()
          }
        }
      },
      [`${componentCls}-item`]: {
        overflow: "visible",
        textAlign: "center",
        "&-container": {
          display: "inline-block",
          height: "100%",
          marginInlineStart: token2.calc(token2.margin).mul(-1).equal(),
          paddingBottom: token2.paddingSM,
          textAlign: "start",
          transition: `opacity ${motionDurationSlow}`,
          [`${componentCls}-item-content`]: {
            maxWidth: navContentMaxWidth
          },
          [`${componentCls}-item-title`]: {
            maxWidth: "100%",
            paddingInlineEnd: 0,
            ...textEllipsis,
            "&::after": {
              display: "none"
            }
          }
        },
        [`&:not(${componentCls}-item-active)`]: {
          [`${componentCls}-item-container[role='button']`]: {
            cursor: "pointer",
            "&:hover": {
              opacity: 0.85
            }
          }
        },
        "&:last-child": {
          flex: 1,
          "&::after": {
            display: "none"
          }
        },
        "&::after": {
          position: "absolute",
          top: `calc(50% - ${unit(token2.calc(token2.paddingSM).div(2).equal())})`,
          insetInlineStart: "100%",
          display: "inline-block",
          width: token2.fontSizeIcon,
          height: token2.fontSizeIcon,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${navArrowColor}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${navArrowColor}`,
          transform: "translateY(-50%) translateX(-50%) rotate(45deg)",
          content: '""'
        },
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: "50%",
          display: "inline-block",
          width: 0,
          height: token2.lineWidthBold,
          backgroundColor: stepsNavActiveColor,
          transition: `width ${motionDurationSlow}, inset-inline-start ${motionDurationSlow}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        }
      },
      [`${componentCls}-item${componentCls}-item-active::before`]: {
        insetInlineStart: 0,
        width: "100%"
      }
    },
    [`&${componentCls}-navigation${componentCls}-vertical`]: {
      [`> ${componentCls}-item`]: {
        marginInlineEnd: 0,
        "&::before": {
          display: "none"
        },
        [`&${componentCls}-item-active::before`]: {
          top: 0,
          insetInlineEnd: 0,
          insetInlineStart: "unset",
          display: "block",
          width: token2.calc(token2.lineWidth).mul(3).equal(),
          height: `calc(100% - ${unit(token2.marginLG)})`
        },
        "&::after": {
          position: "relative",
          insetInlineStart: "50%",
          display: "block",
          width: token2.calc(token2.controlHeight).mul(0.25).equal(),
          height: token2.calc(token2.controlHeight).mul(0.25).equal(),
          marginBottom: token2.marginXS,
          textAlign: "center",
          transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
        },
        "&:last-child": {
          "&::after": {
            display: "none"
          }
        },
        [`> ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          visibility: "hidden"
        }
      }
    },
    [`&${componentCls}-navigation${componentCls}-horizontal`]: {
      [`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        visibility: "hidden"
      }
    }
  };
}, "genStepsNavStyle");
var nav_default = genStepsNavStyle;

// packages/ant-design/components/steps/style/progress.ts
var genStepsProgressStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    componentCls,
    iconSize,
    iconSizeSM,
    processIconColor,
    marginXXS,
    lineWidthBold,
    lineWidth,
    paddingXXS
  } = token2;
  const progressSize = token2.calc(iconSize).add(token2.calc(lineWidthBold).mul(4).equal()).equal();
  const progressSizeSM = token2.calc(iconSizeSM).add(token2.calc(token2.lineWidth).mul(4).equal()).equal();
  return {
    [`&${componentCls}-with-progress`]: {
      [`${componentCls}-item`]: {
        paddingTop: paddingXXS,
        [`&-process ${componentCls}-item-container ${componentCls}-item-icon ${componentCls}-icon`]: {
          color: processIconColor
        }
      },
      [`&${componentCls}-vertical > ${componentCls}-item `]: {
        paddingInlineStart: paddingXXS,
        [`> ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          top: marginXXS,
          insetInlineStart: token2.calc(iconSize).div(2).sub(lineWidth).add(paddingXXS).equal()
        }
      },
      [`&, &${componentCls}-small`]: {
        [`&${componentCls}-horizontal ${componentCls}-item:first-child`]: {
          paddingBottom: paddingXXS,
          paddingInlineStart: paddingXXS
        }
      },
      [`&${componentCls}-small${componentCls}-vertical > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        insetInlineStart: token2.calc(iconSizeSM).div(2).sub(lineWidth).add(paddingXXS).equal()
      },
      [`&${componentCls}-label-vertical ${componentCls}-item ${componentCls}-item-tail`]: {
        top: token2.calc(iconSize).div(2).add(paddingXXS).equal()
      },
      [`${componentCls}-item-icon`]: {
        position: "relative",
        [`${antCls}-progress`]: {
          position: "absolute",
          insetInlineStart: "50%",
          top: "50%",
          transform: "translate(-50%, -50%)",
          "&-inner": {
            width: `${unit(progressSize)} !important`,
            height: `${unit(progressSize)} !important`
          }
        }
      },
      // ============================== Small size ==============================
      [`&${componentCls}-small`]: {
        [`&${componentCls}-label-vertical ${componentCls}-item ${componentCls}-item-tail`]: {
          top: token2.calc(iconSizeSM).div(2).add(paddingXXS).equal()
        },
        [`${componentCls}-item-icon ${antCls}-progress-inner`]: {
          width: `${unit(progressSizeSM)} !important`,
          height: `${unit(progressSizeSM)} !important`
        }
      }
    }
  };
}, "genStepsProgressStyle");
var progress_default3 = genStepsProgressStyle;

// packages/ant-design/components/steps/style/progress-dot.ts
var genStepsProgressDotStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    descriptionMaxWidth,
    lineHeight,
    dotCurrentSize,
    dotSize,
    motionDurationSlow
  } = token2;
  return {
    [`&${componentCls}-dot, &${componentCls}-dot${componentCls}-small`]: {
      [`${componentCls}-item`]: {
        "&-title": {
          lineHeight
        },
        "&-tail": {
          // Math.floor((token.size - token.lineWidth * 3) / 2)
          top: token2.calc(token2.dotSize).sub(token2.calc(token2.lineWidth).mul(3).equal()).div(2).equal(),
          width: "100%",
          marginTop: 0,
          marginBottom: 0,
          marginInline: `${unit(token2.calc(descriptionMaxWidth).div(2).equal())} 0`,
          padding: 0,
          "&::after": {
            width: `calc(100% - ${unit(token2.calc(token2.marginSM).mul(2).equal())})`,
            height: token2.calc(token2.lineWidth).mul(3).equal(),
            marginInlineStart: token2.marginSM
          }
        },
        "&-icon": {
          width: dotSize,
          height: dotSize,
          marginInlineStart: token2.calc(token2.descriptionMaxWidth).sub(dotSize).div(2).equal(),
          paddingInlineEnd: 0,
          lineHeight: `${unit(dotSize)}`,
          background: "transparent",
          border: 0,
          [`${componentCls}-icon-dot`]: {
            position: "relative",
            float: "left",
            width: "100%",
            height: "100%",
            borderRadius: 100,
            // very large number
            transition: `all ${motionDurationSlow}`,
            /* expand hover area */
            "&::after": {
              position: "absolute",
              top: token2.calc(token2.marginSM).mul(-1).equal(),
              insetInlineStart: token2.calc(dotSize).sub(token2.calc(token2.controlHeightLG).mul(1.5).equal()).div(2).equal(),
              width: token2.calc(token2.controlHeightLG).mul(1.5).equal(),
              height: token2.controlHeight,
              background: "transparent",
              content: '""'
            }
          }
        },
        "&-content": {
          width: descriptionMaxWidth
        },
        [`&-process ${componentCls}-item-icon`]: {
          position: "relative",
          top: token2.calc(dotSize).sub(dotCurrentSize).div(2).equal(),
          width: dotCurrentSize,
          height: dotCurrentSize,
          lineHeight: `${unit(dotCurrentSize)}`,
          background: "none",
          marginInlineStart: token2.calc(token2.descriptionMaxWidth).sub(dotCurrentSize).div(2).equal()
        },
        [`&-process ${componentCls}-icon`]: {
          [`&:first-child ${componentCls}-icon-dot`]: {
            insetInlineStart: 0
          }
        }
      }
    },
    [`&${componentCls}-vertical${componentCls}-dot`]: {
      [`${componentCls}-item-icon`]: {
        marginTop: token2.calc(token2.controlHeight).sub(dotSize).div(2).equal(),
        marginInlineStart: 0,
        background: "none"
      },
      [`${componentCls}-item-process ${componentCls}-item-icon`]: {
        marginTop: token2.calc(token2.controlHeight).sub(dotCurrentSize).div(2).equal(),
        top: 0,
        insetInlineStart: token2.calc(dotSize).sub(dotCurrentSize).div(2).equal(),
        marginInlineStart: 0
      },
      // https://github.com/ant-design/ant-design/issues/18354
      [`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        top: token2.calc(token2.controlHeight).sub(dotSize).div(2).equal(),
        insetInlineStart: 0,
        margin: 0,
        padding: `${unit(token2.calc(dotSize).add(token2.paddingXS).equal())} 0 ${unit(
          token2.paddingXS
        )}`,
        "&::after": {
          marginInlineStart: token2.calc(dotSize).sub(token2.lineWidth).div(2).equal()
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-item-icon`]: {
          marginTop: token2.calc(token2.controlHeightSM).sub(dotSize).div(2).equal()
        },
        [`${componentCls}-item-process ${componentCls}-item-icon`]: {
          marginTop: token2.calc(token2.controlHeightSM).sub(dotCurrentSize).div(2).equal()
        },
        [`${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
          top: token2.calc(token2.controlHeightSM).sub(dotSize).div(2).equal()
        }
      },
      [`${componentCls}-item:first-child ${componentCls}-icon-dot`]: {
        insetInlineStart: 0
      },
      [`${componentCls}-item-content`]: {
        width: "inherit"
      }
    }
  };
}, "genStepsProgressDotStyle");
var progress_dot_default = genStepsProgressDotStyle;

// packages/ant-design/components/steps/style/rtl.ts
var genStepsRTLStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`&${componentCls}-rtl`]: {
      direction: "rtl",
      [`${componentCls}-item`]: {
        "&-subtitle": {
          float: "left"
        }
      },
      // nav
      [`&${componentCls}-navigation`]: {
        [`${componentCls}-item::after`]: {
          transform: "rotate(-45deg)"
        }
      },
      // vertical
      [`&${componentCls}-vertical`]: {
        [`> ${componentCls}-item`]: {
          "&::after": {
            transform: "rotate(225deg)"
          },
          [`${componentCls}-item-icon`]: {
            float: "right"
          }
        }
      },
      // progress-dot
      [`&${componentCls}-dot`]: {
        [`${componentCls}-item-icon ${componentCls}-icon-dot, &${componentCls}-small ${componentCls}-item-icon ${componentCls}-icon-dot`]: {
          float: "right"
        }
      }
    }
  };
}, "genStepsRTLStyle");
var rtl_default2 = genStepsRTLStyle;

// packages/ant-design/components/steps/style/small.ts
var genStepsSmallStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    iconSizeSM,
    // stepsSmallIconMargin,
    fontSizeSM,
    fontSize,
    colorTextDescription
  } = token2;
  return {
    [`&${componentCls}-small`]: {
      [`&${componentCls}-horizontal:not(${componentCls}-label-vertical) ${componentCls}-item`]: {
        paddingInlineStart: token2.paddingSM,
        "&:first-child": {
          paddingInlineStart: 0
        }
      },
      [`${componentCls}-item-icon`]: {
        width: iconSizeSM,
        height: iconSizeSM,
        // margin: stepsSmallIconMargin,
        marginTop: 0,
        marginBottom: 0,
        marginInline: `0 ${unit(token2.marginXS)}`,
        fontSize: fontSizeSM,
        lineHeight: `${unit(iconSizeSM)}`,
        textAlign: "center",
        borderRadius: iconSizeSM
      },
      [`${componentCls}-item-title`]: {
        paddingInlineEnd: token2.paddingSM,
        fontSize,
        lineHeight: `${unit(iconSizeSM)}`,
        "&::after": {
          top: token2.calc(iconSizeSM).div(2).equal()
        }
      },
      [`${componentCls}-item-description`]: {
        color: colorTextDescription,
        fontSize
      },
      [`${componentCls}-item-tail`]: {
        top: token2.calc(iconSizeSM).div(2).sub(token2.paddingXXS).equal()
      },
      [`${componentCls}-item-custom ${componentCls}-item-icon`]: {
        width: "inherit",
        height: "inherit",
        lineHeight: "inherit",
        background: "none",
        border: 0,
        borderRadius: 0,
        [`> ${componentCls}-icon`]: {
          fontSize: iconSizeSM,
          lineHeight: `${unit(iconSizeSM)}`,
          transform: "none"
        }
      }
    }
  };
}, "genStepsSmallStyle");
var small_default = genStepsSmallStyle;

// packages/ant-design/components/steps/style/vertical.ts
var genStepsVerticalStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconSizeSM, iconSize } = token2;
  return {
    [`&${componentCls}-vertical`]: {
      display: "flex",
      flexDirection: "column",
      [`> ${componentCls}-item`]: {
        display: "block",
        flex: "1 0 auto",
        paddingInlineStart: 0,
        overflow: "visible",
        [`${componentCls}-item-icon`]: {
          float: "left",
          marginInlineEnd: token2.margin
        },
        [`${componentCls}-item-content`]: {
          display: "block",
          minHeight: token2.calc(token2.controlHeight).mul(1.5).equal(),
          overflow: "hidden"
        },
        [`${componentCls}-item-title`]: {
          lineHeight: `${unit(iconSize)}`
        },
        [`${componentCls}-item-description`]: {
          paddingBottom: token2.paddingSM
        }
      },
      [`> ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: token2.calc(iconSize).div(2).sub(token2.lineWidth).equal(),
        width: token2.lineWidth,
        height: "100%",
        padding: `${unit(token2.calc(token2.marginXXS).mul(1.5).add(iconSize).equal())} 0 ${unit(
          token2.calc(token2.marginXXS).mul(1.5).equal()
        )}`,
        "&::after": {
          width: token2.lineWidth,
          height: "100%"
        }
      },
      [`> ${componentCls}-item:not(:last-child) > ${componentCls}-item-container > ${componentCls}-item-tail`]: {
        display: "block"
      },
      [` > ${componentCls}-item > ${componentCls}-item-container > ${componentCls}-item-content > ${componentCls}-item-title`]: {
        "&::after": {
          display: "none"
        }
      },
      [`&${componentCls}-small ${componentCls}-item-container`]: {
        [`${componentCls}-item-tail`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: token2.calc(iconSizeSM).div(2).sub(token2.lineWidth).equal(),
          padding: `${unit(token2.calc(token2.marginXXS).mul(1.5).add(iconSizeSM).equal())} 0 ${unit(
            token2.calc(token2.marginXXS).mul(1.5).equal()
          )}`
        },
        [`${componentCls}-item-title`]: {
          lineHeight: `${unit(iconSizeSM)}`
        }
      }
    }
  };
}, "genStepsVerticalStyle");
var vertical_default2 = genStepsVerticalStyle;

// packages/ant-design/components/steps/style/index.ts
var STEP_ITEM_STATUS_WAIT = "wait";
var STEP_ITEM_STATUS_PROCESS = "process";
var STEP_ITEM_STATUS_FINISH = "finish";
var STEP_ITEM_STATUS_ERROR = "error";
var genStepsItemStatusStyle = /* @__PURE__ */ __name((status, token2) => {
  const prefix = `${token2.componentCls}-item`;
  const iconColorKey = `${status}IconColor`;
  const titleColorKey = `${status}TitleColor`;
  const descriptionColorKey = `${status}DescriptionColor`;
  const tailColorKey = `${status}TailColor`;
  const iconBgColorKey = `${status}IconBgColor`;
  const iconBorderColorKey = `${status}IconBorderColor`;
  const dotColorKey = `${status}DotColor`;
  return {
    [`${prefix}-${status} ${prefix}-icon`]: {
      backgroundColor: token2[iconBgColorKey],
      borderColor: token2[iconBorderColorKey],
      [`> ${token2.componentCls}-icon`]: {
        color: token2[iconColorKey],
        [`${token2.componentCls}-icon-dot`]: {
          background: token2[dotColorKey]
        }
      }
    },
    [`${prefix}-${status}${prefix}-custom ${prefix}-icon`]: {
      [`> ${token2.componentCls}-icon`]: {
        color: token2[dotColorKey]
      }
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-title`]: {
      color: token2[titleColorKey],
      "&::after": {
        backgroundColor: token2[tailColorKey]
      }
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-content > ${prefix}-description`]: {
      color: token2[descriptionColorKey]
    },
    [`${prefix}-${status} > ${prefix}-container > ${prefix}-tail::after`]: {
      backgroundColor: token2[tailColorKey]
    }
  };
}, "genStepsItemStatusStyle");
var genStepsItemStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationSlow } = token2;
  const stepsItemCls = `${componentCls}-item`;
  const stepItemIconCls = `${stepsItemCls}-icon`;
  return {
    [stepsItemCls]: {
      position: "relative",
      display: "inline-block",
      flex: 1,
      overflow: "hidden",
      verticalAlign: "top",
      "&:last-child": {
        flex: "none",
        [`> ${stepsItemCls}-container > ${stepsItemCls}-tail, > ${stepsItemCls}-container >  ${stepsItemCls}-content > ${stepsItemCls}-title::after`]: {
          display: "none"
        }
      }
    },
    [`${stepsItemCls}-container`]: {
      outline: "none",
      [`&:focus-visible`]: {
        [stepItemIconCls]: {
          ...genFocusOutline(token2)
        }
      }
    },
    [`${stepItemIconCls}, ${stepsItemCls}-content`]: {
      display: "inline-block",
      verticalAlign: "top"
    },
    [stepItemIconCls]: {
      width: token2.iconSize,
      height: token2.iconSize,
      marginTop: 0,
      marginBottom: 0,
      marginInlineStart: 0,
      marginInlineEnd: token2.marginXS,
      fontSize: token2.iconFontSize,
      fontFamily: token2.fontFamily,
      lineHeight: `${unit(token2.iconSize)}`,
      textAlign: "center",
      borderRadius: token2.iconSize,
      border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
      transition: `background-color ${motionDurationSlow}, border-color ${motionDurationSlow}`,
      [`${componentCls}-icon`]: {
        position: "relative",
        top: token2.iconTop,
        color: token2.colorPrimary,
        lineHeight: 1
      }
    },
    [`${stepsItemCls}-tail`]: {
      position: "absolute",
      top: token2.calc(token2.iconSize).div(2).equal(),
      insetInlineStart: 0,
      width: "100%",
      "&::after": {
        display: "inline-block",
        width: "100%",
        height: token2.lineWidth,
        background: token2.colorSplit,
        borderRadius: token2.lineWidth,
        transition: `background ${motionDurationSlow}`,
        content: '""'
      }
    },
    [`${stepsItemCls}-title`]: {
      position: "relative",
      display: "inline-block",
      paddingInlineEnd: token2.padding,
      color: token2.colorText,
      fontSize: token2.fontSizeLG,
      lineHeight: `${unit(token2.titleLineHeight)}`,
      "&::after": {
        position: "absolute",
        top: token2.calc(token2.titleLineHeight).div(2).equal(),
        insetInlineStart: "100%",
        display: "block",
        width: 9999,
        height: token2.lineWidth,
        background: token2.processTailColor,
        content: '""'
      }
    },
    [`${stepsItemCls}-subtitle`]: {
      display: "inline",
      marginInlineStart: token2.marginXS,
      color: token2.colorTextDescription,
      fontWeight: "normal",
      fontSize: token2.fontSize
    },
    [`${stepsItemCls}-description`]: {
      color: token2.colorTextDescription,
      fontSize: token2.fontSize
    },
    ...genStepsItemStatusStyle(STEP_ITEM_STATUS_WAIT, token2),
    ...genStepsItemStatusStyle(STEP_ITEM_STATUS_PROCESS, token2),
    [`${stepsItemCls}-process > ${stepsItemCls}-container > ${stepsItemCls}-title`]: {
      fontWeight: token2.fontWeightStrong
    },
    ...genStepsItemStatusStyle(STEP_ITEM_STATUS_FINISH, token2),
    ...genStepsItemStatusStyle(STEP_ITEM_STATUS_ERROR, token2),
    [`${stepsItemCls}${componentCls}-next-error > ${componentCls}-item-title::after`]: {
      background: token2.colorError
    },
    [`${stepsItemCls}-disabled`]: {
      cursor: "not-allowed"
    }
  };
}, "genStepsItemStyle");
var genStepsClickableStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationSlow } = token2;
  return {
    [`& ${componentCls}-item`]: {
      [`&:not(${componentCls}-item-active)`]: {
        [`& > ${componentCls}-item-container[role='button']`]: {
          cursor: "pointer",
          [`${componentCls}-item`]: {
            [`&-title, &-subtitle, &-description, &-icon ${componentCls}-icon`]: {
              transition: `color ${motionDurationSlow}`
            }
          },
          "&:hover": {
            [`${componentCls}-item`]: {
              [`&-title, &-subtitle, &-description`]: {
                color: token2.colorPrimary
              }
            }
          }
        },
        [`&:not(${componentCls}-item-process)`]: {
          [`& > ${componentCls}-item-container[role='button']:hover`]: {
            [`${componentCls}-item`]: {
              "&-icon": {
                borderColor: token2.colorPrimary,
                [`${componentCls}-icon`]: {
                  color: token2.colorPrimary
                }
              }
            }
          }
        }
      }
    },
    [`&${componentCls}-horizontal:not(${componentCls}-label-vertical)`]: {
      [`${componentCls}-item`]: {
        paddingInlineStart: token2.padding,
        whiteSpace: "nowrap",
        "&:first-child": {
          paddingInlineStart: 0
        },
        [`&:last-child ${componentCls}-item-title`]: {
          paddingInlineEnd: 0
        },
        "&-tail": {
          display: "none"
        },
        "&-description": {
          maxWidth: token2.descriptionMaxWidth,
          whiteSpace: "normal"
        }
      }
    }
  };
}, "genStepsClickableStyle");
var genStepsStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      width: "100%",
      fontSize: 0,
      textAlign: "initial",
      // single Item
      ...genStepsItemStyle(token2),
      // Clickable
      ...genStepsClickableStyle(token2),
      // custom-icon
      ...custom_icon_default(token2),
      // small
      ...small_default(token2),
      // vertical
      ...vertical_default2(token2),
      // horizontal
      ...horizontal_default2(token2),
      // label-placement
      ...label_placement_default(token2),
      // progress-dot
      ...progress_dot_default(token2),
      // nav
      ...nav_default(token2),
      // rtl
      ...rtl_default2(token2),
      // progress
      ...progress_default3(token2),
      // inline
      ...inline_default(token2)
    }
  };
}, "genStepsStyle");
var prepareComponentToken48 = /* @__PURE__ */ __name((token2) => ({
  titleLineHeight: token2.controlHeight,
  customIconSize: token2.controlHeight,
  customIconTop: 0,
  customIconFontSize: token2.controlHeightSM,
  iconSize: token2.controlHeight,
  iconTop: -0.5,
  // magic for ui experience
  iconFontSize: token2.fontSize,
  iconSizeSM: token2.fontSizeHeading3,
  dotSize: token2.controlHeight / 4,
  dotCurrentSize: token2.controlHeightLG / 4,
  navArrowColor: token2.colorTextDisabled,
  navContentMaxWidth: "auto",
  descriptionMaxWidth: 140,
  waitIconColor: token2.wireframe ? token2.colorTextDisabled : token2.colorTextLabel,
  waitIconBgColor: token2.wireframe ? token2.colorBgContainer : token2.colorFillContent,
  waitIconBorderColor: token2.wireframe ? token2.colorTextDisabled : "transparent",
  finishIconBgColor: token2.wireframe ? token2.colorBgContainer : token2.controlItemBgActive,
  finishIconBorderColor: token2.wireframe ? token2.colorPrimary : token2.controlItemBgActive
}), "prepareComponentToken");
var style_default54 = genStyleHooks(
  "Steps",
  (token2) => {
    const {
      colorTextDisabled,
      controlHeightLG,
      colorTextLightSolid,
      colorText,
      colorPrimary,
      colorTextDescription,
      colorTextQuaternary,
      colorError,
      colorBorderSecondary,
      colorSplit
    } = token2;
    const stepsToken = merge2(token2, {
      // Steps component less variable
      processIconColor: colorTextLightSolid,
      processTitleColor: colorText,
      processDescriptionColor: colorText,
      processIconBgColor: colorPrimary,
      processIconBorderColor: colorPrimary,
      processDotColor: colorPrimary,
      processTailColor: colorSplit,
      waitTitleColor: colorTextDescription,
      waitDescriptionColor: colorTextDescription,
      waitTailColor: colorSplit,
      waitDotColor: colorTextDisabled,
      finishIconColor: colorPrimary,
      finishTitleColor: colorText,
      finishDescriptionColor: colorTextDescription,
      finishTailColor: colorPrimary,
      finishDotColor: colorPrimary,
      errorIconColor: colorTextLightSolid,
      errorTitleColor: colorError,
      errorDescriptionColor: colorError,
      errorTailColor: colorSplit,
      errorIconBgColor: colorError,
      errorIconBorderColor: colorError,
      errorDotColor: colorError,
      stepsNavActiveColor: colorPrimary,
      stepsProgressSize: controlHeightLG,
      // Steps inline variable
      inlineDotSize: 6,
      inlineTitleColor: colorTextQuaternary,
      inlineTailColor: colorBorderSecondary
    });
    return [genStepsStyle(stepsToken)];
  },
  prepareComponentToken48
);

// packages/ant-design/components/steps/useLegacyItems.ts
import * as React483 from "react";
function filter2(items) {
  return items.filter((item) => item);
}
__name(filter2, "filter");
function useLegacyItems2(items, children) {
  if (false) {
    const warning5 = devUseWarning("Menu");
    warning5.deprecated(!children, "Step", "items");
  }
  if (items) {
    return items;
  }
  const childrenItems = toArray(children).map((node2) => {
    if (React483.isValidElement(node2)) {
      const { props } = node2;
      const item = {
        ...props
      };
      return item;
    }
    return null;
  });
  return filter2(childrenItems);
}
__name(useLegacyItems2, "useLegacyItems");

// packages/ant-design/components/steps/index.tsx
var Steps4 = /* @__PURE__ */ __name((props) => {
  const {
    percent,
    size: customizeSize,
    className,
    rootClassName,
    direction,
    items,
    responsive = true,
    current = 0,
    children,
    style: style2,
    ...restProps
  } = props;
  const { xs } = useBreakpoint_default(responsive);
  const { getPrefixCls, direction: rtlDirection, steps } = React484.useContext(ConfigContext);
  const realDirectionValue = React484.useMemo(
    () => responsive && xs ? "vertical" : direction,
    [xs, direction]
  );
  const size = useSize_default(customizeSize);
  const prefixCls = getPrefixCls("steps", props.prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default54(prefixCls);
  const isInline = props.type === "inline";
  const iconPrefix = getPrefixCls("", props.iconPrefix);
  const mergedItems = useLegacyItems2(items, children);
  const mergedPercent = isInline ? void 0 : percent;
  const mergedStyle = { ...steps?.style, ...style2 };
  const stepsClassName = (0, import_classnames218.default)(
    steps?.className,
    {
      [`${prefixCls}-rtl`]: rtlDirection === "rtl",
      [`${prefixCls}-with-progress`]: mergedPercent !== void 0
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const icons2 = {
    finish: /* @__PURE__ */ React484.createElement(import_CheckOutlined3.default, { className: `${prefixCls}-finish-icon` }),
    error: /* @__PURE__ */ React484.createElement(import_CloseOutlined12.default, { className: `${prefixCls}-error-icon` })
  };
  const stepIconRender = /* @__PURE__ */ __name(({ node: node2, status }) => {
    if (status === "process" && mergedPercent !== void 0) {
      const progressWidth = size === "small" ? 32 : 40;
      return /* @__PURE__ */ React484.createElement("div", { className: `${prefixCls}-progress-icon` }, /* @__PURE__ */ React484.createElement(
        progress_default2,
        {
          type: "circle",
          percent: mergedPercent,
          size: progressWidth,
          strokeWidth: 4,
          format: () => null
        }
      ), node2);
    }
    return node2;
  }, "stepIconRender");
  const itemRender = /* @__PURE__ */ __name((item, stepItem) => item.description ? /* @__PURE__ */ React484.createElement(tooltip_default, { title: item.description }, stepItem) : stepItem, "itemRender");
  return wrapCSSVar(
    /* @__PURE__ */ React484.createElement(
      src_default26,
      {
        icons: icons2,
        ...restProps,
        style: mergedStyle,
        current,
        size,
        items: mergedItems,
        itemRender: isInline ? itemRender : void 0,
        stepIcon: stepIconRender,
        direction: realDirectionValue,
        prefixCls,
        iconPrefix,
        className: stepsClassName
      }
    )
  );
}, "Steps");
Steps4.Step = src_default26.Step;
if (true) {
  Steps4.displayName = "Steps";
}
var steps_default = Steps4;

// packages/ant-design/components/switch/index.tsx
var import_LoadingOutlined6 = __toESM(require_LoadingOutlined3());
var import_classnames220 = __toESM(require_classnames());
import * as React486 from "react";

// packages/switch/src/index.tsx
var import_classnames219 = __toESM(require_classnames());
import * as React485 from "react";
var Switch = React485.forwardRef(
  ({
    prefixCls = "rc-switch",
    className,
    checked,
    defaultChecked,
    disabled,
    loadingIcon,
    checkedChildren,
    unCheckedChildren,
    onClick,
    onChange,
    onKeyDown: onKeyDown2,
    ...restProps
  }, ref) => {
    const [innerChecked, setInnerChecked] = useMergedState(false, {
      value: checked,
      defaultValue: defaultChecked
    });
    function triggerChange(newChecked, event) {
      let mergedChecked = innerChecked;
      if (!disabled) {
        mergedChecked = newChecked;
        setInnerChecked(mergedChecked);
        onChange?.(mergedChecked, event);
      }
      return mergedChecked;
    }
    __name(triggerChange, "triggerChange");
    function onInternalKeyDown(e3) {
      if (e3.which === KeyCode_default.LEFT) {
        triggerChange(false, e3);
      } else if (e3.which === KeyCode_default.RIGHT) {
        triggerChange(true, e3);
      }
      onKeyDown2?.(e3);
    }
    __name(onInternalKeyDown, "onInternalKeyDown");
    function onInternalClick(e3) {
      const ret = triggerChange(!innerChecked, e3);
      onClick?.(ret, e3);
    }
    __name(onInternalClick, "onInternalClick");
    const switchClassName = (0, import_classnames219.default)(prefixCls, className, {
      [`${prefixCls}-checked`]: innerChecked,
      [`${prefixCls}-disabled`]: disabled
    });
    return /* @__PURE__ */ React485.createElement(
      "button",
      {
        ...restProps,
        type: "button",
        role: "switch",
        "aria-checked": innerChecked,
        disabled,
        className: switchClassName,
        ref,
        onKeyDown: onInternalKeyDown,
        onClick: onInternalClick
      },
      loadingIcon,
      /* @__PURE__ */ React485.createElement("span", { className: `${prefixCls}-inner` }, /* @__PURE__ */ React485.createElement("span", { className: `${prefixCls}-inner-checked` }, checkedChildren), /* @__PURE__ */ React485.createElement("span", { className: `${prefixCls}-inner-unchecked` }, unCheckedChildren))
    );
  }
);
Switch.displayName = "Switch";
var src_default27 = Switch;

// packages/ant-design/components/switch/style/index.ts
init_public_api();
var genSwitchSmallStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    trackHeightSM,
    trackPadding,
    trackMinWidthSM,
    innerMinMarginSM,
    innerMaxMarginSM,
    handleSizeSM,
    calc
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMarginSM).mul(2).equal());
  return {
    [componentCls]: {
      [`&${componentCls}-small`]: {
        minWidth: trackMinWidthSM,
        height: trackHeightSM,
        lineHeight: unit(trackHeightSM),
        [`${componentCls}-inner`]: {
          paddingInlineStart: innerMaxMarginSM,
          paddingInlineEnd: innerMinMarginSM,
          [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
            minHeight: trackHeightSM
          },
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
            marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: calc(trackHeightSM).mul(-1).equal(),
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${componentCls}-handle`]: {
          width: handleSizeSM,
          height: handleSizeSM
        },
        [`${componentCls}-loading-icon`]: {
          top: calc(calc(handleSizeSM).sub(token2.switchLoadingIconSize)).div(2).equal(),
          fontSize: token2.switchLoadingIconSize
        },
        [`&${componentCls}-checked`]: {
          [`${componentCls}-inner`]: {
            paddingInlineStart: innerMinMarginSM,
            paddingInlineEnd: innerMaxMarginSM,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
            }
          },
          [`${componentCls}-handle`]: {
            insetInlineStart: `calc(100% - ${unit(calc(handleSizeSM).add(trackPadding).equal())})`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: calc(token2.marginXXS).div(2).equal(),
              marginInlineEnd: calc(token2.marginXXS).mul(-1).div(2).equal()
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: calc(token2.marginXXS).mul(-1).div(2).equal(),
              marginInlineEnd: calc(token2.marginXXS).div(2).equal()
            }
          }
        }
      }
    }
  };
}, "genSwitchSmallStyle");
var genSwitchLoadingStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, handleSize, calc } = token2;
  return {
    [componentCls]: {
      [`${componentCls}-loading-icon${token2.iconCls}`]: {
        position: "relative",
        top: calc(calc(handleSize).sub(token2.fontSize)).div(2).equal(),
        color: token2.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
        color: token2.switchColor
      }
    }
  };
}, "genSwitchLoadingStyle");
var genSwitchHandleStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, trackPadding, handleBg, handleShadow, handleSize, calc } = token2;
  const switchHandleCls = `${componentCls}-handle`;
  return {
    [componentCls]: {
      [switchHandleCls]: {
        position: "absolute",
        top: trackPadding,
        insetInlineStart: trackPadding,
        width: handleSize,
        height: handleSize,
        transition: `all ${token2.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: handleBg,
          borderRadius: calc(handleSize).div(2).equal(),
          boxShadow: handleShadow,
          transition: `all ${token2.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${componentCls}-checked ${switchHandleCls}`]: {
        insetInlineStart: `calc(100% - ${unit(calc(handleSize).add(trackPadding).equal())})`
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`${switchHandleCls}::before`]: {
          insetInlineEnd: token2.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${componentCls}-checked ${switchHandleCls}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: token2.switchHandleActiveInset
        }
      }
    }
  };
}, "genSwitchHandleStyle");
var genSwitchInnerStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    trackHeight,
    trackPadding,
    innerMinMargin,
    innerMaxMargin,
    handleSize,
    calc
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMargin).mul(2).equal());
  return {
    [componentCls]: {
      [switchInnerCls]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: innerMaxMargin,
        paddingInlineEnd: innerMinMargin,
        transition: `padding-inline-start ${token2.switchDuration} ease-in-out, padding-inline-end ${token2.switchDuration} ease-in-out`,
        [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
          display: "block",
          color: token2.colorTextLightSolid,
          fontSize: token2.fontSizeSM,
          transition: `margin-inline-start ${token2.switchDuration} ease-in-out, margin-inline-end ${token2.switchDuration} ease-in-out`,
          pointerEvents: "none",
          minHeight: trackHeight
        },
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
        },
        [`${switchInnerCls}-unchecked`]: {
          marginTop: calc(trackHeight).mul(-1).equal(),
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${componentCls}-checked ${switchInnerCls}`]: {
        paddingInlineStart: innerMinMargin,
        paddingInlineEnd: innerMaxMargin,
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${switchInnerCls}-unchecked`]: {
          marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
        }
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: calc(trackPadding).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(2).equal()
          }
        }
      }
    }
  };
}, "genSwitchInnerStyle");
var genSwitchStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, trackHeight, trackMinWidth } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: trackMinWidth,
      height: trackHeight,
      lineHeight: `${unit(trackHeight)}`,
      verticalAlign: "middle",
      background: token2.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${componentCls}-disabled)`]: {
        background: token2.colorTextTertiary
      },
      ...genFocusStyle(token2),
      [`&${componentCls}-checked`]: {
        background: token2.switchColor,
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token2.colorPrimaryHover
        }
      },
      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
        cursor: "not-allowed",
        opacity: token2.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
}, "genSwitchStyle");
var prepareComponentToken49 = /* @__PURE__ */ __name((token2) => {
  const { fontSize, lineHeight, controlHeight, colorWhite } = token2;
  const height = fontSize * lineHeight;
  const heightSM = controlHeight / 2;
  const padding = 2;
  const handleSize = height - padding * 2;
  const handleSizeSM = heightSM - padding * 2;
  return {
    trackHeight: height,
    trackHeightSM: heightSM,
    trackMinWidth: handleSize * 2 + padding * 4,
    trackMinWidthSM: handleSizeSM * 2 + padding * 2,
    trackPadding: padding,
    // Fixed value
    handleBg: colorWhite,
    handleSize,
    handleSizeSM,
    handleShadow: `0 2px 4px 0 ${new TinyColor("#00230b").setAlpha(0.2).toRgbString()}`,
    innerMinMargin: handleSize / 2,
    innerMaxMargin: handleSize + padding + padding * 2,
    innerMinMarginSM: handleSizeSM / 2,
    innerMaxMarginSM: handleSizeSM + padding + padding * 2
  };
}, "prepareComponentToken");
var style_default55 = genStyleHooks(
  "Switch",
  (token2) => {
    const switchToken = merge2(token2, {
      switchDuration: token2.motionDurationMid,
      switchColor: token2.colorPrimary,
      switchDisabledOpacity: token2.opacityLoading,
      switchLoadingIconSize: token2.calc(token2.fontSizeIcon).mul(0.75).equal(),
      switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
      switchHandleActiveInset: "-30%"
    });
    return [
      genSwitchStyle(switchToken),
      // inner style
      genSwitchInnerStyle(switchToken),
      // handle style
      genSwitchHandleStyle(switchToken),
      // loading style
      genSwitchLoadingStyle(switchToken),
      // small style
      genSwitchSmallStyle(switchToken)
    ];
  },
  prepareComponentToken49
);

// packages/ant-design/components/switch/index.tsx
var InternalSwitch = React486.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    loading,
    className,
    rootClassName,
    style: style2,
    checked: checkedProp,
    value,
    defaultChecked: defaultCheckedProp,
    defaultValue,
    onChange,
    ...restProps
  } = props;
  const [checked, setChecked] = useMergedState(false, {
    value: checkedProp ?? value,
    defaultValue: defaultCheckedProp ?? defaultValue
  });
  const { getPrefixCls, direction, switch: SWITCH } = React486.useContext(ConfigContext);
  const disabled = React486.useContext(DisabledContext_default);
  const mergedDisabled = (customDisabled ?? disabled) || loading;
  const prefixCls = getPrefixCls("switch", customizePrefixCls);
  const loadingIcon = /* @__PURE__ */ React486.createElement("div", { className: `${prefixCls}-handle` }, loading && /* @__PURE__ */ React486.createElement(import_LoadingOutlined6.default, { className: `${prefixCls}-loading-icon` }));
  const [wrapCSSVar, hashId, cssVarCls] = style_default55(prefixCls);
  const mergedSize = useSize_default(customizeSize);
  const classes = (0, import_classnames220.default)(
    SWITCH?.className,
    {
      [`${prefixCls}-small`]: mergedSize === "small",
      [`${prefixCls}-loading`]: loading,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...SWITCH?.style, ...style2 };
  const changeHandler = /* @__PURE__ */ __name((...args) => {
    setChecked(args[0]);
    onChange?.(...args);
  }, "changeHandler");
  return wrapCSSVar(
    /* @__PURE__ */ React486.createElement(wave_default, { component: "Switch" }, /* @__PURE__ */ React486.createElement(
      src_default27,
      {
        ...restProps,
        checked,
        onChange: changeHandler,
        prefixCls,
        className: classes,
        style: mergedStyle,
        disabled: mergedDisabled,
        ref,
        loadingIcon
      }
    ))
  );
});
var Switch2 = InternalSwitch;
Switch2.__ANT_SWITCH = true;
if (true) {
  Switch2.displayName = "Switch";
}
var switch_default = Switch2;

// packages/ant-design/components/table/Table.tsx
import * as React553 from "react";

// packages/table/src/constant.ts
var EXPAND_COLUMN = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";

// node_modules/.pnpm/@rc-component+context@1.4.0_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/context/es/context.js
import * as React487 from "react";
import { unstable_batchedUpdates as unstable_batchedUpdates2 } from "react-dom";
function createContext45(defaultValue) {
  var Context3 = /* @__PURE__ */ React487.createContext(void 0);
  var Provider = /* @__PURE__ */ __name(function Provider2(_ref) {
    var value = _ref.value, children = _ref.children;
    var valueRef = React487.useRef(value);
    valueRef.current = value;
    var _React$useState = React487.useState(function() {
      return {
        getValue: /* @__PURE__ */ __name(function getValue3() {
          return valueRef.current;
        }, "getValue"),
        listeners: /* @__PURE__ */ new Set()
      };
    }), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
    useLayoutEffect_default(function() {
      unstable_batchedUpdates2(function() {
        context.listeners.forEach(function(listener) {
          listener(value);
        });
      });
    }, [value]);
    return /* @__PURE__ */ React487.createElement(Context3.Provider, {
      value: context
    }, children);
  }, "Provider");
  return {
    Context: Context3,
    Provider,
    defaultValue
  };
}
__name(createContext45, "createContext");
function useContext206(holder, selector) {
  var eventSelector = useEvent(typeof selector === "function" ? selector : function(ctx) {
    if (selector === void 0) {
      return ctx;
    }
    if (!Array.isArray(selector)) {
      return ctx[selector];
    }
    var obj = {};
    selector.forEach(function(key) {
      obj[key] = ctx[key];
    });
    return obj;
  });
  var context = React487.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
  var _ref2 = context || {}, listeners = _ref2.listeners, getValue3 = _ref2.getValue;
  var valueRef = React487.useRef();
  valueRef.current = eventSelector(context ? getValue3() : holder === null || holder === void 0 ? void 0 : holder.defaultValue);
  var _React$useState3 = React487.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
  useLayoutEffect_default(function() {
    if (!context) {
      return;
    }
    function trigger(nextValue) {
      var nextSelectorValue = eventSelector(nextValue);
      if (!isEqual_default(valueRef.current, nextSelectorValue, true)) {
        forceUpdate({});
      }
    }
    __name(trigger, "trigger");
    listeners.add(trigger);
    return function() {
      listeners.delete(trigger);
    };
  }, [context]);
  return valueRef.current;
}
__name(useContext206, "useContext");

// node_modules/.pnpm/@rc-component+context@1.4.0_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/context/es/Immutable.js
import * as React488 from "react";
function createImmutable() {
  var ImmutableContext = /* @__PURE__ */ React488.createContext(null);
  function useImmutableMark3() {
    return React488.useContext(ImmutableContext);
  }
  __name(useImmutableMark3, "useImmutableMark");
  function makeImmutable3(Component11, shouldTriggerRender) {
    var refAble = supportRef(Component11);
    var ImmutableComponent = /* @__PURE__ */ __name(function ImmutableComponent2(props, ref) {
      var refProps = refAble ? {
        ref
      } : {};
      var renderTimesRef = React488.useRef(0);
      var prevProps = React488.useRef(props);
      var mark = useImmutableMark3();
      if (mark !== null) {
        return /* @__PURE__ */ React488.createElement(Component11, _extends({}, props, refProps));
      }
      if (
        // Always trigger re-render if not provide `notTriggerRender`
        !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
      ) {
        renderTimesRef.current += 1;
      }
      prevProps.current = props;
      return /* @__PURE__ */ React488.createElement(ImmutableContext.Provider, {
        value: renderTimesRef.current
      }, /* @__PURE__ */ React488.createElement(Component11, _extends({}, props, refProps)));
    }, "ImmutableComponent");
    if (true) {
      ImmutableComponent.displayName = "ImmutableRoot(".concat(Component11.displayName || Component11.name, ")");
    }
    return refAble ? /* @__PURE__ */ React488.forwardRef(ImmutableComponent) : ImmutableComponent;
  }
  __name(makeImmutable3, "makeImmutable");
  function responseImmutable3(Component11, propsAreEqual) {
    var refAble = supportRef(Component11);
    var ImmutableComponent = /* @__PURE__ */ __name(function ImmutableComponent2(props, ref) {
      var refProps = refAble ? {
        ref
      } : {};
      useImmutableMark3();
      return /* @__PURE__ */ React488.createElement(Component11, _extends({}, props, refProps));
    }, "ImmutableComponent");
    if (true) {
      ImmutableComponent.displayName = "ImmutableResponse(".concat(Component11.displayName || Component11.name, ")");
    }
    return refAble ? /* @__PURE__ */ React488.memo(/* @__PURE__ */ React488.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ React488.memo(ImmutableComponent, propsAreEqual);
  }
  __name(responseImmutable3, "responseImmutable");
  return {
    makeImmutable: makeImmutable3,
    responseImmutable: responseImmutable3,
    useImmutableMark: useImmutableMark3
  };
}
__name(createImmutable, "createImmutable");

// node_modules/.pnpm/@rc-component+context@1.4.0_react-dom@16.14.0_react@16.14.0/node_modules/@rc-component/context/es/index.js
var _createImmutable = createImmutable();
var makeImmutable = _createImmutable.makeImmutable;
var responseImmutable = _createImmutable.responseImmutable;
var useImmutableMark = _createImmutable.useImmutableMark;

// packages/table/src/Footer/index.tsx
import * as React496 from "react";

// packages/table/src/context/TableContext.tsx
var { makeImmutable: makeImmutable2, responseImmutable: responseImmutable2, useImmutableMark: useImmutableMark2 } = createImmutable();
var TableContext = createContext45();
var TableContext_default = TableContext;

// packages/table/src/hooks/useRenderTimes.tsx
import * as React489 from "react";
function useRenderTimes(props, debug) {
  const timesRef = React489.useRef(0);
  timesRef.current += 1;
  const propsRef = React489.useRef(props);
  const keys2 = [];
  Object.keys(props || {}).map((key) => {
    if (props?.[key] !== propsRef.current?.[key]) {
      keys2.push(key);
    }
  });
  propsRef.current = props;
  const keysRef = React489.useRef([]);
  if (keys2.length) {
    keysRef.current = keys2;
  }
  React489.useDebugValue(timesRef.current);
  React489.useDebugValue(keysRef.current.join(", "));
  if (debug) {
    console.log(`${debug}:`, timesRef.current, keysRef.current);
  }
  return timesRef.current;
}
__name(useRenderTimes, "useRenderTimes");
var useRenderTimes_default = true ? useRenderTimes : () => {
};
var RenderBlock = React489.memo(() => {
  const times = useRenderTimes();
  return /* @__PURE__ */ React489.createElement("h1", null, "Render Times: ", times);
});
if (true) {
  RenderBlock.displayName = "RenderBlock";
}

// packages/table/src/Footer/Cell.tsx
import * as React494 from "react";

// packages/table/src/Cell/index.tsx
var import_classnames221 = __toESM(require_classnames());
import * as React492 from "react";

// packages/table/src/Cell/useCellRender.ts
init_warning();
import * as React491 from "react";

// packages/table/src/context/PerfContext.tsx
import * as React490 from "react";
var PerfContext = React490.createContext({
  renderWithProps: false
});
var PerfContext_default = PerfContext;

// packages/table/src/utils/valueUtil.tsx
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray8(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
__name(toArray8, "toArray");
function getColumnsKey(columns) {
  const columnKeys = [];
  const keys2 = {};
  columns.forEach((column2) => {
    const { key, dataIndex } = column2 || {};
    let mergedKey = key || toArray8(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = `${mergedKey}_next`;
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
__name(getColumnsKey, "getColumnsKey");
function validateValue(val) {
  return val !== null && val !== void 0;
}
__name(validateValue, "validateValue");

// packages/table/src/Cell/useCellRender.ts
function isRenderCell(data) {
  return data && typeof data === "object" && !Array.isArray(data) && !React491.isValidElement(data);
}
__name(isRenderCell, "isRenderCell");
function useCellRender2(record, dataIndex, renderIndex, children, render2, shouldCellUpdate) {
  const perfRecord = React491.useContext(PerfContext_default);
  const mark = useImmutableMark2();
  const retData = useMemo(
    () => {
      if (validateValue(children)) {
        return [children];
      }
      const path2 = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
      const value = get(record, path2);
      let returnChildNode = value;
      let returnCellProps = void 0;
      if (render2) {
        const renderData = render2(value, record, renderIndex);
        if (isRenderCell(renderData)) {
          if (true) {
            warning_default(
              false,
              "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead."
            );
          }
          returnChildNode = renderData.children;
          returnCellProps = renderData.props;
          perfRecord.renderWithProps = true;
        } else {
          returnChildNode = renderData;
        }
      }
      return [returnChildNode, returnCellProps];
    },
    [
      // Force update deps
      mark,
      // Normal deps
      record,
      children,
      dataIndex,
      render2,
      renderIndex
    ],
    (prev2, next2) => {
      if (shouldCellUpdate) {
        const [, prevRecord] = prev2;
        const [, nextRecord] = next2;
        return shouldCellUpdate(nextRecord, prevRecord);
      }
      if (perfRecord.renderWithProps) {
        return true;
      }
      return !isEqual_default(prev2, next2, true);
    }
  );
  return retData;
}
__name(useCellRender2, "useCellRender");

// packages/table/src/Cell/useHoverState.ts
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  const cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
__name(inHoverRange, "inHoverRange");
function useHoverState(rowIndex, rowSpan) {
  return useContext206(TableContext_default, (ctx) => {
    const hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
    return [hovering, ctx.onHover];
  });
}
__name(useHoverState, "useHoverState");

// packages/table/src/Cell/index.tsx
var getTitleFromCellRenderChildren = /* @__PURE__ */ __name(({
  ellipsis,
  rowType,
  children
}) => {
  let title;
  const ellipsisConfig = ellipsis === true ? { showTitle: true } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
    if (typeof children === "string" || typeof children === "number") {
      title = children.toString();
    } else if (React492.isValidElement(children) && typeof children.props.children === "string") {
      title = children.props.children;
    }
  }
  return title;
}, "getTitleFromCellRenderChildren");
function Cell2(props) {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    component: Component11,
    children,
    ellipsis,
    scope,
    // Style
    prefixCls,
    className,
    align,
    // Value
    record,
    render: render2,
    dataIndex,
    renderIndex,
    shouldCellUpdate,
    // Row
    index: index3,
    rowType,
    // Span
    colSpan,
    rowSpan,
    // Fixed
    fixLeft,
    fixRight,
    firstFixLeft,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    // Private
    appendNode,
    additionalProps = {},
    isSticky
  } = props;
  const cellPrefixCls = `${prefixCls}-cell`;
  const { supportSticky, allColumnsFixedLeft, rowHoverable } = useContext206(TableContext_default, [
    "supportSticky",
    "allColumnsFixedLeft",
    "rowHoverable"
  ]);
  const [childNode, legacyCellProps] = useCellRender2(
    record,
    dataIndex,
    renderIndex,
    children,
    render2,
    shouldCellUpdate
  );
  const fixedStyle = {};
  const isFixLeft = typeof fixLeft === "number" && supportSticky;
  const isFixRight = typeof fixRight === "number" && supportSticky;
  if (isFixLeft) {
    fixedStyle.position = "sticky";
    fixedStyle.left = fixLeft;
  }
  if (isFixRight) {
    fixedStyle.position = "sticky";
    fixedStyle.right = fixRight;
  }
  const mergedColSpan = legacyCellProps?.colSpan ?? additionalProps.colSpan ?? colSpan ?? 1;
  const mergedRowSpan = legacyCellProps?.rowSpan ?? additionalProps.rowSpan ?? rowSpan ?? 1;
  const [hovering, onHover] = useHoverState(index3, mergedRowSpan);
  const onMouseEnter = useEvent((event) => {
    if (record) {
      onHover(index3, index3 + mergedRowSpan - 1);
    }
    additionalProps?.onMouseEnter?.(event);
  });
  const onMouseLeave = useEvent((event) => {
    if (record) {
      onHover(-1, -1);
    }
    additionalProps?.onMouseLeave?.(event);
  });
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  }
  const title = additionalProps.title ?? getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  });
  const mergedClassName = (0, import_classnames221.default)(
    cellPrefixCls,
    className,
    {
      [`${cellPrefixCls}-fix-left`]: isFixLeft && supportSticky,
      [`${cellPrefixCls}-fix-left-first`]: firstFixLeft && supportSticky,
      [`${cellPrefixCls}-fix-left-last`]: lastFixLeft && supportSticky,
      [`${cellPrefixCls}-fix-left-all`]: lastFixLeft && allColumnsFixedLeft && supportSticky,
      [`${cellPrefixCls}-fix-right`]: isFixRight && supportSticky,
      [`${cellPrefixCls}-fix-right-first`]: firstFixRight && supportSticky,
      [`${cellPrefixCls}-fix-right-last`]: lastFixRight && supportSticky,
      [`${cellPrefixCls}-ellipsis`]: ellipsis,
      [`${cellPrefixCls}-with-append`]: appendNode,
      [`${cellPrefixCls}-fix-sticky`]: (isFixLeft || isFixRight) && isSticky && supportSticky,
      [`${cellPrefixCls}-row-hover`]: !legacyCellProps && hovering
    },
    additionalProps.className,
    legacyCellProps?.className
  );
  const alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  }
  const mergedStyle = {
    ...fixedStyle,
    ...additionalProps.style,
    ...alignStyle,
    ...legacyCellProps?.style
  };
  let mergedChildNode = childNode;
  if (typeof mergedChildNode === "object" && !Array.isArray(mergedChildNode) && !React492.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (lastFixLeft || firstFixRight)) {
    mergedChildNode = /* @__PURE__ */ React492.createElement("span", { className: `${cellPrefixCls}-content` }, mergedChildNode);
  }
  return /* @__PURE__ */ React492.createElement(
    Component11,
    {
      ...legacyCellProps,
      ...additionalProps,
      className: mergedClassName,
      style: mergedStyle,
      title,
      scope,
      onMouseEnter: rowHoverable ? onMouseEnter : void 0,
      onMouseLeave: rowHoverable ? onMouseLeave : void 0,
      colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
      rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
    },
    appendNode,
    mergedChildNode
  );
}
__name(Cell2, "Cell");
var Cell_default2 = React492.memo(Cell2);

// packages/table/src/utils/fixUtil.ts
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  const startColumn = columns[colStart] || {};
  const endColumn = columns[colEnd] || {};
  let fixLeft;
  let fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[direction === "rtl" ? colEnd : colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[direction === "rtl" ? colStart : colEnd];
  }
  let lastFixLeft = false;
  let firstFixRight = false;
  let lastFixRight = false;
  let firstFixLeft = false;
  const nextColumn = columns[colEnd + 1];
  const prevColumn = columns[colStart - 1];
  const canLastFix = nextColumn && nextColumn.fixed === void 0 || prevColumn && prevColumn.fixed === void 0 || columns.every((col) => col.fixed === "left");
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      const prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft && canLastFix;
    } else if (fixRight !== void 0) {
      const nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight && canLastFix;
    }
  } else if (fixLeft !== void 0) {
    const nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft && canLastFix;
  } else if (fixRight !== void 0) {
    const prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight && canLastFix;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
__name(getCellFixedInfo, "getCellFixedInfo");

// packages/table/src/Footer/SummaryContext.tsx
import * as React493 from "react";
var SummaryContext = React493.createContext({});
var SummaryContext_default = SummaryContext;

// packages/table/src/Footer/Cell.tsx
function SummaryCell({
  className,
  index: index3,
  children,
  colSpan = 1,
  rowSpan,
  align
}) {
  const { prefixCls, direction } = useContext206(TableContext_default, ["prefixCls", "direction"]);
  const { scrollColumnIndex, stickyOffsets, flattenColumns } = React494.useContext(SummaryContext_default);
  const lastIndex = index3 + colSpan - 1;
  const mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  const fixedInfo = getCellFixedInfo(
    index3,
    index3 + mergedColSpan - 1,
    flattenColumns,
    stickyOffsets,
    direction
  );
  return /* @__PURE__ */ React494.createElement(
    Cell_default2,
    {
      className,
      index: index3,
      component: "td",
      prefixCls,
      record: null,
      dataIndex: null,
      align,
      colSpan: mergedColSpan,
      rowSpan,
      render: () => children,
      ...fixedInfo
    }
  );
}
__name(SummaryCell, "SummaryCell");

// packages/table/src/Footer/Row.tsx
import * as React495 from "react";
function FooterRow({ children, ...props }) {
  return /* @__PURE__ */ React495.createElement("tr", { ...props }, children);
}
__name(FooterRow, "FooterRow");

// packages/table/src/Footer/Summary.tsx
function Summary({ children }) {
  return children;
}
__name(Summary, "Summary");
Summary.Row = FooterRow;
Summary.Cell = SummaryCell;
var Summary_default = Summary;

// packages/table/src/Footer/index.tsx
function Footer4(props) {
  if (true) {
    useRenderTimes_default(props);
  }
  const { children, stickyOffsets, flattenColumns } = props;
  const prefixCls = useContext206(TableContext_default, "prefixCls");
  const lastColumnIndex = flattenColumns.length - 1;
  const scrollColumn = flattenColumns[lastColumnIndex];
  const summaryContext = React496.useMemo(
    () => ({
      stickyOffsets,
      flattenColumns,
      scrollColumnIndex: scrollColumn?.scrollbar ? lastColumnIndex : null
    }),
    [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]
  );
  return /* @__PURE__ */ React496.createElement(SummaryContext_default.Provider, { value: summaryContext }, /* @__PURE__ */ React496.createElement("tfoot", { className: `${prefixCls}-summary` }, children));
}
__name(Footer4, "Footer");
var Footer_default = responseImmutable2(Footer4);
var FooterComponents = Summary_default;

// packages/table/src/sugar/Column.tsx
function Column2(_) {
  return null;
}
__name(Column2, "Column");
var Column_default = Column2;

// packages/table/src/sugar/ColumnGroup.tsx
function ColumnGroup(_) {
  return null;
}
__name(ColumnGroup, "ColumnGroup");
var ColumnGroup_default = ColumnGroup;

// packages/table/src/Table.tsx
var import_classnames227 = __toESM(require_classnames());
init_warning();
import * as React515 from "react";

// packages/table/src/Body/index.tsx
import * as React502 from "react";

// packages/table/src/hooks/useFlattenRecords.ts
import * as React497 from "react";
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index3) {
  list.push({
    record,
    indent,
    index: index3
  });
  const key = getRowKey(record);
  const expanded = expandedKeys?.has(key);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (let i = 0; i < record[childrenColumnName].length; i += 1) {
      fillRecords(
        list,
        record[childrenColumnName][i],
        indent + 1,
        childrenColumnName,
        expandedKeys,
        getRowKey,
        i
      );
    }
  }
}
__name(fillRecords, "fillRecords");
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
  const arr = React497.useMemo(() => {
    if (expandedKeys?.size) {
      const list = [];
      for (let i = 0; i < data?.length; i += 1) {
        const record = data[i];
        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
      }
      return list;
    }
    return data?.map((item, index3) => {
      return {
        record: item,
        indent: 0,
        index: index3
      };
    });
  }, [data, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}
__name(useFlattenRecords, "useFlattenRecords");

// packages/table/src/Body/BodyRow.tsx
var import_classnames223 = __toESM(require_classnames());
import * as React499 from "react";

// packages/table/src/hooks/useRowInfo.tsx
var import_classnames222 = __toESM(require_classnames());
function useRowInfo(record, rowKey, recordIndex, indent) {
  const context = useContext206(TableContext_default, [
    "prefixCls",
    "fixedInfoList",
    "flattenColumns",
    "expandableType",
    "expandRowByClick",
    "onTriggerExpand",
    "rowClassName",
    "expandedRowClassName",
    "indentSize",
    "expandIcon",
    "expandedRowRender",
    "expandIconColumnIndex",
    "expandedKeys",
    "childrenColumnName",
    "rowExpandable",
    "onRow"
  ]);
  const {
    flattenColumns,
    expandableType,
    expandedKeys,
    childrenColumnName,
    onTriggerExpand,
    rowExpandable,
    onRow,
    expandRowByClick,
    rowClassName
  } = context;
  const nestExpandable = expandableType === "nest";
  const rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
  const mergedExpandable = rowSupportExpand || nestExpandable;
  const expanded = expandedKeys && expandedKeys.has(rowKey);
  const hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  const onInternalTriggerExpand = useEvent(onTriggerExpand);
  const rowProps = onRow?.(record, recordIndex);
  const onRowClick = rowProps?.onClick;
  const onClick = /* @__PURE__ */ __name((event, ...args) => {
    if (expandRowByClick && mergedExpandable) {
      onTriggerExpand(record, event);
    }
    onRowClick?.(event, ...args);
  }, "onClick");
  let computeRowClassName;
  if (typeof rowClassName === "string") {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === "function") {
    computeRowClassName = rowClassName(record, recordIndex, indent);
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return {
    ...context,
    columnsKey,
    nestExpandable,
    expanded,
    hasNestChildren,
    record,
    onTriggerExpand: onInternalTriggerExpand,
    rowSupportExpand,
    expandable: mergedExpandable,
    rowProps: {
      ...rowProps,
      className: (0, import_classnames222.default)(computeRowClassName, rowProps?.className),
      onClick
    }
  };
}
__name(useRowInfo, "useRowInfo");

// packages/table/src/Body/ExpandedRow.tsx
import * as React498 from "react";
function ExpandedRow(props) {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    prefixCls,
    children,
    component: Component11,
    cellComponent,
    className,
    expanded,
    colSpan,
    isEmpty: isEmpty2
  } = props;
  const { scrollbarSize, fixHeader, fixColumn, componentWidth, horizonScroll } = useContext206(
    TableContext_default,
    ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]
  );
  let contentNode = children;
  if (isEmpty2 ? horizonScroll && componentWidth : fixColumn) {
    contentNode = /* @__PURE__ */ React498.createElement(
      "div",
      {
        style: {
          width: componentWidth - (fixHeader ? scrollbarSize : 0),
          position: "sticky",
          left: 0,
          overflow: "hidden"
        },
        className: `${prefixCls}-expanded-row-fixed`
      },
      contentNode
    );
  }
  return /* @__PURE__ */ React498.createElement(
    Component11,
    {
      className,
      style: {
        display: expanded ? null : "none"
      }
    },
    /* @__PURE__ */ React498.createElement(Cell_default2, { component: cellComponent, prefixCls, colSpan }, contentNode)
  );
}
__name(ExpandedRow, "ExpandedRow");
var ExpandedRow_default = ExpandedRow;

// packages/table/src/Body/BodyRow.tsx
function getCellProps(rowInfo, column2, colIndex, indent, index3) {
  const {
    record,
    prefixCls,
    columnsKey,
    fixedInfoList,
    expandIconColumnIndex,
    nestExpandable,
    indentSize,
    expandIcon,
    expanded,
    hasNestChildren,
    onTriggerExpand
  } = rowInfo;
  const key = columnsKey[colIndex];
  const fixedInfo = fixedInfoList[colIndex];
  let appendCellNode;
  if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
    appendCellNode = /* @__PURE__ */ React499.createElement(React499.Fragment, null, /* @__PURE__ */ React499.createElement(
      "span",
      {
        style: { paddingLeft: `${indentSize * indent}px` },
        className: `${prefixCls}-row-indent indent-level-${indent}`
      }
    ), expandIcon({
      prefixCls,
      expanded,
      expandable: hasNestChildren,
      record,
      onExpand: onTriggerExpand
    }));
  }
  let additionalCellProps;
  if (column2.onCell) {
    additionalCellProps = column2.onCell(record, index3);
  }
  return {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps: additionalCellProps || {}
  };
}
__name(getCellProps, "getCellProps");
function BodyRow(props) {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    style: style2,
    record,
    index: index3,
    renderIndex,
    rowKey,
    indent = 0,
    rowComponent: RowComponent,
    cellComponent,
    scopeCellComponent
  } = props;
  const rowInfo = useRowInfo(record, rowKey, index3, indent);
  const {
    prefixCls,
    flattenColumns,
    expandedRowClassName,
    expandedRowRender,
    rowProps,
    // Misc
    expanded,
    rowSupportExpand
  } = rowInfo;
  const expandedRef = React499.useRef(false);
  expandedRef.current ||= expanded;
  if (true) {
    useRenderTimes_default(props);
  }
  const computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index3, indent);
  const baseRowNode = /* @__PURE__ */ React499.createElement(
    RowComponent,
    {
      ...rowProps,
      "data-row-key": rowKey,
      className: (0, import_classnames223.default)(
        className,
        `${prefixCls}-row`,
        `${prefixCls}-row-level-${indent}`,
        rowProps?.className,
        indent >= 1 ? computedExpandedRowClassName : ""
      ),
      style: {
        ...style2,
        ...rowProps?.style
      }
    },
    flattenColumns.map((column2, colIndex) => {
      const { render: render2, dataIndex, className: columnClassName } = column2;
      const { key, fixedInfo, appendCellNode, additionalCellProps } = getCellProps(
        rowInfo,
        column2,
        colIndex,
        indent,
        index3
      );
      return /* @__PURE__ */ React499.createElement(
        Cell_default2,
        {
          className: columnClassName,
          ellipsis: column2.ellipsis,
          align: column2.align,
          scope: column2.rowScope,
          component: column2.rowScope ? scopeCellComponent : cellComponent,
          prefixCls,
          key,
          record,
          index: index3,
          renderIndex,
          dataIndex,
          render: render2,
          shouldCellUpdate: column2.shouldCellUpdate,
          ...fixedInfo,
          appendNode: appendCellNode,
          additionalProps: additionalCellProps
        }
      );
    })
  );
  let expandRowNode;
  if (rowSupportExpand && (expandedRef.current || expanded)) {
    const expandContent = expandedRowRender(record, index3, indent + 1, expanded);
    expandRowNode = /* @__PURE__ */ React499.createElement(
      ExpandedRow_default,
      {
        expanded,
        className: (0, import_classnames223.default)(
          `${prefixCls}-expanded-row`,
          `${prefixCls}-expanded-row-level-${indent + 1}`,
          computedExpandedRowClassName
        ),
        prefixCls,
        component: RowComponent,
        cellComponent,
        colSpan: flattenColumns.length,
        isEmpty: false
      },
      expandContent
    );
  }
  return /* @__PURE__ */ React499.createElement(React499.Fragment, null, baseRowNode, expandRowNode);
}
__name(BodyRow, "BodyRow");
if (true) {
  BodyRow.displayName = "BodyRow";
}
var BodyRow_default = responseImmutable2(BodyRow);

// packages/table/src/Body/MeasureRow.tsx
import * as React501 from "react";

// packages/table/src/Body/MeasureCell.tsx
import * as React500 from "react";
function MeasureCell({ columnKey, onColumnResize }) {
  const cellRef = React500.useRef();
  React500.useEffect(() => {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return /* @__PURE__ */ React500.createElement(src_default, { data: columnKey }, /* @__PURE__ */ React500.createElement("td", { ref: cellRef, style: { padding: 0, border: 0, height: 0 } }, /* @__PURE__ */ React500.createElement("div", { style: { height: 0, overflow: "hidden" } }, "\xA0")));
}
__name(MeasureCell, "MeasureCell");

// packages/table/src/Body/MeasureRow.tsx
function MeasureRow({ prefixCls, columnsKey, onColumnResize }) {
  return /* @__PURE__ */ React501.createElement(
    "tr",
    {
      "aria-hidden": "true",
      className: `${prefixCls}-measure-row`,
      style: { height: 0, fontSize: 0 }
    },
    /* @__PURE__ */ React501.createElement(
      src_default.Collection,
      {
        onBatchResize: (infoList) => {
          infoList.forEach(({ data: columnKey, size }) => {
            onColumnResize(columnKey, size.offsetWidth);
          });
        }
      },
      columnsKey.map((columnKey) => /* @__PURE__ */ React501.createElement(MeasureCell, { key: columnKey, columnKey, onColumnResize }))
    )
  );
}
__name(MeasureRow, "MeasureRow");

// packages/table/src/Body/index.tsx
function Body(props) {
  if (true) {
    useRenderTimes_default(props);
  }
  const { data, measureColumnWidth } = props;
  const {
    prefixCls,
    getComponent,
    onColumnResize,
    flattenColumns,
    getRowKey,
    expandedKeys,
    childrenColumnName,
    emptyNode
  } = useContext206(TableContext_default, [
    "prefixCls",
    "getComponent",
    "onColumnResize",
    "flattenColumns",
    "getRowKey",
    "expandedKeys",
    "childrenColumnName",
    "emptyNode"
  ]);
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const perfRef = React502.useRef({
    renderWithProps: false
  });
  const WrapperComponent = getComponent(["body", "wrapper"], "tbody");
  const trComponent = getComponent(["body", "row"], "tr");
  const tdComponent = getComponent(["body", "cell"], "td");
  const thComponent = getComponent(["body", "cell"], "th");
  let rows;
  if (data.length) {
    rows = flattenData2.map((item, idx) => {
      const { record, indent, index: renderIndex } = item;
      const key = getRowKey(record, idx);
      return /* @__PURE__ */ React502.createElement(
        BodyRow_default,
        {
          key,
          rowKey: key,
          record,
          index: idx,
          renderIndex,
          rowComponent: trComponent,
          cellComponent: tdComponent,
          scopeCellComponent: thComponent,
          getRowKey,
          indent
        }
      );
    });
  } else {
    rows = /* @__PURE__ */ React502.createElement(
      ExpandedRow_default,
      {
        expanded: true,
        className: `${prefixCls}-placeholder`,
        prefixCls,
        component: trComponent,
        cellComponent: tdComponent,
        colSpan: flattenColumns.length,
        isEmpty: true
      },
      emptyNode
    );
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return /* @__PURE__ */ React502.createElement(PerfContext_default.Provider, { value: perfRef.current }, /* @__PURE__ */ React502.createElement(WrapperComponent, { className: `${prefixCls}-tbody` }, measureColumnWidth && /* @__PURE__ */ React502.createElement(
    MeasureRow,
    {
      prefixCls,
      columnsKey,
      onColumnResize
    }
  ), rows));
}
__name(Body, "Body");
if (true) {
  Body.displayName = "Body";
}
var Body_default = responseImmutable2(Body);

// packages/table/src/ColGroup.tsx
import * as React503 from "react";

// packages/table/src/utils/legacyUtil.ts
init_warning();
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  const { expandable, ...legacyExpandableConfig } = props;
  let config;
  if ("expandable" in props) {
    config = {
      ...legacyExpandableConfig,
      ...expandable
    };
  } else {
    if ([
      "indentSize",
      "expandedRowKeys",
      "defaultExpandedRowKeys",
      "defaultExpandAllRows",
      "expandedRowRender",
      "expandRowByClick",
      "expandIcon",
      "onExpand",
      "onExpandedRowsChange",
      "expandedRowClassName",
      "expandIconColumnIndex",
      "showExpandColumn",
      "title"
    ].some((prop) => prop in props)) {
      warning_default(false, "expanded related props have been moved into `expandable`.");
    }
    config = legacyExpandableConfig;
  }
  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }
  return config;
}
__name(getExpandableProps, "getExpandableProps");

// packages/table/src/ColGroup.tsx
function ColGroup({ colWidths, columns, columCount }) {
  const cols = [];
  const len = columCount || columns.length;
  let mustInsert = false;
  for (let i = len - 1; i >= 0; i -= 1) {
    const width = colWidths[i];
    const column2 = columns && columns[i];
    const additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      const { columnType, ...restAdditionalProps } = additionalProps || {};
      cols.unshift(/* @__PURE__ */ React503.createElement("col", { key: i, style: { width }, ...restAdditionalProps }));
      mustInsert = true;
    }
  }
  return /* @__PURE__ */ React503.createElement("colgroup", null, cols);
}
__name(ColGroup, "ColGroup");
var ColGroup_default = ColGroup;

// packages/table/src/FixedHolder/index.tsx
var import_classnames224 = __toESM(require_classnames());
import * as React504 from "react";
import { useMemo as useMemo154 } from "react";
function useColumnWidth(colWidths, columCount) {
  return useMemo154(() => {
    const cloneColumns = [];
    for (let i = 0; i < columCount; i += 1) {
      const val = colWidths[i];
      if (val !== void 0) {
        cloneColumns[i] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
__name(useColumnWidth, "useColumnWidth");
var FixedHolder = React504.forwardRef((props, ref) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    noData,
    columns,
    flattenColumns,
    colWidths,
    columCount,
    stickyOffsets,
    direction,
    fixHeader,
    stickyTopOffset,
    stickyBottomOffset,
    stickyClassName,
    onScroll,
    maxContentScroll,
    children,
    ...restProps
  } = props;
  const { prefixCls, scrollbarSize, isSticky, getComponent } = useContext206(TableContext_default, [
    "prefixCls",
    "scrollbarSize",
    "isSticky",
    "getComponent"
  ]);
  const TableComponent = getComponent(["header", "table"], "table");
  const combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
  const scrollRef = React504.useRef(null);
  const setScrollRef = React504.useCallback((element) => {
    fillRef(ref, element);
    fillRef(scrollRef, element);
  }, []);
  React504.useEffect(() => {
    function onWheel(e3) {
      const { currentTarget, deltaX } = e3;
      if (deltaX) {
        onScroll({ currentTarget, scrollLeft: currentTarget.scrollLeft + deltaX });
        e3.preventDefault();
      }
    }
    __name(onWheel, "onWheel");
    scrollRef.current?.addEventListener("wheel", onWheel);
    return () => {
      scrollRef.current?.removeEventListener("wheel", onWheel);
    };
  }, []);
  const allFlattenColumnsWithWidth = React504.useMemo(
    () => flattenColumns.every((column2) => column2.width),
    [flattenColumns]
  );
  const lastColumn = flattenColumns[flattenColumns.length - 1];
  const ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: () => ({
      className: `${prefixCls}-cell-scrollbar`
    })
  };
  const columnsWithScrollbar = useMemo154(
    () => combinationScrollBarSize ? [...columns, ScrollBarColumn] : columns,
    [combinationScrollBarSize, columns]
  );
  const flattenColumnsWithScrollbar = useMemo154(
    () => combinationScrollBarSize ? [...flattenColumns, ScrollBarColumn] : flattenColumns,
    [combinationScrollBarSize, flattenColumns]
  );
  const headerStickyOffsets = useMemo154(() => {
    const { right, left } = stickyOffsets;
    return {
      ...stickyOffsets,
      left: direction === "rtl" ? [...left.map((width) => width + combinationScrollBarSize), 0] : left,
      right: direction === "rtl" ? right : [...right.map((width) => width + combinationScrollBarSize), 0],
      isSticky
    };
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  const mergedColumnWidth = useColumnWidth(colWidths, columCount);
  return /* @__PURE__ */ React504.createElement(
    "div",
    {
      style: {
        overflow: "hidden",
        ...isSticky ? { top: stickyTopOffset, bottom: stickyBottomOffset } : {}
      },
      ref: setScrollRef,
      className: (0, import_classnames224.default)(className, {
        [stickyClassName]: !!stickyClassName
      })
    },
    /* @__PURE__ */ React504.createElement(
      TableComponent,
      {
        style: {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth ? null : "hidden"
        }
      },
      (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ React504.createElement(
        ColGroup_default,
        {
          colWidths: mergedColumnWidth ? [...mergedColumnWidth, combinationScrollBarSize] : [],
          columCount: columCount + 1,
          columns: flattenColumnsWithScrollbar
        }
      ),
      children({
        ...restProps,
        stickyOffsets: headerStickyOffsets,
        columns: columnsWithScrollbar,
        flattenColumns: flattenColumnsWithScrollbar
      })
    )
  );
});
if (true) {
  FixedHolder.displayName = "FixedHolder";
}
var FixedHolder_default = React504.memo(FixedHolder);

// packages/table/src/Header/Header.tsx
import * as React506 from "react";

// packages/table/src/Header/HeaderRow.tsx
import * as React505 from "react";
var HeaderRow = /* @__PURE__ */ __name((props) => {
  const {
    cells,
    stickyOffsets,
    flattenColumns,
    rowComponent: RowComponent,
    cellComponent: CellComponent,
    onHeaderRow,
    index: index3
  } = props;
  const { prefixCls, direction } = useContext206(TableContext_default, ["prefixCls", "direction"]);
  let rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(
      cells.map((cell) => cell.column),
      index3
    );
  }
  const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
  return /* @__PURE__ */ React505.createElement(RowComponent, { ...rowProps }, cells.map((cell, cellIndex) => {
    const { column: column2 } = cell;
    const fixedInfo = getCellFixedInfo(
      cell.colStart,
      cell.colEnd,
      flattenColumns,
      stickyOffsets,
      direction
    );
    let additionalProps;
    if (column2 && column2.onHeaderCell) {
      additionalProps = cell.column.onHeaderCell(column2);
    }
    return /* @__PURE__ */ React505.createElement(
      Cell_default2,
      {
        ...cell,
        scope: column2.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
        ellipsis: column2.ellipsis,
        align: column2.align,
        component: CellComponent,
        prefixCls,
        key: columnsKey[cellIndex],
        ...fixedInfo,
        additionalProps,
        rowType: "header"
      }
    );
  }));
}, "HeaderRow");
if (true) {
  HeaderRow.displayName = "HeaderRow";
}
var HeaderRow_default = HeaderRow;

// packages/table/src/Header/Header.tsx
function parseHeaderRows(rootColumns) {
  const rows = [];
  function fillRowCells(columns, colIndex, rowIndex = 0) {
    rows[rowIndex] = rows[rowIndex] || [];
    let currentColIndex = colIndex;
    const colSpans = columns.filter(Boolean).map((column2) => {
      const cell = {
        key: column2.key,
        className: column2.className || "",
        children: column2.title,
        column: column2,
        colStart: currentColIndex
      };
      let colSpan = 1;
      const subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce(
          (total, count) => total + count,
          0
        );
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column2) {
        ({ colSpan } = column2);
      }
      if ("rowSpan" in column2) {
        cell.rowSpan = column2.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  __name(fillRowCells, "fillRowCells");
  fillRowCells(rootColumns, 0);
  const rowCount = rows.length;
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    rows[rowIndex].forEach((cell) => {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  }
  return rows;
}
__name(parseHeaderRows, "parseHeaderRows");
var Header2 = /* @__PURE__ */ __name((props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const { stickyOffsets, columns, flattenColumns, onHeaderRow } = props;
  const { prefixCls, getComponent } = useContext206(TableContext_default, ["prefixCls", "getComponent"]);
  const rows = React506.useMemo(() => parseHeaderRows(columns), [columns]);
  const WrapperComponent = getComponent(["header", "wrapper"], "thead");
  const trComponent = getComponent(["header", "row"], "tr");
  const thComponent = getComponent(["header", "cell"], "th");
  return /* @__PURE__ */ React506.createElement(WrapperComponent, { className: `${prefixCls}-thead` }, rows.map((row, rowIndex) => {
    const rowNode = /* @__PURE__ */ React506.createElement(
      HeaderRow_default,
      {
        key: rowIndex,
        flattenColumns,
        cells: row,
        stickyOffsets,
        rowComponent: trComponent,
        cellComponent: thComponent,
        onHeaderRow,
        index: rowIndex
      }
    );
    return rowNode;
  }));
}, "Header");
var Header_default2 = responseImmutable2(Header2);

// packages/table/src/hooks/useColumns/index.tsx
init_warning();
import * as React508 from "react";

// packages/table/src/hooks/useColumns/useWidthColumns.tsx
import * as React507 from "react";
function parseColWidth(totalWidth, width = "") {
  if (typeof width === "number") {
    return width;
  }
  if (width.endsWith("%")) {
    return totalWidth * parseFloat(width) / 100;
  }
  return null;
}
__name(parseColWidth, "parseColWidth");
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
  return React507.useMemo(() => {
    if (scrollWidth && scrollWidth > 0) {
      let totalWidth = 0;
      let missWidthCount = 0;
      flattenColumns.forEach((col) => {
        const colWidth = parseColWidth(scrollWidth, col.width);
        if (colWidth) {
          totalWidth += colWidth;
        } else {
          missWidthCount += 1;
        }
      });
      const maxFitWidth = Math.max(scrollWidth, clientWidth);
      let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
      let restCount = missWidthCount;
      const avgWidth = restWidth / missWidthCount;
      let realTotal = 0;
      const filledColumns = flattenColumns.map((col) => {
        const clone = {
          ...col
        };
        const colWidth = parseColWidth(scrollWidth, clone.width);
        if (colWidth) {
          clone.width = colWidth;
        } else {
          const colAvgWidth = Math.floor(avgWidth);
          clone.width = restCount === 1 ? restWidth : colAvgWidth;
          restWidth -= colAvgWidth;
          restCount -= 1;
        }
        realTotal += clone.width;
        return clone;
      });
      if (realTotal < maxFitWidth) {
        const scale = maxFitWidth / realTotal;
        restWidth = maxFitWidth;
        filledColumns.forEach((col, index3) => {
          const colWidth = Math.floor(col.width * scale);
          col.width = index3 === filledColumns.length - 1 ? restWidth : colWidth;
          restWidth -= colWidth;
        });
      }
      return [filledColumns, Math.max(realTotal, maxFitWidth)];
    }
    return [flattenColumns, scrollWidth];
  }, [flattenColumns, scrollWidth, clientWidth]);
}
__name(useWidthColumns, "useWidthColumns");

// packages/table/src/hooks/useColumns/index.tsx
function convertChildrenToColumns(children) {
  return toArray(children).filter((node2) => React508.isValidElement(node2)).map(({ key, props }) => {
    const { children: nodeChildren, ...restProps } = props;
    const column2 = {
      key,
      ...restProps
    };
    if (nodeChildren) {
      column2.children = convertChildrenToColumns(nodeChildren);
    }
    return column2;
  });
}
__name(convertChildrenToColumns, "convertChildrenToColumns");
function filterHiddenColumns(columns) {
  return columns.filter((column2) => column2 && typeof column2 === "object" && !column2.hidden).map((column2) => {
    const subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return {
        ...column2,
        children: filterHiddenColumns(subColumns)
      };
    }
    return column2;
  });
}
__name(filterHiddenColumns, "filterHiddenColumns");
function flatColumns(columns, parentKey = "key") {
  return columns.filter((column2) => column2 && typeof column2 === "object").reduce((list, column2, index3) => {
    const { fixed } = column2;
    const parsedFixed = fixed === true ? "left" : fixed;
    const mergedKey = `${parentKey}-${index3}`;
    const subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return [
        ...list,
        ...flatColumns(subColumns, mergedKey).map((subColum) => ({
          fixed: parsedFixed,
          ...subColum
        }))
      ];
    }
    return [
      ...list,
      {
        key: mergedKey,
        ...column2,
        fixed: parsedFixed
      }
    ];
  }, []);
}
__name(flatColumns, "flatColumns");
function revertForRtl(columns) {
  return columns.map((column2) => {
    const { fixed, ...restProps } = column2;
    let parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return {
      fixed: parsedFixed,
      ...restProps
    };
  });
}
__name(revertForRtl, "revertForRtl");
function useColumns({
  prefixCls,
  columns,
  children,
  expandable,
  expandedKeys,
  columnTitle,
  getRowKey,
  onTriggerExpand,
  expandIcon,
  rowExpandable,
  expandIconColumnIndex,
  direction,
  expandRowByClick,
  columnWidth,
  fixed,
  scrollWidth,
  clientWidth
}, transformColumns) {
  const baseColumns = React508.useMemo(() => {
    const newColumns = columns || convertChildrenToColumns(children) || [];
    return filterHiddenColumns(newColumns.slice());
  }, [columns, children]);
  const withExpandColumns = React508.useMemo(() => {
    if (expandable) {
      let cloneColumns = baseColumns.slice();
      if (expandIconColumnIndex >= 0) {
        warning_default(
          false,
          "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead."
        );
      }
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        const expandColIndex = expandIconColumnIndex || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      if (cloneColumns.filter((c) => c === EXPAND_COLUMN).length > 1) {
        warning_default(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      }
      const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(
        (column2, index3) => column2 !== EXPAND_COLUMN || index3 === expandColumnIndex
      );
      const prevColumn = baseColumns[expandColumnIndex];
      let fixedColumn;
      if ((fixed === "left" || fixed) && !expandIconColumnIndex) {
        fixedColumn = "left";
      } else if ((fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      const expandColumn = {
        [INTERNAL_COL_DEFINE]: {
          className: `${prefixCls}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: columnTitle,
        fixed: fixedColumn,
        className: `${prefixCls}-row-expand-icon-cell`,
        width: columnWidth,
        render: (_, record, index3) => {
          const rowKey = getRowKey(record, index3);
          const expanded = expandedKeys.has(rowKey);
          const recordExpandable = rowExpandable ? rowExpandable(record) : true;
          const icon = expandIcon({
            prefixCls,
            expanded,
            expandable: recordExpandable,
            record,
            onExpand: onTriggerExpand
          });
          if (expandRowByClick) {
            return /* @__PURE__ */ React508.createElement("span", { onClick: (e3) => e3.stopPropagation() }, icon);
          }
          return icon;
        }
      };
      return cloneColumns.map((col) => col === EXPAND_COLUMN ? expandColumn : col);
    }
    if (baseColumns.includes(EXPAND_COLUMN)) {
      warning_default(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
    }
    return baseColumns.filter((col) => col !== EXPAND_COLUMN);
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]);
  const mergedColumns = React508.useMemo(() => {
    let finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [
        {
          render: () => null
        }
      ];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction]);
  const flattenColumns = React508.useMemo(() => {
    if (direction === "rtl") {
      return revertForRtl(flatColumns(mergedColumns));
    }
    return flatColumns(mergedColumns);
  }, [mergedColumns, direction, scrollWidth]);
  const hasGapFixed = React508.useMemo(() => {
    let lastLeftIndex = -1;
    for (let i = flattenColumns.length - 1; i >= 0; i -= 1) {
      const colFixed = flattenColumns[i].fixed;
      if (colFixed === "left" || colFixed === true) {
        lastLeftIndex = i;
        break;
      }
    }
    if (lastLeftIndex >= 0) {
      for (let i = 0; i <= lastLeftIndex; i += 1) {
        const colFixed = flattenColumns[i].fixed;
        if (colFixed !== "left" && colFixed !== true) {
          return true;
        }
      }
    }
    const firstRightIndex = flattenColumns.findIndex(({ fixed: colFixed }) => colFixed === "right");
    if (firstRightIndex >= 0) {
      for (let i = firstRightIndex; i < flattenColumns.length; i += 1) {
        const colFixed = flattenColumns[i].fixed;
        if (colFixed !== "right") {
          return true;
        }
      }
    }
    return false;
  }, [flattenColumns]);
  const [filledColumns, realScrollWidth] = useWidthColumns(
    flattenColumns,
    scrollWidth,
    clientWidth
  );
  return [mergedColumns, filledColumns, realScrollWidth, hasGapFixed];
}
__name(useColumns, "useColumns");
var useColumns_default = useColumns;

// packages/table/src/hooks/useExpand.ts
init_warning();
import * as React510 from "react";

// packages/table/src/utils/expandUtil.tsx
var import_classnames225 = __toESM(require_classnames());
import * as React509 from "react";
function renderExpandIcon({
  prefixCls,
  record,
  onExpand,
  expanded,
  expandable
}) {
  const expandClassName = `${prefixCls}-row-expand-icon`;
  if (!expandable) {
    return /* @__PURE__ */ React509.createElement("span", { className: (0, import_classnames225.default)(expandClassName, `${prefixCls}-row-spaced`) });
  }
  const onClick = /* @__PURE__ */ __name((event) => {
    onExpand(record, event);
    event.stopPropagation();
  }, "onClick");
  return /* @__PURE__ */ React509.createElement(
    "span",
    {
      className: (0, import_classnames225.default)(expandClassName, {
        [`${prefixCls}-row-expanded`]: expanded,
        [`${prefixCls}-row-collapsed`]: !expanded
      }),
      onClick
    }
  );
}
__name(renderExpandIcon, "renderExpandIcon");
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  const keys2 = [];
  function dig(list) {
    (list || []).forEach((item, index3) => {
      keys2.push(getRowKey(item, index3));
      dig(item[childrenColumnName]);
    });
  }
  __name(dig, "dig");
  dig(data);
  return keys2;
}
__name(findAllChildrenKeys, "findAllChildrenKeys");

// packages/table/src/hooks/useExpand.ts
function useExpand(props, mergedData, getRowKey) {
  const expandableConfig = getExpandableProps(props);
  const {
    expandIcon,
    expandedRowKeys,
    defaultExpandedRowKeys,
    defaultExpandAllRows,
    expandedRowRender,
    onExpand,
    onExpandedRowsChange,
    childrenColumnName
  } = expandableConfig;
  const mergedExpandIcon = expandIcon || renderExpandIcon;
  const mergedChildrenColumnName = childrenColumnName || "children";
  const expandableType = React510.useMemo(() => {
    if (expandedRowRender) {
      return "row";
    }
    if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(
      (record) => record && typeof record === "object" && record[mergedChildrenColumnName]
    )) {
      return "nest";
    }
    return false;
  }, [!!expandedRowRender, mergedData]);
  const [innerExpandedKeys, setInnerExpandedKeys] = React510.useState(() => {
    if (defaultExpandedRowKeys) {
      return defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows) {
      return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
    }
    return [];
  });
  const mergedExpandedKeys = React510.useMemo(
    () => new Set(expandedRowKeys || innerExpandedKeys || []),
    [expandedRowKeys, innerExpandedKeys]
  );
  const onTriggerExpand = React510.useCallback(
    (record) => {
      const key = getRowKey(record, mergedData.indexOf(record));
      let newExpandedKeys;
      const hasKey = mergedExpandedKeys.has(key);
      if (hasKey) {
        mergedExpandedKeys.delete(key);
        newExpandedKeys = [...mergedExpandedKeys];
      } else {
        newExpandedKeys = [...mergedExpandedKeys, key];
      }
      setInnerExpandedKeys(newExpandedKeys);
      if (onExpand) {
        onExpand(!hasKey, record);
      }
      if (onExpandedRowsChange) {
        onExpandedRowsChange(newExpandedKeys);
      }
    },
    [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]
  );
  if (expandedRowRender && mergedData.some((record) => {
    return Array.isArray(record?.[mergedChildrenColumnName]);
  })) {
    warning_default(false, "`expandedRowRender` should not use with nested Table");
  }
  return [
    expandableConfig,
    expandableType,
    mergedExpandedKeys,
    mergedExpandIcon,
    mergedChildrenColumnName,
    onTriggerExpand
  ];
}
__name(useExpand, "useExpand");

// packages/table/src/hooks/useFixedInfo.ts
function useFixedInfo(flattenColumns, stickyOffsets, direction) {
  const fixedInfoList = flattenColumns.map(
    (_, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction)
  );
  return useMemo(
    () => fixedInfoList,
    [fixedInfoList],
    (prev2, next2) => !isEqual_default(prev2, next2)
  );
}
__name(useFixedInfo, "useFixedInfo");

// packages/table/src/hooks/useFrame.ts
import { useRef as useRef156, useState as useState117, useEffect as useEffect122 } from "react";
function useLayoutState(defaultState) {
  const stateRef = useRef156(defaultState);
  const [, forceUpdate] = useState117({});
  const lastPromiseRef = useRef156(null);
  const updateBatchRef = useRef156([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    const promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(() => {
      if (lastPromiseRef.current === promise) {
        const prevBatch = updateBatchRef.current;
        const prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach((batchUpdater) => {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;
        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }
  __name(setFrameState, "setFrameState");
  useEffect122(
    () => () => {
      lastPromiseRef.current = null;
    },
    []
  );
  return [stateRef.current, setFrameState];
}
__name(useLayoutState, "useLayoutState");
function useTimeoutLock(defaultState) {
  const frameRef = useRef156(defaultState || null);
  const timeoutRef = useRef156();
  function cleanUp() {
    window.clearTimeout(timeoutRef.current);
  }
  __name(cleanUp, "cleanUp");
  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = window.setTimeout(() => {
      frameRef.current = null;
      timeoutRef.current = void 0;
    }, 100);
  }
  __name(setState, "setState");
  function getState() {
    return frameRef.current;
  }
  __name(getState, "getState");
  useEffect122(() => cleanUp, []);
  return [setState, getState];
}
__name(useTimeoutLock, "useTimeoutLock");

// packages/table/src/hooks/useHover.ts
import * as React511 from "react";
function useHover() {
  const [startRow, setStartRow] = React511.useState(-1);
  const [endRow, setEndRow] = React511.useState(-1);
  const onHover = React511.useCallback((start, end) => {
    setStartRow(start);
    setEndRow(end);
  }, []);
  return [startRow, endRow, onHover];
}
__name(useHover, "useHover");

// packages/table/src/hooks/useSticky.ts
init_canUseDom();
import * as React512 from "react";
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  const {
    offsetHeader = 0,
    offsetSummary = 0,
    offsetScroll = 0,
    getContainer: getContainer2 = /* @__PURE__ */ __name(() => defaultContainer, "getContainer")
  } = typeof sticky === "object" ? sticky : {};
  const container = getContainer2() || defaultContainer;
  return React512.useMemo(() => {
    const isSticky = !!sticky;
    return {
      isSticky,
      stickyClassName: isSticky ? `${prefixCls}-sticky-holder` : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}
__name(useSticky, "useSticky");

// packages/table/src/hooks/useStickyOffsets.ts
import { useMemo as useMemo160 } from "react";
function useStickyOffsets(colWidths, flattenColumns, direction) {
  const stickyOffsets = useMemo160(() => {
    const columnCount = flattenColumns.length;
    const getOffsets = /* @__PURE__ */ __name((startIndex, endIndex, offset3) => {
      const offsets = [];
      let total = 0;
      for (let i = startIndex; i !== endIndex; i += offset3) {
        offsets.push(total);
        if (flattenColumns[i].fixed) {
          total += colWidths[i] || 0;
        }
      }
      return offsets;
    }, "getOffsets");
    const startOffsets = getOffsets(0, columnCount, 1);
    const endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
    return direction === "rtl" ? {
      left: endOffsets,
      right: startOffsets
    } : {
      left: startOffsets,
      right: endOffsets
    };
  }, [colWidths, flattenColumns, direction]);
  return stickyOffsets;
}
__name(useStickyOffsets, "useStickyOffsets");
var useStickyOffsets_default = useStickyOffsets;

// packages/table/src/Panel/index.tsx
import * as React513 from "react";
function Panel4({ className, children }) {
  return /* @__PURE__ */ React513.createElement("div", { className }, children);
}
__name(Panel4, "Panel");
var Panel_default4 = Panel4;

// packages/table/src/stickyScrollBar.tsx
var import_classnames226 = __toESM(require_classnames());
import * as React514 from "react";
var StickyScrollBar = /* @__PURE__ */ __name(({ scrollBodyRef, onScroll, offsetScroll, container }, ref) => {
  const prefixCls = useContext206(TableContext_default, "prefixCls");
  const bodyScrollWidth = scrollBodyRef.current?.scrollWidth || 0;
  const bodyWidth = scrollBodyRef.current?.clientWidth || 0;
  const scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  const scrollBarRef = React514.useRef();
  const [scrollState, setScrollState] = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: false
  });
  const refState = React514.useRef({
    delta: 0,
    x: 0
  });
  const [isActive2, setActive] = React514.useState(false);
  const rafRef = React514.useRef(null);
  React514.useEffect(
    () => () => {
      raf_default.cancel(rafRef.current);
    },
    []
  );
  const onMouseUp = /* @__PURE__ */ __name(() => {
    setActive(false);
  }, "onMouseUp");
  const onMouseDown = /* @__PURE__ */ __name((event) => {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  }, "onMouseDown");
  const onMouseMove = /* @__PURE__ */ __name((event) => {
    const { buttons } = event || window?.event;
    if (!isActive2 || buttons === 0) {
      if (isActive2) {
        setActive(false);
      }
      return;
    }
    let left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    if (left <= 0) {
      left = 0;
    }
    if (left + scrollBarWidth >= bodyWidth) {
      left = bodyWidth - scrollBarWidth;
    }
    onScroll({
      scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
    });
    refState.current.x = event.pageX;
  }, "onMouseMove");
  const checkScrollBarVisible = /* @__PURE__ */ __name(() => {
    rafRef.current = raf_default(() => {
      if (!scrollBodyRef.current) {
        return;
      }
      const tableOffsetTop = getOffset4(scrollBodyRef.current).top;
      const tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
      const currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset4(container).top + container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: true
        }));
      } else {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: false
        }));
      }
    });
  }, "checkScrollBarVisible");
  const setScrollLeft = /* @__PURE__ */ __name((left) => {
    setScrollState((state) => {
      return {
        ...state,
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      };
    });
  }, "setScrollLeft");
  React514.useImperativeHandle(ref, () => ({
    setScrollLeft,
    checkScrollBarVisible
  }));
  React514.useEffect(() => {
    const onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
    const onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
    checkScrollBarVisible();
    return () => {
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
    };
  }, [scrollBarWidth, isActive2]);
  React514.useEffect(() => {
    const onScrollListener = addEventListenerWrap(container, "scroll", checkScrollBarVisible, false);
    const onResizeListener = addEventListenerWrap(window, "resize", checkScrollBarVisible, false);
    return () => {
      onScrollListener.remove();
      onResizeListener.remove();
    };
  }, [container]);
  React514.useEffect(() => {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState((state) => {
        const bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state;
        }
        return {
          ...state,
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        };
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return /* @__PURE__ */ React514.createElement(
    "div",
    {
      style: {
        height: getScrollBarSize(),
        width: bodyWidth,
        bottom: offsetScroll
      },
      className: `${prefixCls}-sticky-scroll`
    },
    /* @__PURE__ */ React514.createElement(
      "div",
      {
        onMouseDown,
        ref: scrollBarRef,
        className: (0, import_classnames226.default)(`${prefixCls}-sticky-scroll-bar`, {
          [`${prefixCls}-sticky-scroll-bar-active`]: isActive2
        }),
        style: {
          width: `${scrollBarWidth}px`,
          transform: `translate3d(${scrollState.scrollLeft}px, 0, 0)`
        }
      }
    )
  );
}, "StickyScrollBar");
var stickyScrollBar_default = React514.forwardRef(StickyScrollBar);

// packages/table/src/Table.tsx
var DEFAULT_PREFIX = "rc-table";
var EMPTY_DATA2 = [];
var EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
  return "No Data";
}
__name(defaultEmpty, "defaultEmpty");
function Table(tableProps, ref) {
  const props = {
    rowKey: "key",
    prefixCls: DEFAULT_PREFIX,
    emptyText: defaultEmpty,
    ...tableProps
  };
  const {
    prefixCls,
    className,
    rowClassName,
    style: style2,
    data,
    rowKey,
    scroll,
    tableLayout,
    direction,
    // Additional Part
    title,
    footer,
    summary,
    caption,
    // Customize
    id,
    showHeader,
    components,
    emptyText,
    onRow,
    onHeaderRow,
    // Events
    onScroll,
    // Internal
    internalHooks,
    transformColumns,
    internalRefs,
    tailor,
    getContainerWidth,
    sticky,
    rowHoverable = true
  } = props;
  const mergedData = data || EMPTY_DATA2;
  const hasData = !!mergedData.length;
  const useInternalHooks = internalHooks === INTERNAL_HOOKS;
  if (true) {
    [
      "onRowClick",
      "onRowDoubleClick",
      "onRowContextMenu",
      "onRowMouseEnter",
      "onRowMouseLeave"
    ].forEach((name) => {
      warning_default(props[name] === void 0, `\`${name}\` is removed, please use \`onRow\` instead.`);
    });
    warning_default(
      !("getBodyWrapper" in props),
      "`getBodyWrapper` is deprecated, please use custom `components` instead."
    );
  }
  const getComponent = React515.useCallback(
    (path2, defaultComponent) => get(components, path2) || defaultComponent,
    [components]
  );
  const getRowKey = React515.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => {
      const key = record && record[rowKey];
      if (true) {
        warning_default(
          key !== void 0,
          "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key."
        );
      }
      return key;
    };
  }, [rowKey]);
  const customizeScrollBody = getComponent(["body"]);
  const [startRow, endRow, onHover] = useHover();
  const [
    expandableConfig,
    expandableType,
    mergedExpandedKeys,
    mergedExpandIcon,
    mergedChildrenColumnName,
    onTriggerExpand
  ] = useExpand(props, mergedData, getRowKey);
  const scrollX = scroll?.x;
  const [componentWidth, setComponentWidth] = React515.useState(0);
  const [columns, flattenColumns, flattenScrollX, hasGapFixed] = useColumns_default(
    {
      ...props,
      ...expandableConfig,
      expandable: !!expandableConfig.expandedRowRender,
      columnTitle: expandableConfig.columnTitle,
      expandedKeys: mergedExpandedKeys,
      getRowKey,
      // https://github.com/ant-design/ant-design/issues/23894
      onTriggerExpand,
      expandIcon: mergedExpandIcon,
      expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
      direction,
      scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
      clientWidth: componentWidth
    },
    useInternalHooks ? transformColumns : null
  );
  const mergedScrollX = flattenScrollX ?? scrollX;
  const columnContext = React515.useMemo(
    () => ({
      columns,
      flattenColumns
    }),
    [columns, flattenColumns]
  );
  const fullTableRef = React515.useRef();
  const scrollHeaderRef = React515.useRef();
  const scrollBodyRef = React515.useRef();
  const scrollBodyContainerRef = React515.useRef();
  React515.useImperativeHandle(ref, () => {
    return {
      nativeElement: fullTableRef.current,
      scrollTo: (config) => {
        if (scrollBodyRef.current instanceof HTMLElement) {
          const { index: index3, top, key } = config;
          if (top) {
            scrollBodyRef.current?.scrollTo({
              top
            });
          } else {
            const mergedKey = key ?? getRowKey(mergedData[index3]);
            scrollBodyRef.current.querySelector(`[data-row-key="${mergedKey}"]`)?.scrollIntoView();
          }
        } else if (scrollBodyRef.current?.scrollTo) {
          scrollBodyRef.current.scrollTo(config);
        }
      }
    };
  });
  const scrollSummaryRef = React515.useRef();
  const [pingedLeft, setPingedLeft] = React515.useState(false);
  const [pingedRight, setPingedRight] = React515.useState(false);
  const [colsWidths, updateColsWidths] = useLayoutState(/* @__PURE__ */ new Map());
  const colsKeys = getColumnsKey(flattenColumns);
  const pureColWidths = colsKeys.map((columnKey) => colsWidths.get(columnKey));
  const colWidths = React515.useMemo(() => pureColWidths, [pureColWidths.join("_")]);
  const stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns, direction);
  const fixHeader = scroll && validateValue(scroll.y);
  const horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
  const fixColumn = horizonScroll && flattenColumns.some(({ fixed }) => fixed);
  const stickyRef = React515.useRef();
  const { isSticky, offsetHeader, offsetSummary, offsetScroll, stickyClassName, container } = useSticky(sticky, prefixCls);
  const summaryNode = React515.useMemo(() => summary?.(mergedData), [summary, mergedData]);
  const fixFooter = (fixHeader || isSticky) && React515.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
  let scrollXStyle;
  let scrollYStyle;
  let scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: "scroll",
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = { overflowX: "auto" };
    if (!fixHeader) {
      scrollYStyle = { overflowY: "hidden" };
    }
    scrollTableStyle = {
      width: mergedScrollX === true ? "auto" : mergedScrollX,
      minWidth: "100%"
    };
  }
  const onColumnResize = React515.useCallback((columnKey, width) => {
    if (isVisible_default(fullTableRef.current)) {
      updateColsWidths((widths) => {
        if (widths.get(columnKey) !== width) {
          const newWidths = new Map(widths);
          newWidths.set(columnKey, width);
          return newWidths;
        }
        return widths;
      });
    }
  }, []);
  const [setScrollTarget, getScrollTarget] = useTimeoutLock(null);
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === "function") {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
      if (target.scrollLeft !== scrollLeft) {
        setTimeout(() => {
          target.scrollLeft = scrollLeft;
        }, 0);
      }
    }
  }
  __name(forceScroll, "forceScroll");
  const onInternalScroll = useEvent(
    ({ currentTarget, scrollLeft }) => {
      const isRTL = direction === "rtl";
      const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
      const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
      if (!getScrollTarget() || getScrollTarget() === compareTarget) {
        setScrollTarget(compareTarget);
        forceScroll(mergedScrollLeft, scrollHeaderRef.current);
        forceScroll(mergedScrollLeft, scrollBodyRef.current);
        forceScroll(mergedScrollLeft, scrollSummaryRef.current);
        forceScroll(mergedScrollLeft, stickyRef.current?.setScrollLeft);
      }
      const measureTarget = currentTarget || scrollHeaderRef.current;
      if (measureTarget) {
        const { scrollWidth, clientWidth } = measureTarget;
        if (scrollWidth === clientWidth) {
          setPingedLeft(false);
          setPingedRight(false);
          return;
        }
        if (isRTL) {
          setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
          setPingedRight(-mergedScrollLeft > 0);
        } else {
          setPingedLeft(mergedScrollLeft > 0);
          setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
        }
      }
    }
  );
  const onBodyScroll = useEvent((e3) => {
    onInternalScroll(e3);
    onScroll?.(e3);
  });
  const triggerOnScroll = /* @__PURE__ */ __name(() => {
    if (horizonScroll && scrollBodyRef.current) {
      onInternalScroll({ currentTarget: scrollBodyRef.current });
    } else {
      setPingedLeft(false);
      setPingedRight(false);
    }
  }, "triggerOnScroll");
  const onFullTableResize = /* @__PURE__ */ __name(({ width }) => {
    stickyRef.current?.checkScrollBarVisible();
    let mergedWidth = fullTableRef.current ? fullTableRef.current.offsetWidth : width;
    if (useInternalHooks && getContainerWidth && fullTableRef.current) {
      mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
    }
    if (mergedWidth !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(mergedWidth);
    }
  }, "onFullTableResize");
  const mounted = React515.useRef(false);
  React515.useEffect(() => {
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data, columns.length]);
  React515.useEffect(() => {
    mounted.current = true;
  }, []);
  const [scrollbarSize, setScrollbarSize] = React515.useState(0);
  const [supportSticky, setSupportSticky] = React515.useState(true);
  React515.useEffect(() => {
    if (!tailor || !useInternalHooks) {
      if (scrollBodyRef.current instanceof Element) {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
      } else {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
      }
    }
    setSupportSticky(isStyleSupport("position", "sticky"));
  }, []);
  React515.useEffect(() => {
    if (useInternalHooks && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  });
  const renderFixedHeaderTable = React515.useCallback(
    (fixedHolderPassProps) => /* @__PURE__ */ React515.createElement(React515.Fragment, null, /* @__PURE__ */ React515.createElement(Header_default2, { ...fixedHolderPassProps }), fixFooter === "top" && /* @__PURE__ */ React515.createElement(Footer_default, { ...fixedHolderPassProps }, summaryNode)),
    [fixFooter, summaryNode]
  );
  const renderFixedFooterTable = React515.useCallback(
    (fixedHolderPassProps) => /* @__PURE__ */ React515.createElement(Footer_default, { ...fixedHolderPassProps }, summaryNode),
    [summaryNode]
  );
  const TableComponent = getComponent(["table"], "table");
  const mergedTableLayout = React515.useMemo(() => {
    if (tableLayout) {
      return tableLayout;
    }
    if (fixColumn) {
      return mergedScrollX === "max-content" ? "auto" : "fixed";
    }
    if (fixHeader || isSticky || flattenColumns.some(({ ellipsis }) => ellipsis)) {
      return "fixed";
    }
    return "auto";
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  let groupTableNode;
  const headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  };
  const emptyNode = React515.useMemo(() => {
    if (hasData) {
      return null;
    }
    if (typeof emptyText === "function") {
      return emptyText();
    }
    return emptyText;
  }, [hasData, emptyText]);
  const bodyTable = /* @__PURE__ */ React515.createElement(Body_default, { data: mergedData, measureColumnWidth: fixHeader || horizonScroll || isSticky });
  const bodyColGroup = /* @__PURE__ */ React515.createElement(ColGroup_default, { colWidths: flattenColumns.map(({ width }) => width), columns: flattenColumns });
  const captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ React515.createElement("caption", { className: `${prefixCls}-caption` }, caption) : void 0;
  const dataProps = pickAttrs(props, { data: true });
  const ariaProps = pickAttrs(props, { aria: true });
  if (fixHeader || isSticky) {
    let bodyContent;
    if (typeof customizeScrollBody === "function") {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize,
        ref: scrollBodyRef,
        onScroll: onInternalScroll
      });
      headerProps.colWidths = flattenColumns.map(({ width }, index3) => {
        const colWidth = index3 === flattenColumns.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        if (true) {
          warning_default(
            props.columns.length === 0,
            "When use `components.body` with render props. Each column should have a fixed `width` value."
          );
        }
        return 0;
      });
    } else {
      bodyContent = /* @__PURE__ */ React515.createElement(
        "div",
        {
          style: {
            ...scrollXStyle,
            ...scrollYStyle
          },
          onScroll: onBodyScroll,
          ref: scrollBodyRef,
          className: (0, import_classnames227.default)(`${prefixCls}-body`)
        },
        /* @__PURE__ */ React515.createElement(
          TableComponent,
          {
            style: {
              ...scrollTableStyle,
              tableLayout: mergedTableLayout
            },
            ...ariaProps
          },
          captionElement,
          bodyColGroup,
          bodyTable,
          !fixFooter && summaryNode && /* @__PURE__ */ React515.createElement(Footer_default, { stickyOffsets, flattenColumns }, summaryNode)
        )
      );
    }
    const fixedHolderProps = {
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && mergedScrollX === "max-content",
      ...headerProps,
      ...columnContext,
      direction,
      stickyClassName,
      onScroll: onInternalScroll
    };
    groupTableNode = /* @__PURE__ */ React515.createElement(React515.Fragment, null, showHeader !== false && /* @__PURE__ */ React515.createElement(
      FixedHolder_default,
      {
        ...fixedHolderProps,
        stickyTopOffset: offsetHeader,
        className: `${prefixCls}-header`,
        ref: scrollHeaderRef
      },
      renderFixedHeaderTable
    ), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ React515.createElement(
      FixedHolder_default,
      {
        ...fixedHolderProps,
        stickyBottomOffset: offsetSummary,
        className: `${prefixCls}-summary`,
        ref: scrollSummaryRef
      },
      renderFixedFooterTable
    ), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ React515.createElement(
      stickyScrollBar_default,
      {
        ref: stickyRef,
        offsetScroll,
        scrollBodyRef,
        onScroll: onInternalScroll,
        container
      }
    ));
  } else {
    groupTableNode = /* @__PURE__ */ React515.createElement(
      "div",
      {
        style: {
          ...scrollXStyle,
          ...scrollYStyle
        },
        className: (0, import_classnames227.default)(`${prefixCls}-content`),
        onScroll: onInternalScroll,
        ref: scrollBodyRef
      },
      /* @__PURE__ */ React515.createElement(
        TableComponent,
        {
          style: { ...scrollTableStyle, tableLayout: mergedTableLayout },
          ...ariaProps
        },
        captionElement,
        bodyColGroup,
        showHeader !== false && /* @__PURE__ */ React515.createElement(Header_default2, { ...headerProps, ...columnContext }),
        bodyTable,
        summaryNode && /* @__PURE__ */ React515.createElement(Footer_default, { stickyOffsets, flattenColumns }, summaryNode)
      )
    );
  }
  let fullTable = /* @__PURE__ */ React515.createElement(
    "div",
    {
      className: (0, import_classnames227.default)(prefixCls, className, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-ping-left`]: pingedLeft,
        [`${prefixCls}-ping-right`]: pingedRight,
        [`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
        [`${prefixCls}-fixed-header`]: fixHeader,
        /** No used but for compatible */
        [`${prefixCls}-fixed-column`]: fixColumn,
        [`${prefixCls}-fixed-column-gapped`]: fixColumn && hasGapFixed,
        [`${prefixCls}-scroll-horizontal`]: horizonScroll,
        [`${prefixCls}-has-fix-left`]: flattenColumns[0] && flattenColumns[0].fixed,
        [`${prefixCls}-has-fix-right`]: flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right"
      }),
      style: style2,
      id,
      ref: fullTableRef,
      ...dataProps
    },
    title && /* @__PURE__ */ React515.createElement(Panel_default4, { className: `${prefixCls}-title` }, title(mergedData)),
    /* @__PURE__ */ React515.createElement("div", { ref: scrollBodyContainerRef, className: `${prefixCls}-container` }, groupTableNode),
    footer && /* @__PURE__ */ React515.createElement(Panel_default4, { className: `${prefixCls}-footer` }, footer(mergedData))
  );
  if (horizonScroll) {
    fullTable = /* @__PURE__ */ React515.createElement(src_default, { onResize: onFullTableResize }, fullTable);
  }
  const fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction);
  const TableContextValue = React515.useMemo(
    () => ({
      // Scroll
      scrollX: mergedScrollX,
      // Table
      prefixCls,
      getComponent,
      scrollbarSize,
      direction,
      fixedInfoList,
      isSticky,
      supportSticky,
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll,
      // Body
      tableLayout: mergedTableLayout,
      rowClassName,
      expandedRowClassName: expandableConfig.expandedRowClassName,
      expandIcon: mergedExpandIcon,
      expandableType,
      expandRowByClick: expandableConfig.expandRowByClick,
      expandedRowRender: expandableConfig.expandedRowRender,
      onTriggerExpand,
      expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
      indentSize: expandableConfig.indentSize,
      allColumnsFixedLeft: flattenColumns.every((col) => col.fixed === "left"),
      emptyNode,
      // Column
      columns,
      flattenColumns,
      onColumnResize,
      // Row
      hoverStartRow: startRow,
      hoverEndRow: endRow,
      onHover,
      rowExpandable: expandableConfig.rowExpandable,
      onRow,
      getRowKey,
      expandedKeys: mergedExpandedKeys,
      childrenColumnName: mergedChildrenColumnName,
      rowHoverable
    }),
    [
      // Scroll
      mergedScrollX,
      // Table
      prefixCls,
      getComponent,
      scrollbarSize,
      direction,
      fixedInfoList,
      isSticky,
      supportSticky,
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll,
      // Body
      mergedTableLayout,
      rowClassName,
      expandableConfig.expandedRowClassName,
      mergedExpandIcon,
      expandableType,
      expandableConfig.expandRowByClick,
      expandableConfig.expandedRowRender,
      onTriggerExpand,
      expandableConfig.expandIconColumnIndex,
      expandableConfig.indentSize,
      emptyNode,
      // Column
      columns,
      flattenColumns,
      onColumnResize,
      // Row
      startRow,
      endRow,
      onHover,
      expandableConfig.rowExpandable,
      onRow,
      getRowKey,
      mergedExpandedKeys,
      mergedChildrenColumnName,
      rowHoverable
    ]
  );
  return /* @__PURE__ */ React515.createElement(TableContext_default.Provider, { value: TableContextValue }, fullTable);
}
__name(Table, "Table");
var RefTable = React515.forwardRef(Table);
if (true) {
  RefTable.displayName = "Table";
}
function genTable(shouldTriggerRender) {
  return makeImmutable2(RefTable, shouldTriggerRender);
}
__name(genTable, "genTable");
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column_default;
ImmutableTable.ColumnGroup = ColumnGroup_default;
ImmutableTable.Summary = FooterComponents;
var Table_default = ImmutableTable;

// packages/table/src/VirtualTable/index.tsx
var import_classnames234 = __toESM(require_classnames());
import * as React528 from "react";

// packages/table/src/VirtualTable/BodyGrid.tsx
var import_classnames233 = __toESM(require_classnames());

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/List.js
var import_classnames230 = __toESM(require_classnames());
import * as React524 from "react";
import { useRef as useRef165, useState as useState126 } from "react";
import { flushSync as flushSync3 } from "react-dom";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/Filler.js
import * as React516 from "react";
var import_classnames228 = __toESM(require_classnames());
var Filler2 = /* @__PURE__ */ React516.forwardRef(function(_ref, ref) {
  var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offsetY !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      transform: "translateY(".concat(offsetY, "px)")
    }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0));
  }
  return /* @__PURE__ */ React516.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ React516.createElement(src_default, {
    onResize: /* @__PURE__ */ __name(function onResize2(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }, "onResize")
  }, /* @__PURE__ */ React516.createElement("div", _extends({
    style: innerStyle,
    className: (0, import_classnames228.default)(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref
  }, innerProps), children, extra)));
});
Filler2.displayName = "Filler";
var Filler_default2 = Filler2;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/ScrollBar.js
var import_classnames229 = __toESM(require_classnames());
import * as React517 from "react";
function getPageXY2(e3, horizontal) {
  var obj = "touches" in e3 ? e3.touches[0] : e3;
  return obj[horizontal ? "pageX" : "pageY"];
}
__name(getPageXY2, "getPageXY");
var ScrollBar2 = /* @__PURE__ */ React517.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle;
  var _React$useState = React517.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
  var _React$useState3 = React517.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
  var _React$useState5 = React517.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
  var isLTR = !rtl;
  var scrollbarRef = React517.useRef();
  var thumbRef = React517.useRef();
  var _React$useState7 = React517.useState(false), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
  var visibleTimeoutRef = React517.useRef();
  var delayHidden = /* @__PURE__ */ __name(function delayHidden2() {
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(function() {
      setVisible(false);
    }, 3e3);
  }, "delayHidden");
  var enableScrollRange = scrollRange - containerSize || 0;
  var enableOffsetRange = containerSize - spinSize || 0;
  var top = React517.useMemo(function() {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    var ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);
  var onContainerMouseDown = /* @__PURE__ */ __name(function onContainerMouseDown2(e3) {
    e3.stopPropagation();
    e3.preventDefault();
  }, "onContainerMouseDown");
  var stateRef = React517.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  var onThumbMouseDown = /* @__PURE__ */ __name(function onThumbMouseDown2(e3) {
    setDragging(true);
    setPageXY(getPageXY2(e3, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e3.stopPropagation();
    e3.preventDefault();
  }, "onThumbMouseDown");
  React517.useEffect(function() {
    var onScrollbarTouchStart = /* @__PURE__ */ __name(function onScrollbarTouchStart2(e3) {
      e3.preventDefault();
    }, "onScrollbarTouchStart");
    var scrollbarEle = scrollbarRef.current;
    var thumbEle = thumbRef.current;
    scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart);
    thumbEle.addEventListener("touchstart", onThumbMouseDown);
    return function() {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  var enableScrollRangeRef = React517.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  var enableOffsetRangeRef = React517.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  React517.useEffect(function() {
    if (dragging) {
      var moveRafId;
      var onMouseMove = /* @__PURE__ */ __name(function onMouseMove2(e3) {
        var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
        raf_default.cancel(moveRafId);
        if (stateDragging) {
          var offset3 = getPageXY2(e3, horizontal) - statePageY;
          var newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset3;
          } else {
            newTop += offset3;
          }
          var tmpEnableScrollRange = enableScrollRangeRef.current;
          var tmpEnableOffsetRange = enableOffsetRangeRef.current;
          var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = raf_default(function() {
            onScroll(newScrollTop, horizontal);
          });
        }
      }, "onMouseMove");
      var onMouseUp = /* @__PURE__ */ __name(function onMouseUp2() {
        setDragging(false);
        onStopMove();
      }, "onMouseUp");
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("touchmove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      window.addEventListener("touchend", onMouseUp);
      return function() {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
        window.removeEventListener("touchend", onMouseUp);
        raf_default.cancel(moveRafId);
      };
    }
  }, [dragging]);
  React517.useEffect(function() {
    delayHidden();
  }, [scrollOffset]);
  React517.useImperativeHandle(ref, function() {
    return {
      delayHidden
    };
  });
  var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
  var containerStyle = {
    position: "absolute",
    visibility: visible ? null : "hidden"
  };
  var thumbStyle = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  if (horizontal) {
    containerStyle.height = 8;
    containerStyle.left = 0;
    containerStyle.right = 0;
    containerStyle.bottom = 0;
    thumbStyle.height = "100%";
    thumbStyle.width = spinSize;
    if (isLTR) {
      thumbStyle.left = top;
    } else {
      thumbStyle.right = top;
    }
  } else {
    containerStyle.width = 8;
    containerStyle.top = 0;
    containerStyle.bottom = 0;
    if (isLTR) {
      containerStyle.right = 0;
    } else {
      containerStyle.left = 0;
    }
    thumbStyle.width = "100%";
    thumbStyle.height = spinSize;
    thumbStyle.top = top;
  }
  return /* @__PURE__ */ React517.createElement("div", {
    ref: scrollbarRef,
    className: (0, import_classnames229.default)(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
    style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, /* @__PURE__ */ React517.createElement("div", {
    ref: thumbRef,
    className: (0, import_classnames229.default)("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
    style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
    onMouseDown: onThumbMouseDown
  }));
});
if (true) {
  ScrollBar2.displayName = "ScrollBar";
}
var ScrollBar_default2 = ScrollBar2;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useChildren.js
import * as React519 from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/Item.js
import * as React518 from "react";
function Item5(_ref) {
  var children = _ref.children, setRef = _ref.setRef;
  var refFunc = React518.useCallback(function(node2) {
    setRef(node2);
  }, []);
  return /* @__PURE__ */ React518.cloneElement(children, {
    ref: refFunc
  });
}
__name(Item5, "Item");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useChildren.js
function useChildren3(list, startIndex, endIndex, scrollWidth, setNodeRef, renderFunc, _ref) {
  var getKey4 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index3) {
    var eleIndex = startIndex + index3;
    var node2 = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      }
    });
    var key = getKey4(item);
    return /* @__PURE__ */ React519.createElement(Item5, {
      key,
      setRef: /* @__PURE__ */ __name(function setRef(ele) {
        return setNodeRef(item, ele);
      }, "setRef")
    }, node2);
  });
}
__name(useChildren3, "useChildren");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useHeights.js
import * as React520 from "react";
import { useRef as useRef160, useEffect as useEffect126 } from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/utils/CacheMap.js
var CacheMap2 = /* @__PURE__ */ function() {
  function CacheMap3() {
    _classCallCheck(this, CacheMap3);
    _defineProperty(this, "maps", void 0);
    _defineProperty(this, "id", 0);
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  __name(CacheMap3, "CacheMap");
  _createClass(CacheMap3, [{
    key: "set",
    value: /* @__PURE__ */ __name(function set2(key, value) {
      this.maps[key] = value;
      this.id += 1;
    }, "set")
  }, {
    key: "get",
    value: /* @__PURE__ */ __name(function get2(key) {
      return this.maps[key];
    }, "get")
  }]);
  return CacheMap3;
}();
var CacheMap_default2 = CacheMap2;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useHeights.js
function useHeights2(getKey4, onItemAdd, onItemRemove) {
  var _React$useState = React520.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = useRef160(/* @__PURE__ */ new Map());
  var heightsRef = useRef160(new CacheMap_default2());
  var collectRafRef = useRef160();
  function cancelRaf() {
    raf_default.cancel(collectRafRef.current);
  }
  __name(cancelRaf, "cancelRaf");
  function collectHeight() {
    var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    cancelRaf();
    var doCollect = /* @__PURE__ */ __name(function doCollect2() {
      instanceRef.current.forEach(function(element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c) {
        return c + 1;
      });
    }, "doCollect");
    if (sync) {
      doCollect();
    } else {
      collectRafRef.current = raf_default(doCollect);
    }
  }
  __name(collectHeight, "collectHeight");
  function setInstanceRef(item, instance) {
    var key = getKey4(item);
    var origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
      }
    }
  }
  __name(setInstanceRef, "setInstanceRef");
  useEffect126(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
__name(useHeights2, "useHeights");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useScrollTo.js
import * as React521 from "react";
var MAX_TIMES2 = 10;
function useScrollTo3(containerRef, data, heights, itemHeight, getKey4, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = React521.useRef();
  var _React$useState = React521.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
  useLayoutEffect_default(function() {
    if (syncState && syncState.times < MAX_TIMES2) {
      if (!containerRef.current) {
        setSyncState(function(ori) {
          return _objectSpread2({}, ori);
        });
        return;
      }
      collectHeight();
      var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index3 = syncState.index, offset3 = syncState.offset;
      var height = containerRef.current.clientHeight;
      var needCollectHeight = false;
      var newTargetAlign = targetAlign;
      var targetTop = null;
      if (height) {
        var mergedAlign = targetAlign || originAlign;
        var stackTop = 0;
        var itemTop = 0;
        var itemBottom = 0;
        var maxLen = Math.min(data.length - 1, index3);
        for (var i = 0; i <= maxLen; i += 1) {
          var key = getKey4(data[i]);
          itemTop = stackTop;
          var cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        var leftHeight = mergedAlign === "top" ? offset3 : height - offset3;
        for (var _i = maxLen; _i >= 0; _i -= 1) {
          var _key = getKey4(data[_i]);
          var _cacheHeight = heights.get(_key);
          if (_cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= _cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset3;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset3;
            break;
          default: {
            var scrollTop = containerRef.current.scrollTop;
            var scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        }));
      }
    } else if ((syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES2) {
      warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
    }
  }, [syncState, containerRef.current]);
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    raf_default.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof(arg) === "object") {
      var index3;
      var align = arg.align;
      if ("index" in arg) {
        index3 = arg.index;
      } else {
        index3 = data.findIndex(function(item) {
          return getKey4(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      setSyncState({
        times: 0,
        index: index3,
        offset: offset3,
        originAlign: align
      });
    }
  };
}
__name(useScrollTo3, "useScrollTo");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useDiffItem.js
import * as React522 from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/utils/algorithmUtil.js
function findListDiffIndex2(originList, targetList, getKey4) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey4(item);
    }
    return notExistKey;
  }
  __name(getItemKey, "getItemKey");
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
__name(findListDiffIndex2, "findListDiffIndex");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useDiffItem.js
function useDiffItem2(data, getKey4, onDiff) {
  var _React$useState = React522.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = React522.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  React522.useEffect(function() {
    var diff = findListDiffIndex2(prevData || [], data || [], getKey4);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
      onDiff === null || onDiff === void 0 || onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}
__name(useDiffItem2, "useDiffItem");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
import { useRef as useRef163 } from "react";

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/utils/isFirefox.js
var isFF2 = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default2 = isFF2;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useOriginScroll.js
import { useRef as useRef162 } from "react";
var useOriginScroll_default2 = /* @__PURE__ */ __name(function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = useRef162(false);
  var lockTimeoutRef = useRef162(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  __name(lockScroll, "lockScroll");
  var scrollPingRef = useRef162({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = (
      // Pass origin wheel when on the top
      deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
      deltaY > 0 && scrollPingRef.current.bottom
    );
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
}, "default");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel2(inVirtual, isScrollAtTop, isScrollAtBottom, horizontalScroll, onWheelDelta) {
  var offsetRef = useRef163(0);
  var nextFrameRef = useRef163(null);
  var wheelValueRef = useRef163(null);
  var isMouseScrollRef = useRef163(false);
  var originScroll = useOriginScroll_default2(isScrollAtTop, isScrollAtBottom);
  function onWheelY(event, deltaY) {
    raf_default.cancel(nextFrameRef.current);
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFirefox_default2) {
      event.preventDefault();
    }
    nextFrameRef.current = raf_default(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  __name(onWheelY, "onWheelY");
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFirefox_default2) {
      event.preventDefault();
    }
  }
  __name(onWheelX, "onWheelX");
  var wheelDirectionRef = useRef163(null);
  var wheelDirectionCleanRef = useRef163(null);
  function onWheel(event) {
    if (!inVirtual)
      return;
    raf_default.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = raf_default(function() {
      wheelDirectionRef.current = null;
    }, 2);
    var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
    var mergedDeltaX = deltaX;
    var mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = "sx";
    }
    var absX = Math.abs(mergedDeltaX);
    var absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
    }
    if (wheelDirectionRef.current === "y") {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }
  __name(onWheel, "onWheel");
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  __name(onFireFoxScroll, "onFireFoxScroll");
  return [onWheel, onFireFoxScroll];
}
__name(useFrameWheel2, "useFrameWheel");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js
import { useRef as useRef164 } from "react";
var SMOOTH_PTG2 = 14 / 15;
function useMobileTouchMove2(inVirtual, listRef, callback) {
  var touchedRef = useRef164(false);
  var touchYRef = useRef164(0);
  var elementRef = useRef164(null);
  var intervalRef = useRef164(null);
  var cleanUpEvents;
  var onTouchMove = /* @__PURE__ */ __name(function onTouchMove2(e3) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e3.touches[0].pageY);
      var _offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(_offsetY)) {
        e3.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        _offsetY *= SMOOTH_PTG2;
        if (!callback(_offsetY, true) || Math.abs(_offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  }, "onTouchMove");
  var onTouchEnd = /* @__PURE__ */ __name(function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  }, "onTouchEnd");
  var onTouchStart = /* @__PURE__ */ __name(function onTouchStart2(e3) {
    cleanUpEvents();
    if (e3.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e3.touches[0].pageY);
      elementRef.current = e3.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  }, "onTouchStart");
  cleanUpEvents = /* @__PURE__ */ __name(function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  }, "cleanUpEvents");
  useLayoutEffect_default(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
__name(useMobileTouchMove2, "useMobileTouchMove");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE2 = 20;
function getSpinSize2() {
  var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var baseSize = containerSize / scrollRange * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE2);
  return Math.floor(baseSize);
}
__name(getSpinSize2, "getSpinSize");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/hooks/useGetSize.js
import * as React523 from "react";
function useGetSize2(mergedData, getKey4, heights, itemHeight) {
  var _React$useMemo = React523.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
  var getSize3 = /* @__PURE__ */ __name(function getSize4(startKey) {
    var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
    var startIndex = key2Index.get(startKey);
    var endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0) {
      var dataLen = mergedData.length;
      for (var i = bottomList.length; i < dataLen; i += 1) {
        var _heights$get;
        var item = mergedData[i];
        var key = getKey4(item);
        key2Index.set(key, i);
        var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }
        if (startIndex !== void 0 && endIndex !== void 0) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  }, "getSize");
  return getSize3;
}
__name(useGetSize2, "useGetSize");

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/List.js
var _excluded6 = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"];
var EMPTY_DATA3 = [];
var ScrollStyle2 = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList2(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey3 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component11 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, restProps = _objectWithoutProperties(props, _excluded6);
  var getKey4 = React524.useCallback(function(item) {
    if (typeof itemKey3 === "function") {
      return itemKey3(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey3];
  }, [itemKey3]);
  var _useHeights = useHeights2(getKey4, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var containerHeight = React524.useMemo(function() {
    return Object.values(heights.maps).reduce(function(total, curr) {
      return total + curr;
    }, 0);
  }, [heights.id, heights.maps]);
  var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  var isRTL = direction === "rtl";
  var mergedClassName = (0, import_classnames230.default)(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
  var mergedData = data || EMPTY_DATA3;
  var componentRef = useRef165();
  var fillerInnerRef = useRef165();
  var _useState = useState126(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
  var _useState3 = useState126(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
  var _useState5 = useState126(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
  var onScrollbarStartMove = /* @__PURE__ */ __name(function onScrollbarStartMove2() {
    setScrollMoving(true);
  }, "onScrollbarStartMove");
  var onScrollbarStopMove = /* @__PURE__ */ __name(function onScrollbarStopMove2() {
    setScrollMoving(false);
  }, "onScrollbarStopMove");
  var sharedConfig = {
    getKey: getKey4
  };
  function syncScrollTop(newTop) {
    setOffsetTop(function(origin) {
      var value;
      if (typeof newTop === "function") {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  __name(syncScrollTop, "syncScrollTop");
  var rangeRef = useRef165({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = useRef165();
  var _useDiffItem = useDiffItem2(mergedData, getKey4), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _React$useMemo = React524.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i = 0; i < dataLen; i += 1) {
      var _item = mergedData[i];
      var key = getKey4(_item);
      var cacheHeight = heights.get(key);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= offsetTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > offsetTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var _React$useState = React524.useState({
    width: 0,
    height
  }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
  var onHolderResize = /* @__PURE__ */ __name(function onHolderResize2(sizeInfo) {
    setSize({
      width: sizeInfo.width || sizeInfo.offsetWidth,
      height: sizeInfo.height || sizeInfo.offsetHeight
    });
  }, "onHolderResize");
  var verticalScrollBarRef = useRef165();
  var horizontalScrollBarRef = useRef165();
  var horizontalScrollBarSpinSize = React524.useMemo(function() {
    return getSpinSize2(size.width, scrollWidth);
  }, [size.width, scrollWidth]);
  var verticalScrollBarSpinSize = React524.useMemo(function() {
    return getSpinSize2(size.height, scrollHeight);
  }, [size.height, scrollHeight]);
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = useRef165(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  __name(keepInRange, "keepInRange");
  var isScrollAtTop = offsetTop <= 0;
  var isScrollAtBottom = offsetTop >= maxScrollHeight;
  var originScroll = useOriginScroll_default2(isScrollAtTop, isScrollAtBottom);
  var getVirtualScrollInfo = /* @__PURE__ */ __name(function getVirtualScrollInfo2() {
    return {
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    };
  }, "getVirtualScrollInfo");
  var lastVirtualScrollInfoRef = useRef165(getVirtualScrollInfo());
  var triggerScroll = useEvent(function() {
    if (onVirtualScroll) {
      var nextInfo = getVirtualScrollInfo();
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    var newOffset = newScrollOffset;
    if (horizontal) {
      flushSync3(function() {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }
  __name(onScrollBar, "onScrollBar");
  function onFallbackScroll(e3) {
    var newScrollTop = e3.currentTarget.scrollTop;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 || onScroll(e3);
    triggerScroll();
  }
  __name(onFallbackScroll, "onFallbackScroll");
  var keepInHorizontalRange = /* @__PURE__ */ __name(function keepInHorizontalRange2(nextOffsetLeft) {
    var tmpOffsetLeft = nextOffsetLeft;
    var max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
    return tmpOffsetLeft;
  }, "keepInHorizontalRange");
  var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
    if (fromHorizontal) {
      flushSync3(function() {
        setOffsetLeft(function(left) {
          var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop(function(top) {
        var newTop = top + offsetXY;
        return newTop;
      });
    }
  });
  var _useFrameWheel = useFrameWheel2(useVirtual, isScrollAtTop, isScrollAtBottom, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove2(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: /* @__PURE__ */ __name(function preventDefault() {
      }, "preventDefault"),
      deltaY
    });
    return true;
  });
  useLayoutEffect_default(function() {
    function onMozMousePixelScroll(e3) {
      if (useVirtual) {
        e3.preventDefault();
      }
    }
    __name(onMozMousePixelScroll, "onMozMousePixelScroll");
    var componentEle = componentRef.current;
    componentEle.addEventListener("wheel", onRawWheel);
    componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      componentEle.removeEventListener("wheel", onRawWheel);
      componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual]);
  useLayoutEffect_default(function() {
    if (scrollWidth) {
      setOffsetLeft(function(left) {
        return keepInHorizontalRange(left);
      });
    }
  }, [size.width, scrollWidth]);
  var delayHideScrollBar = /* @__PURE__ */ __name(function delayHideScrollBar2() {
    var _verticalScrollBarRef, _horizontalScrollBarR;
    (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
    (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
  }, "delayHideScrollBar");
  var _scrollTo = useScrollTo3(componentRef, mergedData, heights, itemHeight, getKey4, function() {
    return collectHeight(true);
  }, syncScrollTop, delayHideScrollBar);
  React524.useImperativeHandle(ref, function() {
    return {
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: /* @__PURE__ */ __name(function scrollTo2(config) {
        function isPosScroll(arg) {
          return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
        }
        __name(isPosScroll, "isPosScroll");
        if (isPosScroll(config)) {
          if (config.left !== void 0) {
            setOffsetLeft(keepInHorizontalRange(config.left));
          }
          _scrollTo(config.top);
        } else {
          _scrollTo(config);
        }
      }, "scrollTo")
    };
  });
  useLayoutEffect_default(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var getSize3 = useGetSize2(mergedData, getKey4, heights, itemHeight);
  var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize: getSize3
  });
  var listChildren = useChildren3(mergedData, start, end, scrollWidth, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle2);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollWidth) {
        componentStyle.overflowX = "hidden";
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  var containerProps = {};
  if (isRTL) {
    containerProps.dir = "rtl";
  }
  return /* @__PURE__ */ React524.createElement("div", _extends({
    style: _objectSpread2(_objectSpread2({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, containerProps, restProps), /* @__PURE__ */ React524.createElement(src_default, {
    onResize: onHolderResize
  }, /* @__PURE__ */ React524.createElement(Component11, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, /* @__PURE__ */ React524.createElement(Filler_default2, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ React524.createElement(ScrollBar_default2, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb
  }), inVirtual && scrollWidth > size.width && /* @__PURE__ */ React524.createElement(ScrollBar_default2, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
    thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb
  }));
}
__name(RawList2, "RawList");
var List4 = /* @__PURE__ */ React524.forwardRef(RawList2);
List4.displayName = "List";
var List_default4 = List4;

// node_modules/.pnpm/rc-virtual-list@3.11.5_react-dom@16.14.0_react@16.14.0/node_modules/rc-virtual-list/es/index.js
var es_default7 = List_default4;

// packages/table/src/VirtualTable/BodyGrid.tsx
import * as React527 from "react";

// packages/table/src/VirtualTable/BodyLine.tsx
var import_classnames232 = __toESM(require_classnames());
import * as React526 from "react";

// packages/table/src/VirtualTable/VirtualCell.tsx
var import_classnames231 = __toESM(require_classnames());
import * as React525 from "react";

// packages/table/src/VirtualTable/context.ts
var StaticContext = createContext45(null);
var GridContext = createContext45(null);

// packages/table/src/VirtualTable/VirtualCell.tsx
function getColumnWidth(colIndex, colSpan, columnsOffset) {
  const mergedColSpan = colSpan || 1;
  return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
}
__name(getColumnWidth, "getColumnWidth");
function VirtualCell(props) {
  const {
    rowInfo,
    column: column2,
    colIndex,
    indent,
    index: index3,
    component,
    renderIndex,
    record,
    style: style2,
    className,
    inverse,
    getHeight: getHeight2
  } = props;
  const { render: render2, dataIndex, className: columnClassName, width: colWidth } = column2;
  const { columnsOffset } = useContext206(GridContext, ["columnsOffset"]);
  const { key, fixedInfo, appendCellNode, additionalCellProps } = getCellProps(
    rowInfo,
    column2,
    colIndex,
    indent,
    index3
  );
  const { style: cellStyle, colSpan = 1, rowSpan = 1 } = additionalCellProps;
  const startColIndex = colIndex - 1;
  const concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
  const marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
  const mergedStyle = {
    ...cellStyle,
    ...style2,
    flex: `0 0 ${concatColWidth}px`,
    width: `${concatColWidth}px`,
    marginRight: marginOffset,
    pointerEvents: "auto"
  };
  const needHide = React525.useMemo(() => {
    if (inverse) {
      return rowSpan <= 1;
    } else {
      return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
    }
  }, [rowSpan, colSpan, inverse]);
  if (needHide) {
    mergedStyle.visibility = "hidden";
  } else if (inverse) {
    mergedStyle.height = getHeight2?.(rowSpan);
  }
  const mergedRender = needHide ? () => null : render2;
  const cellSpan = {};
  if (rowSpan === 0 || colSpan === 0) {
    cellSpan.rowSpan = 1;
    cellSpan.colSpan = 1;
  }
  return /* @__PURE__ */ React525.createElement(
    Cell_default2,
    {
      className: (0, import_classnames231.default)(columnClassName, className),
      ellipsis: column2.ellipsis,
      align: column2.align,
      scope: column2.rowScope,
      component,
      prefixCls: rowInfo.prefixCls,
      key,
      record,
      index: index3,
      renderIndex,
      dataIndex,
      render: mergedRender,
      shouldCellUpdate: column2.shouldCellUpdate,
      ...fixedInfo,
      appendNode: appendCellNode,
      additionalProps: {
        ...additionalCellProps,
        style: mergedStyle,
        ...cellSpan
      }
    }
  );
}
__name(VirtualCell, "VirtualCell");
var VirtualCell_default = VirtualCell;

// packages/table/src/VirtualTable/BodyLine.tsx
var BodyLine = React526.forwardRef((props, ref) => {
  const { data, index: index3, className, rowKey, style: style2, extra, getHeight: getHeight2, ...restProps } = props;
  const { record, indent, index: renderIndex } = data;
  const { scrollX, flattenColumns, prefixCls, fixColumn, componentWidth } = useContext206(
    TableContext_default,
    ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]
  );
  const { getComponent } = useContext206(StaticContext, ["getComponent"]);
  const rowInfo = useRowInfo(record, rowKey, index3, indent);
  const RowComponent = getComponent(["body", "row"], "div");
  const cellComponent = getComponent(["body", "cell"], "div");
  const { rowSupportExpand, expanded, rowProps, expandedRowRender, expandedRowClassName } = rowInfo;
  let expandRowNode;
  if (rowSupportExpand && expanded) {
    const expandContent = expandedRowRender(record, index3, indent + 1, expanded);
    const computedExpandedRowClassName = expandedRowClassName?.(record, index3, indent);
    let additionalProps = {};
    if (fixColumn) {
      additionalProps = {
        style: {
          ["--virtual-width"]: `${componentWidth}px`
        }
      };
    }
    const rowCellCls = `${prefixCls}-expanded-row-cell`;
    expandRowNode = /* @__PURE__ */ React526.createElement(
      RowComponent,
      {
        className: (0, import_classnames232.default)(
          `${prefixCls}-expanded-row`,
          `${prefixCls}-expanded-row-level-${indent + 1}`,
          computedExpandedRowClassName
        )
      },
      /* @__PURE__ */ React526.createElement(
        Cell_default2,
        {
          component: cellComponent,
          prefixCls,
          className: (0, import_classnames232.default)(rowCellCls, {
            [`${rowCellCls}-fixed`]: fixColumn
          }),
          additionalProps
        },
        expandContent
      )
    );
  }
  const rowStyle = {
    ...style2,
    width: scrollX
  };
  if (extra) {
    rowStyle.position = "absolute";
    rowStyle.pointerEvents = "none";
  }
  const rowNode = /* @__PURE__ */ React526.createElement(
    RowComponent,
    {
      ...rowProps,
      ...restProps,
      "data-row-key": rowKey,
      ref: rowSupportExpand ? null : ref,
      className: (0, import_classnames232.default)(className, `${prefixCls}-row`, rowProps?.className, {
        [`${prefixCls}-row-extra`]: extra
      }),
      style: { ...rowStyle, ...rowProps?.style }
    },
    flattenColumns.map((column2, colIndex) => {
      return /* @__PURE__ */ React526.createElement(
        VirtualCell_default,
        {
          key: colIndex,
          component: cellComponent,
          rowInfo,
          column: column2,
          colIndex,
          indent,
          index: index3,
          renderIndex,
          record,
          inverse: extra,
          getHeight: getHeight2
        }
      );
    })
  );
  if (rowSupportExpand) {
    return /* @__PURE__ */ React526.createElement("div", { ref }, rowNode, expandRowNode);
  }
  return rowNode;
});
var ResponseBodyLine = responseImmutable2(BodyLine);
if (true) {
  ResponseBodyLine.displayName = "BodyLine";
}
var BodyLine_default = ResponseBodyLine;

// packages/table/src/VirtualTable/BodyGrid.tsx
var Grid2 = React527.forwardRef((props, ref) => {
  const { data, onScroll } = props;
  const {
    flattenColumns,
    onColumnResize,
    getRowKey,
    expandedKeys,
    prefixCls,
    childrenColumnName,
    emptyNode,
    scrollX
  } = useContext206(TableContext_default, [
    "flattenColumns",
    "onColumnResize",
    "getRowKey",
    "prefixCls",
    "expandedKeys",
    "childrenColumnName",
    "emptyNode",
    "scrollX"
  ]);
  const {
    sticky,
    scrollY,
    listItemHeight,
    getComponent,
    onScroll: onTablePropScroll
  } = useContext206(StaticContext);
  const listRef = React527.useRef();
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const columnsWidth = React527.useMemo(() => {
    let total = 0;
    return flattenColumns.map(({ width, key }) => {
      total += width;
      return [key, width, total];
    });
  }, [flattenColumns]);
  const columnsOffset = React527.useMemo(
    () => columnsWidth.map((colWidth) => colWidth[2]),
    [columnsWidth]
  );
  React527.useEffect(() => {
    columnsWidth.forEach(([key, width]) => {
      onColumnResize(key, width);
    });
  }, [columnsWidth]);
  React527.useImperativeHandle(ref, () => {
    const obj = {
      scrollTo: (config) => {
        listRef.current?.scrollTo(config);
      }
    };
    Object.defineProperty(obj, "scrollLeft", {
      get: () => listRef.current?.getScrollInfo().x || 0,
      set: (value) => {
        listRef.current?.scrollTo({
          left: value
        });
      }
    });
    return obj;
  });
  const getRowSpan = /* @__PURE__ */ __name((column2, index3) => {
    const record = flattenData2[index3]?.record;
    const { onCell } = column2;
    if (onCell) {
      const cellProps = onCell(record, index3);
      return cellProps?.rowSpan ?? 1;
    }
    return 1;
  }, "getRowSpan");
  const extraRender = /* @__PURE__ */ __name((info) => {
    const { start, end, getSize: getSize3, offsetY } = info;
    if (end < 0) {
      return null;
    }
    let firstRowSpanColumns = flattenColumns.filter(
      // rowSpan is 0
      (column2) => getRowSpan(column2, start) === 0
    );
    let startIndex = start;
    for (let i = start; i >= 0; i -= 1) {
      firstRowSpanColumns = firstRowSpanColumns.filter((column2) => getRowSpan(column2, i) === 0);
      if (!firstRowSpanColumns.length) {
        startIndex = i;
        break;
      }
    }
    let lastRowSpanColumns = flattenColumns.filter(
      // rowSpan is not 1
      (column2) => getRowSpan(column2, end) !== 1
    );
    let endIndex = end;
    for (let i = end; i < flattenData2.length; i += 1) {
      lastRowSpanColumns = lastRowSpanColumns.filter((column2) => getRowSpan(column2, i) !== 1);
      if (!lastRowSpanColumns.length) {
        endIndex = Math.max(i - 1, end);
        break;
      }
    }
    const spanLines = [];
    for (let i = startIndex; i <= endIndex; i += 1) {
      const item = flattenData2[i];
      if (!item) {
        continue;
      }
      if (flattenColumns.some((column2) => getRowSpan(column2, i) > 1)) {
        spanLines.push(i);
      }
    }
    const nodes = spanLines.map((index3) => {
      const item = flattenData2[index3];
      const rowKey = getRowKey(item.record, index3);
      const getHeight2 = /* @__PURE__ */ __name((rowSpan) => {
        const endItemIndex = index3 + rowSpan - 1;
        const endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex);
        const sizeInfo2 = getSize3(rowKey, endItemKey);
        return sizeInfo2.bottom - sizeInfo2.top;
      }, "getHeight");
      const sizeInfo = getSize3(rowKey);
      return /* @__PURE__ */ React527.createElement(
        BodyLine_default,
        {
          key: index3,
          data: item,
          rowKey,
          index: index3,
          style: {
            top: -offsetY + sizeInfo.top
          },
          extra: true,
          getHeight: getHeight2
        }
      );
    });
    return nodes;
  }, "extraRender");
  const gridContext = React527.useMemo(() => ({ columnsOffset }), [columnsOffset]);
  const tblPrefixCls = `${prefixCls}-tbody`;
  const wrapperComponent = getComponent(["body", "wrapper"]);
  const RowComponent = getComponent(["body", "row"], "div");
  const cellComponent = getComponent(["body", "cell"], "div");
  let bodyContent;
  if (flattenData2.length) {
    const horizontalScrollBarStyle = {};
    if (sticky) {
      horizontalScrollBarStyle.position = "sticky";
      horizontalScrollBarStyle.bottom = 0;
      if (typeof sticky === "object" && sticky.offsetScroll) {
        horizontalScrollBarStyle.bottom = sticky.offsetScroll;
      }
    }
    bodyContent = /* @__PURE__ */ React527.createElement(
      es_default7,
      {
        fullHeight: false,
        ref: listRef,
        prefixCls: `${tblPrefixCls}-virtual`,
        styles: { horizontalScrollBar: horizontalScrollBarStyle },
        className: tblPrefixCls,
        height: scrollY,
        itemHeight: listItemHeight || 24,
        data: flattenData2,
        itemKey: (item) => getRowKey(item.record),
        component: wrapperComponent,
        scrollWidth: scrollX,
        onVirtualScroll: ({ x }) => {
          onScroll({
            scrollLeft: x
          });
        },
        onScroll: onTablePropScroll,
        extraRender
      },
      (item, index3, itemProps) => {
        const rowKey = getRowKey(item.record, index3);
        return /* @__PURE__ */ React527.createElement(BodyLine_default, { data: item, rowKey, index: index3, ...itemProps });
      }
    );
  } else {
    bodyContent = /* @__PURE__ */ React527.createElement(RowComponent, { className: (0, import_classnames233.default)(`${prefixCls}-placeholder`) }, /* @__PURE__ */ React527.createElement(Cell_default2, { component: cellComponent, prefixCls }, emptyNode));
  }
  return /* @__PURE__ */ React527.createElement(GridContext.Provider, { value: gridContext }, bodyContent);
});
var ResponseGrid = responseImmutable2(Grid2);
if (true) {
  ResponseGrid.displayName = "ResponseGrid";
}
var BodyGrid_default = ResponseGrid;

// packages/table/src/VirtualTable/index.tsx
var renderBody = /* @__PURE__ */ __name((rawData, props) => {
  const { ref, onScroll } = props;
  return /* @__PURE__ */ React528.createElement(BodyGrid_default, { ref, data: rawData, onScroll });
}, "renderBody");
function VirtualTable(props, ref) {
  const {
    columns,
    scroll,
    sticky,
    prefixCls = DEFAULT_PREFIX,
    className,
    listItemHeight,
    components,
    onScroll
  } = props;
  let { x: scrollX, y: scrollY } = scroll || {};
  if (typeof scrollX !== "number") {
    if (true) {
      warning_default(!scrollX, "`scroll.x` in virtual table must be number.");
    }
    scrollX = 1;
  }
  if (typeof scrollY !== "number") {
    scrollY = 500;
    if (true) {
      warning_default(false, "`scroll.y` in virtual table must be number.");
    }
  }
  const getComponent = useEvent(
    (path2, defaultComponent) => get(components, path2) || defaultComponent
  );
  const onInternalScroll = useEvent(onScroll);
  const context = React528.useMemo(
    () => ({ sticky, scrollY, listItemHeight, getComponent, onScroll: onInternalScroll }),
    [sticky, scrollY, listItemHeight, getComponent, onInternalScroll]
  );
  return /* @__PURE__ */ React528.createElement(StaticContext.Provider, { value: context }, /* @__PURE__ */ React528.createElement(
    Table_default,
    {
      ...props,
      className: (0, import_classnames234.default)(className, `${prefixCls}-virtual`),
      scroll: {
        ...scroll,
        x: scrollX
      },
      components: {
        ...components,
        body: renderBody
      },
      columns,
      internalHooks: INTERNAL_HOOKS,
      tailor: true,
      ref
    }
  ));
}
__name(VirtualTable, "VirtualTable");
var RefVirtualTable = React528.forwardRef(VirtualTable);
if (true) {
  RefVirtualTable.displayName = "VirtualTable";
}
function genVirtualTable(shouldTriggerRender) {
  return makeImmutable2(RefVirtualTable, shouldTriggerRender);
}
__name(genVirtualTable, "genVirtualTable");
var VirtualTable_default = genVirtualTable();

// packages/ant-design/components/table/Column.ts
function Column3(_) {
  return null;
}
__name(Column3, "Column");
var Column_default2 = Column3;

// packages/ant-design/components/table/ColumnGroup.ts
function ColumnGroup2(_) {
  return null;
}
__name(ColumnGroup2, "ColumnGroup");
var ColumnGroup_default2 = ColumnGroup2;

// packages/ant-design/components/table/hooks/useSelection.tsx
var import_DownOutlined4 = __toESM(require_DownOutlined3());
var import_classnames237 = __toESM(require_classnames());
import * as React533 from "react";
import { useCallback as useCallback45, useMemo as useMemo168 } from "react";

// packages/tree/src/util.tsx
init_warning();
import React532 from "react";

// packages/tree/src/TreeNode.tsx
var import_classnames236 = __toESM(require_classnames());
import * as React531 from "react";

// packages/tree/src/contextTypes.ts
import * as React529 from "react";
var TreeContext = React529.createContext(null);

// packages/tree/src/Indent.tsx
var import_classnames235 = __toESM(require_classnames());
import * as React530 from "react";
var Indent = /* @__PURE__ */ __name(({ prefixCls, level, isStart, isEnd, width }) => {
  const widthStyle = width >= 0 ? {
    width
  } : {};
  const baseClassName = `${prefixCls}-indent-unit`;
  const list = [];
  for (let i = 0; i < level; i += 1) {
    list.push(
      /* @__PURE__ */ React530.createElement(
        "span",
        {
          key: i,
          className: (0, import_classnames235.default)(baseClassName, {
            [`${baseClassName}-start`]: isStart[i],
            [`${baseClassName}-end`]: isEnd[i]
          }),
          style: widthStyle
        }
      )
    );
  }
  return /* @__PURE__ */ React530.createElement("span", { "aria-hidden": "true", className: `${prefixCls}-indent` }, list);
}, "Indent");
var Indent_default = React530.memo(Indent);

// packages/tree/src/TreeNode.tsx
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var InternalTreeNode = class extends React531.Component {
  static {
    __name(this, "InternalTreeNode");
  }
  state = {
    dragNodeHighlight: false
  };
  selectHandle;
  cacheIndent;
  // Isomorphic needn't load data in server side
  componentDidMount() {
    this.syncLoadData(this.props);
  }
  componentDidUpdate() {
    this.syncLoadData(this.props);
  }
  onSelectorClick = (e3) => {
    const {
      context: { onNodeClick }
    } = this.props;
    onNodeClick(e3, convertNodePropsToEventData(this.props));
    if (this.isSelectable()) {
      this.onSelect(e3);
    } else {
      this.onCheck(e3);
    }
  };
  onSelectorDoubleClick = (e3) => {
    const {
      context: { onNodeDoubleClick }
    } = this.props;
    onNodeDoubleClick(e3, convertNodePropsToEventData(this.props));
  };
  onSelect = (e3) => {
    if (this.isDisabled())
      return;
    const {
      context: { onNodeSelect }
    } = this.props;
    onNodeSelect(e3, convertNodePropsToEventData(this.props));
  };
  onCheck = (e3) => {
    if (this.isDisabled())
      return;
    const { disableCheckbox, checked } = this.props;
    const {
      context: { onNodeCheck }
    } = this.props;
    if (!this.isCheckable() || disableCheckbox)
      return;
    const targetChecked = !checked;
    onNodeCheck(e3, convertNodePropsToEventData(this.props), targetChecked);
  };
  onMouseEnter = (e3) => {
    const {
      context: { onNodeMouseEnter }
    } = this.props;
    onNodeMouseEnter(e3, convertNodePropsToEventData(this.props));
  };
  onMouseLeave = (e3) => {
    const {
      context: { onNodeMouseLeave }
    } = this.props;
    onNodeMouseLeave(e3, convertNodePropsToEventData(this.props));
  };
  onContextMenu = (e3) => {
    const {
      context: { onNodeContextMenu }
    } = this.props;
    onNodeContextMenu(e3, convertNodePropsToEventData(this.props));
  };
  onDragStart = (e3) => {
    const {
      context: { onNodeDragStart }
    } = this.props;
    e3.stopPropagation();
    this.setState({
      dragNodeHighlight: true
    });
    onNodeDragStart(e3, this);
    try {
      e3.dataTransfer.setData("text/plain", "");
    } catch (error) {
    }
  };
  onDragEnter = (e3) => {
    const {
      context: { onNodeDragEnter }
    } = this.props;
    e3.preventDefault();
    e3.stopPropagation();
    onNodeDragEnter(e3, this);
  };
  onDragOver = (e3) => {
    const {
      context: { onNodeDragOver }
    } = this.props;
    e3.preventDefault();
    e3.stopPropagation();
    onNodeDragOver(e3, this);
  };
  onDragLeave = (e3) => {
    const {
      context: { onNodeDragLeave }
    } = this.props;
    e3.stopPropagation();
    onNodeDragLeave(e3, this);
  };
  onDragEnd = (e3) => {
    const {
      context: { onNodeDragEnd }
    } = this.props;
    e3.stopPropagation();
    this.setState({
      dragNodeHighlight: false
    });
    onNodeDragEnd(e3, this);
  };
  onDrop = (e3) => {
    const {
      context: { onNodeDrop }
    } = this.props;
    e3.preventDefault();
    e3.stopPropagation();
    this.setState({
      dragNodeHighlight: false
    });
    onNodeDrop(e3, this);
  };
  // Disabled item still can be switch
  onExpand = (e3) => {
    const {
      loading,
      context: { onNodeExpand }
    } = this.props;
    if (loading)
      return;
    onNodeExpand(e3, convertNodePropsToEventData(this.props));
  };
  // Drag usage
  setSelectHandle = (node2) => {
    this.selectHandle = node2;
  };
  getNodeState = () => {
    const { expanded } = this.props;
    if (this.isLeaf()) {
      return null;
    }
    return expanded ? ICON_OPEN : ICON_CLOSE;
  };
  hasChildren = () => {
    const { eventKey } = this.props;
    const {
      context: { keyEntities }
    } = this.props;
    const { children } = getEntity(keyEntities, eventKey) || {};
    return !!(children || []).length;
  };
  isLeaf = () => {
    const { isLeaf: isLeaf2, loaded } = this.props;
    const {
      context: { loadData }
    } = this.props;
    const hasChildren = this.hasChildren();
    if (isLeaf2 === false) {
      return false;
    }
    return isLeaf2 || !loadData && !hasChildren || loadData && loaded && !hasChildren;
  };
  isDisabled = () => {
    const { disabled } = this.props;
    const {
      context: { disabled: treeDisabled }
    } = this.props;
    return !!(treeDisabled || disabled);
  };
  isCheckable = () => {
    const { checkable } = this.props;
    const {
      context: { checkable: treeCheckable }
    } = this.props;
    if (!treeCheckable || checkable === false)
      return false;
    return treeCheckable;
  };
  // Load data to avoid default expanded tree without data
  syncLoadData = (props) => {
    const { expanded, loading, loaded } = props;
    const {
      context: { loadData, onNodeLoad }
    } = this.props;
    if (loading) {
      return;
    }
    if (loadData && expanded && !this.isLeaf()) {
      if (!this.hasChildren() && !loaded) {
        onNodeLoad(convertNodePropsToEventData(this.props));
      }
    }
  };
  isSelectable() {
    const { selectable } = this.props;
    const {
      context: { selectable: treeSelectable }
    } = this.props;
    if (typeof selectable === "boolean") {
      return selectable;
    }
    return treeSelectable;
  }
  isDraggable = () => {
    const {
      data,
      context: { draggable }
    } = this.props;
    return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
  };
  // ==================== Render: Drag Handler ====================
  renderDragHandler = () => {
    const {
      context: { draggable, prefixCls }
    } = this.props;
    return draggable?.icon ? /* @__PURE__ */ React531.createElement("span", { className: `${prefixCls}-draggable-icon` }, draggable.icon) : null;
  };
  // ====================== Render: Switcher ======================
  renderSwitcherIconDom = (isLeaf2) => {
    const { switcherIcon: switcherIconFromProps } = this.props;
    const {
      context: { switcherIcon: switcherIconFromCtx }
    } = this.props;
    const switcherIcon = switcherIconFromProps || switcherIconFromCtx;
    if (typeof switcherIcon === "function") {
      return switcherIcon({ ...this.props, isLeaf: isLeaf2 });
    }
    return switcherIcon;
  };
  // Switcher
  renderSwitcher = () => {
    const { expanded } = this.props;
    const {
      context: { prefixCls }
    } = this.props;
    if (this.isLeaf()) {
      const switcherIconDom2 = this.renderSwitcherIconDom(true);
      return switcherIconDom2 !== false ? /* @__PURE__ */ React531.createElement("span", { className: (0, import_classnames236.default)(`${prefixCls}-switcher`, `${prefixCls}-switcher-noop`) }, switcherIconDom2) : null;
    }
    const switcherCls = (0, import_classnames236.default)(
      `${prefixCls}-switcher`,
      `${prefixCls}-switcher_${expanded ? ICON_OPEN : ICON_CLOSE}`
    );
    const switcherIconDom = this.renderSwitcherIconDom(false);
    return switcherIconDom !== false ? /* @__PURE__ */ React531.createElement("span", { onClick: this.onExpand, className: switcherCls }, switcherIconDom) : null;
  };
  // ====================== Render: Checkbox ======================
  // Checkbox
  renderCheckbox = () => {
    const { checked, halfChecked, disableCheckbox } = this.props;
    const {
      context: { prefixCls }
    } = this.props;
    const disabled = this.isDisabled();
    const checkable = this.isCheckable();
    if (!checkable)
      return null;
    const $custom = typeof checkable !== "boolean" ? checkable : null;
    return /* @__PURE__ */ React531.createElement(
      "span",
      {
        className: (0, import_classnames236.default)(
          `${prefixCls}-checkbox`,
          checked && `${prefixCls}-checkbox-checked`,
          !checked && halfChecked && `${prefixCls}-checkbox-indeterminate`,
          (disabled || disableCheckbox) && `${prefixCls}-checkbox-disabled`
        ),
        onClick: this.onCheck
      },
      $custom
    );
  };
  // ==================== Render: Title + Icon ====================
  renderIcon = () => {
    const { loading } = this.props;
    const {
      context: { prefixCls }
    } = this.props;
    return /* @__PURE__ */ React531.createElement(
      "span",
      {
        className: (0, import_classnames236.default)(
          `${prefixCls}-iconEle`,
          `${prefixCls}-icon__${this.getNodeState() || "docu"}`,
          loading && `${prefixCls}-icon_loading`
        )
      }
    );
  };
  // Icon + Title
  renderSelector = () => {
    const { dragNodeHighlight } = this.state;
    const { title = defaultTitle, selected, icon, loading, data } = this.props;
    const {
      context: { prefixCls, showIcon, icon: treeIcon, loadData, titleRender }
    } = this.props;
    const disabled = this.isDisabled();
    const wrapClass = `${prefixCls}-node-content-wrapper`;
    let $icon;
    if (showIcon) {
      const currentIcon = icon || treeIcon;
      $icon = currentIcon ? /* @__PURE__ */ React531.createElement("span", { className: (0, import_classnames236.default)(`${prefixCls}-iconEle`, `${prefixCls}-icon__customize`) }, typeof currentIcon === "function" ? currentIcon(this.props) : currentIcon) : this.renderIcon();
    } else if (loadData && loading) {
      $icon = this.renderIcon();
    }
    let titleNode;
    if (typeof title === "function") {
      titleNode = title(data);
    } else if (titleRender) {
      titleNode = titleRender(data);
    } else {
      titleNode = title;
    }
    const $title = /* @__PURE__ */ React531.createElement("span", { className: `${prefixCls}-title` }, titleNode);
    return /* @__PURE__ */ React531.createElement(
      "span",
      {
        ref: this.setSelectHandle,
        title: typeof title === "string" ? title : "",
        className: (0, import_classnames236.default)(
          `${wrapClass}`,
          `${wrapClass}-${this.getNodeState() || "normal"}`,
          !disabled && (selected || dragNodeHighlight) && `${prefixCls}-node-selected`
        ),
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave,
        onContextMenu: this.onContextMenu,
        onClick: this.onSelectorClick,
        onDoubleClick: this.onSelectorDoubleClick
      },
      $icon,
      $title,
      this.renderDropIndicator()
    );
  };
  // =================== Render: Drop Indicator ===================
  renderDropIndicator = () => {
    const { disabled, eventKey } = this.props;
    const {
      context: {
        draggable,
        dropLevelOffset,
        dropPosition,
        prefixCls,
        indent,
        dropIndicatorRender: dropIndicatorRender2,
        dragOverNodeKey,
        direction
      }
    } = this.props;
    const rootDraggable = !!draggable;
    const showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
    const mergedIndent = indent ?? this.cacheIndent;
    this.cacheIndent = indent;
    return showIndicator ? dropIndicatorRender2({
      dropPosition,
      dropLevelOffset,
      indent: mergedIndent,
      prefixCls,
      direction
    }) : null;
  };
  // =========================== Render ===========================
  render() {
    const {
      eventKey,
      className,
      style: style2,
      dragOver,
      dragOverGapTop,
      dragOverGapBottom,
      isLeaf: isLeaf2,
      isStart,
      isEnd,
      expanded,
      selected,
      checked,
      halfChecked,
      loading,
      domRef,
      active,
      data,
      onMouseMove,
      selectable,
      indentWidth,
      ...otherProps
    } = this.props;
    const {
      context: {
        prefixCls,
        filterTreeNode,
        keyEntities,
        dropContainerKey,
        dropTargetKey,
        draggingNodeKey
      }
    } = this.props;
    const disabled = this.isDisabled();
    const dataOrAriaAttributeProps = pickAttrs(otherProps, { aria: true, data: true });
    const { level } = getEntity(keyEntities, eventKey) || {};
    const isEndNode = isEnd[isEnd.length - 1];
    const mergedDraggable = this.isDraggable();
    const draggableWithoutDisabled = !disabled && mergedDraggable;
    const dragging = draggingNodeKey === eventKey;
    const ariaSelected = selectable !== void 0 ? { "aria-selected": !!selectable } : void 0;
    return /* @__PURE__ */ React531.createElement(
      "div",
      {
        ref: domRef,
        className: (0, import_classnames236.default)(className, `${prefixCls}-treenode`, {
          [`${prefixCls}-treenode-disabled`]: disabled,
          [`${prefixCls}-treenode-switcher-${expanded ? "open" : "close"}`]: !isLeaf2,
          [`${prefixCls}-treenode-checkbox-checked`]: checked,
          [`${prefixCls}-treenode-checkbox-indeterminate`]: halfChecked,
          [`${prefixCls}-treenode-selected`]: selected,
          [`${prefixCls}-treenode-loading`]: loading,
          [`${prefixCls}-treenode-active`]: active,
          [`${prefixCls}-treenode-leaf-last`]: isEndNode,
          [`${prefixCls}-treenode-draggable`]: mergedDraggable,
          dragging,
          "drop-target": dropTargetKey === eventKey,
          "drop-container": dropContainerKey === eventKey,
          "drag-over": !disabled && dragOver,
          "drag-over-gap-top": !disabled && dragOverGapTop,
          "drag-over-gap-bottom": !disabled && dragOverGapBottom,
          "filter-node": filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))
        }),
        style: style2,
        draggable: draggableWithoutDisabled,
        "aria-grabbed": dragging,
        onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
        onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
        onDragOver: mergedDraggable ? this.onDragOver : void 0,
        onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
        onDrop: mergedDraggable ? this.onDrop : void 0,
        onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
        onMouseMove,
        ...ariaSelected,
        ...dataOrAriaAttributeProps
      },
      /* @__PURE__ */ React531.createElement(Indent_default, { prefixCls, level, isStart, isEnd, width: indentWidth }),
      this.renderDragHandler(),
      this.renderSwitcher(),
      this.renderCheckbox(),
      this.renderSelector()
    );
  }
};
var ContextTreeNode = /* @__PURE__ */ __name((props) => /* @__PURE__ */ React531.createElement(TreeContext.Consumer, null, (context) => /* @__PURE__ */ React531.createElement(InternalTreeNode, { ...props, context })), "ContextTreeNode");
ContextTreeNode.displayName = "TreeNode";
ContextTreeNode.isTreeNode = 1;
var TreeNode_default = ContextTreeNode;

// packages/tree/src/util.tsx
function arrDel(list, value) {
  if (!list)
    return [];
  const clone = list.slice();
  const index3 = clone.indexOf(value);
  if (index3 >= 0) {
    clone.splice(index3, 1);
  }
  return clone;
}
__name(arrDel, "arrDel");
function arrAdd(list, value) {
  const clone = (list || []).slice();
  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }
  return clone;
}
__name(arrAdd, "arrAdd");
function posToArr(pos) {
  return pos.split("-");
}
__name(posToArr, "posToArr");
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  const dragChildrenKeys = [];
  const entity = getEntity(keyEntities, dragNodeKey);
  function dig(list = []) {
    list.forEach(({ key, children }) => {
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  __name(dig, "dig");
  dig(entity.children);
  return dragChildrenKeys;
}
__name(getDragChildrenKeys, "getDragChildrenKeys");
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    const posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
__name(isLastChild, "isLastChild");
function isFirstChild(treeNodeEntity) {
  const posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
__name(isFirstChild, "isFirstChild");
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
  const { clientX, clientY } = event;
  const { top, height } = event.target.getBoundingClientRect();
  const horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * ((startMousePosition?.x || 0) - clientX);
  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  const filteredExpandKeys = expandKeys.filter((key) => keyEntities[key]?.children?.length);
  let abstractDropNodeEntity = getEntity(
    keyEntities,
    targetNode.props.eventKey
  );
  if (clientY < top + height / 2) {
    const nodeIndex = flattenedNodes.findIndex(
      (flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key
    );
    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    const prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
  }
  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  const abstractDragOverEntity = abstractDropNodeEntity;
  const dragOverNodeKey = abstractDropNodeEntity.key;
  let dropPosition = 0;
  let dropLevelOffset = 0;
  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {
    for (let i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  const abstractDragDataNode = dragNode.props.data;
  const abstractDropDataNode = abstractDropNodeEntity.node;
  let dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : abstractDropNodeEntity.parent?.key || null,
    dropAllowed
  };
}
__name(calcDropPosition, "calcDropPosition");
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys)
    return void 0;
  const { multiple } = props;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
__name(calcSelectedKeys, "calcSelectedKeys");
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  let keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (typeof keys2 === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    warning_default(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
__name(parseCheckedKeys, "parseCheckedKeys");
function conductExpandParent(keyList, keyEntities) {
  const expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key) {
    if (expandedKeys.has(key))
      return;
    const entity = getEntity(keyEntities, key);
    if (!entity)
      return;
    expandedKeys.add(key);
    const { parent, node: node2 } = entity;
    if (node2.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  __name(conductUp, "conductUp");
  (keyList || []).forEach((key) => {
    conductUp(key);
  });
  return [...expandedKeys];
}
__name(conductExpandParent, "conductExpandParent");

// packages/ant-design/components/_util/hooks/useMultipleSelect.ts
import { useCallback as useCallback44, useState as useState127 } from "react";
function useMultipleSelect(getKey4) {
  const [prevSelectedIndex, setPrevSelectedIndex] = useState127(null);
  const multipleSelect = useCallback44(
    (currentSelectedIndex, data, selectedKeys) => {
      const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex;
      const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
      const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
      const rangeKeys = data.slice(startIndex, endIndex + 1).map((item) => getKey4(item));
      const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
      const changedKeys = [];
      rangeKeys.forEach((item) => {
        if (shouldSelected) {
          if (!selectedKeys.has(item)) {
            changedKeys.push(item);
          }
          selectedKeys.add(item);
        } else {
          selectedKeys.delete(item);
          changedKeys.push(item);
        }
      });
      setPrevSelectedIndex(shouldSelected ? endIndex : null);
      return changedKeys;
    },
    [prevSelectedIndex]
  );
  const updatePrevSelectedIndex = /* @__PURE__ */ __name((val) => {
    setPrevSelectedIndex(val);
  }, "updatePrevSelectedIndex");
  return [multipleSelect, updatePrevSelectedIndex];
}
__name(useMultipleSelect, "useMultipleSelect");

// packages/ant-design/components/table/hooks/useSelection.tsx
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST6 = [];
var flattenData = /* @__PURE__ */ __name((childrenColumnName, data) => {
  let list = [];
  (data || []).forEach((record) => {
    list.push(record);
    if (record && typeof record === "object" && childrenColumnName in record) {
      list = [...list, ...flattenData(childrenColumnName, record[childrenColumnName])];
    }
  });
  return list;
}, "flattenData");
var useSelection = /* @__PURE__ */ __name((config, rowSelection) => {
  const {
    preserveSelectedRowKeys,
    selectedRowKeys,
    defaultSelectedRowKeys,
    getCheckboxProps,
    onChange: onSelectionChange,
    onSelect,
    onSelectAll,
    onSelectInvert,
    onSelectNone,
    onSelectMultiple,
    columnWidth: selectionColWidth,
    type: selectionType,
    selections,
    fixed,
    renderCell: customizeRenderCell,
    hideSelectAll,
    checkStrictly = true
  } = rowSelection || {};
  const {
    prefixCls,
    data,
    pageData,
    getRecordByKey,
    getRowKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  } = config;
  const warning5 = devUseWarning("Table");
  const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect(
    (item) => item
  );
  const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(
    selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST6,
    {
      value: selectedRowKeys
    }
  );
  const preserveRecordsRef = React533.useRef(/* @__PURE__ */ new Map());
  const updatePreserveRecordsCache = useCallback45(
    (keys2) => {
      if (preserveSelectedRowKeys) {
        const newCache = /* @__PURE__ */ new Map();
        keys2.forEach((key) => {
          let record = getRecordByKey(key);
          if (!record && preserveRecordsRef.current.has(key)) {
            record = preserveRecordsRef.current.get(key);
          }
          newCache.set(key, record);
        });
        preserveRecordsRef.current = newCache;
      }
    },
    [getRecordByKey, preserveSelectedRowKeys]
  );
  React533.useEffect(() => {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  const { keyEntities } = useMemo168(() => {
    if (checkStrictly) {
      return { keyEntities: null };
    }
    let convertData = data;
    if (preserveSelectedRowKeys) {
      const keysSet = new Set(data.map((record, index3) => getRowKey(record, index3)));
      const preserveRecords = Array.from(preserveRecordsRef.current).reduce(
        (total, [key, value]) => keysSet.has(key) ? total : total.concat(value),
        []
      );
      convertData = [...convertData, ...preserveRecords];
    }
    return convertDataToEntities(convertData, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys]);
  const flattedData = useMemo168(
    () => flattenData(childrenColumnName, pageData),
    [childrenColumnName, pageData]
  );
  const checkboxPropsMap = useMemo168(() => {
    const map = /* @__PURE__ */ new Map();
    flattedData.forEach((record, index3) => {
      const key = getRowKey(record, index3);
      const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps);
      warning5(
        !("checked" in checkboxProps || "defaultChecked" in checkboxProps),
        "usage",
        "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead."
      );
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  const isCheckboxDisabled = useCallback45(
    (r2) => !!checkboxPropsMap.get(getRowKey(r2))?.disabled,
    [checkboxPropsMap, getRowKey]
  );
  const [derivedSelectedKeys, derivedHalfSelectedKeys] = useMemo168(() => {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    const { checkedKeys, halfCheckedKeys } = conductCheck(
      mergedSelectedKeys,
      true,
      keyEntities,
      isCheckboxDisabled
    );
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
  const derivedSelectedKeySet = useMemo168(() => {
    const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys2);
  }, [derivedSelectedKeys, selectionType]);
  const derivedHalfSelectedKeySet = useMemo168(
    () => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys),
    [derivedHalfSelectedKeys, selectionType]
  );
  React533.useEffect(() => {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST6);
    }
  }, [!!rowSelection]);
  const setSelectedKeys = useCallback45(
    (keys2, method4) => {
      let availableKeys;
      let records;
      updatePreserveRecordsCache(keys2);
      if (preserveSelectedRowKeys) {
        availableKeys = keys2;
        records = keys2.map((key) => preserveRecordsRef.current.get(key));
      } else {
        availableKeys = [];
        records = [];
        keys2.forEach((key) => {
          const record = getRecordByKey(key);
          if (record !== void 0) {
            availableKeys.push(key);
            records.push(record);
          }
        });
      }
      setMergedSelectedKeys(availableKeys);
      onSelectionChange?.(availableKeys, records, { type: method4 });
    },
    [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]
  );
  const triggerSingleSelection = useCallback45(
    (key, selected, keys2, event) => {
      if (onSelect) {
        const rows = keys2.map((k) => getRecordByKey(k));
        onSelect(getRecordByKey(key), selected, rows, event);
      }
      setSelectedKeys(keys2, "single");
    },
    [onSelect, getRecordByKey, setSelectedKeys]
  );
  const mergedSelections = useMemo168(() => {
    if (!selections || hideSelectAll) {
      return null;
    }
    const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map((selection) => {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect() {
            setSelectedKeys(
              data.map((record, index3) => getRowKey(record, index3)).filter((key) => {
                const checkProps = checkboxPropsMap.get(key);
                return !checkProps?.disabled || derivedSelectedKeySet.has(key);
              }),
              "all"
            );
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect() {
            const keySet = new Set(derivedSelectedKeySet);
            pageData.forEach((record, index3) => {
              const key = getRowKey(record, index3);
              const checkProps = checkboxPropsMap.get(key);
              if (!checkProps?.disabled) {
                if (keySet.has(key)) {
                  keySet.delete(key);
                } else {
                  keySet.add(key);
                }
              }
            });
            const keys2 = Array.from(keySet);
            if (onSelectInvert) {
              warning5.deprecated(false, "onSelectInvert", "onChange");
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect() {
            onSelectNone?.();
            setSelectedKeys(
              Array.from(derivedSelectedKeySet).filter((key) => {
                const checkProps = checkboxPropsMap.get(key);
                return checkProps?.disabled;
              }),
              "none"
            );
          }
        };
      }
      return selection;
    }).map((selection) => ({
      ...selection,
      onSelect: (...rest) => {
        selection.onSelect?.(...rest);
        updatePrevSelectedIndex(null);
      }
    }));
  }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  const transformColumns = useCallback45(
    (columns) => {
      if (!rowSelection) {
        warning5(
          !columns.includes(SELECTION_COLUMN),
          "usage",
          "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."
        );
        return columns.filter((col) => col !== SELECTION_COLUMN);
      }
      let cloneColumns = [...columns];
      const keySet = new Set(derivedSelectedKeySet);
      const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
      const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
      const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
      const onSelectAllChange = /* @__PURE__ */ __name(() => {
        const changeKeys = [];
        if (checkedCurrentAll) {
          recordKeys.forEach((key) => {
            keySet.delete(key);
            changeKeys.push(key);
          });
        } else {
          recordKeys.forEach((key) => {
            if (!keySet.has(key)) {
              keySet.add(key);
              changeKeys.push(key);
            }
          });
        }
        const keys2 = Array.from(keySet);
        onSelectAll?.(
          !checkedCurrentAll,
          keys2.map((k) => getRecordByKey(k)),
          changeKeys.map((k) => getRecordByKey(k))
        );
        setSelectedKeys(keys2, "all");
        updatePrevSelectedIndex(null);
      }, "onSelectAllChange");
      let title;
      let columnTitleCheckbox;
      if (selectionType !== "radio") {
        let customizeSelections;
        if (mergedSelections) {
          const menu = {
            getPopupContainer,
            items: mergedSelections.map((selection, index3) => {
              const { key, text, onSelect: onSelectionClick } = selection;
              return {
                key: key ?? index3,
                onClick: () => {
                  onSelectionClick?.(recordKeys);
                },
                label: text
              };
            })
          };
          customizeSelections = /* @__PURE__ */ React533.createElement("div", { className: `${prefixCls}-selection-extra` }, /* @__PURE__ */ React533.createElement(dropdown_default3, { menu, getPopupContainer }, /* @__PURE__ */ React533.createElement("span", null, /* @__PURE__ */ React533.createElement(import_DownOutlined4.default, null))));
        }
        const allDisabledData = flattedData.map((record, index3) => {
          const key = getRowKey(record, index3);
          const checkboxProps = checkboxPropsMap.get(key) || {};
          return { checked: keySet.has(key), ...checkboxProps };
        }).filter(({ disabled }) => disabled);
        const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
        const allDisabledAndChecked = allDisabled && allDisabledData.every(({ checked }) => checked);
        const allDisabledSomeChecked = allDisabled && allDisabledData.some(({ checked }) => checked);
        columnTitleCheckbox = /* @__PURE__ */ React533.createElement(
          checkbox_default,
          {
            checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
            indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
            onChange: onSelectAllChange,
            disabled: flattedData.length === 0 || allDisabled,
            "aria-label": customizeSelections ? "Custom selection" : "Select all",
            skipGroup: true
          }
        );
        title = !hideSelectAll && /* @__PURE__ */ React533.createElement("div", { className: `${prefixCls}-selection` }, columnTitleCheckbox, customizeSelections);
      }
      let renderCell;
      if (selectionType === "radio") {
        renderCell = /* @__PURE__ */ __name((_, record, index3) => {
          const key = getRowKey(record, index3);
          const checked = keySet.has(key);
          return {
            node: /* @__PURE__ */ React533.createElement(
              radio_default2,
              {
                ...checkboxPropsMap.get(key),
                checked,
                onClick: (e3) => e3.stopPropagation(),
                onChange: (event) => {
                  if (!keySet.has(key)) {
                    triggerSingleSelection(key, true, [key], event.nativeEvent);
                  }
                }
              }
            ),
            checked
          };
        }, "renderCell");
      } else {
        renderCell = /* @__PURE__ */ __name((_, record, index3) => {
          const key = getRowKey(record, index3);
          const checked = keySet.has(key);
          const indeterminate = derivedHalfSelectedKeySet.has(key);
          const checkboxProps = checkboxPropsMap.get(key);
          let mergedIndeterminate;
          if (expandType === "nest") {
            mergedIndeterminate = indeterminate;
            warning5(
              typeof checkboxProps?.indeterminate !== "boolean",
              "usage",
              "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource."
            );
          } else {
            mergedIndeterminate = checkboxProps?.indeterminate ?? indeterminate;
          }
          return {
            node: /* @__PURE__ */ React533.createElement(
              checkbox_default,
              {
                ...checkboxProps,
                indeterminate: mergedIndeterminate,
                checked,
                skipGroup: true,
                onClick: (e3) => e3.stopPropagation(),
                onChange: ({ nativeEvent }) => {
                  const { shiftKey } = nativeEvent;
                  const currentSelectedIndex = recordKeys.findIndex((item) => item === key);
                  const isMultiple2 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
                  if (shiftKey && checkStrictly && isMultiple2) {
                    const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
                    const keys2 = Array.from(keySet);
                    onSelectMultiple?.(
                      !checked,
                      keys2.map((recordKey) => getRecordByKey(recordKey)),
                      changedKeys.map((recordKey) => getRecordByKey(recordKey))
                    );
                    setSelectedKeys(keys2, "multiple");
                  } else {
                    const originCheckedKeys = derivedSelectedKeys;
                    if (checkStrictly) {
                      const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                      triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                    } else {
                      const result = conductCheck(
                        [...originCheckedKeys, key],
                        true,
                        keyEntities,
                        isCheckboxDisabled
                      );
                      const { checkedKeys, halfCheckedKeys } = result;
                      let nextCheckedKeys = checkedKeys;
                      if (checked) {
                        const tempKeySet = new Set(checkedKeys);
                        tempKeySet.delete(key);
                        nextCheckedKeys = conductCheck(
                          Array.from(tempKeySet),
                          { checked: false, halfCheckedKeys },
                          keyEntities,
                          isCheckboxDisabled
                        ).checkedKeys;
                      }
                      triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                    }
                  }
                  if (checked) {
                    updatePrevSelectedIndex(null);
                  } else {
                    updatePrevSelectedIndex(currentSelectedIndex);
                  }
                }
              }
            ),
            checked
          };
        }, "renderCell");
      }
      const renderSelectionCell = /* @__PURE__ */ __name((_, record, index3) => {
        const { node: node2, checked } = renderCell(_, record, index3);
        if (customizeRenderCell) {
          return customizeRenderCell(checked, record, index3, node2);
        }
        return node2;
      }, "renderSelectionCell");
      if (!cloneColumns.includes(SELECTION_COLUMN)) {
        if (cloneColumns.findIndex(
          (col) => col[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN"
        ) === 0) {
          const [expandColumn, ...restColumns] = cloneColumns;
          cloneColumns = [expandColumn, SELECTION_COLUMN, ...restColumns];
        } else {
          cloneColumns = [SELECTION_COLUMN, ...cloneColumns];
        }
      }
      const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
      warning5(
        cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1,
        "usage",
        "Multiple `SELECTION_COLUMN` exist in `columns`."
      );
      cloneColumns = cloneColumns.filter(
        (column2, index3) => column2 !== SELECTION_COLUMN || index3 === selectionColumnIndex
      );
      const prevCol = cloneColumns[selectionColumnIndex - 1];
      const nextCol = cloneColumns[selectionColumnIndex + 1];
      let mergedFixed = fixed;
      if (mergedFixed === void 0) {
        if (nextCol?.fixed !== void 0) {
          mergedFixed = nextCol.fixed;
        } else if (prevCol?.fixed !== void 0) {
          mergedFixed = prevCol.fixed;
        }
      }
      if (mergedFixed && prevCol && prevCol[INTERNAL_COL_DEFINE]?.columnType === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
        prevCol.fixed = mergedFixed;
      }
      const columnCls = (0, import_classnames237.default)(`${prefixCls}-selection-col`, {
        [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
      });
      const renderColumnTitle2 = /* @__PURE__ */ __name(() => {
        if (!rowSelection?.columnTitle) {
          return title;
        }
        if (typeof rowSelection.columnTitle === "function") {
          return rowSelection.columnTitle(columnTitleCheckbox);
        }
        return rowSelection.columnTitle;
      }, "renderColumnTitle");
      const selectionColumn = {
        fixed: mergedFixed,
        width: selectionColWidth,
        className: `${prefixCls}-selection-column`,
        title: renderColumnTitle2(),
        render: renderSelectionCell,
        onCell: rowSelection.onCell,
        [INTERNAL_COL_DEFINE]: { className: columnCls }
      };
      return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
    },
    [
      getRowKey,
      flattedData,
      rowSelection,
      derivedSelectedKeys,
      derivedSelectedKeySet,
      derivedHalfSelectedKeySet,
      selectionColWidth,
      mergedSelections,
      expandType,
      checkboxPropsMap,
      onSelectMultiple,
      triggerSingleSelection,
      isCheckboxDisabled
    ]
  );
  return [transformColumns, derivedSelectedKeySet];
}, "useSelection");
var useSelection_default = useSelection;

// packages/ant-design/components/table/InternalTable.tsx
var import_classnames246 = __toESM(require_classnames());
import * as React552 from "react";

// packages/ant-design/components/_util/hooks/useProxyImperativeHandle.ts
import { useImperativeHandle as useImperativeHandle44 } from "react";
function fillProxy(element, handler) {
  element._antProxy = element._antProxy || {};
  Object.keys(handler).forEach((key) => {
    if (!(key in element._antProxy)) {
      const ori = element[key];
      element._antProxy[key] = ori;
      element[key] = handler[key];
    }
  });
  return element;
}
__name(fillProxy, "fillProxy");
function useProxyImperativeHandle(ref, init) {
  return useImperativeHandle44(ref, () => {
    const refObj = init();
    const { nativeElement } = refObj;
    if (typeof Proxy !== "undefined") {
      return new Proxy(nativeElement, {
        get(obj, prop) {
          if (refObj[prop]) {
            return refObj[prop];
          }
          return Reflect.get(obj, prop);
        }
      });
    }
    return fillProxy(nativeElement, refObj);
  });
}
__name(useProxyImperativeHandle, "useProxyImperativeHandle");

// packages/ant-design/components/table/ExpandIcon.tsx
var import_classnames238 = __toESM(require_classnames());
import * as React534 from "react";
function renderExpandIcon2(locale6) {
  return /* @__PURE__ */ __name(function expandIcon({
    prefixCls,
    onExpand,
    record,
    expanded,
    expandable
  }) {
    const iconPrefix = `${prefixCls}-row-expand-icon`;
    return /* @__PURE__ */ React534.createElement(
      "button",
      {
        type: "button",
        onClick: (e3) => {
          onExpand(record, e3);
          e3.stopPropagation();
        },
        className: (0, import_classnames238.default)(iconPrefix, {
          [`${iconPrefix}-spaced`]: !expandable,
          [`${iconPrefix}-expanded`]: expandable && expanded,
          [`${iconPrefix}-collapsed`]: expandable && !expanded
        }),
        "aria-label": expanded ? locale6.collapse : locale6.expand,
        "aria-expanded": expanded
      }
    );
  }, "expandIcon");
}
__name(renderExpandIcon2, "renderExpandIcon");
var ExpandIcon_default = renderExpandIcon2;

// packages/ant-design/components/table/hooks/useContainerWidth.ts
function useContainerWidth(prefixCls) {
  const getContainerWidth = /* @__PURE__ */ __name((ele, width) => {
    const container = ele.querySelector(`.${prefixCls}-container`);
    let returnWidth = width;
    if (container) {
      const style2 = getComputedStyle(container);
      const borderLeft = parseInt(style2.borderLeftWidth, 10);
      const borderRight = parseInt(style2.borderRightWidth, 10);
      returnWidth = width - borderLeft - borderRight;
    }
    return returnWidth;
  }, "getContainerWidth");
  return getContainerWidth;
}
__name(useContainerWidth, "useContainerWidth");

// packages/ant-design/components/table/hooks/useFilter/index.tsx
import * as React548 from "react";

// packages/ant-design/components/table/util.ts
function getColumnKey(column2, defaultKey) {
  if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
    return column2.key;
  }
  if (column2.dataIndex) {
    return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
  }
  return defaultKey;
}
__name(getColumnKey, "getColumnKey");
function getColumnPos(index3, pos) {
  return pos ? `${pos}-${index3}` : `${index3}`;
}
__name(getColumnPos, "getColumnPos");
function renderColumnTitle(title, props) {
  if (typeof title === "function") {
    return title(props);
  }
  return title;
}
__name(renderColumnTitle, "renderColumnTitle");
function safeColumnTitle(title, props) {
  const res = renderColumnTitle(title, props);
  if (Object.prototype.toString.call(res) === "[object Object]")
    return "";
  return res;
}
__name(safeColumnTitle, "safeColumnTitle");

// packages/ant-design/components/table/hooks/useFilter/FilterDropdown.tsx
var import_FilterFilled = __toESM(require_FilterFilled3());
var import_classnames244 = __toESM(require_classnames());
import * as React547 from "react";

// packages/ant-design/components/_util/hooks/useSyncState.ts
import * as React535 from "react";
function useSyncState3(initialValue) {
  const ref = React535.useRef(initialValue);
  const forceUpdate = useForceUpdate();
  return [
    () => ref.current,
    (newValue) => {
      ref.current = newValue;
      forceUpdate();
    }
  ];
}
__name(useSyncState3, "useSyncState");

// packages/tree/src/Tree.tsx
var import_classnames240 = __toESM(require_classnames());
init_warning();
import * as React540 from "react";

// packages/tree/src/DropIndicator.tsx
import * as React536 from "react";
function DropIndicator({
  dropPosition,
  dropLevelOffset,
  indent
}) {
  const style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0;
      style2.left = indent;
      break;
  }
  return /* @__PURE__ */ React536.createElement("div", { style: style2 });
}
__name(DropIndicator, "DropIndicator");

// packages/tree/src/NodeList.tsx
import * as React539 from "react";

// packages/tree/src/MotionTreeNode.tsx
var import_classnames239 = __toESM(require_classnames());
import * as React538 from "react";

// packages/tree/src/useUnmount.ts
import * as React537 from "react";
function useUnmount(triggerStart, triggerEnd) {
  const [firstMount, setFirstMount] = React537.useState(false);
  useLayoutEffect_default(() => {
    if (firstMount) {
      triggerStart();
      return () => {
        triggerEnd();
      };
    }
  }, [firstMount]);
  useLayoutEffect_default(() => {
    setFirstMount(true);
    return () => {
      setFirstMount(false);
    };
  }, []);
}
__name(useUnmount, "useUnmount");

// packages/tree/src/MotionTreeNode.tsx
var MotionTreeNode = /* @__PURE__ */ __name(({
  className,
  style: style2,
  motion: motion2,
  motionNodes,
  motionType,
  onMotionStart: onOriginMotionStart,
  onMotionEnd: onOriginMotionEnd,
  active,
  treeNodeRequiredProps,
  ...props
}, ref) => {
  const [visible, setVisible] = React538.useState(true);
  const { prefixCls } = React538.useContext(TreeContext);
  const targetVisible = motionNodes && motionType !== "hide";
  useLayoutEffect_default(() => {
    if (motionNodes) {
      if (targetVisible !== visible) {
        setVisible(targetVisible);
      }
    }
  }, [motionNodes]);
  const triggerMotionStart = /* @__PURE__ */ __name(() => {
    if (motionNodes) {
      onOriginMotionStart();
    }
  }, "triggerMotionStart");
  const triggerMotionEndRef = React538.useRef(false);
  const triggerMotionEnd = /* @__PURE__ */ __name(() => {
    if (motionNodes && !triggerMotionEndRef.current) {
      triggerMotionEndRef.current = true;
      onOriginMotionEnd();
    }
  }, "triggerMotionEnd");
  useUnmount(triggerMotionStart, triggerMotionEnd);
  const onVisibleChanged = /* @__PURE__ */ __name((nextVisible) => {
    if (targetVisible === nextVisible) {
      triggerMotionEnd();
    }
  }, "onVisibleChanged");
  if (motionNodes) {
    return /* @__PURE__ */ React538.createElement(
      src_default2,
      {
        ref,
        visible,
        ...motion2,
        motionAppear: motionType === "show",
        onVisibleChanged
      },
      ({ className: motionClassName, style: motionStyle }, motionRef) => /* @__PURE__ */ React538.createElement(
        "div",
        {
          ref: motionRef,
          className: (0, import_classnames239.default)(`${prefixCls}-treenode-motion`, motionClassName),
          style: motionStyle
        },
        motionNodes.map((treeNode) => {
          const {
            data: { ...restProps },
            title,
            key,
            isStart,
            isEnd
          } = treeNode;
          delete restProps.children;
          const treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
          return /* @__PURE__ */ React538.createElement(
            TreeNode_default,
            {
              ...restProps,
              ...treeNodeProps,
              title,
              active,
              data: treeNode.data,
              key,
              isStart,
              isEnd
            }
          );
        })
      )
    );
  }
  return /* @__PURE__ */ React538.createElement(TreeNode_default, { domRef: ref, className, style: style2, ...props, active });
}, "MotionTreeNode");
MotionTreeNode.displayName = "MotionTreeNode";
var RefMotionTreeNode = React538.forwardRef(MotionTreeNode);
var MotionTreeNode_default = RefMotionTreeNode;

// packages/tree/src/utils/diffUtil.ts
function findExpandedKeys(prev2 = [], next2 = []) {
  const prevLen = prev2.length;
  const nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return { add: false, key: null };
  }
  function find(shorter, longer) {
    const cache = /* @__PURE__ */ new Map();
    shorter.forEach((key) => {
      cache.set(key, true);
    });
    const keys2 = longer.filter((key) => !cache.has(key));
    return keys2.length === 1 ? keys2[0] : null;
  }
  __name(find, "find");
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev2, next2)
    };
  }
  return {
    add: false,
    key: find(next2, prev2)
  };
}
__name(findExpandedKeys, "findExpandedKeys");
function getExpandRange(shorter, longer, key) {
  const shorterStartIndex = shorter.findIndex((data) => data.key === key);
  const shorterEndNode = shorter[shorterStartIndex + 1];
  const longerStartIndex = longer.findIndex((data) => data.key === key);
  if (shorterEndNode) {
    const longerEndIndex = longer.findIndex((data) => data.key === shorterEndNode.key);
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
__name(getExpandRange, "getExpandRange");

// packages/tree/src/NodeList.tsx
var HIDDEN_STYLE2 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop5 = /* @__PURE__ */ __name(() => {
}, "noop");
var MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
__name(getMinimumRangeTransitionRange, "getMinimumRangeTransitionRange");
function itemKey2(item) {
  const { key, pos } = item;
  return getKey3(key, pos);
}
__name(itemKey2, "itemKey");
function getAccessibilityPath(item) {
  let path2 = String(item.data.key);
  let current = item;
  while (current.parent) {
    current = current.parent;
    path2 = `${current.data.key} > ${path2}`;
  }
  return path2;
}
__name(getAccessibilityPath, "getAccessibilityPath");
var NodeList = React539.forwardRef((props, ref) => {
  const {
    prefixCls,
    data,
    selectable,
    checkable,
    expandedKeys,
    selectedKeys,
    checkedKeys,
    loadedKeys,
    loadingKeys,
    halfCheckedKeys,
    keyEntities,
    disabled,
    indentWidth,
    dragging,
    dragOverNodeKey,
    dropPosition,
    motion: motion2,
    height,
    itemHeight,
    virtual,
    focusable: focusable2,
    activeItem,
    focused,
    tabIndex,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    onActiveChange,
    onListChangeStart,
    onListChangeEnd,
    ...domProps
  } = props;
  const listRef = React539.useRef(null);
  const indentMeasurerRef = React539.useRef(null);
  React539.useImperativeHandle(ref, () => ({
    scrollTo: (scroll) => {
      listRef.current.scrollTo(scroll);
    },
    getIndentWidth: () => indentMeasurerRef.current.offsetWidth
  }));
  const [prevExpandedKeys, setPrevExpandedKeys] = React539.useState(expandedKeys);
  const [prevData, setPrevData] = React539.useState(data);
  const [transitionData, setTransitionData] = React539.useState(data);
  const [transitionRange, setTransitionRange] = React539.useState([]);
  const [motionType, setMotionType] = React539.useState(null);
  const dataRef = React539.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    const latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  __name(onMotionEnd, "onMotionEnd");
  useLayoutEffect_default(() => {
    setPrevExpandedKeys(expandedKeys);
    const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        const keyIndex2 = prevData.findIndex(({ key }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(
          getExpandRange(prevData, data, diffExpanded.key),
          virtual,
          height,
          itemHeight
        );
        const newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        const keyIndex2 = data.findIndex(({ key }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(
          getExpandRange(data, prevData, diffExpanded.key),
          virtual,
          height,
          itemHeight
        );
        const newTransitionData = data.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data) {
      setPrevData(data);
      setTransitionData(data);
    }
  }, [expandedKeys, data]);
  React539.useEffect(() => {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  const mergedData = motion2 ? transitionData : data;
  const treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return /* @__PURE__ */ React539.createElement(React539.Fragment, null, focused && activeItem && /* @__PURE__ */ React539.createElement("span", { style: HIDDEN_STYLE2, "aria-live": "assertive" }, getAccessibilityPath(activeItem)), /* @__PURE__ */ React539.createElement("div", null, /* @__PURE__ */ React539.createElement(
    "input",
    {
      style: HIDDEN_STYLE2,
      disabled: focusable2 === false || disabled,
      tabIndex: focusable2 !== false ? tabIndex : null,
      onKeyDown: onKeyDown2,
      onFocus,
      onBlur,
      value: "",
      onChange: noop5,
      "aria-label": "for screen reader"
    }
  )), /* @__PURE__ */ React539.createElement(
    "div",
    {
      className: `${prefixCls}-treenode`,
      "aria-hidden": true,
      style: {
        position: "absolute",
        pointerEvents: "none",
        visibility: "hidden",
        height: 0,
        overflow: "hidden",
        border: 0,
        padding: 0
      }
    },
    /* @__PURE__ */ React539.createElement("div", { className: `${prefixCls}-indent` }, /* @__PURE__ */ React539.createElement("div", { ref: indentMeasurerRef, className: `${prefixCls}-indent-unit` }))
  ), /* @__PURE__ */ React539.createElement(
    es_default5,
    {
      ...domProps,
      data: mergedData,
      itemKey: itemKey2,
      height,
      fullHeight: false,
      virtual,
      itemHeight,
      prefixCls: `${prefixCls}-list`,
      ref: listRef,
      onVisibleChange: (originList, fullList) => {
        const originSet = new Set(originList);
        const restList = fullList.filter((item) => !originSet.has(item));
        if (restList.some((item) => itemKey2(item) === MOTION_KEY)) {
          onMotionEnd();
        }
      }
    },
    (treeNode) => {
      const {
        pos,
        data: { ...restProps },
        title,
        key,
        isStart,
        isEnd
      } = treeNode;
      const mergedKey = getKey3(key, pos);
      delete restProps.key;
      delete restProps.children;
      const treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
      return /* @__PURE__ */ React539.createElement(
        MotionTreeNode_default,
        {
          ...restProps,
          ...treeNodeProps,
          title,
          active: !!activeItem && key === activeItem.key,
          pos,
          data: treeNode.data,
          isStart,
          isEnd,
          motion: motion2,
          indentWidth,
          motionNodes: key === MOTION_KEY ? transitionRange : null,
          motionType,
          onMotionStart: onListChangeStart,
          onMotionEnd,
          treeNodeRequiredProps,
          onMouseMove: () => {
            onActiveChange(null);
          }
        }
      );
    }
  ));
});
NodeList.displayName = "NodeList";
var NodeList_default = NodeList;

// packages/tree/src/Tree.tsx
var MAX_RETRY_TIMES = 10;
var Tree = class extends React540.Component {
  static {
    __name(this, "Tree");
  }
  static defaultProps = {
    prefixCls: "rc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator,
    allowDrop: () => true,
    expandAction: false
  };
  static TreeNode = TreeNode_default;
  destroyed = false;
  delayedDragEnterLogic;
  loadingRetryTimes = {};
  state = {
    keyEntities: {},
    indent: null,
    selectedKeys: [],
    checkedKeys: [],
    halfCheckedKeys: [],
    loadedKeys: [],
    loadingKeys: [],
    expandedKeys: [],
    draggingNodeKey: null,
    dragChildrenKeys: [],
    // dropTargetKey is the key of abstract-drop-node
    // the abstract-drop-node is the real drop node when drag and drop
    // not the DOM drag over node
    dropTargetKey: null,
    dropPosition: null,
    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
    dropContainerKey: null,
    // the container key of abstract-drop-node if dropPosition is -1 or 1
    dropLevelOffset: null,
    // the drop level offset of abstract-drag-over-node
    dropTargetPos: null,
    // the pos of abstract-drop-node
    dropAllowed: true,
    // if drop to abstract-drop-node is allowed
    // the abstract-drag-over-node
    // if mouse is on the bottom of top dom node or no the top of the bottom dom node
    // abstract-drag-over-node is the top node
    dragOverNodeKey: null,
    treeData: [],
    flattenNodes: [],
    focused: false,
    activeKey: null,
    listChanging: false,
    prevProps: null,
    fieldNames: fillFieldNames3()
  };
  dragStartMousePosition = null;
  dragNode;
  currentMouseOverDroppableNodeKey = null;
  listRef = React540.createRef();
  componentDidMount() {
    this.destroyed = false;
    this.onUpdated();
  }
  componentDidUpdate() {
    this.onUpdated();
  }
  onUpdated() {
    const { activeKey, itemScrollOffset = 0 } = this.props;
    if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
      this.setState({ activeKey });
      if (activeKey !== null) {
        this.scrollTo({ key: activeKey, offset: itemScrollOffset });
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("dragend", this.onWindowDragEnd);
    this.destroyed = true;
  }
  static getDerivedStateFromProps(props, prevState) {
    const { prevProps } = prevState;
    const newState = {
      prevProps: props
    };
    function needSync(name) {
      return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
    }
    __name(needSync, "needSync");
    let treeData;
    let { fieldNames } = prevState;
    if (needSync("fieldNames")) {
      fieldNames = fillFieldNames3(props.fieldNames);
      newState.fieldNames = fieldNames;
    }
    if (needSync("treeData")) {
      ({ treeData } = props);
    } else if (needSync("children")) {
      warning_default(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
      treeData = convertTreeToData(props.children);
    }
    if (treeData) {
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData, { fieldNames });
      newState.keyEntities = {
        [MOTION_KEY]: MotionEntity,
        ...entitiesMap.keyEntities
      };
      if (true) {
        warningWithoutKey(treeData, fieldNames);
      }
    }
    const keyEntities = newState.keyEntities || prevState.keyEntities;
    if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
    } else if (!prevProps && props.defaultExpandAll) {
      const cloneKeyEntities = { ...keyEntities };
      delete cloneKeyEntities[MOTION_KEY];
      newState.expandedKeys = Object.keys(cloneKeyEntities).map((key) => cloneKeyEntities[key].key);
    } else if (!prevProps && props.defaultExpandedKeys) {
      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
    }
    if (!newState.expandedKeys) {
      delete newState.expandedKeys;
    }
    if (treeData || newState.expandedKeys) {
      const flattenNodes = flattenTreeData(
        treeData || prevState.treeData,
        newState.expandedKeys || prevState.expandedKeys,
        fieldNames
      );
      newState.flattenNodes = flattenNodes;
    }
    if (props.selectable) {
      if (needSync("selectedKeys")) {
        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
      } else if (!prevProps && props.defaultSelectedKeys) {
        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
      }
    }
    if (props.checkable) {
      let checkedKeyEntity;
      if (needSync("checkedKeys")) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
      } else if (!prevProps && props.defaultCheckedKeys) {
        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
      } else if (treeData) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
          checkedKeys: prevState.checkedKeys,
          halfCheckedKeys: prevState.halfCheckedKeys
        };
      }
      if (checkedKeyEntity) {
        let { checkedKeys = [], halfCheckedKeys = [] } = checkedKeyEntity;
        if (!props.checkStrictly) {
          const conductKeys = conductCheck(checkedKeys, true, keyEntities);
          ({ checkedKeys, halfCheckedKeys } = conductKeys);
        }
        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
      }
    }
    if (needSync("loadedKeys")) {
      newState.loadedKeys = props.loadedKeys;
    }
    return newState;
  }
  onNodeDragStart = (event, node2) => {
    const { expandedKeys, keyEntities } = this.state;
    const { onDragStart } = this.props;
    const { eventKey } = node2.props;
    this.dragNode = node2;
    this.dragStartMousePosition = {
      x: event.clientX,
      y: event.clientY
    };
    const newExpandedKeys = arrDel(expandedKeys, eventKey);
    this.setState({
      draggingNodeKey: eventKey,
      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
      indent: this.listRef.current.getIndentWidth()
    });
    this.setExpandedKeys(newExpandedKeys);
    window.addEventListener("dragend", this.onWindowDragEnd);
    onDragStart?.({ event, node: convertNodePropsToEventData(node2.props) });
  };
  /**
   * [Legacy] Select handler is smaller than node,
   * so that this will trigger when drag enter node or select handler.
   * This is a little tricky if customize css without padding.
   * Better for use mouse move event to refresh drag state.
   * But let's just keep it to avoid event trigger logic change.
   */
  onNodeDragEnter = (event, node2) => {
    const { expandedKeys, keyEntities, dragChildrenKeys, flattenNodes, indent } = this.state;
    const { onDragEnter, onExpand, allowDrop, direction } = this.props;
    const { pos, eventKey } = node2.props;
    const { dragNode } = this;
    if (this.currentMouseOverDroppableNodeKey !== eventKey) {
      this.currentMouseOverDroppableNodeKey = eventKey;
    }
    if (!dragNode) {
      this.resetDragState();
      return;
    }
    const {
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropTargetPos,
      dropAllowed,
      dragOverNodeKey
    } = calcDropPosition(
      event,
      dragNode,
      node2,
      indent,
      this.dragStartMousePosition,
      allowDrop,
      flattenNodes,
      keyEntities,
      expandedKeys,
      direction
    );
    if (
      // don't allow drop inside its children
      dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
      !dropAllowed
    ) {
      this.resetDragState();
      return;
    }
    if (!this.delayedDragEnterLogic) {
      this.delayedDragEnterLogic = {};
    }
    Object.keys(this.delayedDragEnterLogic).forEach((key) => {
      clearTimeout(this.delayedDragEnterLogic[key]);
    });
    if (dragNode.props.eventKey !== node2.props.eventKey) {
      event.persist();
      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {
        if (this.state.draggingNodeKey === null)
          return;
        let newExpandedKeys = [...expandedKeys];
        const entity = getEntity(keyEntities, node2.props.eventKey);
        if (entity && (entity.children || []).length) {
          newExpandedKeys = arrAdd(expandedKeys, node2.props.eventKey);
        }
        if (!("expandedKeys" in this.props)) {
          this.setExpandedKeys(newExpandedKeys);
        }
        onExpand?.(newExpandedKeys, {
          node: convertNodePropsToEventData(node2.props),
          expanded: true,
          nativeEvent: event.nativeEvent
        });
      }, 800);
    }
    if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
      this.resetDragState();
      return;
    }
    this.setState({
      dragOverNodeKey,
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropTargetPos,
      dropAllowed
    });
    onDragEnter?.({
      event,
      node: convertNodePropsToEventData(node2.props),
      expandedKeys
    });
  };
  onNodeDragOver = (event, node2) => {
    const { dragChildrenKeys, flattenNodes, keyEntities, expandedKeys, indent } = this.state;
    const { onDragOver, allowDrop, direction } = this.props;
    const { dragNode } = this;
    if (!dragNode) {
      return;
    }
    const {
      dropPosition,
      dropLevelOffset,
      dropTargetKey,
      dropContainerKey,
      dropAllowed,
      dropTargetPos,
      dragOverNodeKey
    } = calcDropPosition(
      event,
      dragNode,
      node2,
      indent,
      this.dragStartMousePosition,
      allowDrop,
      flattenNodes,
      keyEntities,
      expandedKeys,
      direction
    );
    if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
      return;
    }
    if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {
        this.resetDragState();
      }
    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {
      this.setState({
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed,
        dragOverNodeKey
      });
    }
    onDragOver?.({ event, node: convertNodePropsToEventData(node2.props) });
  };
  onNodeDragLeave = (event, node2) => {
    if (this.currentMouseOverDroppableNodeKey === node2.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
      this.resetDragState();
      this.currentMouseOverDroppableNodeKey = null;
    }
    const { onDragLeave } = this.props;
    onDragLeave?.({ event, node: convertNodePropsToEventData(node2.props) });
  };
  // since stopPropagation() is called in treeNode
  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared
  onWindowDragEnd = (event) => {
    this.onNodeDragEnd(event, null, true);
    window.removeEventListener("dragend", this.onWindowDragEnd);
  };
  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called
  onNodeDragEnd = (event, node2) => {
    const { onDragEnd } = this.props;
    this.setState({
      dragOverNodeKey: null
    });
    this.cleanDragState();
    onDragEnd?.({ event, node: convertNodePropsToEventData(node2.props) });
    this.dragNode = null;
    window.removeEventListener("dragend", this.onWindowDragEnd);
  };
  onNodeDrop = (event, node2, outsideTree = false) => {
    const { dragChildrenKeys, dropPosition, dropTargetKey, dropTargetPos, dropAllowed } = this.state;
    if (!dropAllowed)
      return;
    const { onDrop } = this.props;
    this.setState({
      dragOverNodeKey: null
    });
    this.cleanDragState();
    if (dropTargetKey === null)
      return;
    const abstractDropNodeProps = {
      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),
      active: this.getActiveItem()?.key === dropTargetKey,
      data: getEntity(this.state.keyEntities, dropTargetKey).node
    };
    const dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
    warning_default(
      !dropToChild,
      "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue."
    );
    const posArr = posToArr(dropTargetPos);
    const dropResult = {
      event,
      node: convertNodePropsToEventData(abstractDropNodeProps),
      dragNode: this.dragNode ? convertNodePropsToEventData(this.dragNode.props) : null,
      dragNodesKeys: [this.dragNode.props.eventKey].concat(dragChildrenKeys),
      dropToGap: dropPosition !== 0,
      dropPosition: dropPosition + Number(posArr[posArr.length - 1])
    };
    if (!outsideTree) {
      onDrop?.(dropResult);
    }
    this.dragNode = null;
  };
  resetDragState() {
    this.setState({
      dragOverNodeKey: null,
      dropPosition: null,
      dropLevelOffset: null,
      dropTargetKey: null,
      dropContainerKey: null,
      dropTargetPos: null,
      dropAllowed: false
    });
  }
  cleanDragState = () => {
    const { draggingNodeKey } = this.state;
    if (draggingNodeKey !== null) {
      this.setState({
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: true,
        dragOverNodeKey: null
      });
    }
    this.dragStartMousePosition = null;
    this.currentMouseOverDroppableNodeKey = null;
  };
  triggerExpandActionExpand = (e3, treeNode) => {
    const { expandedKeys, flattenNodes } = this.state;
    const { expanded, key, isLeaf: isLeaf2 } = treeNode;
    if (isLeaf2 || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
      return;
    }
    const node2 = flattenNodes.filter((nodeItem) => nodeItem.key === key)[0];
    const eventNode = convertNodePropsToEventData({
      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),
      data: node2.data
    });
    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
    this.onNodeExpand(e3, eventNode);
  };
  onNodeClick = (e3, treeNode) => {
    const { onClick, expandAction } = this.props;
    if (expandAction === "click") {
      this.triggerExpandActionExpand(e3, treeNode);
    }
    onClick?.(e3, treeNode);
  };
  onNodeDoubleClick = (e3, treeNode) => {
    const { onDoubleClick, expandAction } = this.props;
    if (expandAction === "doubleClick") {
      this.triggerExpandActionExpand(e3, treeNode);
    }
    onDoubleClick?.(e3, treeNode);
  };
  onNodeSelect = (e3, treeNode) => {
    let { selectedKeys } = this.state;
    const { keyEntities, fieldNames } = this.state;
    const { onSelect, multiple } = this.props;
    const { selected } = treeNode;
    const key = treeNode[fieldNames.key];
    const targetSelected = !selected;
    if (!targetSelected) {
      selectedKeys = arrDel(selectedKeys, key);
    } else if (!multiple) {
      selectedKeys = [key];
    } else {
      selectedKeys = arrAdd(selectedKeys, key);
    }
    const selectedNodes = selectedKeys.map((selectedKey) => {
      const entity = getEntity(keyEntities, selectedKey);
      if (!entity)
        return null;
      return entity.node;
    }).filter((node2) => node2);
    this.setUncontrolledState({ selectedKeys });
    onSelect?.(selectedKeys, {
      event: "select",
      selected: targetSelected,
      node: treeNode,
      selectedNodes,
      nativeEvent: e3.nativeEvent
    });
  };
  onNodeCheck = (e3, treeNode, checked) => {
    const {
      keyEntities,
      checkedKeys: oriCheckedKeys,
      halfCheckedKeys: oriHalfCheckedKeys
    } = this.state;
    const { checkStrictly, onCheck } = this.props;
    const { key } = treeNode;
    let checkedObj;
    const eventObj = {
      event: "check",
      node: treeNode,
      checked,
      nativeEvent: e3.nativeEvent
    };
    if (checkStrictly) {
      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
      checkedObj = { checked: checkedKeys, halfChecked: halfCheckedKeys };
      eventObj.checkedNodes = checkedKeys.map((checkedKey) => getEntity(keyEntities, checkedKey)).filter((entity) => entity).map((entity) => entity.node);
      this.setUncontrolledState({ checkedKeys });
    } else {
      let { checkedKeys, halfCheckedKeys } = conductCheck(
        [...oriCheckedKeys, key],
        true,
        keyEntities
      );
      if (!checked) {
        const keySet = new Set(checkedKeys);
        keySet.delete(key);
        ({ checkedKeys, halfCheckedKeys } = conductCheck(
          Array.from(keySet),
          { checked: false, halfCheckedKeys },
          keyEntities
        ));
      }
      checkedObj = checkedKeys;
      eventObj.checkedNodes = [];
      eventObj.checkedNodesPositions = [];
      eventObj.halfCheckedKeys = halfCheckedKeys;
      checkedKeys.forEach((checkedKey) => {
        const entity = getEntity(keyEntities, checkedKey);
        if (!entity)
          return;
        const { node: node2, pos } = entity;
        eventObj.checkedNodes.push(node2);
        eventObj.checkedNodesPositions.push({ node: node2, pos });
      });
      this.setUncontrolledState(
        {
          checkedKeys
        },
        false,
        {
          halfCheckedKeys
        }
      );
    }
    onCheck?.(checkedObj, eventObj);
  };
  onNodeLoad = (treeNode) => {
    const { key } = treeNode;
    const loadPromise = new Promise((resolve, reject) => {
      this.setState(({ loadedKeys = [], loadingKeys = [] }) => {
        const { loadData, onLoad } = this.props;
        if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
          return null;
        }
        const promise = loadData(treeNode);
        promise.then(() => {
          const { loadedKeys: currentLoadedKeys } = this.state;
          const newLoadedKeys = arrAdd(currentLoadedKeys, key);
          onLoad?.(newLoadedKeys, {
            event: "load",
            node: treeNode
          });
          this.setUncontrolledState({
            loadedKeys: newLoadedKeys
          });
          this.setState((prevState) => ({
            loadingKeys: arrDel(prevState.loadingKeys, key)
          }));
          resolve();
        }).catch((e3) => {
          this.setState((prevState) => ({
            loadingKeys: arrDel(prevState.loadingKeys, key)
          }));
          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;
          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
            const { loadedKeys: currentLoadedKeys } = this.state;
            warning_default(false, "Retry for `loadData` many times but still failed. No more retry.");
            this.setUncontrolledState({
              loadedKeys: arrAdd(currentLoadedKeys, key)
            });
            resolve();
          }
          reject(e3);
        });
        return {
          loadingKeys: arrAdd(loadingKeys, key)
        };
      });
    });
    loadPromise.catch(() => {
    });
    return loadPromise;
  };
  onNodeMouseEnter = (event, node2) => {
    const { onMouseEnter } = this.props;
    onMouseEnter?.({ event, node: node2 });
  };
  onNodeMouseLeave = (event, node2) => {
    const { onMouseLeave } = this.props;
    onMouseLeave?.({ event, node: node2 });
  };
  onNodeContextMenu = (event, node2) => {
    const { onRightClick } = this.props;
    if (onRightClick) {
      event.preventDefault();
      onRightClick({ event, node: node2 });
    }
  };
  onFocus = (...args) => {
    const { onFocus } = this.props;
    this.setState({ focused: true });
    onFocus?.(...args);
  };
  onBlur = (...args) => {
    const { onBlur } = this.props;
    this.setState({ focused: false });
    this.onActiveChange(null);
    onBlur?.(...args);
  };
  getTreeNodeRequiredProps = () => {
    const {
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      dragOverNodeKey,
      dropPosition,
      keyEntities
    } = this.state;
    return {
      expandedKeys: expandedKeys || [],
      selectedKeys: selectedKeys || [],
      loadedKeys: loadedKeys || [],
      loadingKeys: loadingKeys || [],
      checkedKeys: checkedKeys || [],
      halfCheckedKeys: halfCheckedKeys || [],
      dragOverNodeKey,
      dropPosition,
      keyEntities
    };
  };
  // =========================== Expanded ===========================
  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
  setExpandedKeys = (expandedKeys) => {
    const { treeData, fieldNames } = this.state;
    const flattenNodes = flattenTreeData(
      treeData,
      expandedKeys,
      fieldNames
    );
    this.setUncontrolledState(
      {
        expandedKeys,
        flattenNodes
      },
      true
    );
  };
  onNodeExpand = (e3, treeNode) => {
    let { expandedKeys } = this.state;
    const { listChanging, fieldNames } = this.state;
    const { onExpand, loadData } = this.props;
    const { expanded } = treeNode;
    const key = treeNode[fieldNames.key];
    if (listChanging) {
      return;
    }
    const index3 = expandedKeys.indexOf(key);
    const targetExpanded = !expanded;
    warning_default(
      expanded && index3 !== -1 || !expanded && index3 === -1,
      "Expand state not sync with index check"
    );
    if (targetExpanded) {
      expandedKeys = arrAdd(expandedKeys, key);
    } else {
      expandedKeys = arrDel(expandedKeys, key);
    }
    this.setExpandedKeys(expandedKeys);
    onExpand?.(expandedKeys, {
      node: treeNode,
      expanded: targetExpanded,
      nativeEvent: e3.nativeEvent
    });
    if (targetExpanded && loadData) {
      const loadPromise = this.onNodeLoad(treeNode);
      if (loadPromise) {
        loadPromise.then(() => {
          const newFlattenTreeData = flattenTreeData(
            this.state.treeData,
            expandedKeys,
            fieldNames
          );
          this.setUncontrolledState({ flattenNodes: newFlattenTreeData });
        }).catch(() => {
          const { expandedKeys: currentExpandedKeys } = this.state;
          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);
          this.setExpandedKeys(expandedKeysToRestore);
        });
      }
    }
  };
  onListChangeStart = () => {
    this.setUncontrolledState({
      listChanging: true
    });
  };
  onListChangeEnd = () => {
    setTimeout(() => {
      this.setUncontrolledState({
        listChanging: false
      });
    });
  };
  // =========================== Keyboard ===========================
  onActiveChange = (newActiveKey) => {
    const { activeKey } = this.state;
    const { onActiveChange, itemScrollOffset = 0 } = this.props;
    if (activeKey === newActiveKey) {
      return;
    }
    this.setState({ activeKey: newActiveKey });
    if (newActiveKey !== null) {
      this.scrollTo({ key: newActiveKey, offset: itemScrollOffset });
    }
    onActiveChange?.(newActiveKey);
  };
  getActiveItem = () => {
    const { activeKey, flattenNodes } = this.state;
    if (activeKey === null) {
      return null;
    }
    return flattenNodes.find(({ key }) => key === activeKey) || null;
  };
  offsetActiveKey = (offset3) => {
    const { flattenNodes, activeKey } = this.state;
    let index3 = flattenNodes.findIndex(({ key }) => key === activeKey);
    if (index3 === -1 && offset3 < 0) {
      index3 = flattenNodes.length;
    }
    index3 = (index3 + offset3 + flattenNodes.length) % flattenNodes.length;
    const item = flattenNodes[index3];
    if (item) {
      const { key } = item;
      this.onActiveChange(key);
    } else {
      this.onActiveChange(null);
    }
  };
  onKeyDown = (event) => {
    const { activeKey, expandedKeys, checkedKeys, fieldNames } = this.state;
    const { onKeyDown: onKeyDown2, checkable, selectable } = this.props;
    switch (event.which) {
      case KeyCode_default.UP: {
        this.offsetActiveKey(-1);
        event.preventDefault();
        break;
      }
      case KeyCode_default.DOWN: {
        this.offsetActiveKey(1);
        event.preventDefault();
        break;
      }
    }
    const activeItem = this.getActiveItem();
    if (activeItem && activeItem.data) {
      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();
      const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
      const eventNode = convertNodePropsToEventData({
        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),
        data: activeItem.data,
        active: true
      });
      switch (event.which) {
        case KeyCode_default.LEFT: {
          if (expandable && expandedKeys.includes(activeKey)) {
            this.onNodeExpand({}, eventNode);
          } else if (activeItem.parent) {
            this.onActiveChange(activeItem.parent.key);
          }
          event.preventDefault();
          break;
        }
        case KeyCode_default.RIGHT: {
          if (expandable && !expandedKeys.includes(activeKey)) {
            this.onNodeExpand({}, eventNode);
          } else if (activeItem.children && activeItem.children.length) {
            this.onActiveChange(activeItem.children[0].key);
          }
          event.preventDefault();
          break;
        }
        case KeyCode_default.ENTER:
        case KeyCode_default.SPACE: {
          if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
            this.onNodeCheck(
              {},
              eventNode,
              !checkedKeys.includes(activeKey)
            );
          } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
            this.onNodeSelect({}, eventNode);
          }
          break;
        }
      }
    }
    onKeyDown2?.(event);
  };
  /**
   * Only update the value which is not in props
   */
  setUncontrolledState = (state, atomic = false, forceState = null) => {
    if (!this.destroyed) {
      let needSync = false;
      let allPassed = true;
      const newState = {};
      Object.keys(state).forEach((name) => {
        if (name in this.props) {
          allPassed = false;
          return;
        }
        needSync = true;
        newState[name] = state[name];
      });
      if (needSync && (!atomic || allPassed)) {
        this.setState({
          ...newState,
          ...forceState
        });
      }
    }
  };
  scrollTo = (scroll) => {
    this.listRef.current.scrollTo(scroll);
  };
  render() {
    const {
      focused,
      flattenNodes,
      keyEntities,
      draggingNodeKey,
      activeKey,
      dropLevelOffset,
      dropContainerKey,
      dropTargetKey,
      dropPosition,
      dragOverNodeKey,
      indent
    } = this.state;
    const {
      prefixCls,
      className,
      style: style2,
      showLine,
      focusable: focusable2,
      tabIndex = 0,
      selectable,
      showIcon,
      icon,
      indentWidth,
      switcherIcon,
      draggable,
      checkable,
      checkStrictly,
      disabled,
      motion: motion2,
      loadData,
      filterTreeNode,
      height,
      itemHeight,
      virtual,
      titleRender,
      dropIndicatorRender: dropIndicatorRender2,
      onContextMenu,
      onScroll,
      direction,
      rootClassName,
      rootStyle
    } = this.props;
    const domProps = pickAttrs(this.props, {
      aria: true,
      data: true
    });
    let draggableConfig;
    if (draggable) {
      if (typeof draggable === "object") {
        draggableConfig = draggable;
      } else if (typeof draggable === "function") {
        draggableConfig = {
          nodeDraggable: draggable
        };
      } else {
        draggableConfig = {};
      }
    }
    return /* @__PURE__ */ React540.createElement(
      TreeContext.Provider,
      {
        value: {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          indentWidth,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      },
      /* @__PURE__ */ React540.createElement(
        "div",
        {
          role: "tree",
          className: (0, import_classnames240.default)(prefixCls, className, rootClassName, {
            [`${prefixCls}-show-line`]: showLine,
            [`${prefixCls}-focused`]: focused,
            [`${prefixCls}-active-focused`]: activeKey !== null
          }),
          style: rootStyle
        },
        /* @__PURE__ */ React540.createElement(
          NodeList_default,
          {
            ref: this.listRef,
            prefixCls,
            style: style2,
            data: flattenNodes,
            disabled,
            selectable,
            checkable: !!checkable,
            indentWidth,
            motion: motion2,
            dragging: draggingNodeKey !== null,
            height,
            itemHeight,
            virtual,
            focusable: focusable2,
            focused,
            tabIndex,
            activeItem: this.getActiveItem(),
            onFocus: this.onFocus,
            onBlur: this.onBlur,
            onKeyDown: this.onKeyDown,
            onActiveChange: this.onActiveChange,
            onListChangeStart: this.onListChangeStart,
            onListChangeEnd: this.onListChangeEnd,
            onContextMenu,
            onScroll,
            ...this.getTreeNodeRequiredProps(),
            ...domProps
          }
        )
      )
    );
  }
};
var Tree_default = Tree;

// packages/tree/src/index.ts
var src_default28 = Tree_default;

// packages/ant-design/components/tree/DirectoryTree.tsx
var import_FileOutlined2 = __toESM(require_FileOutlined3());
var import_FolderOpenOutlined = __toESM(require_FolderOpenOutlined3());
var import_FolderOutlined = __toESM(require_FolderOutlined3());
var import_classnames243 = __toESM(require_classnames());
import * as React544 from "react";

// packages/ant-design/components/tree/Tree.tsx
var import_HolderOutlined = __toESM(require_HolderOutlined3());
var import_classnames242 = __toESM(require_classnames());
import React543 from "react";

// packages/ant-design/components/tree/style/index.ts
var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var getSwitchStyle = /* @__PURE__ */ __name((prefixCls, token2) => ({
  [`.${prefixCls}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${token2.motionDurationSlow}`
    }
  }
}), "getSwitchStyle");
var getDropIndicatorStyle = /* @__PURE__ */ __name((prefixCls, token2) => ({
  [`.${prefixCls}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token2.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${unit(token2.lineWidthBold)} solid ${token2.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
}), "getDropIndicatorStyle");
var genBaseStyle15 = /* @__PURE__ */ __name((prefixCls, token2) => {
  const { treeCls, treeNodeCls, treeNodePadding, titleHeight, nodeSelectedBg, nodeHoverBg } = token2;
  const treeCheckBoxMarginHorizontal = token2.paddingXS;
  return {
    [treeCls]: {
      ...resetComponent(token2),
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadius,
      transition: `background-color ${token2.motionDurationSlow}`,
      [`&${treeCls}-rtl`]: {
        // >>> Switcher
        [`${treeCls}-switcher`]: {
          "&_close": {
            [`${treeCls}-switcher-icon`]: {
              svg: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      },
      [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: {
        ...genFocusOutline(token2)
      },
      // =================== Virtual List ===================
      [`${treeCls}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${treeCls}-block-node`]: {
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${treeNodeCls}.dragging`]: {
            position: "relative",
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: treeNodePadding,
              insetInlineStart: 0,
              border: `1px solid ${token2.colorPrimary}`,
              opacity: 0,
              animationName: treeNodeFX,
              animationDuration: token2.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none"
            }
          }
        }
      },
      // ===================== TreeNode =====================
      [`${treeNodeCls}`]: {
        display: "flex",
        alignItems: "flex-start",
        padding: `0 0 ${unit(treeNodePadding)} 0`,
        outline: "none",
        "&-rtl": {
          direction: "rtl"
        },
        // Disabled
        "&-disabled": {
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          }
        },
        [`&-active ${treeCls}-node-content-wrapper`]: {
          background: token2.controlItemBgHover
        },
        [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
          color: "inherit",
          fontWeight: 500
        },
        "&-draggable": {
          cursor: "grab",
          [`${treeCls}-draggable-icon`]: {
            // https://github.com/ant-design/ant-design/issues/41915
            flexShrink: 0,
            width: titleHeight,
            lineHeight: `${unit(titleHeight)}`,
            textAlign: "center",
            visibility: "visible",
            opacity: 0.2,
            transition: `opacity ${token2.motionDurationSlow}`,
            [`${treeNodeCls}:hover &`]: {
              opacity: 0.45
            }
          },
          [`&${treeNodeCls}-disabled`]: {
            [`${treeCls}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        }
      },
      // >>> Indent
      [`${treeCls}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: titleHeight
        }
      },
      // >>> Drag Handler
      [`${treeCls}-draggable-icon`]: {
        visibility: "hidden"
      },
      // >>> Switcher
      [`${treeCls}-switcher`]: {
        ...getSwitchStyle(prefixCls, token2),
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: titleHeight,
        margin: 0,
        lineHeight: `${unit(titleHeight)}`,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        transition: `all ${token2.motionDurationSlow}`,
        borderRadius: token2.borderRadius,
        "&-noop": {
          cursor: "unset"
        },
        [`&:not(${treeCls}-switcher-noop):hover`]: {
          backgroundColor: token2.colorBgTextHover
        },
        "&_close": {
          [`${treeCls}-switcher-icon`]: {
            svg: {
              transform: "rotate(-90deg)"
            }
          }
        },
        "&-loading-icon": {
          color: token2.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
            bottom: token2.calc(treeNodePadding).mul(-1).equal(),
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: token2.calc(token2.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
            height: token2.calc(titleHeight).div(2).equal(),
            borderBottom: `1px solid ${token2.colorBorder}`,
            content: '""'
          }
        }
      },
      // >>> Checkbox
      [`${treeCls}-checkbox`]: {
        top: "initial",
        marginInlineEnd: treeCheckBoxMarginHorizontal,
        alignSelf: "flex-start",
        marginTop: token2.marginXXS
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${treeCls}-node-content-wrapper, ${treeCls}-checkbox + span`]: {
        position: "relative",
        zIndex: "auto",
        minHeight: titleHeight,
        margin: 0,
        padding: `0 ${unit(token2.calc(token2.paddingXS).div(2).equal())}`,
        color: "inherit",
        lineHeight: `${unit(titleHeight)}`,
        background: "transparent",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        "&:hover": {
          backgroundColor: nodeHoverBg
        },
        [`&${treeCls}-node-selected`]: {
          backgroundColor: nodeSelectedBg
        },
        // Icon
        [`${treeCls}-iconEle`]: {
          display: "inline-block",
          width: titleHeight,
          height: titleHeight,
          lineHeight: `${unit(titleHeight)}`,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      // ==================== Draggable =====================
      [`${treeCls}-node-content-wrapper`]: {
        lineHeight: `${unit(titleHeight)}`,
        userSelect: "none",
        ...getDropIndicatorStyle(prefixCls, token2)
      },
      [`${treeNodeCls}.drop-container`]: {
        "> [draggable]": {
          boxShadow: `0 0 0 2px ${token2.colorPrimary}`
        }
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${treeCls}-indent`]: {
          "&-unit": {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
              bottom: token2.calc(treeNodePadding).mul(-1).equal(),
              borderInlineEnd: `1px solid ${token2.colorBorder}`,
              content: '""'
            },
            "&-end": {
              "&:before": {
                display: "none"
              }
            }
          }
        },
        // ============== Cover Background ==============
        [`${treeCls}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${treeNodeCls}-leaf-last`]: {
        [`${treeCls}-switcher`]: {
          "&-leaf-line": {
            "&:before": {
              top: "auto !important",
              bottom: "auto !important",
              height: `${unit(token2.calc(titleHeight).div(2).equal())} !important`
            }
          }
        }
      }
    }
  };
}, "genBaseStyle");
var genDirectoryStyle = /* @__PURE__ */ __name((token2) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    directoryNodeSelectedBg,
    directoryNodeSelectedColor
  } = token2;
  return {
    [`${treeCls}${treeCls}-directory`]: {
      // ================== TreeNode ==================
      [treeNodeCls]: {
        position: "relative",
        // Hover color
        "&:before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: treeNodePadding,
          insetInlineStart: 0,
          transition: `background-color ${token2.motionDurationMid}`,
          content: '""',
          pointerEvents: "none"
        },
        "&:hover": {
          "&:before": {
            background: token2.controlItemBgHover
          }
        },
        // Elements
        "> *": {
          zIndex: 1
        },
        // >>> Switcher
        [`${treeCls}-switcher`]: {
          transition: `color ${token2.motionDurationMid}`
        },
        // >>> Title
        [`${treeCls}-node-content-wrapper`]: {
          borderRadius: 0,
          userSelect: "none",
          "&:hover": {
            background: "transparent"
          },
          [`&${treeCls}-node-selected`]: {
            color: directoryNodeSelectedColor,
            background: "transparent"
          }
        },
        // ============= Selected =============
        "&-selected": {
          [`
            &:hover::before,
            &::before
          `]: {
            background: directoryNodeSelectedBg
          },
          // >>> Switcher
          [`${treeCls}-switcher`]: {
            color: directoryNodeSelectedColor
          },
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            color: directoryNodeSelectedColor,
            background: "transparent"
          }
        }
      }
    }
  };
}, "genDirectoryStyle");
var genTreeStyle = /* @__PURE__ */ __name((prefixCls, token2) => {
  const treeCls = `.${prefixCls}`;
  const treeNodeCls = `${treeCls}-treenode`;
  const treeNodePadding = token2.calc(token2.paddingXS).div(2).equal();
  const treeToken = merge2(token2, {
    treeCls,
    treeNodeCls,
    treeNodePadding
  });
  return [
    // Basic
    genBaseStyle15(prefixCls, treeToken),
    // Directory
    genDirectoryStyle(treeToken)
  ];
}, "genTreeStyle");
var initComponentToken2 = /* @__PURE__ */ __name((token2) => {
  const { controlHeightSM } = token2;
  return {
    titleHeight: controlHeightSM,
    nodeHoverBg: token2.controlItemBgHover,
    nodeSelectedBg: token2.controlItemBgActive
  };
}, "initComponentToken");
var prepareComponentToken50 = /* @__PURE__ */ __name((token2) => {
  const { colorTextLightSolid, colorPrimary } = token2;
  return {
    ...initComponentToken2(token2),
    directoryNodeSelectedColor: colorTextLightSolid,
    directoryNodeSelectedBg: colorPrimary
  };
}, "prepareComponentToken");
var style_default56 = genStyleHooks(
  "Tree",
  (token2, { prefixCls }) => [
    {
      [token2.componentCls]: getStyle2(`${prefixCls}-checkbox`, token2)
    },
    genTreeStyle(prefixCls, token2),
    collapse_default(token2)
  ],
  prepareComponentToken50
);

// packages/ant-design/components/tree/utils/dropIndicator.tsx
import React541 from "react";
var offset2 = 4;
function dropIndicatorRender(props) {
  const { dropPosition, dropLevelOffset, prefixCls, indent, direction = "ltr" } = props;
  const startPosition = direction === "ltr" ? "left" : "right";
  const endPosition = direction === "ltr" ? "right" : "left";
  const style2 = {
    [startPosition]: -dropLevelOffset * indent + offset2,
    [endPosition]: 0
  };
  switch (dropPosition) {
    case -1:
      style2.top = -3;
      break;
    case 1:
      style2.bottom = -3;
      break;
    default:
      style2.bottom = -3;
      style2[startPosition] = indent + offset2;
      break;
  }
  return /* @__PURE__ */ React541.createElement("div", { style: style2, className: `${prefixCls}-drop-indicator` });
}
__name(dropIndicatorRender, "dropIndicatorRender");

// packages/ant-design/components/tree/utils/iconUtil.tsx
var import_CaretDownFilled = __toESM(require_CaretDownFilled3());
var import_FileOutlined = __toESM(require_FileOutlined3());
var import_LoadingOutlined7 = __toESM(require_LoadingOutlined3());
var import_MinusSquareOutlined = __toESM(require_MinusSquareOutlined3());
var import_PlusSquareOutlined = __toESM(require_PlusSquareOutlined3());
var import_classnames241 = __toESM(require_classnames());
import * as React542 from "react";
var SwitcherIconCom = /* @__PURE__ */ __name((props) => {
  const { prefixCls, switcherIcon, treeNodeProps, showLine } = props;
  const { isLeaf: isLeaf2, expanded, loading } = treeNodeProps;
  if (loading) {
    return /* @__PURE__ */ React542.createElement(import_LoadingOutlined7.default, { className: `${prefixCls}-switcher-loading-icon` });
  }
  let showLeafIcon;
  if (showLine && typeof showLine === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf2) {
    if (!showLine) {
      return null;
    }
    if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
      const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
      const leafCls = `${prefixCls}-switcher-line-custom-icon`;
      if (React542.isValidElement(leafIcon)) {
        return cloneElement3(leafIcon, {
          className: (0, import_classnames241.default)(leafIcon.props.className || "", leafCls)
        });
      }
      return leafIcon;
    }
    return showLeafIcon ? /* @__PURE__ */ React542.createElement(import_FileOutlined.default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ React542.createElement("span", { className: `${prefixCls}-switcher-leaf-line` });
  }
  const switcherCls = `${prefixCls}-switcher-icon`;
  const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  if (React542.isValidElement(switcher)) {
    return cloneElement3(switcher, {
      className: (0, import_classnames241.default)(switcher.props.className || "", switcherCls)
    });
  }
  if (switcher !== void 0) {
    return switcher;
  }
  if (showLine) {
    return expanded ? /* @__PURE__ */ React542.createElement(import_MinusSquareOutlined.default, { className: `${prefixCls}-switcher-line-icon` }) : /* @__PURE__ */ React542.createElement(import_PlusSquareOutlined.default, { className: `${prefixCls}-switcher-line-icon` });
  }
  return /* @__PURE__ */ React542.createElement(import_CaretDownFilled.default, { className: switcherCls });
}, "SwitcherIconCom");
var iconUtil_default = SwitcherIconCom;

// packages/ant-design/components/tree/Tree.tsx
var Tree2 = React543.forwardRef((props, ref) => {
  const { getPrefixCls, direction, virtual, tree } = React543.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = false,
    showLine,
    switcherIcon,
    blockNode = false,
    children,
    checkable = false,
    selectable = true,
    draggable,
    motion: customMotion,
    style: style2
  } = props;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const motion2 = customMotion ?? {
    ...motion_default(rootPrefixCls),
    motionAppear: false
  };
  const newProps = {
    ...props,
    checkable,
    selectable,
    showIcon,
    motion: motion2,
    blockNode,
    showLine: Boolean(showLine),
    dropIndicatorRender
  };
  const [wrapCSSVar, hashId, cssVarCls] = style_default56(prefixCls);
  const [, token2] = useToken();
  const itemHeight = token2.paddingXS / 2 + (token2.Tree?.titleHeight || token2.controlHeightSM);
  const draggableConfig = React543.useMemo(() => {
    if (!draggable) {
      return false;
    }
    let mergedDraggable = {};
    switch (typeof draggable) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = { ...draggable };
        break;
      default:
        break;
    }
    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ React543.createElement(import_HolderOutlined.default, null);
    }
    return mergedDraggable;
  }, [draggable]);
  const renderSwitcherIcon = /* @__PURE__ */ __name((nodeProps) => /* @__PURE__ */ React543.createElement(
    iconUtil_default,
    {
      prefixCls,
      switcherIcon,
      treeNodeProps: nodeProps,
      showLine
    }
  ), "renderSwitcherIcon");
  return wrapCSSVar(
    // @ts-ignore
    /* @__PURE__ */ React543.createElement(
      src_default28,
      {
        itemHeight,
        ref,
        virtual,
        ...newProps,
        style: { ...tree?.style, ...style2 },
        prefixCls,
        className: (0, import_classnames242.default)(
          {
            [`${prefixCls}-icon-hide`]: !showIcon,
            [`${prefixCls}-block-node`]: blockNode,
            [`${prefixCls}-unselectable`]: !selectable,
            [`${prefixCls}-rtl`]: direction === "rtl"
          },
          tree?.className,
          className,
          hashId,
          cssVarCls
        ),
        direction,
        checkable: checkable ? /* @__PURE__ */ React543.createElement("span", { className: `${prefixCls}-checkbox-inner` }) : checkable,
        selectable,
        switcherIcon: renderSwitcherIcon,
        draggable: draggableConfig
      },
      children
    )
  );
});
if (true) {
  Tree2.displayName = "Tree";
}
var Tree_default2 = Tree2;

// packages/ant-design/components/tree/utils/dictUtil.ts
var RECORD_NONE = 0;
var RECORD_START = 1;
var RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
  const { key: fieldKey, children: fieldChildren } = fieldNames;
  function processNode(dataNode) {
    const key = dataNode[fieldKey];
    const children = dataNode[fieldChildren];
    if (callback(key, dataNode) !== false) {
      traverseNodesKey(children || [], callback, fieldNames);
    }
  }
  __name(processNode, "processNode");
  treeData.forEach(processNode);
}
__name(traverseNodesKey, "traverseNodesKey");
function calcRangeKeys({
  treeData,
  expandedKeys,
  startKey,
  endKey,
  fieldNames
}) {
  const keys2 = [];
  let record = RECORD_NONE;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key) {
    return key === startKey || key === endKey;
  }
  __name(matchKey, "matchKey");
  traverseNodesKey(
    treeData,
    (key) => {
      if (record === RECORD_END) {
        return false;
      }
      if (matchKey(key)) {
        keys2.push(key);
        if (record === RECORD_NONE) {
          record = RECORD_START;
        } else if (record === RECORD_START) {
          record = RECORD_END;
          return false;
        }
      } else if (record === RECORD_START) {
        keys2.push(key);
      }
      return expandedKeys.includes(key);
    },
    fillFieldNames3(fieldNames)
  );
  return keys2;
}
__name(calcRangeKeys, "calcRangeKeys");
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  const restKeys = [...keys2];
  const nodes = [];
  traverseNodesKey(
    treeData,
    (key, node2) => {
      const index3 = restKeys.indexOf(key);
      if (index3 !== -1) {
        nodes.push(node2);
        restKeys.splice(index3, 1);
      }
      return !!restKeys.length;
    },
    fillFieldNames3(fieldNames)
  );
  return nodes;
}
__name(convertDirectoryKeysToNodes, "convertDirectoryKeysToNodes");

// packages/ant-design/components/tree/DirectoryTree.tsx
function getIcon(props) {
  const { isLeaf: isLeaf2, expanded } = props;
  if (isLeaf2) {
    return /* @__PURE__ */ React544.createElement(import_FileOutlined2.default, null);
  }
  return expanded ? /* @__PURE__ */ React544.createElement(import_FolderOpenOutlined.default, null) : /* @__PURE__ */ React544.createElement(import_FolderOutlined.default, null);
}
__name(getIcon, "getIcon");
function getTreeData({ treeData, children }) {
  return treeData || convertTreeToData(children);
}
__name(getTreeData, "getTreeData");
var DirectoryTree = /* @__PURE__ */ __name(({ defaultExpandAll, defaultExpandParent, defaultExpandedKeys, ...props }, ref) => {
  const lastSelectedKey = React544.useRef();
  const cachedSelectedKeys = React544.useRef();
  const getInitExpandedKeys = /* @__PURE__ */ __name(() => {
    const { keyEntities } = convertDataToEntities(getTreeData(props));
    let initExpandedKeys;
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(
        props.expandedKeys || defaultExpandedKeys || [],
        keyEntities
      );
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
    }
    return initExpandedKeys;
  }, "getInitExpandedKeys");
  const [selectedKeys, setSelectedKeys] = React544.useState(
    props.selectedKeys || props.defaultSelectedKeys || []
  );
  const [expandedKeys, setExpandedKeys] = React544.useState(() => getInitExpandedKeys());
  React544.useEffect(() => {
    if ("selectedKeys" in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  React544.useEffect(() => {
    if ("expandedKeys" in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  const onExpand = /* @__PURE__ */ __name((keys2, info) => {
    if (!("expandedKeys" in props)) {
      setExpandedKeys(keys2);
    }
    return props.onExpand?.(keys2, info);
  }, "onExpand");
  const onSelect = /* @__PURE__ */ __name((keys2, event) => {
    const { multiple, fieldNames } = props;
    const { node: node2, nativeEvent } = event;
    const { key = "" } = node2;
    const treeData = getTreeData(props);
    const newEvent = {
      ...event,
      selected: true
      // Directory selected always true
    };
    const ctrlPick = nativeEvent?.ctrlKey || nativeEvent?.metaKey;
    const shiftPick = nativeEvent?.shiftKey;
    let newSelectedKeys;
    if (multiple && ctrlPick) {
      newSelectedKeys = keys2;
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else if (multiple && shiftPick) {
      newSelectedKeys = Array.from(
        /* @__PURE__ */ new Set([
          ...cachedSelectedKeys.current || [],
          ...calcRangeKeys({
            treeData,
            expandedKeys,
            startKey: key,
            endKey: lastSelectedKey.current,
            fieldNames
          })
        ])
      );
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else {
      newSelectedKeys = [key];
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    }
    props.onSelect?.(newSelectedKeys, newEvent);
    if (!("selectedKeys" in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  }, "onSelect");
  const { getPrefixCls, direction } = React544.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = true,
    expandAction = "click",
    ...otherProps
  } = props;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const connectClassName = (0, import_classnames243.default)(
    `${prefixCls}-directory`,
    {
      [`${prefixCls}-directory-rtl`]: direction === "rtl"
    },
    className
  );
  return /* @__PURE__ */ React544.createElement(
    Tree_default2,
    {
      icon: getIcon,
      ref,
      blockNode: true,
      ...otherProps,
      showIcon,
      expandAction,
      prefixCls,
      className: connectClassName,
      expandedKeys,
      selectedKeys,
      onSelect,
      onExpand
    }
  );
}, "DirectoryTree");
var ForwardDirectoryTree = React544.forwardRef(
  DirectoryTree
);
if (true) {
  ForwardDirectoryTree.displayName = "DirectoryTree";
}
var DirectoryTree_default = ForwardDirectoryTree;

// packages/ant-design/components/tree/index.ts
var Tree3 = Tree_default2;
Tree3.DirectoryTree = DirectoryTree_default;
Tree3.TreeNode = TreeNode_default;
var tree_default = Tree3;

// packages/ant-design/components/table/hooks/useFilter/FilterSearch.tsx
var import_SearchOutlined3 = __toESM(require_SearchOutlined3());
import * as React545 from "react";
function FilterSearch({
  value,
  onChange,
  filterSearch,
  tablePrefixCls,
  locale: locale6
}) {
  if (!filterSearch) {
    return null;
  }
  return /* @__PURE__ */ React545.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-search` }, /* @__PURE__ */ React545.createElement(
    input_default,
    {
      prefix: /* @__PURE__ */ React545.createElement(import_SearchOutlined3.default, null),
      placeholder: locale6.filterSearchPlaceholder,
      onChange,
      value,
      htmlSize: 1,
      className: `${tablePrefixCls}-filter-dropdown-search-input`
    }
  ));
}
__name(FilterSearch, "FilterSearch");
var FilterSearch_default = FilterSearch;

// packages/ant-design/components/table/hooks/useFilter/FilterWrapper.tsx
import * as React546 from "react";
var onKeyDown = /* @__PURE__ */ __name((event) => {
  const { keyCode } = event;
  if (keyCode === KeyCode_default.ENTER) {
    event.stopPropagation();
  }
}, "onKeyDown");
var FilterDropdownMenuWrapper = React546.forwardRef(
  (props, ref) => /* @__PURE__ */ React546.createElement(
    "div",
    {
      className: props.className,
      onClick: (e3) => e3.stopPropagation(),
      onKeyDown,
      ref
    },
    props.children
  )
);
if (true) {
  FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
}
var FilterWrapper_default = FilterDropdownMenuWrapper;

// packages/ant-design/components/table/hooks/useFilter/FilterDropdown.tsx
function flattenKeys(filters) {
  let keys2 = [];
  (filters || []).forEach(({ value, children }) => {
    keys2.push(value);
    if (children) {
      keys2 = [...keys2, ...flattenKeys(children)];
    }
  });
  return keys2;
}
__name(flattenKeys, "flattenKeys");
function hasSubMenu(filters) {
  return filters.some(({ children }) => children);
}
__name(hasSubMenu, "hasSubMenu");
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text?.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
__name(searchValueMatched, "searchValueMatched");
function renderFilterItems({
  filters,
  prefixCls,
  filteredKeys,
  filterMultiple,
  searchValue,
  filterSearch
}) {
  return filters.map((filter3, index3) => {
    const key = String(filter3.value);
    if (filter3.children) {
      return {
        key: key || index3,
        label: filter3.text,
        popupClassName: `${prefixCls}-dropdown-submenu`,
        children: renderFilterItems({
          filters: filter3.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    }
    const Component11 = filterMultiple ? checkbox_default : radio_default2;
    const item = {
      key: filter3.value !== void 0 ? key : index3,
      label: /* @__PURE__ */ React547.createElement(React547.Fragment, null, /* @__PURE__ */ React547.createElement(Component11, { checked: filteredKeys.includes(key) }), /* @__PURE__ */ React547.createElement("span", null, filter3.text))
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter3) ? item : null;
      }
      return searchValueMatched(searchValue, filter3.text) ? item : null;
    }
    return item;
  });
}
__name(renderFilterItems, "renderFilterItems");
function wrapStringListType(keys2) {
  return keys2 || [];
}
__name(wrapStringListType, "wrapStringListType");
function FilterDropdown(props) {
  const {
    tablePrefixCls,
    prefixCls,
    column: column2,
    dropdownPrefixCls,
    columnKey,
    filterOnClose,
    filterMultiple,
    filterMode = "menu",
    filterSearch = false,
    filterState,
    triggerFilter,
    locale: locale6,
    children,
    getPopupContainer,
    rootClassName
  } = props;
  const {
    filterDropdownOpen,
    onFilterDropdownOpenChange,
    filterResetToDefaultFilteredValue,
    defaultFilteredValue,
    // Deprecated
    filterDropdownVisible,
    onFilterDropdownVisibleChange
  } = column2;
  const [visible, setVisible] = React547.useState(false);
  const filtered = !!(filterState && (filterState.filteredKeys?.length || filterState.forceFiltered));
  const triggerVisible = /* @__PURE__ */ __name((newVisible) => {
    setVisible(newVisible);
    onFilterDropdownOpenChange?.(newVisible);
    onFilterDropdownVisibleChange?.(newVisible);
  }, "triggerVisible");
  if (true) {
    const warning5 = devUseWarning("Table");
    [
      ["filterDropdownVisible", "filterDropdownOpen", filterDropdownVisible],
      [
        "onFilterDropdownVisibleChange",
        "onFilterDropdownOpenChange",
        onFilterDropdownVisibleChange
      ]
    ].forEach(([deprecatedName, newName, prop]) => {
      warning5.deprecated(
        prop === void 0 || prop === null,
        deprecatedName,
        newName
      );
    });
  }
  const mergedVisible = filterDropdownOpen ?? filterDropdownVisible ?? visible;
  const propFilteredKeys = filterState?.filteredKeys;
  const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState3(
    wrapStringListType(propFilteredKeys)
  );
  const onSelectKeys = /* @__PURE__ */ __name(({ selectedKeys }) => {
    setFilteredKeysSync(selectedKeys);
  }, "onSelectKeys");
  const onCheck = /* @__PURE__ */ __name((keys2, { node: node2, checked }) => {
    if (!filterMultiple) {
      onSelectKeys({ selectedKeys: checked && node2.key ? [node2.key] : [] });
    } else {
      onSelectKeys({ selectedKeys: keys2 });
    }
  }, "onCheck");
  React547.useEffect(() => {
    if (!visible) {
      return;
    }
    onSelectKeys({ selectedKeys: wrapStringListType(propFilteredKeys) });
  }, [propFilteredKeys]);
  const [openKeys, setOpenKeys] = React547.useState([]);
  const onOpenChange = /* @__PURE__ */ __name((keys2) => {
    setOpenKeys(keys2);
  }, "onOpenChange");
  const [searchValue, setSearchValue] = React547.useState("");
  const onSearch = /* @__PURE__ */ __name((e3) => {
    const { value } = e3.target;
    setSearchValue(value);
  }, "onSearch");
  React547.useEffect(() => {
    if (!visible) {
      setSearchValue("");
    }
  }, [visible]);
  const internalTriggerFilter = /* @__PURE__ */ __name((keys2) => {
    const mergedKeys = keys2 && keys2.length ? keys2 : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (isEqual_default(mergedKeys, filterState?.filteredKeys, true)) {
      return null;
    }
    triggerFilter({
      column: column2,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  }, "internalTriggerFilter");
  const onConfirm = /* @__PURE__ */ __name(() => {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  }, "onConfirm");
  const onReset = /* @__PURE__ */ __name(({ confirm: confirm2, closeDropdown } = { confirm: false, closeDropdown: false }) => {
    if (confirm2) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue("");
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
    } else {
      setFilteredKeysSync([]);
    }
  }, "onReset");
  const doFilter = /* @__PURE__ */ __name(({ closeDropdown } = { closeDropdown: true }) => {
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  }, "doFilter");
  const onVisibleChange = /* @__PURE__ */ __name((newVisible, info) => {
    if (info.source === "trigger") {
      if (newVisible && propFilteredKeys !== void 0) {
        setFilteredKeysSync(wrapStringListType(propFilteredKeys));
      }
      triggerVisible(newVisible);
      if (!newVisible && !column2.filterDropdown && filterOnClose) {
        onConfirm();
      }
    }
  }, "onVisibleChange");
  const dropdownMenuClass = (0, import_classnames244.default)({
    [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
  });
  const onCheckAll = /* @__PURE__ */ __name((e3) => {
    if (e3.target.checked) {
      const allFilterKeys = flattenKeys(column2?.filters).map((key) => String(key));
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  }, "onCheckAll");
  const getTreeData2 = /* @__PURE__ */ __name(({ filters }) => (filters || []).map((filter3, index3) => {
    const key = String(filter3.value);
    const item = {
      title: filter3.text,
      key: filter3.value !== void 0 ? key : String(index3)
    };
    if (filter3.children) {
      item.children = getTreeData2({ filters: filter3.children });
    }
    return item;
  }), "getTreeData");
  const getFilterData2 = /* @__PURE__ */ __name((node2) => ({
    ...node2,
    text: node2.title,
    value: node2.key,
    children: node2.children?.map((item) => getFilterData2(item)) || []
  }), "getFilterData");
  let dropdownContent;
  if (typeof column2.filterDropdown === "function") {
    dropdownContent = column2.filterDropdown({
      prefixCls: `${dropdownPrefixCls}-custom`,
      setSelectedKeys: (selectedKeys) => onSelectKeys({ selectedKeys }),
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column2.filters,
      visible: mergedVisible,
      close: () => {
        triggerVisible(false);
      }
    });
  } else if (column2.filterDropdown) {
    dropdownContent = column2.filterDropdown;
  } else {
    const selectedKeys = getFilteredKeysSync() || [];
    const getFilterComponent = /* @__PURE__ */ __name(() => {
      const empty2 = /* @__PURE__ */ React547.createElement(
        empty_default2,
        {
          image: empty_default2.PRESENTED_IMAGE_SIMPLE,
          description: locale6.filterEmptyText,
          imageStyle: {
            height: 24
          },
          style: {
            margin: 0,
            padding: "16px 0"
          }
        }
      );
      if ((column2.filters || []).length === 0) {
        return empty2;
      }
      if (filterMode === "tree") {
        return /* @__PURE__ */ React547.createElement(React547.Fragment, null, /* @__PURE__ */ React547.createElement(
          FilterSearch_default,
          {
            filterSearch,
            value: searchValue,
            onChange: onSearch,
            tablePrefixCls,
            locale: locale6
          }
        ), /* @__PURE__ */ React547.createElement("div", { className: `${tablePrefixCls}-filter-dropdown-tree` }, filterMultiple ? /* @__PURE__ */ React547.createElement(
          checkbox_default,
          {
            checked: selectedKeys.length === flattenKeys(column2.filters).length,
            indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column2.filters).length,
            className: `${tablePrefixCls}-filter-dropdown-checkall`,
            onChange: onCheckAll
          },
          locale6.filterCheckall
        ) : null, /* @__PURE__ */ React547.createElement(
          tree_default,
          {
            checkable: true,
            selectable: false,
            blockNode: true,
            multiple: filterMultiple,
            checkStrictly: !filterMultiple,
            className: `${dropdownPrefixCls}-menu`,
            onCheck,
            checkedKeys: selectedKeys,
            selectedKeys,
            showIcon: false,
            treeData: getTreeData2({ filters: column2.filters }),
            autoExpandParent: true,
            defaultExpandAll: true,
            filterTreeNode: searchValue.trim() ? (node2) => {
              if (typeof filterSearch === "function") {
                return filterSearch(searchValue, getFilterData2(node2));
              }
              return searchValueMatched(searchValue, node2.title);
            } : void 0
          }
        )));
      }
      const items = renderFilterItems({
        filters: column2.filters || [],
        filterSearch,
        prefixCls,
        filteredKeys: getFilteredKeysSync(),
        filterMultiple,
        searchValue
      });
      const isEmpty2 = items.every((item) => item === null);
      return /* @__PURE__ */ React547.createElement(React547.Fragment, null, /* @__PURE__ */ React547.createElement(
        FilterSearch_default,
        {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale6
        }
      ), isEmpty2 ? empty2 : /* @__PURE__ */ React547.createElement(
        menu_default2,
        {
          selectable: true,
          multiple: filterMultiple,
          prefixCls: `${dropdownPrefixCls}-menu`,
          className: dropdownMenuClass,
          onSelect: onSelectKeys,
          onDeselect: onSelectKeys,
          selectedKeys,
          getPopupContainer,
          openKeys,
          onOpenChange,
          items
        }
      ));
    }, "getFilterComponent");
    const getResetDisabled = /* @__PURE__ */ __name(() => {
      if (filterResetToDefaultFilteredValue) {
        return isEqual_default(
          (defaultFilteredValue || []).map((key) => String(key)),
          selectedKeys,
          true
        );
      }
      return selectedKeys.length === 0;
    }, "getResetDisabled");
    dropdownContent = /* @__PURE__ */ React547.createElement(React547.Fragment, null, getFilterComponent(), /* @__PURE__ */ React547.createElement("div", { className: `${prefixCls}-dropdown-btns` }, /* @__PURE__ */ React547.createElement(button_default2, { type: "link", size: "small", disabled: getResetDisabled(), onClick: () => onReset() }, locale6.filterReset), /* @__PURE__ */ React547.createElement(button_default2, { type: "primary", size: "small", onClick: onConfirm }, locale6.filterConfirm)));
  }
  if (column2.filterDropdown) {
    dropdownContent = /* @__PURE__ */ React547.createElement(OverrideProvider, { selectable: void 0 }, dropdownContent);
  }
  const menu = /* @__PURE__ */ __name(() => /* @__PURE__ */ React547.createElement(FilterWrapper_default, { className: `${prefixCls}-dropdown` }, dropdownContent), "menu");
  let filterIcon;
  if (typeof column2.filterIcon === "function") {
    filterIcon = column2.filterIcon(filtered);
  } else if (column2.filterIcon) {
    filterIcon = column2.filterIcon;
  } else {
    filterIcon = /* @__PURE__ */ React547.createElement(import_FilterFilled.default, null);
  }
  const { direction } = React547.useContext(ConfigContext);
  return /* @__PURE__ */ React547.createElement("div", { className: `${prefixCls}-column` }, /* @__PURE__ */ React547.createElement("span", { className: `${tablePrefixCls}-column-title` }, children), /* @__PURE__ */ React547.createElement(
    dropdown_default3,
    {
      dropdownRender: menu,
      trigger: ["click"],
      open: mergedVisible,
      onOpenChange: onVisibleChange,
      getPopupContainer,
      placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
      rootClassName
    },
    /* @__PURE__ */ React547.createElement(
      "span",
      {
        role: "button",
        tabIndex: -1,
        className: (0, import_classnames244.default)(`${prefixCls}-trigger`, {
          active: filtered
        }),
        onClick: (e3) => {
          e3.stopPropagation();
        }
      },
      filterIcon
    )
  ));
}
__name(FilterDropdown, "FilterDropdown");
var FilterDropdown_default = FilterDropdown;

// packages/ant-design/components/table/hooks/useFilter/index.tsx
function collectFilterStates(columns, init, pos) {
  let filterStates = [];
  (columns || []).forEach((column2, index3) => {
    const columnPos = getColumnPos(index3, pos);
    if (column2.filters || "filterDropdown" in column2 || "onFilter" in column2) {
      if ("filteredValue" in column2) {
        let filteredValues = column2.filteredValue;
        if (!("filterDropdown" in column2)) {
          filteredValues = filteredValues?.map(String) ?? filteredValues;
        }
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column2.filtered
        });
      } else {
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
          forceFiltered: column2.filtered
        });
      }
    }
    if ("children" in column2) {
      filterStates = [...filterStates, ...collectFilterStates(column2.children, init, columnPos)];
    }
  });
  return filterStates;
}
__name(collectFilterStates, "collectFilterStates");
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale6, triggerFilter, getPopupContainer, pos, rootClassName) {
  return columns.map((column2, index3) => {
    const columnPos = getColumnPos(index3, pos);
    const {
      filterOnClose = true,
      filterMultiple = true,
      filterMode,
      filterSearch
    } = column2;
    let newColumn = column2;
    if (newColumn.filters || newColumn.filterDropdown) {
      const columnKey = getColumnKey(newColumn, columnPos);
      const filterState = filterStates.find(({ key }) => columnKey === key);
      newColumn = {
        ...newColumn,
        title: (renderProps) => /* @__PURE__ */ React548.createElement(
          FilterDropdown_default,
          {
            tablePrefixCls: prefixCls,
            prefixCls: `${prefixCls}-filter`,
            dropdownPrefixCls,
            column: newColumn,
            columnKey,
            filterState,
            filterOnClose,
            filterMultiple,
            filterMode,
            filterSearch,
            triggerFilter,
            locale: locale6,
            getPopupContainer,
            rootClassName
          },
          renderColumnTitle(column2.title, renderProps)
        )
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectFilter(
          prefixCls,
          dropdownPrefixCls,
          newColumn.children,
          filterStates,
          locale6,
          triggerFilter,
          getPopupContainer,
          columnPos,
          rootClassName
        )
      };
    }
    return newColumn;
  });
}
__name(injectFilter, "injectFilter");
function generateFilterInfo(filterStates) {
  const currentFilters = {};
  filterStates.forEach(({ key, filteredKeys, column: column2 }) => {
    const keyAsString = key;
    const { filters, filterDropdown } = column2;
    if (filterDropdown) {
      currentFilters[keyAsString] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      const keys2 = flattenKeys(filters);
      currentFilters[keyAsString] = keys2.filter(
        (originKey) => filteredKeys.includes(String(originKey))
      );
    } else {
      currentFilters[keyAsString] = null;
    }
  });
  return currentFilters;
}
__name(generateFilterInfo, "generateFilterInfo");
function getFilterData(data, filterStates, childrenColumnName) {
  return filterStates.reduce((currentData, filterState) => {
    const {
      column: { onFilter, filters },
      filteredKeys
    } = filterState;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.map((record) => ({ ...record })).filter(
        (record) => filteredKeys.some((key) => {
          const keys2 = flattenKeys(filters);
          const keyIndex2 = keys2.findIndex((k) => String(k) === String(key));
          const realKey = keyIndex2 !== -1 ? keys2[keyIndex2] : key;
          if (record[childrenColumnName]) {
            record[childrenColumnName] = getFilterData(
              record[childrenColumnName],
              filterStates,
              childrenColumnName
            );
          }
          return onFilter(realKey, record);
        })
      );
    }
    return currentData;
  }, data);
}
__name(getFilterData, "getFilterData");
var getMergedColumns = /* @__PURE__ */ __name((rawMergedColumns) => rawMergedColumns.flatMap((column2) => {
  if ("children" in column2) {
    return [column2, ...getMergedColumns(column2.children || [])];
  }
  return [column2];
}), "getMergedColumns");
function useFilter({
  prefixCls,
  dropdownPrefixCls,
  mergedColumns: rawMergedColumns,
  onFilterChange,
  getPopupContainer,
  locale: tableLocale,
  rootClassName
}) {
  const warning5 = devUseWarning("Table");
  const mergedColumns = React548.useMemo(
    () => getMergedColumns(rawMergedColumns || []),
    [rawMergedColumns]
  );
  const [filterStates, setFilterStates] = React548.useState(
    () => collectFilterStates(mergedColumns, true)
  );
  const mergedFilterStates = React548.useMemo(() => {
    const collectedStates = collectFilterStates(mergedColumns, false);
    if (collectedStates.length === 0) {
      return collectedStates;
    }
    let filteredKeysIsAllNotControlled = true;
    let filteredKeysIsAllControlled = true;
    collectedStates.forEach(({ filteredKeys }) => {
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      } else {
        filteredKeysIsAllControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      const keyList = (mergedColumns || []).map(
        (column2, index3) => getColumnKey(column2, getColumnPos(index3))
      );
      return filterStates.filter(({ key }) => keyList.includes(key)).map((item) => {
        const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
        return {
          ...item,
          column: {
            ...item.column,
            ...col
          },
          forceFiltered: col.filtered
        };
      });
    }
    warning5(
      filteredKeysIsAllControlled,
      "usage",
      "Columns should all contain `filteredValue` or not contain `filteredValue`."
    );
    return collectedStates;
  }, [mergedColumns, filterStates]);
  const filters = React548.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
  const triggerFilter = /* @__PURE__ */ __name((filterState) => {
    const newFilterStates = mergedFilterStates.filter(({ key }) => key !== filterState.key);
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  }, "triggerFilter");
  const transformColumns = /* @__PURE__ */ __name((innerColumns) => injectFilter(
    prefixCls,
    dropdownPrefixCls,
    innerColumns,
    mergedFilterStates,
    tableLocale,
    triggerFilter,
    getPopupContainer,
    void 0,
    rootClassName
  ), "transformColumns");
  return [transformColumns, mergedFilterStates, filters];
}
__name(useFilter, "useFilter");
var useFilter_default = useFilter;

// packages/ant-design/components/table/hooks/useLazyKVMap.ts
import * as React549 from "react";
function useLazyKVMap(data, childrenColumnName, getRowKey) {
  const mapCacheRef = React549.useRef({});
  function getRecordByKey(key) {
    if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig2 = function(records) {
        records.forEach((record, index3) => {
          const rowKey = getRowKey(record, index3);
          kvMap.set(rowKey, record);
          if (record && typeof record === "object" && childrenColumnName in record) {
            dig2(record[childrenColumnName] || []);
          }
        });
      };
      var dig = dig2;
      __name(dig2, "dig");
      const kvMap = /* @__PURE__ */ new Map();
      dig2(data);
      mapCacheRef.current = {
        data,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return mapCacheRef.current.kvMap.get(key);
  }
  __name(getRecordByKey, "getRecordByKey");
  return [getRecordByKey];
}
__name(useLazyKVMap, "useLazyKVMap");

// packages/ant-design/components/table/hooks/usePagination.ts
import { useState as useState134 } from "react";
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
  const param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  Object.keys(paginationObj).forEach((pageProp) => {
    const value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
__name(getPaginationParam, "getPaginationParam");
function usePagination(total, onChange, pagination) {
  const { total: paginationTotal = 0, ...paginationObj } = pagination && typeof pagination === "object" ? pagination : {};
  const [innerPagination, setInnerPagination] = useState134(
    () => ({
      current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
      pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
    })
  );
  const mergedPagination = extendsObject_default(
    innerPagination,
    paginationObj,
    {
      total: paginationTotal > 0 ? paginationTotal : total
    }
  );
  const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    mergedPagination.current = maxPage || 1;
  }
  const refreshPagination = /* @__PURE__ */ __name((current, pageSize) => {
    setInnerPagination({
      current: current ?? 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  }, "refreshPagination");
  const onInternalChange = /* @__PURE__ */ __name((current, pageSize) => {
    if (pagination) {
      pagination.onChange?.(current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange(current, pageSize || mergedPagination?.pageSize);
  }, "onInternalChange");
  if (pagination === false) {
    return [{}, () => {
    }];
  }
  return [
    {
      ...mergedPagination,
      onChange: onInternalChange
    },
    refreshPagination
  ];
}
__name(usePagination, "usePagination");
var usePagination_default = usePagination;

// packages/ant-design/components/table/hooks/useSorter.tsx
var import_CaretDownOutlined = __toESM(require_CaretDownOutlined3());
var import_CaretUpOutlined = __toESM(require_CaretUpOutlined3());
var import_classnames245 = __toESM(require_classnames());
import * as React550 from "react";
var ASCEND = "ascend";
var DESCEND = "descend";
function getMultiplePriority(column2) {
  if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
    return column2.sorter.multiple;
  }
  return false;
}
__name(getMultiplePriority, "getMultiplePriority");
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && typeof sorter === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
__name(getSortFunction, "getSortFunction");
function nextSortDirection(sortDirections, current) {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
}
__name(nextSortDirection, "nextSortDirection");
function collectSortStates(columns, init, pos) {
  let sortStates = [];
  function pushState(column2, columnPos) {
    sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.sortOrder
    });
  }
  __name(pushState, "pushState");
  (columns || []).forEach((column2, index3) => {
    const columnPos = getColumnPos(index3, pos);
    if (column2.children) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      }
      sortStates = [
        ...sortStates,
        ...collectSortStates(column2.children, init, columnPos)
      ];
    } else if (column2.sorter) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      } else if (init && column2.defaultSortOrder) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
__name(collectSortStates, "collectSortStates");
function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns || []).map((column2, index3) => {
    const columnPos = getColumnPos(index3, pos);
    let newColumn = column2;
    if (newColumn.sorter) {
      const sortDirections = newColumn.sortDirections || defaultSortDirections;
      const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      const columnKey = getColumnKey(newColumn, columnPos);
      const sorterState = sorterStates.find(({ key }) => key === columnKey);
      const sortOrder = sorterState ? sorterState.sortOrder : null;
      const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
      let sorter;
      if (column2.sortIcon) {
        sorter = column2.sortIcon({ sortOrder });
      } else {
        const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ React550.createElement(
          import_CaretUpOutlined.default,
          {
            className: (0, import_classnames245.default)(`${prefixCls}-column-sorter-up`, {
              active: sortOrder === ASCEND
            })
          }
        );
        const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ React550.createElement(
          import_CaretDownOutlined.default,
          {
            className: (0, import_classnames245.default)(`${prefixCls}-column-sorter-down`, {
              active: sortOrder === DESCEND
            })
          }
        );
        sorter = /* @__PURE__ */ React550.createElement(
          "span",
          {
            className: (0, import_classnames245.default)(`${prefixCls}-column-sorter`, {
              [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
            })
          },
          /* @__PURE__ */ React550.createElement("span", { className: `${prefixCls}-column-sorter-inner`, "aria-hidden": "true" }, upNode, downNode)
        );
      }
      const { cancelSort, triggerAsc, triggerDesc } = tableLocale || {};
      let sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      const tooltipProps = typeof showSorterTooltip === "object" ? {
        title: sortTip,
        ...showSorterTooltip
      } : { title: sortTip };
      newColumn = {
        ...newColumn,
        className: (0, import_classnames245.default)(newColumn.className, { [`${prefixCls}-column-sort`]: sortOrder }),
        title: (renderProps) => {
          const columnSortersClass = `${prefixCls}-column-sorters`;
          const renderColumnTitleWrapper = /* @__PURE__ */ React550.createElement("span", { className: `${prefixCls}-column-title` }, renderColumnTitle(column2.title, renderProps));
          const renderSortTitle = /* @__PURE__ */ React550.createElement("div", { className: columnSortersClass }, renderColumnTitleWrapper, sorter);
          if (showSorterTooltip) {
            if (typeof showSorterTooltip !== "boolean" && showSorterTooltip?.target === "sorter-icon") {
              return /* @__PURE__ */ React550.createElement(
                "div",
                {
                  className: `${columnSortersClass} ${prefixCls}-column-sorters-tooltip-target-sorter`
                },
                renderColumnTitleWrapper,
                /* @__PURE__ */ React550.createElement(tooltip_default, { ...tooltipProps }, sorter)
              );
            }
            return /* @__PURE__ */ React550.createElement(tooltip_default, { ...tooltipProps }, renderSortTitle);
          }
          return renderSortTitle;
        },
        onHeaderCell: (col) => {
          const cell = column2.onHeaderCell && column2.onHeaderCell(col) || {};
          const originOnClick = cell.onClick;
          const originOKeyDown = cell.onKeyDown;
          cell.onClick = (event) => {
            triggerSorter({
              column: column2,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column2)
            });
            originOnClick?.(event);
          };
          cell.onKeyDown = (event) => {
            if (event.keyCode === KeyCode_default.ENTER) {
              triggerSorter({
                column: column2,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column2)
              });
              originOKeyDown?.(event);
            }
          };
          const renderTitle = safeColumnTitle(column2.title, {});
          const displayTitle = renderTitle?.toString();
          if (sortOrder) {
            cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
          } else {
            cell["aria-label"] = displayTitle || "";
          }
          cell.className = (0, import_classnames245.default)(cell.className, `${prefixCls}-column-has-sorters`);
          cell.tabIndex = 0;
          if (column2.ellipsis) {
            cell.title = (renderTitle ?? "").toString();
          }
          return cell;
        }
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectSorter(
          prefixCls,
          newColumn.children,
          sorterStates,
          triggerSorter,
          defaultSortDirections,
          tableLocale,
          tableShowSorterTooltip,
          columnPos
        )
      };
    }
    return newColumn;
  });
}
__name(injectSorter, "injectSorter");
var stateToInfo = /* @__PURE__ */ __name((sorterStates) => {
  const { column: column2, sortOrder } = sorterStates;
  return {
    column: column2,
    order: sortOrder,
    field: column2.dataIndex,
    columnKey: column2.key
  };
}, "stateToInfo");
var generateSorterInfo = /* @__PURE__ */ __name((sorterStates) => {
  const list = sorterStates.filter(({ sortOrder }) => sortOrder).map(stateToInfo);
  if (list.length === 0 && sorterStates.length) {
    const lastIndex = sorterStates.length - 1;
    return {
      ...stateToInfo(sorterStates[lastIndex]),
      column: void 0
    };
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}, "generateSorterInfo");
function getSortData(data, sortStates, childrenColumnName) {
  const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
  const cloneData = data.slice();
  const runningSorters = innerSorterStates.filter(
    ({ column: { sorter }, sortOrder }) => getSortFunction(sorter) && sortOrder
  );
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort((record1, record2) => {
    for (let i = 0; i < runningSorters.length; i += 1) {
      const sorterState = runningSorters[i];
      const {
        column: { sorter },
        sortOrder
      } = sorterState;
      const compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        const compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map((record) => {
    const subRecords = record[childrenColumnName];
    if (subRecords) {
      return {
        ...record,
        [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
      };
    }
    return record;
  });
}
__name(getSortData, "getSortData");
function useFilterSorter({
  prefixCls,
  mergedColumns,
  onSorterChange,
  sortDirections,
  tableLocale,
  showSorterTooltip
}) {
  const [sortStates, setSortStates] = React550.useState(
    collectSortStates(mergedColumns, true)
  );
  const mergedSorterStates = React550.useMemo(() => {
    let validate = true;
    const collectedStates = collectSortStates(mergedColumns, false);
    if (!collectedStates.length) {
      return sortStates;
    }
    const validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push({
          ...state,
          sortOrder: null
        });
      }
    }
    __name(patchStates, "patchStates");
    let multipleMode = null;
    collectedStates.forEach((state) => {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  const columnTitleSorterProps = React550.useMemo(() => {
    const sortColumns = mergedSorterStates.map(({ column: column2, sortOrder }) => ({
      column: column2,
      order: sortOrder
    }));
    return {
      sortColumns,
      // Legacy
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  }, [mergedSorterStates]);
  const triggerSorter = /* @__PURE__ */ __name((sortState) => {
    let newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [
        ...mergedSorterStates.filter(({ key }) => key !== sortState.key),
        sortState
      ];
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }, "triggerSorter");
  const transformColumns = /* @__PURE__ */ __name((innerColumns) => injectSorter(
    prefixCls,
    innerColumns,
    mergedSorterStates,
    triggerSorter,
    sortDirections,
    tableLocale,
    showSorterTooltip
  ), "transformColumns");
  const getSorters = /* @__PURE__ */ __name(() => generateSorterInfo(mergedSorterStates), "getSorters");
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
}
__name(useFilterSorter, "useFilterSorter");

// packages/ant-design/components/table/hooks/useTitleColumns.ts
import * as React551 from "react";
function fillTitle(columns, columnTitleProps) {
  return columns.map((column2) => {
    const cloneColumn = { ...column2 };
    cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
__name(fillTitle, "fillTitle");
function useTitleColumns(columnTitleProps) {
  const filledColumns = React551.useCallback(
    (columns) => fillTitle(columns, columnTitleProps),
    [columnTitleProps]
  );
  return [filledColumns];
}
__name(useTitleColumns, "useTitleColumns");

// packages/ant-design/components/table/RcTable/index.tsx
var RcTable_default = genTable((prev2, next2) => {
  const { _renderTimes: prevRenderTimes } = prev2;
  const { _renderTimes: nextRenderTimes } = next2;
  return prevRenderTimes !== nextRenderTimes;
});

// packages/ant-design/components/table/RcTable/VirtualTable.tsx
var VirtualTable_default2 = genVirtualTable((prev2, next2) => {
  const { _renderTimes: prevRenderTimes } = prev2;
  const { _renderTimes: nextRenderTimes } = next2;
  return prevRenderTimes !== nextRenderTimes;
});

// packages/ant-design/components/table/style/index.ts
init_public_api();

// packages/ant-design/components/table/style/bordered.ts
var genBorderedStyle4 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    tableBorderColor,
    tableHeaderBg,
    tablePaddingVertical,
    tablePaddingHorizontal,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const getSizeBorderStyle = /* @__PURE__ */ __name((size, paddingVertical, paddingHorizontal) => ({
    [`&${componentCls}-${size}`]: {
      [`> ${componentCls}-container`]: {
        [`> ${componentCls}-content, > ${componentCls}-body`]: {
          [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
            [`> ${componentCls}-expanded-row-fixed`]: {
              margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
            }
          }
        }
      }
    }
  }), "getSizeBorderStyle");
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}${componentCls}-bordered`]: {
        // ============================ Title =============================
        [`> ${componentCls}-title`]: {
          border: tableBorder,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${componentCls}-container`]: {
          borderInlineStart: tableBorder,
          borderTop: tableBorder,
          [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              [`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                borderInlineEnd: tableBorder
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: tableBorder
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                [`> ${componentCls}-cell-fix-right-first::after`]: {
                  borderInlineEnd: tableBorder
                }
              },
              // ========================== Expandable ==========================
              [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(
                    calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal()
                  )}`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: lineWidth,
                    bottom: 0,
                    borderInlineEnd: tableBorder,
                    content: '""'
                  }
                }
              }
            }
          }
        },
        // ============================ Scroll ============================
        [`&${componentCls}-scroll-horizontal`]: {
          [`> ${componentCls}-container > ${componentCls}-body`]: {
            "> table > tbody": {
              [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                [`> th, > td`]: {
                  borderInlineEnd: 0
                }
              }
            }
          }
        },
        // ============================ Size ============================
        ...getSizeBorderStyle(
          "middle",
          token2.tablePaddingVerticalMiddle,
          token2.tablePaddingHorizontalMiddle
        ),
        ...getSizeBorderStyle(
          "small",
          token2.tablePaddingVerticalSmall,
          token2.tablePaddingHorizontalSmall
        ),
        // ============================ Footer ============================
        [`> ${componentCls}-footer`]: {
          border: tableBorder,
          borderTop: 0
        }
      },
      // ============================ Nested ============================
      [`${componentCls}-cell`]: {
        [`${componentCls}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}`
        }
      },
      [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
        borderInlineEnd: tableBorder
      }
    }
  };
}, "genBorderedStyle");
var bordered_default2 = genBorderedStyle4;

// packages/ant-design/components/table/style/ellipsis.ts
var genEllipsisStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-cell-ellipsis`]: {
        ...textEllipsis,
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
          overflow: "visible",
          [`${componentCls}-cell-content`]: {
            display: "block",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        },
        [`${componentCls}-column-title`]: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "keep-all"
        }
      }
    }
  };
}, "genEllipsisStyle");
var ellipsis_default = genEllipsisStyle;

// packages/ant-design/components/table/style/empty.ts
var genEmptyStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
        textAlign: "center",
        color: token2.colorTextDisabled,
        [`
          &:hover > th,
          &:hover > td,
        `]: {
          background: token2.colorBgContainer
        }
      }
    }
  };
}, "genEmptyStyle");
var empty_default3 = genEmptyStyle;

// packages/ant-design/components/table/style/expand.ts
var genExpandStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    motionDurationSlow,
    lineWidth,
    paddingXS,
    lineType,
    tableBorderColor,
    tableExpandIconBg,
    tableExpandColumnWidth,
    borderRadius,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandedRowBg,
    paddingXXS,
    expandIconMarginTop,
    expandIconSize,
    expandIconHalfInner,
    expandIconScale,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-expand-icon-col`]: {
        width: tableExpandColumnWidth
      },
      [`${componentCls}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${componentCls}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${componentCls}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${componentCls}-row-expand-icon`]: {
        ...operationUnit(token2),
        position: "relative",
        float: "left",
        boxSizing: "border-box",
        width: expandIconSize,
        height: expandIconSize,
        padding: 0,
        color: "inherit",
        lineHeight: unit(expandIconSize),
        background: tableExpandIconBg,
        border: tableBorder,
        borderRadius,
        transform: `scale(${expandIconScale})`,
        transition: `all ${motionDurationSlow}`,
        userSelect: "none",
        [`&:focus, &:hover, &:active`]: {
          borderColor: "currentcolor"
        },
        [`&::before, &::after`]: {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${motionDurationSlow} ease-out`,
          content: '""'
        },
        "&::before": {
          top: expandIconHalfInner,
          insetInlineEnd: expandIconLineOffset,
          insetInlineStart: expandIconLineOffset,
          height: lineWidth
        },
        "&::after": {
          top: expandIconLineOffset,
          bottom: expandIconLineOffset,
          insetInlineStart: expandIconHalfInner,
          width: lineWidth,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      },
      [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
        marginTop: expandIconMarginTop,
        marginInlineEnd: paddingXS
      },
      [`tr${componentCls}-expanded-row`]: {
        "&, &:hover": {
          [`> th, > td`]: {
            background: tableExpandedRowBg
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${antCls}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "auto"
          }
        }
      },
      // With fixed
      [`${componentCls}-expanded-row-fixed`]: {
        position: "relative",
        margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(
          calc(tablePaddingHorizontal).mul(-1).equal()
        )}`,
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      }
    }
  };
}, "genExpandStyle");
var expand_default = genExpandStyle;

// packages/ant-design/components/table/style/filter.ts
var genFilterStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth,
    paddingXXS,
    paddingXS,
    colorText,
    lineWidth,
    lineType,
    tableBorderColor,
    headerIconColor,
    fontSizeSM,
    tablePaddingHorizontal,
    borderRadius,
    motionDurationSlow,
    colorTextDescription,
    colorPrimary,
    tableHeaderFilterActiveBg,
    colorTextDisabled,
    tableFilterDropdownBg,
    tableFilterDropdownHeight,
    controlItemBgHover,
    controlItemBgActive,
    boxShadowSecondary,
    filterDropdownMenuBg,
    calc
  } = token2;
  const dropdownPrefixCls = `${antCls}-dropdown`;
  const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
  const treePrefixCls = `${antCls}-tree`;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${componentCls}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: calc(paddingXXS).mul(-1).equal(),
          marginInline: `${unit(paddingXXS)} ${unit(
            calc(tablePaddingHorizontal).div(2).mul(-1).equal()
          )}`,
          padding: `0 ${unit(paddingXXS)}`,
          color: headerIconColor,
          fontSize: fontSizeSM,
          borderRadius,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorTextDescription,
            background: tableHeaderFilterActiveBg
          },
          "&.active": {
            color: colorPrimary
          }
        }
      }
    },
    {
      // Dropdown
      [`${antCls}-dropdown`]: {
        [tableFilterDropdownPrefixCls]: {
          ...resetComponent(token2),
          minWidth: tableFilterDropdownWidth,
          backgroundColor: tableFilterDropdownBg,
          borderRadius,
          boxShadow: boxShadowSecondary,
          overflow: "hidden",
          // Reset menu
          [`${dropdownPrefixCls}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: tableFilterDropdownHeight,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            borderRadius: "unset",
            backgroundColor: filterDropdownMenuBg,
            "&:empty::after": {
              display: "block",
              padding: `${unit(paddingXS)} 0`,
              color: colorTextDisabled,
              fontSize: fontSizeSM,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${tableFilterDropdownPrefixCls}-tree`]: {
            paddingBlock: `${unit(paddingXS)} 0`,
            paddingInline: paddingXS,
            [treePrefixCls]: {
              padding: 0
            },
            [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
              backgroundColor: controlItemBgHover
            },
            [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: controlItemBgActive
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-search`]: {
            padding: paddingXS,
            borderBottom: tableBorder,
            "&-input": {
              input: {
                minWidth: tableFilterDropdownSearchWidth
              },
              [iconCls]: {
                color: colorTextDisabled
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-checkall`]: {
            width: "100%",
            marginBottom: paddingXXS,
            marginInlineStart: paddingXXS
          },
          // Operation
          [`${tableFilterDropdownPrefixCls}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
            overflow: "hidden",
            borderTop: tableBorder
          }
        }
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
        // Checkbox
        [`${antCls}-checkbox-wrapper + span`]: {
          paddingInlineStart: paddingXS,
          color: colorText
        },
        [`> ul`]: {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
}, "genFilterStyle");
var filter_default = genFilterStyle;

// packages/ant-design/components/table/style/fixed.ts
var genFixedStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineWidth,
    colorSplit,
    motionDurationSlow,
    zIndexTableFixed,
    tableBg,
    zIndexTableSticky,
    calc
  } = token2;
  const shadowColor = colorSplit;
  return {
    [`${componentCls}-wrapper`]: {
      [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
        position: "sticky !important",
        zIndex: zIndexTableFixed,
        background: tableBg
      },
      [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
        position: "absolute",
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: calc(lineWidth).mul(-1).equal(),
        width: 30,
        transform: "translateX(100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-cell-fix-left-all::after`]: {
        display: "none"
      },
      [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
        position: "absolute",
        top: 0,
        bottom: calc(lineWidth).mul(-1).equal(),
        left: {
          _skip_check_: true,
          value: 0
        },
        width: 30,
        transform: "translateX(-100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-container`]: {
        position: "relative",
        "&::before, &::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: calc(zIndexTableSticky).add(1).equal({ unit: false }),
          width: 30,
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        "&::before": {
          insetInlineStart: 0
        },
        "&::after": {
          insetInlineEnd: 0
        }
      },
      [`${componentCls}-ping-left`]: {
        [`&:not(${componentCls}-has-fix-left) ${componentCls}-container::before`]: {
          boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
        },
        [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
          boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
        },
        [`${componentCls}-cell-fix-left-last::before`]: {
          backgroundColor: "transparent !important"
        }
      },
      [`${componentCls}-ping-right`]: {
        [`&:not(${componentCls}-has-fix-right) ${componentCls}-container::after`]: {
          boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
        },
        [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
          boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
        }
      },
      // Gapped fixed Columns do not show the shadow
      [`${componentCls}-fixed-column-gapped`]: {
        [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after,
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
          boxShadow: "none"
        }
      }
    }
  };
}, "genFixedStyle");
var fixed_default = genFixedStyle;

// packages/ant-design/components/table/style/pagination.ts
var genPaginationStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls, margin } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${componentCls}-pagination${antCls}-pagination`]: {
        margin: `${unit(margin)} 0`
      },
      [`${componentCls}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: token2.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-left": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-right": {
          justifyContent: "flex-end"
        }
      }
    }
  };
}, "genPaginationStyle");
var pagination_default2 = genPaginationStyle2;

// packages/ant-design/components/table/style/radius.ts
var genRadiusStyle2 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, tableRadius } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [componentCls]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${componentCls}-title, ${componentCls}-header`]: {
          borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`
        },
        [`${componentCls}-title + ${componentCls}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          // https://github.com/ant-design/ant-design/issues/41975
          [`${componentCls}-header, table`]: {
            borderRadius: 0
          },
          "table > thead > tr:first-child": {
            "th:first-child, th:last-child, td:first-child, td:last-child": {
              borderRadius: 0
            }
          }
        },
        "&-container": {
          borderStartStartRadius: tableRadius,
          borderStartEndRadius: tableRadius,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: tableRadius
            },
            "> *:last-child": {
              borderStartEndRadius: tableRadius
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}`
        }
      }
    }
  };
}, "genRadiusStyle");
var radius_default = genRadiusStyle2;

// packages/ant-design/components/table/style/rtl.ts
var genStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${componentCls}-pagination-left`]: {
        justifyContent: "flex-end"
      },
      [`${componentCls}-pagination-right`]: {
        justifyContent: "flex-start"
      },
      [`${componentCls}-row-expand-icon`]: {
        float: "right",
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      },
      [`${componentCls}-container`]: {
        "&::before": {
          insetInlineStart: "unset",
          insetInlineEnd: 0
        },
        "&::after": {
          insetInlineStart: 0,
          insetInlineEnd: "unset"
        },
        [`${componentCls}-row-indent`]: {
          float: "right"
        }
      }
    }
  };
}, "genStyle");
var rtl_default3 = genStyle;

// packages/ant-design/components/table/style/selection.ts
var genSelectionStyle2 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSizeIcon,
    padding,
    paddingXS,
    headerIconColor,
    headerIconHoverColor,
    tableSelectionColumnWidth,
    tableSelectedRowBg,
    tableSelectedRowHoverBg,
    tableRowHoverBg,
    tablePaddingHorizontal,
    calc
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Selections ==========================
      [`${componentCls}-selection-col`]: {
        width: tableSelectionColumnWidth,
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
        }
      },
      [`${componentCls}-bordered ${componentCls}-selection-col`]: {
        width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
        }
      },
      [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS,
        textAlign: "center",
        [`${antCls}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
        zIndex: token2.zIndexTableFixed + 1
      },
      [`table tr th${componentCls}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${componentCls}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${componentCls}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
        [iconCls]: {
          color: headerIconColor,
          fontSize: fontSizeIcon,
          verticalAlign: "baseline",
          "&:hover": {
            color: headerIconHoverColor
          }
        }
      },
      // ============================= Rows =============================
      [`${componentCls}-tbody`]: {
        [`${componentCls}-row`]: {
          [`&${componentCls}-row-selected`]: {
            [`> ${componentCls}-cell`]: {
              background: tableSelectedRowBg,
              "&-row-hover": {
                background: tableSelectedRowHoverBg
              }
            }
          },
          [`> ${componentCls}-cell-row-hover`]: {
            background: tableRowHoverBg
          }
        }
      }
    }
  };
}, "genSelectionStyle");
var selection_default = genSelectionStyle2;

// packages/ant-design/components/table/style/size.ts
var genSizeStyle5 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, tableExpandColumnWidth, calc } = token2;
  const getSizeStyle = /* @__PURE__ */ __name((size, paddingVertical, paddingHorizontal, fontSize) => ({
    [`${componentCls}${componentCls}-${size}`]: {
      fontSize,
      [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}`
      },
      [`${componentCls}-filter-trigger`]: {
        marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal())
      },
      [`${componentCls}-expanded-row-fixed`]: {
        margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(
          calc(paddingHorizontal).mul(-1).equal()
        )}`
      },
      [`${componentCls}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${componentCls}-wrapper:only-child ${componentCls}`]: {
          marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
          marginInline: `${unit(
            calc(tableExpandColumnWidth).sub(paddingHorizontal).equal()
          )} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${componentCls}-selection-extra`]: {
        paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal())
      }
    }
  }), "getSizeStyle");
  return {
    [`${componentCls}-wrapper`]: {
      ...getSizeStyle(
        "middle",
        token2.tablePaddingVerticalMiddle,
        token2.tablePaddingHorizontalMiddle,
        token2.tableFontSizeMiddle
      ),
      ...getSizeStyle(
        "small",
        token2.tablePaddingVerticalSmall,
        token2.tablePaddingHorizontalSmall,
        token2.tableFontSizeSmall
      )
    }
  };
}, "genSizeStyle");
var size_default = genSizeStyle5;

// packages/ant-design/components/table/style/sorter.ts
var genSorterStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, marginXXS, fontSizeIcon, headerIconColor, headerIconHoverColor } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          background: token2.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: token2.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
          background: token2.tableFixedHeaderSortActiveBg
        }
      },
      [`${componentCls}-thead th${componentCls}-column-sort`]: {
        background: token2.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${componentCls}-column-sort`]: {
        background: token2.tableBodySortBg
      },
      [`${componentCls}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1
      },
      [`${componentCls}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${componentCls}-column-sorters-tooltip-target-sorter`]: {
        "&::after": {
          content: "none"
        }
      },
      [`${componentCls}-column-sorter`]: {
        marginInlineStart: marginXXS,
        color: headerIconColor,
        fontSize: 0,
        transition: `color ${token2.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: fontSizeIcon,
          "&.active": {
            color: token2.colorPrimary
          }
        },
        [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
        color: headerIconHoverColor
      }
    }
  };
}, "genSorterStyle");
var sorter_default = genSorterStyle;

// packages/ant-design/components/table/style/sticky.ts
var genStickyStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    opacityLoading,
    tableScrollThumbBg,
    tableScrollThumbBgHover,
    tableScrollThumbSize,
    tableScrollBg,
    zIndexTableSticky,
    stickyScrollBarBorderRadius,
    lineWidth,
    lineType,
    tableBorderColor
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: zIndexTableSticky,
          background: token2.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${unit(tableScrollThumbSize)} !important`,
          zIndex: zIndexTableSticky,
          display: "flex",
          alignItems: "center",
          background: tableScrollBg,
          borderTop: tableBorder,
          opacity: opacityLoading,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: tableScrollThumbSize,
            backgroundColor: tableScrollThumbBg,
            borderRadius: stickyScrollBarBorderRadius,
            transition: `all ${token2.motionDurationSlow}, transform none`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: tableScrollThumbBgHover
            }
          }
        }
      }
    }
  };
}, "genStickyStyle");
var sticky_default = genStickyStyle;

// packages/ant-design/components/table/style/summary.ts
var genSummaryStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, lineWidth, tableBorderColor, calc } = token2;
  const tableBorder = `${unit(lineWidth)} ${token2.lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-summary`]: {
        position: "relative",
        zIndex: token2.zIndexTableFixed,
        background: token2.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: tableBorder
          }
        }
      },
      [`div${componentCls}-summary`]: {
        boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
      }
    }
  };
}, "genSummaryStyle");
var summary_default = genSummaryStyle;

// packages/ant-design/components/table/style/virtual.ts
var genVirtualStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, motionDurationMid, lineWidth, lineType, tableBorderColor, calc } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const rowCellCls = `${componentCls}-expanded-row-cell`;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Row ==========================
      [`${componentCls}-tbody-virtual`]: {
        [`${componentCls}-row:not(tr)`]: {
          display: "flex",
          boxSizing: "border-box",
          width: "100%"
        },
        [`${componentCls}-cell`]: {
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid}`
        },
        [`${componentCls}-expanded-row`]: {
          [`${rowCellCls}${rowCellCls}-fixed`]: {
            position: "sticky",
            insetInlineStart: 0,
            overflow: "hidden",
            width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
            borderInlineEnd: "none"
          }
        }
      },
      // ======================== Border =========================
      [`${componentCls}-bordered`]: {
        [`${componentCls}-tbody-virtual`]: {
          "&:after": {
            content: '""',
            insetInline: 0,
            bottom: 0,
            borderBottom: tableBorder,
            position: "absolute"
          },
          [`${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            [`&${componentCls}-cell-fix-right-first:before`]: {
              content: '""',
              position: "absolute",
              insetBlock: 0,
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              borderInlineStart: tableBorder
            }
          }
        },
        // Empty placeholder
        [`&${componentCls}-virtual`]: {
          [`${componentCls}-placeholder ${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            borderBottom: tableBorder
          }
        }
      }
    }
  };
}, "genVirtualStyle");
var virtual_default = genVirtualStyle;

// packages/ant-design/components/table/style/index.ts
var genTableStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    fontWeightStrong,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandColumnWidth,
    lineWidth,
    lineType,
    tableBorderColor,
    tableFontSize,
    tableBg,
    tableRadius,
    tableHeaderTextColor,
    motionDurationMid,
    tableHeaderBg,
    tableHeaderCellSplitColor,
    tableFooterTextColor,
    tableFooterBg,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      clear: "both",
      maxWidth: "100%",
      ...clearFix(),
      [componentCls]: {
        ...resetComponent(token2),
        fontSize: tableFontSize,
        background: tableBg,
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        // https://github.com/ant-design/ant-design/issues/47486
        scrollbarColor: `${token2.tableScrollThumbBg} ${token2.tableScrollBg}`
      },
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell ==============================
      [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${componentCls}-title`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      },
      // ============================ Header ============================
      [`${componentCls}-thead`]: {
        [`
          > tr > th,
          > tr > td
        `]: {
          position: "relative",
          color: tableHeaderTextColor,
          fontWeight: fontWeightStrong,
          textAlign: "start",
          background: tableHeaderBg,
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: tableHeaderCellSplitColor,
            transform: "translateY(-50%)",
            transition: `background-color ${motionDurationMid}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      [`${componentCls}-tbody`]: {
        "> tr": {
          [`> th, > td`]: {
            transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
            borderBottom: tableBorder,
            // ========================= Nest Table ===========================
            [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
              [componentCls]: {
                marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
                marginInline: `${unit(
                  calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal()
                )}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                [`${componentCls}-tbody > tr:last-child > td`]: {
                  borderBottom: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          "> th": {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`
          }
        }
      },
      // ============================ Footer ============================
      [`${componentCls}-footer`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        color: tableFooterTextColor,
        background: tableFooterBg
      }
    }
  };
}, "genTableStyle");
var prepareComponentToken51 = /* @__PURE__ */ __name((token2) => {
  const {
    colorFillAlter,
    colorBgContainer,
    colorTextHeading,
    colorFillSecondary,
    colorFillContent,
    controlItemBgActive,
    controlItemBgActiveHover,
    padding,
    paddingSM,
    paddingXS,
    colorBorderSecondary,
    borderRadiusLG,
    controlHeight,
    colorTextPlaceholder,
    fontSize,
    fontSizeSM,
    lineHeight,
    lineWidth,
    colorIcon,
    colorIconHover,
    opacityLoading,
    controlInteractiveSize
  } = token2;
  const colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexShortString();
  const colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexShortString();
  const colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexShortString();
  const baseColorAction = new TinyColor(colorIcon);
  const baseColorActionHover = new TinyColor(colorIconHover);
  const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
  const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
  return {
    headerBg: colorFillAlterSolid,
    headerColor: colorTextHeading,
    headerSortActiveBg: colorFillSecondarySolid,
    headerSortHoverBg: colorFillContentSolid,
    bodySortBg: colorFillAlterSolid,
    rowHoverBg: colorFillAlterSolid,
    rowSelectedBg: controlItemBgActive,
    rowSelectedHoverBg: controlItemBgActiveHover,
    rowExpandedBg: colorFillAlter,
    cellPaddingBlock: padding,
    cellPaddingInline: padding,
    cellPaddingBlockMD: paddingSM,
    cellPaddingInlineMD: paddingXS,
    cellPaddingBlockSM: paddingXS,
    cellPaddingInlineSM: paddingXS,
    borderColor: colorBorderSecondary,
    headerBorderRadius: borderRadiusLG,
    footerBg: colorFillAlterSolid,
    footerColor: colorTextHeading,
    cellFontSize: fontSize,
    cellFontSizeMD: fontSize,
    cellFontSizeSM: fontSize,
    headerSplitColor: colorBorderSecondary,
    fixedHeaderSortActiveBg: colorFillSecondarySolid,
    headerFilterHoverBg: colorFillContent,
    filterDropdownMenuBg: colorBgContainer,
    filterDropdownBg: colorBgContainer,
    expandIconBg: colorBgContainer,
    selectionColumnWidth: controlHeight,
    stickyScrollBarBg: colorTextPlaceholder,
    stickyScrollBarBorderRadius: 100,
    expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
    headerIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
    headerIconHoverColor: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
    expandIconHalfInner,
    expandIconSize,
    expandIconScale: controlInteractiveSize / expandIconSize
  };
}, "prepareComponentToken");
var style_default57 = genStyleHooks(
  "Table",
  (token2) => {
    const {
      colorTextHeading,
      colorSplit,
      colorBgContainer,
      controlInteractiveSize: checkboxSize,
      headerBg,
      headerColor,
      headerSortActiveBg,
      headerSortHoverBg,
      bodySortBg,
      rowHoverBg,
      rowSelectedBg,
      rowSelectedHoverBg,
      rowExpandedBg,
      cellPaddingBlock,
      cellPaddingInline,
      cellPaddingBlockMD,
      cellPaddingInlineMD,
      cellPaddingBlockSM,
      cellPaddingInlineSM,
      borderColor,
      footerBg,
      footerColor,
      headerBorderRadius,
      cellFontSize,
      cellFontSizeMD,
      cellFontSizeSM,
      headerSplitColor,
      fixedHeaderSortActiveBg,
      headerFilterHoverBg,
      filterDropdownBg,
      expandIconBg,
      selectionColumnWidth,
      stickyScrollBarBg,
      calc
    } = token2;
    const zIndexTableFixed = 2;
    const tableToken = merge2(token2, {
      tableFontSize: cellFontSize,
      tableBg: colorBgContainer,
      tableRadius: headerBorderRadius,
      tablePaddingVertical: cellPaddingBlock,
      tablePaddingHorizontal: cellPaddingInline,
      tablePaddingVerticalMiddle: cellPaddingBlockMD,
      tablePaddingHorizontalMiddle: cellPaddingInlineMD,
      tablePaddingVerticalSmall: cellPaddingBlockSM,
      tablePaddingHorizontalSmall: cellPaddingInlineSM,
      tableBorderColor: borderColor,
      tableHeaderTextColor: headerColor,
      tableHeaderBg: headerBg,
      tableFooterTextColor: footerColor,
      tableFooterBg: footerBg,
      tableHeaderCellSplitColor: headerSplitColor,
      tableHeaderSortBg: headerSortActiveBg,
      tableHeaderSortHoverBg: headerSortHoverBg,
      tableBodySortBg: bodySortBg,
      tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
      tableHeaderFilterActiveBg: headerFilterHoverBg,
      tableFilterDropdownBg: filterDropdownBg,
      tableRowHoverBg: rowHoverBg,
      tableSelectedRowBg: rowSelectedBg,
      tableSelectedRowHoverBg: rowSelectedHoverBg,
      zIndexTableFixed,
      zIndexTableSticky: zIndexTableFixed + 1,
      tableFontSizeMiddle: cellFontSizeMD,
      tableFontSizeSmall: cellFontSizeSM,
      tableSelectionColumnWidth: selectionColumnWidth,
      tableExpandIconBg: expandIconBg,
      tableExpandColumnWidth: calc(checkboxSize).add(calc(token2.padding).mul(2)).equal(),
      tableExpandedRowBg: rowExpandedBg,
      // Dropdown
      tableFilterDropdownWidth: 120,
      tableFilterDropdownHeight: 264,
      tableFilterDropdownSearchWidth: 140,
      // Virtual Scroll Bar
      tableScrollThumbSize: 8,
      // Mac scroll bar size
      tableScrollThumbBg: stickyScrollBarBg,
      tableScrollThumbBgHover: colorTextHeading,
      tableScrollBg: colorSplit
    });
    return [
      genTableStyle(tableToken),
      pagination_default2(tableToken),
      summary_default(tableToken),
      sorter_default(tableToken),
      filter_default(tableToken),
      bordered_default2(tableToken),
      radius_default(tableToken),
      expand_default(tableToken),
      summary_default(tableToken),
      empty_default3(tableToken),
      selection_default(tableToken),
      fixed_default(tableToken),
      sticky_default(tableToken),
      ellipsis_default(tableToken),
      size_default(tableToken),
      rtl_default3(tableToken),
      virtual_default(tableToken)
    ];
  },
  prepareComponentToken51,
  {
    unitless: {
      expandIconScale: true
    }
  }
);

// packages/ant-design/components/table/InternalTable.tsx
var EMPTY_LIST7 = [];
var InternalTable = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    bordered,
    dropdownPrefixCls: customizeDropdownPrefixCls,
    dataSource,
    pagination,
    rowSelection,
    rowKey = "key",
    rowClassName,
    columns,
    children,
    childrenColumnName: legacyChildrenColumnName,
    onChange,
    getPopupContainer,
    loading,
    expandIcon,
    expandable,
    expandedRowRender,
    expandIconColumnIndex,
    indentSize,
    scroll,
    sortDirections,
    locale: locale6,
    showSorterTooltip = { target: "full-header" },
    virtual
  } = props;
  const warning5 = devUseWarning("Table");
  if (true) {
    warning5(
      !(typeof rowKey === "function" && rowKey.length > 1),
      "usage",
      "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected."
    );
  }
  const baseColumns = React552.useMemo(
    () => columns || convertChildrenToColumns(children),
    [columns, children]
  );
  const needResponsive = React552.useMemo(
    () => baseColumns.some((col) => col.responsive),
    [baseColumns]
  );
  const screens = useBreakpoint_default(needResponsive);
  const mergedColumns = React552.useMemo(() => {
    const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
    return baseColumns.filter(
      (c) => !c.responsive || c.responsive.some((r2) => matched.has(r2))
    );
  }, [baseColumns, screens]);
  const tableProps = omit(props, ["className", "style", "columns"]);
  const {
    locale: contextLocale = en_US_default6,
    direction,
    table,
    renderEmpty,
    getPrefixCls,
    getPopupContainer: getContextPopupContainer
  } = React552.useContext(ConfigContext);
  const mergedSize = useSize_default(customizeSize);
  const tableLocale = { ...contextLocale.Table, ...locale6 };
  const rawData = dataSource || EMPTY_LIST7;
  const prefixCls = getPrefixCls("table", customizePrefixCls);
  const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
  const [, token2] = useToken();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default57(prefixCls, rootCls);
  const mergedExpandable = {
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex,
    ...expandable,
    expandIcon: expandable?.expandIcon ?? table?.expandable?.expandIcon
  };
  const { childrenColumnName = "children" } = mergedExpandable;
  const expandType = React552.useMemo(() => {
    if (rawData.some((item) => item?.[childrenColumnName])) {
      return "nest";
    }
    if (expandedRowRender || expandable && expandable.expandedRowRender) {
      return "row";
    }
    return null;
  }, [rawData]);
  const internalRefs = {
    body: React552.useRef()
  };
  const getContainerWidth = useContainerWidth(prefixCls);
  const rootRef = React552.useRef(null);
  const tblRef = React552.useRef(null);
  useProxyImperativeHandle(ref, () => ({
    ...tblRef.current,
    nativeElement: rootRef.current
  }));
  const getRowKey = React552.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => record?.[rowKey];
  }, [rowKey]);
  const [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey);
  const changeEventInfo = {};
  const triggerOnChange = /* @__PURE__ */ __name((info, action, reset = false) => {
    const changeInfo = {
      ...changeEventInfo,
      ...info
    };
    if (reset) {
      changeEventInfo.resetPagination?.();
      if (changeInfo.pagination?.current) {
        changeInfo.pagination.current = 1;
      }
      if (pagination && pagination.onChange) {
        pagination.onChange(1, changeInfo.pagination?.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo(0, {
        getContainer: () => internalRefs.body.current
      });
    }
    onChange?.(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(
        getSortData(rawData, changeInfo.sorterStates, childrenColumnName),
        changeInfo.filterStates,
        childrenColumnName
      ),
      action
    });
  }, "triggerOnChange");
  const onSorterChange = /* @__PURE__ */ __name((sorter, sorterStates) => {
    triggerOnChange(
      {
        sorter,
        sorterStates
      },
      "sort",
      false
    );
  }, "onSorterChange");
  const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useFilterSorter({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip
  });
  const sortedData = React552.useMemo(
    () => getSortData(rawData, sortStates, childrenColumnName),
    [rawData, sortStates]
  );
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  const onFilterChange = /* @__PURE__ */ __name((filters2, filterStates2) => {
    triggerOnChange({ filters: filters2, filterStates: filterStates2 }, "filter", true);
  }, "onFilterChange");
  const [transformFilterColumns, filterStates, filters] = useFilter_default({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    rootClassName: (0, import_classnames246.default)(rootClassName, rootCls)
  });
  const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
  changeEventInfo.filters = filters;
  changeEventInfo.filterStates = filterStates;
  const columnTitleProps = React552.useMemo(() => {
    const mergedFilters = {};
    Object.keys(filters).forEach((filterKey) => {
      if (filters[filterKey] !== null) {
        mergedFilters[filterKey] = filters[filterKey];
      }
    });
    return {
      ...sorterTitleProps,
      filters: mergedFilters
    };
  }, [sorterTitleProps, filters]);
  const [transformTitleColumns] = useTitleColumns(columnTitleProps);
  const onPaginationChange = /* @__PURE__ */ __name((current, pageSize) => {
    triggerOnChange(
      {
        pagination: { ...changeEventInfo.pagination, current, pageSize }
      },
      "paginate"
    );
  }, "onPaginationChange");
  const [mergedPagination, resetPagination] = usePagination_default(
    mergedData.length,
    onPaginationChange,
    pagination
  );
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
  changeEventInfo.resetPagination = resetPagination;
  const pageData = React552.useMemo(() => {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    const { current = 1, total, pageSize = DEFAULT_PAGE_SIZE } = mergedPagination;
    warning5(current > 0, "usage", "`current` should be positive number.");
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        warning5(
          false,
          "usage",
          "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode."
        );
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [
    !!pagination,
    mergedData,
    mergedPagination && mergedPagination.current,
    mergedPagination && mergedPagination.pageSize,
    mergedPagination && mergedPagination.total
  ]);
  const [transformSelectionColumns, selectedKeySet] = useSelection_default(
    {
      prefixCls,
      data: mergedData,
      pageData,
      getRowKey,
      getRecordByKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer: getPopupContainer || getContextPopupContainer
    },
    rowSelection
  );
  const internalRowClassName = /* @__PURE__ */ __name((record, index3, indent) => {
    let mergedRowClassName;
    if (typeof rowClassName === "function") {
      mergedRowClassName = (0, import_classnames246.default)(rowClassName(record, index3, indent));
    } else {
      mergedRowClassName = (0, import_classnames246.default)(rowClassName);
    }
    return (0, import_classnames246.default)(
      {
        [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index3))
      },
      mergedRowClassName
    );
  }, "internalRowClassName");
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
  if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  if (typeof mergedExpandable.indentSize !== "number") {
    mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
  }
  const transformColumns = React552.useCallback(
    (innerColumns) => transformTitleColumns(
      transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))
    ),
    [transformSorterColumns, transformFilterColumns, transformSelectionColumns]
  );
  let topPaginationNode;
  let bottomPaginationNode;
  if (pagination !== false && mergedPagination?.total) {
    let paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    }
    const renderPagination = /* @__PURE__ */ __name((position3) => /* @__PURE__ */ React552.createElement(
      pagination_default,
      {
        ...mergedPagination,
        className: (0, import_classnames246.default)(
          `${prefixCls}-pagination ${prefixCls}-pagination-${position3}`,
          mergedPagination.className
        ),
        size: paginationSize
      }
    ), "renderPagination");
    const defaultPosition = direction === "rtl" ? "left" : "right";
    const { position: position2 } = mergedPagination;
    if (position2 !== null && Array.isArray(position2)) {
      const topPos = position2.find((p) => p.includes("top"));
      const bottomPos = position2.find((p) => p.includes("bottom"));
      const isDisable = position2.every((p) => `${p}` === "none");
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination(defaultPosition);
      }
      if (topPos) {
        topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
      }
    } else {
      bottomPaginationNode = renderPagination(defaultPosition);
    }
  }
  let spinProps;
  if (typeof loading === "boolean") {
    spinProps = {
      spinning: loading
    };
  } else if (typeof loading === "object") {
    spinProps = {
      spinning: true,
      ...loading
    };
  }
  const wrapperClassNames = (0, import_classnames246.default)(
    cssVarCls,
    rootCls,
    `${prefixCls}-wrapper`,
    table?.className,
    {
      [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId
  );
  const mergedStyle = { ...table?.style, ...style2 };
  const emptyText = locale6 && locale6.emptyText || renderEmpty?.("Table") || /* @__PURE__ */ React552.createElement(defaultRenderEmpty_default, { componentName: "Table" });
  const TableComponent = virtual ? VirtualTable_default2 : RcTable_default;
  const virtualProps = {};
  const listItemHeight = React552.useMemo(() => {
    const { fontSize, lineHeight, padding, paddingXS, paddingSM } = token2;
    const fontHeight = Math.floor(fontSize * lineHeight);
    switch (mergedSize) {
      case "large":
        return padding * 2 + fontHeight;
      case "small":
        return paddingXS * 2 + fontHeight;
      default:
        return paddingSM * 2 + fontHeight;
    }
  }, [token2, mergedSize]);
  if (virtual) {
    virtualProps.listItemHeight = listItemHeight;
  }
  return wrapCSSVar(
    /* @__PURE__ */ React552.createElement("div", { ref: rootRef, className: wrapperClassNames, style: mergedStyle }, /* @__PURE__ */ React552.createElement(spin_default, { spinning: false, ...spinProps }, topPaginationNode, /* @__PURE__ */ React552.createElement(
      TableComponent,
      {
        ...virtualProps,
        ...tableProps,
        ref: tblRef,
        columns: mergedColumns,
        direction,
        expandable: mergedExpandable,
        prefixCls,
        className: (0, import_classnames246.default)(
          {
            [`${prefixCls}-middle`]: mergedSize === "middle",
            [`${prefixCls}-small`]: mergedSize === "small",
            [`${prefixCls}-bordered`]: bordered,
            [`${prefixCls}-empty`]: rawData.length === 0
          },
          cssVarCls,
          rootCls,
          hashId
        ),
        data: pageData,
        rowKey: getRowKey,
        rowClassName: internalRowClassName,
        emptyText,
        internalHooks: INTERNAL_HOOKS,
        internalRefs,
        transformColumns,
        getContainerWidth
      }
    ), bottomPaginationNode))
  );
}, "InternalTable");
var InternalTable_default = React552.forwardRef(InternalTable);

// packages/ant-design/components/table/Table.tsx
var Table2 = /* @__PURE__ */ __name((props, ref) => {
  const renderTimesRef = React553.useRef(0);
  renderTimesRef.current += 1;
  return /* @__PURE__ */ React553.createElement(InternalTable_default, { ...props, ref, _renderTimes: renderTimesRef.current });
}, "Table");
var ForwardTable = React553.forwardRef(Table2);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column_default2;
ForwardTable.ColumnGroup = ColumnGroup_default2;
ForwardTable.Summary = FooterComponents;
if (true) {
  ForwardTable.displayName = "Table";
}
var Table_default2 = ForwardTable;

// packages/ant-design/components/table/index.ts
var table_default = Table_default2;

// packages/ant-design/components/tag/index.tsx
var import_classnames248 = __toESM(require_classnames());
import * as React555 from "react";

// packages/ant-design/components/tag/CheckableTag.tsx
var import_classnames247 = __toESM(require_classnames());
import * as React554 from "react";

// packages/ant-design/components/tag/style/index.ts
init_public_api();
var genBaseStyle16 = /* @__PURE__ */ __name((token2) => {
  const { paddingXXS, lineWidth, tagPaddingHorizontal, componentCls, calc } = token2;
  const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
  const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
  return {
    // Result
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      height: "auto",
      // https://github.com/ant-design/ant-design/pull/47504
      marginInlineEnd: token2.marginXS,
      paddingInline,
      fontSize: token2.tagFontSize,
      lineHeight: token2.tagLineHeight,
      whiteSpace: "nowrap",
      background: token2.defaultBg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: token2.borderRadiusSM,
      opacity: 1,
      transition: `all ${token2.motionDurationMid}`,
      textAlign: "start",
      position: "relative",
      // RTL
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: token2.defaultColor
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: iconMarginInline,
        fontSize: token2.tagIconSize,
        color: token2.colorTextDescription,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      [`&${componentCls}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
          color: token2.colorTextLightSolid
        }
      },
      [`&-checkable`]: {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${componentCls}-checkable-checked):hover`]: {
          color: token2.colorPrimary,
          backgroundColor: token2.colorFillSecondary
        },
        "&:active, &-checked": {
          color: token2.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: token2.colorPrimary,
          "&:hover": {
            backgroundColor: token2.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: token2.colorPrimaryActive
        }
      },
      [`&-hidden`]: {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
        marginInlineStart: paddingInline
      }
    },
    [`${componentCls}-borderless`]: {
      borderColor: "transparent",
      background: token2.tagBorderlessBg
    }
  };
}, "genBaseStyle");
var prepareToken6 = /* @__PURE__ */ __name((token2) => {
  const { lineWidth, fontSizeIcon, calc } = token2;
  const tagFontSize = token2.fontSizeSM;
  const tagToken = merge2(token2, {
    tagFontSize,
    tagLineHeight: unit(calc(token2.lineHeightSM).mul(tagFontSize).equal()),
    tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
    // Tag icon is much smaller
    tagPaddingHorizontal: 8,
    // Fixed padding.
    tagBorderlessBg: token2.defaultBg
  });
  return tagToken;
}, "prepareToken");
var prepareComponentToken52 = /* @__PURE__ */ __name((token2) => ({
  defaultBg: new TinyColor(token2.colorFillQuaternary).onBackground(token2.colorBgContainer).toHexString(),
  defaultColor: token2.colorText
}), "prepareComponentToken");
var style_default58 = genStyleHooks(
  "Tag",
  (token2) => {
    const tagToken = prepareToken6(token2);
    return genBaseStyle16(tagToken);
  },
  prepareComponentToken52
);

// packages/ant-design/components/tag/CheckableTag.tsx
var CheckableTag = React554.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    style: style2,
    className,
    checked,
    onChange,
    onClick,
    ...restProps
  } = props;
  const { getPrefixCls, tag } = React554.useContext(ConfigContext);
  const handleClick = /* @__PURE__ */ __name((e3) => {
    onChange?.(!checked);
    onClick?.(e3);
  }, "handleClick");
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default58(prefixCls);
  const cls5 = (0, import_classnames247.default)(
    prefixCls,
    `${prefixCls}-checkable`,
    {
      [`${prefixCls}-checkable-checked`]: checked
    },
    tag?.className,
    className,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React554.createElement(
      "span",
      {
        ...restProps,
        ref,
        style: { ...style2, ...tag?.style },
        className: cls5,
        onClick: handleClick
      }
    )
  );
});
var CheckableTag_default = CheckableTag;

// packages/ant-design/components/tag/style/presetCmp.ts
var genPresetStyle = /* @__PURE__ */ __name((token2) => genPresetColor(token2, (colorKey, { textColor, lightBorderColor, lightColor, darkColor }) => ({
  [`${token2.componentCls}${token2.componentCls}-${colorKey}`]: {
    color: textColor,
    background: lightColor,
    borderColor: lightBorderColor,
    // Inverse color
    "&-inverse": {
      color: token2.colorTextLightSolid,
      background: darkColor,
      borderColor: darkColor
    },
    [`&${token2.componentCls}-borderless`]: {
      borderColor: "transparent"
    }
  }
})), "genPresetStyle");
var presetCmp_default = genSubStyleComponent(
  ["Tag", "preset"],
  (token2) => {
    const tagToken = prepareToken6(token2);
    return genPresetStyle(tagToken);
  },
  prepareComponentToken52
);

// packages/ant-design/components/_util/capitalize.ts
function capitalize(str) {
  if (typeof str !== "string") {
    return str;
  }
  const ret = str.charAt(0).toUpperCase() + str.slice(1);
  return ret;
}
__name(capitalize, "capitalize");

// packages/ant-design/components/tag/style/statusCmp.ts
var genTagStatusStyle = /* @__PURE__ */ __name((token2, status, cssVariableType) => {
  const capitalizedCssVariableType = capitalize(cssVariableType);
  return {
    [`${token2.componentCls}${token2.componentCls}-${status}`]: {
      color: token2[`color${cssVariableType}`],
      background: token2[`color${capitalizedCssVariableType}Bg`],
      borderColor: token2[`color${capitalizedCssVariableType}Border`],
      [`&${token2.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, "genTagStatusStyle");
var statusCmp_default = genSubStyleComponent(
  ["Tag", "status"],
  (token2) => {
    const tagToken = prepareToken6(token2);
    return [
      genTagStatusStyle(tagToken, "success", "Success"),
      genTagStatusStyle(tagToken, "processing", "Info"),
      genTagStatusStyle(tagToken, "error", "Error"),
      genTagStatusStyle(tagToken, "warning", "Warning")
    ];
  },
  prepareComponentToken52
);

// packages/ant-design/components/tag/index.tsx
var InternalTag = React555.forwardRef((tagProps, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    children,
    icon,
    color,
    onClose,
    bordered = true,
    visible: deprecatedVisible,
    ...props
  } = tagProps;
  const { getPrefixCls, direction, tag: tagContext } = React555.useContext(ConfigContext);
  const [visible, setVisible] = React555.useState(true);
  const domProps = omit(props, ["closeIcon", "closable"]);
  if (true) {
    const warning5 = devUseWarning("Tag");
    warning5.deprecated(!("visible" in tagProps), "visible", "visible && <Tag />");
  }
  React555.useEffect(() => {
    if (deprecatedVisible !== void 0) {
      setVisible(deprecatedVisible);
    }
  }, [deprecatedVisible]);
  const isPreset = isPresetColor(color);
  const isStatus = isPresetStatusColor(color);
  const isInternalColor = isPreset || isStatus;
  const tagStyle = {
    backgroundColor: color && !isInternalColor ? color : void 0,
    ...tagContext?.style,
    ...style2
  };
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default58(prefixCls);
  const tagClassName = (0, import_classnames248.default)(
    prefixCls,
    tagContext?.className,
    {
      [`${prefixCls}-${color}`]: isInternalColor,
      [`${prefixCls}-has-color`]: color && !isInternalColor,
      [`${prefixCls}-hidden`]: !visible,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-borderless`]: !bordered
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const handleCloseClick = /* @__PURE__ */ __name((e3) => {
    e3.stopPropagation();
    onClose?.(e3);
    if (e3.defaultPrevented) {
      return;
    }
    setVisible(false);
  }, "handleCloseClick");
  const [, mergedCloseIcon] = useClosable(pickClosable(tagProps), pickClosable(tagContext), {
    closable: false,
    closeIconRender: (iconNode2) => {
      const replacement = /* @__PURE__ */ React555.createElement("span", { className: `${prefixCls}-close-icon`, onClick: handleCloseClick }, iconNode2);
      return replaceElement(iconNode2, replacement, (originProps) => ({
        onClick: (e3) => {
          originProps?.onClick?.(e3);
          handleCloseClick(e3);
        },
        className: (0, import_classnames248.default)(originProps?.className, `${prefixCls}-close-icon`)
      }));
    }
  });
  const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
  const iconNode = icon || null;
  const kids = iconNode ? /* @__PURE__ */ React555.createElement(React555.Fragment, null, iconNode, children && /* @__PURE__ */ React555.createElement("span", null, children)) : children;
  const tagNode = /* @__PURE__ */ React555.createElement("span", { ...domProps, ref, className: tagClassName, style: tagStyle }, kids, mergedCloseIcon, isPreset && /* @__PURE__ */ React555.createElement(presetCmp_default, { key: "preset", prefixCls }), isStatus && /* @__PURE__ */ React555.createElement(statusCmp_default, { key: "status", prefixCls }));
  return wrapCSSVar(isNeedWave ? /* @__PURE__ */ React555.createElement(wave_default, { component: "Tag" }, tagNode) : tagNode);
});
var Tag = InternalTag;
if (true) {
  Tag.displayName = "Tag";
}
Tag.CheckableTag = CheckableTag_default;
var tag_default = Tag;

// packages/ant-design/components/theme/getDesignToken.ts
var getDesignToken = /* @__PURE__ */ __name((config) => {
  const theme = config?.algorithm ? createTheme(config.algorithm) : createTheme(derivative);
  const mergedToken = {
    ...seed_default,
    ...config?.token
  };
  return getComputedToken(mergedToken, { override: config?.token }, theme, formatToken);
}, "getDesignToken");
var getDesignToken_default = getDesignToken;

// packages/ant-design/components/theme/themes/compact/genCompactSizeMapToken.ts
function genSizeMapToken2(token2) {
  const { sizeUnit, sizeStep } = token2;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}
__name(genSizeMapToken2, "genSizeMapToken");

// packages/ant-design/components/theme/themes/compact/index.ts
var derivative2 = /* @__PURE__ */ __name((token2, mapToken) => {
  const mergedMapToken = mapToken ?? derivative(token2);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return {
    ...mergedMapToken,
    ...genSizeMapToken2(mapToken ?? token2),
    // font
    ...genFontMapToken_default(fontSize),
    // controlHeight
    controlHeight,
    ...genControlHeight_default({ ...mergedMapToken, controlHeight })
  };
}, "derivative");
var compact_default2 = derivative2;

// packages/ant-design/components/theme/themes/dark/index.ts
init_src();

// packages/ant-design/components/theme/themes/dark/colors.ts
init_src();

// packages/ant-design/components/theme/themes/dark/colorAlgorithm.ts
init_public_api();
var getAlphaColor4 = /* @__PURE__ */ __name((baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), "getAlphaColor");
var getSolidColor2 = /* @__PURE__ */ __name((baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.lighten(brightness).toHexString();
}, "getSolidColor");

// packages/ant-design/components/theme/themes/dark/colors.ts
var generateColorPalettes2 = /* @__PURE__ */ __name((baseColor) => {
  const colors = generate(baseColor, { theme: "dark" });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
    // 8: colors[9],
    // 9: colors[8],
    // 10: colors[7],
  };
}, "generateColorPalettes");
var generateNeutralColorPalettes2 = /* @__PURE__ */ __name((bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor4(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor4(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor4(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor4(colorTextBase, 0.25),
    colorFill: getAlphaColor4(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor4(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor4(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor4(colorTextBase, 0.04),
    colorBgElevated: getSolidColor2(colorBgBase, 12),
    colorBgContainer: getSolidColor2(colorBgBase, 8),
    colorBgLayout: getSolidColor2(colorBgBase, 0),
    colorBgSpotlight: getSolidColor2(colorBgBase, 26),
    colorBgBlur: getAlphaColor4(colorTextBase, 0.04),
    colorBorder: getSolidColor2(colorBgBase, 26),
    colorBorderSecondary: getSolidColor2(colorBgBase, 19)
  };
}, "generateNeutralColorPalettes");

// packages/ant-design/components/theme/themes/dark/index.ts
var derivative3 = /* @__PURE__ */ __name((token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate(token2[colorKey], { theme: "dark" });
    return new Array(10).fill(1).reduce((prev2, _, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors[i];
      prev2[`${colorKey}${i + 1}`] = colors[i];
      return prev2;
    }, {});
  }).reduce(
    (prev2, cur) => {
      prev2 = {
        ...prev2,
        ...cur
      };
      return prev2;
    },
    {}
  );
  const mergedMapToken = mapToken ?? derivative(token2);
  return {
    ...mergedMapToken,
    // Dark tokens
    ...colorPalettes,
    // Colors
    ...genColorMapToken(token2, {
      generateColorPalettes: generateColorPalettes2,
      generateNeutralColorPalettes: generateNeutralColorPalettes2
    })
  };
}, "derivative");
var dark_default = derivative3;

// packages/ant-design/components/theme/index.ts
function useToken2() {
  const [theme, token2, hashId] = useToken();
  return { theme, token: token2, hashId };
}
__name(useToken2, "useToken");
var theme_default2 = {
  /** @private Test Usage. Do not use in production. */
  defaultConfig,
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  useToken: useToken2,
  defaultAlgorithm: derivative,
  darkAlgorithm: dark_default,
  compactAlgorithm: compact_default2,
  getDesignToken: getDesignToken_default
};

// packages/ant-design/components/time-picker/index.tsx
import * as React556 from "react";
var { TimePicker: InternalTimePicker, RangePicker: InternalRangePicker } = date_picker_default;
var RangePicker2 = React556.forwardRef((props, ref) => /* @__PURE__ */ React556.createElement(InternalRangePicker, { ...props, picker: "time", mode: void 0, ref }));
var TimePicker = React556.forwardRef(
  ({ addon, renderExtraFooter, ...restProps }, ref) => {
    if (true) {
      const warning5 = devUseWarning("TimePicker");
      warning5.deprecated(!addon, "addon", "renderExtraFooter");
    }
    const internalRenderExtraFooter = React556.useMemo(() => {
      if (renderExtraFooter) {
        return renderExtraFooter;
      }
      if (addon) {
        return addon;
      }
      return void 0;
    }, [addon, renderExtraFooter]);
    return /* @__PURE__ */ React556.createElement(
      InternalTimePicker,
      {
        ...restProps,
        mode: void 0,
        ref,
        renderExtraFooter: internalRenderExtraFooter
      }
    );
  }
);
if (true) {
  TimePicker.displayName = "TimePicker";
}
var PurePanel16 = PurePanel_default3(TimePicker, "picker");
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel16;
TimePicker.RangePicker = RangePicker2;
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel16;
var time_picker_default = TimePicker;

// packages/ant-design/components/timeline/Timeline.tsx
var import_classnames251 = __toESM(require_classnames());
import * as React559 from "react";

// packages/ant-design/components/timeline/style/index.ts
var genTimelineStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, calc } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      margin: 0,
      padding: 0,
      listStyle: "none",
      [`${componentCls}-item`]: {
        position: "relative",
        margin: 0,
        paddingBottom: token2.itemPaddingBottom,
        fontSize: token2.fontSize,
        listStyle: "none",
        "&-tail": {
          position: "absolute",
          insetBlockStart: token2.itemHeadSize,
          insetInlineStart: calc(calc(token2.itemHeadSize).sub(token2.tailWidth)).div(2).equal(),
          height: `calc(100% - ${unit(token2.itemHeadSize)})`,
          borderInlineStart: `${unit(token2.tailWidth)} ${token2.lineType} ${token2.tailColor}`
        },
        "&-pending": {
          [`${componentCls}-item-head`]: {
            fontSize: token2.fontSizeSM,
            backgroundColor: "transparent"
          },
          [`${componentCls}-item-tail`]: {
            display: "none"
          }
        },
        "&-head": {
          position: "absolute",
          width: token2.itemHeadSize,
          height: token2.itemHeadSize,
          backgroundColor: token2.dotBg,
          border: `${unit(token2.dotBorderWidth)} ${token2.lineType} transparent`,
          borderRadius: "50%",
          "&-blue": {
            color: token2.colorPrimary,
            borderColor: token2.colorPrimary
          },
          "&-red": {
            color: token2.colorError,
            borderColor: token2.colorError
          },
          "&-green": {
            color: token2.colorSuccess,
            borderColor: token2.colorSuccess
          },
          "&-gray": {
            color: token2.colorTextDisabled,
            borderColor: token2.colorTextDisabled
          }
        },
        "&-head-custom": {
          position: "absolute",
          insetBlockStart: calc(token2.itemHeadSize).div(2).equal(),
          insetInlineStart: calc(token2.itemHeadSize).div(2).equal(),
          width: "auto",
          height: "auto",
          marginBlockStart: 0,
          paddingBlock: token2.customHeadPaddingVertical,
          lineHeight: 1,
          textAlign: "center",
          border: 0,
          borderRadius: 0,
          transform: `translate(-50%, -50%)`
        },
        "&-content": {
          position: "relative",
          insetBlockStart: calc(calc(token2.fontSize).mul(token2.lineHeight).sub(token2.fontSize)).mul(-1).add(token2.lineWidth).equal(),
          marginInlineStart: calc(token2.margin).add(token2.itemHeadSize).equal(),
          marginInlineEnd: 0,
          marginBlockStart: 0,
          marginBlockEnd: 0,
          wordBreak: "break-word"
        },
        "&-last": {
          [`> ${componentCls}-item-tail`]: {
            display: "none"
          },
          [`> ${componentCls}-item-content`]: {
            minHeight: calc(token2.controlHeightLG).mul(1.2).equal()
          }
        }
      },
      [`&${componentCls}-alternate,
        &${componentCls}-right,
        &${componentCls}-label`]: {
        [`${componentCls}-item`]: {
          "&-tail, &-head, &-head-custom": {
            insetInlineStart: "50%"
          },
          "&-head": {
            marginInlineStart: calc(token2.marginXXS).mul(-1).equal(),
            "&-custom": {
              marginInlineStart: calc(token2.tailWidth).div(2).equal()
            }
          },
          "&-left": {
            [`${componentCls}-item-content`]: {
              insetInlineStart: `calc(50% - ${unit(token2.marginXXS)})`,
              width: `calc(50% - ${unit(token2.marginSM)})`,
              textAlign: "start"
            }
          },
          "&-right": {
            [`${componentCls}-item-content`]: {
              width: `calc(50% - ${unit(token2.marginSM)})`,
              margin: 0,
              textAlign: "end"
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`${componentCls}-item-right`]: {
          [`${componentCls}-item-tail,
            ${componentCls}-item-head,
            ${componentCls}-item-head-custom`]: {
            insetInlineStart: `calc(100% - ${unit(
              calc(calc(token2.itemHeadSize).add(token2.tailWidth)).div(2).equal()
            )})`
          },
          [`${componentCls}-item-content`]: {
            width: `calc(100% - ${unit(calc(token2.itemHeadSize).add(token2.marginXS).equal())})`
          }
        }
      },
      [`&${componentCls}-pending
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: {
        display: "block",
        height: `calc(100% - ${unit(token2.margin)})`,
        borderInlineStart: `${unit(token2.tailWidth)} dotted ${token2.tailColor}`
      },
      [`&${componentCls}-reverse
        ${componentCls}-item-last
        ${componentCls}-item-tail`]: {
        display: "none"
      },
      [`&${componentCls}-reverse ${componentCls}-item-pending`]: {
        [`${componentCls}-item-tail`]: {
          insetBlockStart: token2.margin,
          display: "block",
          height: `calc(100% - ${unit(token2.margin)})`,
          borderInlineStart: `${unit(token2.tailWidth)} dotted ${token2.tailColor}`
        },
        [`${componentCls}-item-content`]: {
          minHeight: calc(token2.controlHeightLG).mul(1.2).equal()
        }
      },
      [`&${componentCls}-label`]: {
        [`${componentCls}-item-label`]: {
          position: "absolute",
          insetBlockStart: calc(calc(token2.fontSize).mul(token2.lineHeight).sub(token2.fontSize)).mul(-1).add(token2.tailWidth).equal(),
          width: `calc(50% - ${unit(token2.marginSM)})`,
          textAlign: "end"
        },
        [`${componentCls}-item-right`]: {
          [`${componentCls}-item-label`]: {
            insetInlineStart: `calc(50% + ${unit(token2.marginSM)})`,
            width: `calc(50% - ${unit(token2.marginSM)})`,
            textAlign: "start"
          }
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-item-head-custom`]: {
          transform: `translate(50%, -50%)`
        }
      }
    }
  };
}, "genTimelineStyle");
var prepareComponentToken53 = /* @__PURE__ */ __name((token2) => ({
  tailColor: token2.colorSplit,
  tailWidth: token2.lineWidthBold,
  dotBorderWidth: token2.wireframe ? token2.lineWidthBold : token2.lineWidth * 3,
  dotBg: token2.colorBgContainer,
  itemPaddingBottom: token2.padding * 1.25
}), "prepareComponentToken");
var style_default59 = genStyleHooks(
  "Timeline",
  (token2) => {
    const timeLineToken = merge2(token2, {
      itemHeadSize: 10,
      customHeadPaddingVertical: token2.paddingXXS,
      paddingInlineEnd: 2
    });
    return [genTimelineStyle(timeLineToken)];
  },
  prepareComponentToken53
);

// packages/ant-design/components/timeline/TimelineItem.tsx
var import_classnames249 = __toESM(require_classnames());
import * as React557 from "react";
var TimelineItem = /* @__PURE__ */ __name(({
  prefixCls: customizePrefixCls,
  className,
  color = "blue",
  dot,
  pending = false,
  position: position2,
  label,
  children,
  ...restProps
}) => {
  const { getPrefixCls } = React557.useContext(ConfigContext);
  const prefixCls = getPrefixCls("timeline", customizePrefixCls);
  const itemClassName = (0, import_classnames249.default)(
    `${prefixCls}-item`,
    {
      [`${prefixCls}-item-pending`]: pending
    },
    className
  );
  const customColor = /blue|red|green|gray/.test(color || "") ? void 0 : color;
  const dotClassName = (0, import_classnames249.default)(`${prefixCls}-item-head`, {
    [`${prefixCls}-item-head-custom`]: !!dot,
    [`${prefixCls}-item-head-${color}`]: !customColor
  });
  return /* @__PURE__ */ React557.createElement("li", { ...restProps, className: itemClassName }, label && /* @__PURE__ */ React557.createElement("div", { className: `${prefixCls}-item-label` }, label), /* @__PURE__ */ React557.createElement("div", { className: `${prefixCls}-item-tail` }), /* @__PURE__ */ React557.createElement("div", { className: dotClassName, style: { borderColor: customColor, color: customColor } }, dot), /* @__PURE__ */ React557.createElement("div", { className: `${prefixCls}-item-content` }, children));
}, "TimelineItem");
var TimelineItem_default = TimelineItem;

// packages/ant-design/components/timeline/TimelineItemList.tsx
var import_LoadingOutlined8 = __toESM(require_LoadingOutlined3());
var import_classnames250 = __toESM(require_classnames());
import * as React558 from "react";
var TimelineItemList = /* @__PURE__ */ __name(({
  prefixCls,
  className,
  pending = false,
  children,
  items,
  rootClassName,
  reverse = false,
  direction,
  hashId,
  pendingDot,
  mode = "",
  ...restProps
}) => {
  const getPositionCls = /* @__PURE__ */ __name((position2, idx) => {
    if (mode === "alternate") {
      if (position2 === "right")
        return `${prefixCls}-item-right`;
      if (position2 === "left")
        return `${prefixCls}-item-left`;
      return idx % 2 === 0 ? `${prefixCls}-item-left` : `${prefixCls}-item-right`;
    }
    if (mode === "left")
      return `${prefixCls}-item-left`;
    if (mode === "right")
      return `${prefixCls}-item-right`;
    if (position2 === "right")
      return `${prefixCls}-item-right`;
    return "";
  }, "getPositionCls");
  const mergedItems = [...items || []];
  const pendingNode = typeof pending === "boolean" ? null : pending;
  if (pending) {
    mergedItems.push({
      pending: !!pending,
      dot: pendingDot || /* @__PURE__ */ React558.createElement(import_LoadingOutlined8.default, null),
      children: pendingNode
    });
  }
  if (reverse) {
    mergedItems.reverse();
  }
  const itemsCount = mergedItems.length;
  const lastCls = `${prefixCls}-item-last`;
  const itemsList = mergedItems.filter((item) => !!item).map((item, idx) => {
    const pendingClass = idx === itemsCount - 2 ? lastCls : "";
    const readyClass = idx === itemsCount - 1 ? lastCls : "";
    const { className: itemClassName, ...itemProps } = item;
    return /* @__PURE__ */ React558.createElement(
      TimelineItem_default,
      {
        ...itemProps,
        className: (0, import_classnames250.default)([
          itemClassName,
          !reverse && !!pending ? pendingClass : readyClass,
          getPositionCls(item?.position ?? "", idx)
        ]),
        key: item?.key || idx
      }
    );
  });
  const hasLabelItem = mergedItems.some((item) => !!item?.label);
  const classString = (0, import_classnames250.default)(
    prefixCls,
    {
      [`${prefixCls}-pending`]: !!pending,
      [`${prefixCls}-reverse`]: !!reverse,
      [`${prefixCls}-${mode}`]: !!mode && !hasLabelItem,
      [`${prefixCls}-label`]: hasLabelItem,
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId
  );
  return /* @__PURE__ */ React558.createElement("ul", { ...restProps, className: classString }, itemsList);
}, "TimelineItemList");
var TimelineItemList_default = TimelineItemList;

// packages/ant-design/components/timeline/useItems.ts
function useItems5(items, children) {
  if (items && Array.isArray(items)) {
    return items;
  }
  return toArray(children).map((ele) => ({
    children: ele?.props?.children ?? "",
    ...ele.props
  }));
}
__name(useItems5, "useItems");
var useItems_default2 = useItems5;

// packages/ant-design/components/timeline/Timeline.tsx
var Timeline = /* @__PURE__ */ __name((props) => {
  const { getPrefixCls, direction, timeline } = React559.useContext(ConfigContext);
  const { prefixCls: customizePrefixCls, children, items, className, style: style2, ...restProps } = props;
  const prefixCls = getPrefixCls("timeline", customizePrefixCls);
  if (true) {
    const warning5 = devUseWarning("Timeline");
    warning5.deprecated(!children, "Timeline.Item", "items");
  }
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default59(prefixCls, rootCls);
  const mergedItems = useItems_default2(items, children);
  return wrapCSSVar(
    /* @__PURE__ */ React559.createElement(
      TimelineItemList_default,
      {
        ...restProps,
        className: (0, import_classnames251.default)(timeline?.className, className, cssVarCls, rootCls),
        style: { ...timeline?.style, ...style2 },
        prefixCls,
        direction,
        items: mergedItems,
        hashId
      }
    )
  );
}, "Timeline");
Timeline.Item = TimelineItem_default;
if (true) {
  Timeline.displayName = "Timeline";
}
var Timeline_default = Timeline;

// packages/ant-design/components/timeline/index.ts
var timeline_default = Timeline_default;

// packages/ant-design/components/tour/index.tsx
import React567, { useContext as useContext219 } from "react";

// packages/tour/src/Tour.tsx
import * as React564 from "react";
var import_classnames254 = __toESM(require_classnames());
import { useMemo as useMemo175 } from "react";

// packages/tour/src/hooks/useClosable.tsx
import * as React560 from "react";
function isConfigObj(closable) {
  return closable !== null && typeof closable === "object";
}
__name(isConfigObj, "isConfigObj");
function getClosableConfig(closable, closeIcon, preset) {
  if (closable === false || closeIcon === false && (!isConfigObj(closable) || !closable.closeIcon)) {
    return null;
  }
  const mergedCloseIcon = typeof closeIcon !== "boolean" ? closeIcon : void 0;
  if (isConfigObj(closable)) {
    return {
      ...closable,
      closeIcon: closable.closeIcon ?? mergedCloseIcon
    };
  }
  return preset || closable || closeIcon ? {
    closeIcon: mergedCloseIcon
  } : "empty";
}
__name(getClosableConfig, "getClosableConfig");
function useClosable2(stepClosable, stepCloseIcon, closable, closeIcon) {
  return React560.useMemo(() => {
    const stepClosableConfig = getClosableConfig(
      stepClosable,
      stepCloseIcon,
      false
    );
    const rootClosableConfig = getClosableConfig(closable, closeIcon, true);
    if (stepClosableConfig !== "empty") {
      return stepClosableConfig;
    }
    return rootClosableConfig;
  }, [closable, closeIcon, stepClosable, stepCloseIcon]);
}
__name(useClosable2, "useClosable");

// packages/tour/src/hooks/useTarget.ts
import { useMemo as useMemo174, useState as useState137 } from "react";

// packages/tour/src/util.ts
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const { top, right, bottom, left } = element.getBoundingClientRect();
  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
__name(isInViewPort, "isInViewPort");
function getPlacement(targetElement, placement, stepPlacement) {
  return stepPlacement ?? placement ?? (targetElement === null ? "center" : "bottom");
}
__name(getPlacement, "getPlacement");

// packages/tour/src/hooks/useTarget.ts
function useTarget(target, open3, gap, scrollIntoViewOptions) {
  const [targetElement, setTargetElement] = useState137(void 0);
  useLayoutEffect_default(() => {
    const nextElement = typeof target === "function" ? target() : target;
    setTargetElement(nextElement || null);
  });
  const [posInfo, setPosInfo] = useState137(null);
  const updatePos = useEvent(() => {
    if (targetElement) {
      if (!isInViewPort(targetElement) && open3) {
        targetElement.scrollIntoView(scrollIntoViewOptions);
      }
      const { left, top, width, height } = targetElement.getBoundingClientRect();
      const nextPosInfo = { left, top, width, height, radius: 0 };
      setPosInfo((origin) => {
        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {
          return nextPosInfo;
        }
        return origin;
      });
    } else {
      setPosInfo(null);
    }
  });
  const getGapOffset = /* @__PURE__ */ __name((index3) => (Array.isArray(gap?.offset) ? gap?.offset[index3] : gap?.offset) ?? 6, "getGapOffset");
  useLayoutEffect_default(() => {
    updatePos();
    window.addEventListener("resize", updatePos);
    return () => {
      window.removeEventListener("resize", updatePos);
    };
  }, [targetElement, open3, updatePos]);
  const mergedPosInfo = useMemo174(() => {
    if (!posInfo) {
      return posInfo;
    }
    const gapOffsetX = getGapOffset(0);
    const gapOffsetY = getGapOffset(1);
    const gapRadius = gap?.radius || 2;
    return {
      left: posInfo.left - gapOffsetX,
      top: posInfo.top - gapOffsetY,
      width: posInfo.width + gapOffsetX * 2,
      height: posInfo.height + gapOffsetY * 2,
      radius: gapRadius
    };
  }, [posInfo, gap]);
  return [mergedPosInfo, targetElement];
}
__name(useTarget, "useTarget");

// packages/tour/src/Mask.tsx
var import_classnames252 = __toESM(require_classnames());
import React561 from "react";
var COVER_PROPS = {
  fill: "transparent",
  pointerEvents: "auto"
};
var Mask3 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    rootClassName,
    pos,
    showMask,
    style: style2 = {},
    fill = "rgba(0,0,0,0.5)",
    open: open3,
    animated,
    zIndex,
    disabledInteraction
  } = props;
  const id = useId_default();
  const maskId = `${prefixCls}-mask-${id}`;
  const mergedAnimated = typeof animated === "object" ? animated?.placeholder : animated;
  const isSafari = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const maskRectSize = isSafari ? { width: "100%", height: "100%" } : { width: "100vw", height: "100vh" };
  return /* @__PURE__ */ React561.createElement(es_default4, { open: open3, autoLock: true }, /* @__PURE__ */ React561.createElement(
    "div",
    {
      className: (0, import_classnames252.default)(`${prefixCls}-mask`, rootClassName),
      style: {
        position: "fixed",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex,
        pointerEvents: pos && !disabledInteraction ? "none" : "auto",
        ...style2
      }
    },
    showMask ? /* @__PURE__ */ React561.createElement(
      "svg",
      {
        style: {
          width: "100%",
          height: "100%"
        }
      },
      /* @__PURE__ */ React561.createElement("defs", null, /* @__PURE__ */ React561.createElement("mask", { id: maskId }, /* @__PURE__ */ React561.createElement("rect", { x: "0", y: "0", ...maskRectSize, fill: "white" }), pos && /* @__PURE__ */ React561.createElement(
        "rect",
        {
          x: pos.left,
          y: pos.top,
          rx: pos.radius,
          width: pos.width,
          height: pos.height,
          fill: "black",
          className: mergedAnimated ? `${prefixCls}-placeholder-animated` : ""
        }
      ))),
      /* @__PURE__ */ React561.createElement(
        "rect",
        {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          fill,
          mask: `url(#${maskId})`
        }
      ),
      pos && /* @__PURE__ */ React561.createElement(React561.Fragment, null, /* @__PURE__ */ React561.createElement(
        "rect",
        {
          ...COVER_PROPS,
          x: "0",
          y: "0",
          width: "100%",
          height: pos.top
        }
      ), /* @__PURE__ */ React561.createElement(
        "rect",
        {
          ...COVER_PROPS,
          x: "0",
          y: "0",
          width: pos.left,
          height: "100%"
        }
      ), /* @__PURE__ */ React561.createElement(
        "rect",
        {
          ...COVER_PROPS,
          x: "0",
          y: pos.top + pos.height,
          width: "100%",
          height: `calc(100vh - ${pos.top + pos.height}px)`
        }
      ), /* @__PURE__ */ React561.createElement(
        "rect",
        {
          ...COVER_PROPS,
          x: pos.left + pos.width,
          y: "0",
          width: `calc(100vw - ${pos.left + pos.width}px)`,
          height: "100%"
        }
      ))
    ) : null
  ));
}, "Mask");
var Mask_default = Mask3;

// packages/tour/src/placements.tsx
var targetOffset3 = [0, 0];
var basePlacements = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function getPlacements2(arrowPointAtCenter = false) {
  const placements5 = {};
  Object.keys(basePlacements).forEach((key) => {
    placements5[key] = { ...basePlacements[key], autoArrow: arrowPointAtCenter, targetOffset: targetOffset3 };
  });
  return placements5;
}
__name(getPlacements2, "getPlacements");
var placements4 = getPlacements2();

// packages/tour/src/TourStep/index.tsx
import * as React563 from "react";

// packages/tour/src/TourStep/DefaultPanel.tsx
var import_classnames253 = __toESM(require_classnames());
import * as React562 from "react";
function DefaultPanel(props) {
  const {
    prefixCls,
    current,
    total,
    title,
    description,
    onClose,
    onPrev,
    onNext,
    onFinish,
    className,
    closable
  } = props;
  const ariaProps = pickAttrs(closable || {}, true);
  const closeIcon = closable?.closeIcon ?? /* @__PURE__ */ React562.createElement("span", { className: `${prefixCls}-close-x` }, "\xD7");
  const mergedClosable = !!closable;
  return /* @__PURE__ */ React562.createElement("div", { className: (0, import_classnames253.default)(`${prefixCls}-content`, className) }, /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-inner` }, mergedClosable && /* @__PURE__ */ React562.createElement(
    "button",
    {
      type: "button",
      onClick: onClose,
      "aria-label": "Close",
      ...ariaProps,
      className: `${prefixCls}-close`
    },
    closeIcon
  ), /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-title` }, title)), /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-description` }, description), /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-footer` }, /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-sliders` }, total > 1 ? [...Array.from({ length: total }).keys()].map((item, index3) => {
    return /* @__PURE__ */ React562.createElement(
      "span",
      {
        key: item,
        className: index3 === current ? "active" : ""
      }
    );
  }) : null), /* @__PURE__ */ React562.createElement("div", { className: `${prefixCls}-buttons` }, current !== 0 ? /* @__PURE__ */ React562.createElement("button", { className: `${prefixCls}-prev-btn`, onClick: onPrev }, "Prev") : null, current === total - 1 ? /* @__PURE__ */ React562.createElement("button", { className: `${prefixCls}-finish-btn`, onClick: onFinish }, "Finish") : /* @__PURE__ */ React562.createElement("button", { className: `${prefixCls}-next-btn`, onClick: onNext }, "Next")))));
}
__name(DefaultPanel, "DefaultPanel");

// packages/tour/src/TourStep/index.tsx
var TourStep = /* @__PURE__ */ __name((props) => {
  const { current, renderPanel } = props;
  return /* @__PURE__ */ React563.createElement(React563.Fragment, null, typeof renderPanel === "function" ? renderPanel(props, current) : /* @__PURE__ */ React563.createElement(DefaultPanel, { ...props }));
}, "TourStep");
var TourStep_default = TourStep;

// packages/tour/src/Tour.tsx
var CENTER_PLACEHOLDER = {
  left: "50%",
  top: "50%",
  width: 1,
  height: 1
};
var defaultScrollIntoViewOptions = {
  block: "center",
  inline: "center"
};
var Tour = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls = "rc-tour",
    steps = [],
    defaultCurrent,
    current,
    onChange,
    onClose,
    onFinish,
    open: open3,
    mask = true,
    arrow = true,
    rootClassName,
    placement,
    renderPanel,
    gap,
    animated,
    scrollIntoViewOptions = defaultScrollIntoViewOptions,
    zIndex = 1001,
    closeIcon,
    closable,
    builtinPlacements,
    disabledInteraction,
    ...restProps
  } = props;
  const triggerRef = React564.useRef();
  const [mergedCurrent, setMergedCurrent] = useMergedState(0, {
    value: current,
    defaultValue: defaultCurrent
  });
  const [mergedOpen, setMergedOpen] = useMergedState(void 0, {
    value: open3,
    postState: (origin) => mergedCurrent < 0 || mergedCurrent >= steps.length ? false : origin ?? true
  });
  const openRef = React564.useRef(mergedOpen);
  useLayoutEffect_default(() => {
    if (mergedOpen && !openRef.current) {
      setMergedCurrent(0);
    }
    openRef.current = mergedOpen;
  }, [mergedOpen]);
  const {
    target,
    placement: stepPlacement,
    style: stepStyle,
    arrow: stepArrow,
    className: stepClassName,
    mask: stepMask,
    scrollIntoViewOptions: stepScrollIntoViewOptions = defaultScrollIntoViewOptions,
    closeIcon: stepCloseIcon,
    closable: stepClosable
  } = steps[mergedCurrent] || {};
  const mergedClosable = useClosable2(
    stepClosable,
    stepCloseIcon,
    closable,
    closeIcon
  );
  const mergedMask = mergedOpen && (stepMask ?? mask);
  const mergedScrollIntoViewOptions = stepScrollIntoViewOptions ?? scrollIntoViewOptions;
  const [posInfo, targetElement] = useTarget(
    target,
    open3,
    gap,
    mergedScrollIntoViewOptions
  );
  const mergedPlacement = getPlacement(targetElement, placement, stepPlacement);
  const mergedArrow = targetElement ? typeof stepArrow === "undefined" ? arrow : stepArrow : false;
  const arrowPointAtCenter = typeof mergedArrow === "object" ? mergedArrow.pointAtCenter : false;
  useLayoutEffect_default(() => {
    triggerRef.current?.forceAlign();
  }, [arrowPointAtCenter, mergedCurrent]);
  const onInternalChange = /* @__PURE__ */ __name((nextCurrent) => {
    setMergedCurrent(nextCurrent);
    onChange?.(nextCurrent);
  }, "onInternalChange");
  const mergedBuiltinPlacements2 = useMemo175(() => {
    if (builtinPlacements) {
      return typeof builtinPlacements === "function" ? builtinPlacements({ arrowPointAtCenter }) : builtinPlacements;
    }
    return getPlacements2(arrowPointAtCenter);
  }, [builtinPlacements, arrowPointAtCenter]);
  if (targetElement === void 0) {
    return null;
  }
  const handleClose = /* @__PURE__ */ __name(() => {
    setMergedOpen(false);
    onClose?.(mergedCurrent);
  }, "handleClose");
  const getPopupElement = /* @__PURE__ */ __name(() => /* @__PURE__ */ React564.createElement(
    TourStep_default,
    {
      arrow: mergedArrow,
      key: "content",
      prefixCls,
      total: steps.length,
      renderPanel,
      onPrev: () => {
        onInternalChange(mergedCurrent - 1);
      },
      onNext: () => {
        onInternalChange(mergedCurrent + 1);
      },
      onClose: handleClose,
      current: mergedCurrent,
      onFinish: () => {
        handleClose();
        onFinish?.();
      },
      ...steps[mergedCurrent],
      closable: mergedClosable
    }
  ), "getPopupElement");
  const mergedShowMask = typeof mergedMask === "boolean" ? mergedMask : !!mergedMask;
  const mergedMaskStyle = typeof mergedMask === "boolean" ? void 0 : mergedMask;
  const getTriggerDOMNode = /* @__PURE__ */ __name((node2) => {
    return node2 || targetElement || document.body;
  }, "getTriggerDOMNode");
  return /* @__PURE__ */ React564.createElement(React564.Fragment, null, /* @__PURE__ */ React564.createElement(
    Mask_default,
    {
      zIndex,
      prefixCls,
      pos: posInfo,
      showMask: mergedShowMask,
      style: mergedMaskStyle?.style,
      fill: mergedMaskStyle?.color,
      open: mergedOpen,
      animated,
      rootClassName,
      disabledInteraction
    }
  ), /* @__PURE__ */ React564.createElement(
    src_default5,
    {
      ...restProps,
      builtinPlacements: mergedBuiltinPlacements2,
      ref: triggerRef,
      popupStyle: stepStyle,
      popupPlacement: mergedPlacement,
      popupVisible: mergedOpen,
      popupClassName: (0, import_classnames254.default)(rootClassName, stepClassName),
      prefixCls,
      popup: getPopupElement,
      forceRender: false,
      destroyPopupOnHide: true,
      zIndex,
      getTriggerDOMNode,
      arrow: !!mergedArrow
    },
    /* @__PURE__ */ React564.createElement(es_default4, { open: mergedOpen, autoLock: true }, /* @__PURE__ */ React564.createElement(
      "div",
      {
        className: (0, import_classnames254.default)(
          rootClassName,
          `${prefixCls}-target-placeholder`
        ),
        style: {
          ...posInfo || CENTER_PLACEHOLDER,
          position: "fixed",
          pointerEvents: "none"
        }
      }
    ))
  ));
}, "Tour");
var Tour_default = Tour;

// packages/tour/src/index.tsx
var src_default29 = Tour_default;

// packages/ant-design/components/tour/index.tsx
var import_classnames257 = __toESM(require_classnames());

// packages/ant-design/components/tour/panelRender.tsx
var import_CloseOutlined13 = __toESM(require_CloseOutlined3());
var import_classnames255 = __toESM(require_classnames());
import React565 from "react";
function isValidNode(node2) {
  return node2 !== void 0 && node2 !== null;
}
__name(isValidNode, "isValidNode");
var TourPanel = /* @__PURE__ */ __name((props) => {
  const { stepProps, current, type: type5, indicatorsRender } = props;
  const {
    prefixCls,
    total = 1,
    title,
    onClose,
    onPrev,
    onNext,
    onFinish,
    cover,
    description,
    nextButtonProps,
    prevButtonProps,
    type: stepType,
    closable
  } = stepProps;
  const mergedType = stepType ?? type5;
  const mergedCloseIcon = React565.useMemo(() => {
    let defaultCloseIcon = /* @__PURE__ */ React565.createElement(import_CloseOutlined13.default, { className: `${prefixCls}-close-icon` });
    if (closable && closable.closeIcon) {
      defaultCloseIcon = closable.closeIcon;
    }
    return /* @__PURE__ */ React565.createElement("button", { type: "button", onClick: onClose, className: `${prefixCls}-close` }, defaultCloseIcon);
  }, [closable]);
  const isLastStep = current === total - 1;
  const prevBtnClick = /* @__PURE__ */ __name(() => {
    onPrev?.();
    prevButtonProps?.onClick?.();
  }, "prevBtnClick");
  const nextBtnClick = /* @__PURE__ */ __name(() => {
    if (isLastStep) {
      onFinish?.();
    } else {
      onNext?.();
    }
    nextButtonProps?.onClick?.();
  }, "nextBtnClick");
  const headerNode = isValidNode(title) ? /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-header` }, /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-title` }, title)) : null;
  const descriptionNode = isValidNode(description) ? /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-description` }, description) : null;
  const coverNode = isValidNode(cover) ? /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-cover` }, cover) : null;
  let mergedIndicatorNode;
  if (indicatorsRender) {
    mergedIndicatorNode = indicatorsRender(current, total);
  } else {
    mergedIndicatorNode = [...Array.from({ length: total }).keys()].map(
      (stepItem, index3) => /* @__PURE__ */ React565.createElement(
        "span",
        {
          key: stepItem,
          className: (0, import_classnames255.default)(
            index3 === current && `${prefixCls}-indicator-active`,
            `${prefixCls}-indicator`
          )
        }
      )
    );
  }
  const mainBtnType = mergedType === "primary" ? "default" : "primary";
  const secondaryBtnProps = {
    type: "default",
    ghost: mergedType === "primary"
  };
  const [contextLocale] = useLocale_default("Tour", en_US_default6.Tour);
  return /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-content` }, /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-inner` }, closable && mergedCloseIcon, coverNode, headerNode, descriptionNode, /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-footer` }, total > 1 && /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-indicators` }, mergedIndicatorNode), /* @__PURE__ */ React565.createElement("div", { className: `${prefixCls}-buttons` }, current !== 0 ? /* @__PURE__ */ React565.createElement(
    button_default2,
    {
      ...secondaryBtnProps,
      ...prevButtonProps,
      onClick: prevBtnClick,
      size: "small",
      className: (0, import_classnames255.default)(`${prefixCls}-prev-btn`, prevButtonProps?.className)
    },
    prevButtonProps?.children ?? contextLocale?.Previous
  ) : null, /* @__PURE__ */ React565.createElement(
    button_default2,
    {
      type: mainBtnType,
      ...nextButtonProps,
      onClick: nextBtnClick,
      size: "small",
      className: (0, import_classnames255.default)(`${prefixCls}-next-btn`, nextButtonProps?.className)
    },
    nextButtonProps?.children ?? (isLastStep ? contextLocale?.Finish : contextLocale?.Next)
  )))));
}, "TourPanel");
var panelRender_default = TourPanel;

// packages/ant-design/components/tour/PurePanel.tsx
var import_classnames256 = __toESM(require_classnames());
import * as React566 from "react";

// packages/ant-design/components/tour/style/index.ts
init_public_api();
var genBaseStyle17 = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    lineHeight,
    padding,
    paddingXS,
    borderRadius,
    borderRadiusXS,
    colorPrimary,
    colorText,
    colorFill,
    indicatorHeight,
    indicatorWidth,
    boxShadowTertiary,
    tourZIndexPopup,
    fontSize,
    colorBgElevated,
    fontWeightStrong,
    marginXS,
    colorTextLightSolid,
    tourBorderRadius,
    colorWhite,
    primaryNextBtnHoverBg,
    closeBtnSize,
    motionDurationSlow,
    antCls,
    primaryPrevBtnBg
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        color: colorText,
        position: "absolute",
        zIndex: tourZIndexPopup,
        display: "block",
        visibility: "visible",
        fontSize,
        lineHeight,
        width: 520,
        "--antd-arrow-background-color": colorBgElevated,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${componentCls}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: tourBorderRadius,
          boxShadow: boxShadowTertiary,
          position: "relative",
          backgroundColor: colorBgElevated,
          border: "none",
          backgroundClip: "padding-box",
          [`${componentCls}-close`]: {
            position: "absolute",
            top: padding,
            insetInlineEnd: padding,
            color: token2.colorIcon,
            background: "none",
            border: "none",
            width: closeBtnSize,
            height: closeBtnSize,
            borderRadius: token2.borderRadiusSM,
            transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            "&:hover": {
              color: token2.colorIconHover,
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            ...genFocusStyle(token2)
          },
          [`${componentCls}-cover`]: {
            textAlign: "center",
            padding: `${unit(token2.calc(padding).add(closeBtnSize).add(paddingXS).equal())} ${unit(
              padding
            )} 0`,
            img: {
              width: "100%"
            }
          },
          [`${componentCls}-header`]: {
            padding: `${unit(padding)} ${unit(padding)} ${unit(paddingXS)}`,
            [`${componentCls}-title`]: {
              lineHeight,
              fontSize,
              fontWeight: fontWeightStrong
            }
          },
          [`${componentCls}-description`]: {
            padding: `0 ${unit(padding)}`,
            lineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            padding: `${unit(paddingXS)} ${unit(padding)} ${unit(padding)}`,
            textAlign: "end",
            borderRadius: `0 0 ${unit(borderRadiusXS)} ${unit(borderRadiusXS)}`,
            display: "flex",
            [`${componentCls}-indicators`]: {
              display: "inline-block",
              [`${componentCls}-indicator`]: {
                width: indicatorWidth,
                height: indicatorHeight,
                display: "inline-block",
                borderRadius: "50%",
                background: colorFill,
                "&:not(:last-child)": {
                  marginInlineEnd: indicatorHeight
                },
                "&-active": {
                  background: colorPrimary
                }
              }
            },
            [`${componentCls}-buttons`]: {
              marginInlineStart: "auto",
              [`${antCls}-btn`]: {
                marginInlineStart: marginXS
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${componentCls}-primary, &${componentCls}-primary`]: {
          "--antd-arrow-background-color": colorPrimary,
          [`${componentCls}-inner`]: {
            color: colorTextLightSolid,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: colorPrimary,
            borderRadius,
            boxShadow: boxShadowTertiary,
            [`${componentCls}-close`]: {
              color: colorTextLightSolid
            },
            [`${componentCls}-indicators`]: {
              [`${componentCls}-indicator`]: {
                background: primaryPrevBtnBg,
                "&-active": {
                  background: colorTextLightSolid
                }
              }
            },
            [`${componentCls}-prev-btn`]: {
              color: colorTextLightSolid,
              borderColor: primaryPrevBtnBg,
              backgroundColor: colorPrimary,
              "&:hover": {
                backgroundColor: primaryPrevBtnBg,
                borderColor: "transparent"
              }
            },
            [`${componentCls}-next-btn`]: {
              color: colorPrimary,
              borderColor: "transparent",
              background: colorWhite,
              "&:hover": {
                background: primaryNextBtnHoverBg
              }
            }
          }
        }
      },
      // ============================= mask ===========================
      [`${componentCls}-mask`]: {
        [`${componentCls}-placeholder-animated`]: {
          transition: `all ${motionDurationSlow}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [[
        "&-placement-left",
        "&-placement-leftTop",
        "&-placement-leftBottom",
        "&-placement-right",
        "&-placement-rightTop",
        "&-placement-rightBottom"
      ].join(",")]: {
        [`${componentCls}-inner`]: {
          borderRadius: token2.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
        }
      }
    },
    // ============================= Arrow ===========================
    getArrowStyle(token2, "var(--antd-arrow-background-color)")
  ];
}, "genBaseStyle");
var prepareComponentToken54 = /* @__PURE__ */ __name((token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 70,
  closeBtnSize: token2.fontSize * token2.lineHeight,
  primaryPrevBtnBg: new TinyColor(token2.colorTextLightSolid).setAlpha(0.15).toRgbString(),
  primaryNextBtnHoverBg: new TinyColor(token2.colorBgTextHover).onBackground(token2.colorWhite).toRgbString(),
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token2)
}), "prepareComponentToken");
var style_default60 = genStyleHooks(
  "Tour",
  (token2) => {
    const { borderRadiusLG } = token2;
    const TourToken = merge2(token2, {
      indicatorWidth: 6,
      indicatorHeight: 6,
      tourBorderRadius: borderRadiusLG
    });
    return [genBaseStyle17(TourToken)];
  },
  prepareComponentToken54
);

// packages/ant-design/components/tour/PurePanel.tsx
var PurePanel17 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    current = 0,
    total = 6,
    className,
    style: style2,
    type: type5,
    closable,
    closeIcon,
    ...restProps
  } = props;
  const { getPrefixCls } = React566.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default60(prefixCls);
  const [mergedClosable, mergedCloseIcon] = useClosable({ closable, closeIcon }, null, {
    closable: true,
    closeIconRender: (icon) => React566.isValidElement(icon) ? cloneElement3(icon, {
      className: (0, import_classnames256.default)(icon.props.className, `${prefixCls}-close-icon`)
    }) : icon
  });
  return wrapCSSVar(
    /* @__PURE__ */ React566.createElement(
      RawPurePanel,
      {
        prefixCls,
        hashId,
        className: (0, import_classnames256.default)(
          className,
          `${prefixCls}-pure`,
          type5 && `${prefixCls}-${type5}`,
          cssVarCls
        ),
        style: style2
      },
      /* @__PURE__ */ React566.createElement(
        panelRender_default,
        {
          stepProps: {
            ...restProps,
            prefixCls,
            total,
            closable: mergedClosable ? { closeIcon: mergedCloseIcon } : void 0
          },
          current,
          type: type5
        }
      )
    )
  );
}, "PurePanel");
var PurePanel_default9 = withPureRenderTheme(PurePanel17);

// packages/ant-design/components/tour/index.tsx
var Tour2 = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls: customizePrefixCls,
    type: type5,
    rootClassName,
    indicatorsRender,
    steps,
    closeIcon,
    ...restProps
  } = props;
  const { getPrefixCls, direction, tour } = useContext219(ConfigContext);
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default60(prefixCls);
  const [, token2] = useToken();
  const mergedSteps = React567.useMemo(
    () => steps?.map((step) => ({
      ...step,
      className: (0, import_classnames257.default)(step.className, {
        [`${prefixCls}-primary`]: (step.type ?? type5) === "primary"
      })
    })),
    [steps, type5]
  );
  const builtinPlacements = /* @__PURE__ */ __name((config) => getPlacements({
    arrowPointAtCenter: config?.arrowPointAtCenter ?? true,
    autoAdjustOverflow: true,
    offset: token2.marginXXS,
    arrowWidth: token2.sizePopupArrow,
    borderRadius: token2.borderRadius
  }), "builtinPlacements");
  const customClassName = (0, import_classnames257.default)(
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    hashId,
    cssVarCls,
    rootClassName
  );
  const mergedRenderPanel = /* @__PURE__ */ __name((stepProps, stepCurrent) => /* @__PURE__ */ React567.createElement(
    panelRender_default,
    {
      type: type5,
      stepProps,
      current: stepCurrent,
      indicatorsRender
    }
  ), "mergedRenderPanel");
  const [zIndex, contextZIndex] = useZIndex("Tour", restProps.zIndex);
  return wrapCSSVar(
    /* @__PURE__ */ React567.createElement(zindexContext_default.Provider, { value: contextZIndex }, /* @__PURE__ */ React567.createElement(
      src_default29,
      {
        ...restProps,
        closeIcon: closeIcon ?? tour?.closeIcon,
        zIndex,
        rootClassName: customClassName,
        prefixCls,
        animated: true,
        renderPanel: mergedRenderPanel,
        builtinPlacements,
        steps: mergedSteps
      }
    ))
  );
}, "Tour");
if (true) {
  Tour2.displayName = "Tour";
}
Tour2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default9;
var tour_default = Tour2;

// packages/ant-design/components/transfer/index.tsx
var import_classnames261 = __toESM(require_classnames());
import React576, { useCallback as useCallback49, useContext as useContext220 } from "react";

// packages/ant-design/components/_util/transKeys.ts
var groupKeysMap = /* @__PURE__ */ __name((keys2) => {
  const map = /* @__PURE__ */ new Map();
  keys2.forEach((key, index3) => {
    map.set(key, index3);
  });
  return map;
}, "groupKeysMap");
var groupDisabledKeysMap = /* @__PURE__ */ __name((dataSource) => {
  const map = /* @__PURE__ */ new Map();
  dataSource.forEach(({ disabled, key }, index3) => {
    if (disabled) {
      map.set(key, index3);
    }
  });
  return map;
}, "groupDisabledKeysMap");

// packages/ant-design/components/transfer/hooks/useData.ts
import * as React568 from "react";
var useData = /* @__PURE__ */ __name((dataSource, rowKey, targetKeys) => {
  const mergedDataSource = React568.useMemo(
    () => (dataSource || []).map((record) => {
      if (rowKey) {
        record = { ...record, key: rowKey(record) };
      }
      return record;
    }),
    [dataSource, rowKey]
  );
  const [leftDataSource, rightDataSource] = React568.useMemo(() => {
    const leftData = [];
    const rightData = new Array((targetKeys || []).length);
    const targetKeysMap = groupKeysMap(targetKeys || []);
    mergedDataSource.forEach((record) => {
      if (targetKeysMap.has(record.key)) {
        rightData[targetKeysMap.get(record.key)] = record;
      } else {
        leftData.push(record);
      }
    });
    return [leftData, rightData];
  }, [mergedDataSource, targetKeys, rowKey]);
  return [mergedDataSource, leftDataSource, rightDataSource];
}, "useData");
var useData_default = useData;

// packages/ant-design/components/transfer/hooks/useSelection.ts
import * as React569 from "react";
var EMPTY_KEYS = [];
function filterKeys(keys2, dataKeys) {
  const filteredKeys = keys2.filter((key) => dataKeys.has(key));
  return keys2.length === filteredKeys.length ? keys2 : filteredKeys;
}
__name(filterKeys, "filterKeys");
function flattenKeys2(keys2) {
  return Array.from(keys2).join(";");
}
__name(flattenKeys2, "flattenKeys");
function useSelection2(leftDataSource, rightDataSource, selectedKeys = EMPTY_KEYS) {
  const [leftKeys, rightKeys] = React569.useMemo(
    () => [
      new Set(leftDataSource.map((src) => src.key)),
      new Set(rightDataSource.map((src) => src.key))
    ],
    [leftDataSource, rightDataSource]
  );
  const [sourceSelectedKeys, setSourceSelectedKeys] = React569.useState(
    () => filterKeys(selectedKeys, leftKeys)
  );
  const [targetSelectedKeys, setTargetSelectedKeys] = React569.useState(
    () => filterKeys(selectedKeys, rightKeys)
  );
  React569.useEffect(() => {
    setSourceSelectedKeys(filterKeys(selectedKeys, leftKeys));
    setTargetSelectedKeys(filterKeys(selectedKeys, rightKeys));
  }, [selectedKeys]);
  React569.useEffect(() => {
    setSourceSelectedKeys(filterKeys(sourceSelectedKeys, leftKeys));
    setTargetSelectedKeys(filterKeys(targetSelectedKeys, rightKeys));
  }, [flattenKeys2(leftKeys), flattenKeys2(rightKeys)]);
  return [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Updater
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ];
}
__name(useSelection2, "useSelection");

// packages/ant-design/components/transfer/list.tsx
var import_DownOutlined5 = __toESM(require_DownOutlined3());
var import_classnames260 = __toESM(require_classnames());
import React574, { useMemo as useMemo179, useRef as useRef176, useState as useState140 } from "react";

// packages/ant-design/components/transfer/ListBody.tsx
var import_classnames259 = __toESM(require_classnames());
import * as React572 from "react";

// packages/ant-design/components/transfer/ListItem.tsx
var import_DeleteOutlined = __toESM(require_DeleteOutlined3());
var import_classnames258 = __toESM(require_classnames());
import * as React571 from "react";

// packages/ant-design/components/_util/transButton.tsx
import * as React570 from "react";
var inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
var TransButton = React570.forwardRef((props, ref) => {
  const onKeyDown2 = /* @__PURE__ */ __name((event) => {
    const { keyCode } = event;
    if (keyCode === KeyCode_default.ENTER) {
      event.preventDefault();
    }
  }, "onKeyDown");
  const onKeyUp = /* @__PURE__ */ __name((event) => {
    const { keyCode } = event;
    const { onClick } = props;
    if (keyCode === KeyCode_default.ENTER && onClick) {
      onClick();
    }
  }, "onKeyUp");
  const { style: style2, noStyle, disabled, ...restProps } = props;
  let mergedStyle = {};
  if (!noStyle) {
    mergedStyle = {
      ...inlineStyle
    };
  }
  if (disabled) {
    mergedStyle.pointerEvents = "none";
  }
  mergedStyle = {
    ...mergedStyle,
    ...style2
  };
  return /* @__PURE__ */ React570.createElement(
    "div",
    {
      role: "button",
      tabIndex: 0,
      ref,
      ...restProps,
      onKeyDown: onKeyDown2,
      onKeyUp,
      style: mergedStyle
    }
  );
});
var transButton_default = TransButton;

// packages/ant-design/components/transfer/ListItem.tsx
var ListItem = /* @__PURE__ */ __name((props) => {
  const {
    renderedText,
    renderedEl,
    item,
    checked,
    disabled,
    prefixCls,
    onClick,
    onRemove,
    showRemove
  } = props;
  const className = (0, import_classnames258.default)(`${prefixCls}-content-item`, {
    [`${prefixCls}-content-item-disabled`]: disabled || item.disabled,
    [`${prefixCls}-content-item-checked`]: checked
  });
  let title;
  if (typeof renderedText === "string" || typeof renderedText === "number") {
    title = String(renderedText);
  }
  const [contextLocale] = useLocale_default("Transfer", en_US_default6.Transfer);
  const liProps = { className, title };
  const labelNode = /* @__PURE__ */ React571.createElement("span", { className: `${prefixCls}-content-item-text` }, renderedEl);
  if (showRemove) {
    return /* @__PURE__ */ React571.createElement("li", { ...liProps }, labelNode, /* @__PURE__ */ React571.createElement(
      transButton_default,
      {
        disabled: disabled || item.disabled,
        className: `${prefixCls}-content-item-remove`,
        "aria-label": contextLocale?.remove,
        onClick: () => {
          onRemove?.(item);
        }
      },
      /* @__PURE__ */ React571.createElement(import_DeleteOutlined.default, null)
    ));
  }
  liProps.onClick = disabled || item.disabled ? void 0 : (event) => onClick(item, event);
  return /* @__PURE__ */ React571.createElement("li", { ...liProps }, /* @__PURE__ */ React571.createElement(
    checkbox_default,
    {
      className: `${prefixCls}-checkbox`,
      checked,
      disabled: disabled || item.disabled
    }
  ), labelNode);
}, "ListItem");
var ListItem_default = React571.memo(ListItem);

// packages/ant-design/components/transfer/ListBody.tsx
var OmitProps = ["handleFilter", "handleClear", "checkedKeys"];
var parsePagination = /* @__PURE__ */ __name((pagination) => {
  const defaultPagination = {
    simple: true,
    showSizeChanger: false,
    showLessItems: false
  };
  return { ...defaultPagination, ...pagination };
}, "parsePagination");
var TransferListBody = /* @__PURE__ */ __name((props, ref) => {
  const {
    prefixCls,
    filteredRenderItems,
    selectedKeys,
    disabled: globalDisabled,
    showRemove,
    pagination,
    onScroll,
    onItemSelect,
    onItemRemove
  } = props;
  const [current, setCurrent] = React572.useState(1);
  const mergedPagination = React572.useMemo(() => {
    if (!pagination) {
      return null;
    }
    const convertPagination = typeof pagination === "object" ? pagination : {};
    return parsePagination(convertPagination);
  }, [pagination]);
  const [pageSize, setPageSize] = useMergedState(10, {
    value: mergedPagination?.pageSize
  });
  React572.useEffect(() => {
    if (mergedPagination) {
      const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
      setCurrent(Math.min(current, maxPageCount));
    }
  }, [filteredRenderItems, mergedPagination, pageSize]);
  const onInternalClick = /* @__PURE__ */ __name((item, e3) => {
    onItemSelect(item.key, !selectedKeys.includes(item.key), e3);
  }, "onInternalClick");
  const onRemove = /* @__PURE__ */ __name((item) => {
    onItemRemove?.([item.key]);
  }, "onRemove");
  const onPageChange = /* @__PURE__ */ __name((cur) => {
    setCurrent(cur);
  }, "onPageChange");
  const onSizeChange = /* @__PURE__ */ __name((cur, size) => {
    setCurrent(cur);
    setPageSize(size);
  }, "onSizeChange");
  const memoizedItems = React572.useMemo(() => {
    const displayItems = mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
    return displayItems;
  }, [current, filteredRenderItems, mergedPagination, pageSize]);
  React572.useImperativeHandle(ref, () => ({ items: memoizedItems }));
  const paginationNode = mergedPagination ? /* @__PURE__ */ React572.createElement(
    pagination_default,
    {
      size: "small",
      disabled: globalDisabled,
      simple: mergedPagination.simple,
      pageSize,
      showLessItems: mergedPagination.showLessItems,
      showSizeChanger: mergedPagination.showSizeChanger,
      className: `${prefixCls}-pagination`,
      total: filteredRenderItems.length,
      current,
      onChange: onPageChange,
      onShowSizeChange: onSizeChange
    }
  ) : null;
  const cls5 = (0, import_classnames259.default)(`${prefixCls}-content`, {
    [`${prefixCls}-content-show-remove`]: showRemove
  });
  return /* @__PURE__ */ React572.createElement(React572.Fragment, null, /* @__PURE__ */ React572.createElement("ul", { className: cls5, onScroll }, (memoizedItems || []).map(({ renderedEl, renderedText, item }) => /* @__PURE__ */ React572.createElement(
    ListItem_default,
    {
      key: item.key,
      item,
      renderedText,
      renderedEl,
      prefixCls,
      showRemove,
      onClick: onInternalClick,
      onRemove,
      checked: selectedKeys.includes(item.key),
      disabled: globalDisabled || item.disabled
    }
  ))), paginationNode);
}, "TransferListBody");
if (true) {
  TransferListBody.displayName = "TransferListBody";
}
var ListBody_default = React572.forwardRef(TransferListBody);

// packages/ant-design/components/transfer/search.tsx
var import_SearchOutlined4 = __toESM(require_SearchOutlined3());
import * as React573 from "react";
var Search2 = /* @__PURE__ */ __name((props) => {
  const { placeholder = "", value, prefixCls, disabled, onChange, handleClear } = props;
  const handleChange = React573.useCallback(
    (e3) => {
      onChange?.(e3);
      if (e3.target.value === "") {
        handleClear?.();
      }
    },
    [onChange]
  );
  return /* @__PURE__ */ React573.createElement(
    input_default,
    {
      placeholder,
      className: prefixCls,
      value,
      onChange: handleChange,
      disabled,
      allowClear: true,
      prefix: /* @__PURE__ */ React573.createElement(import_SearchOutlined4.default, null)
    }
  );
}, "Search");
if (true) {
  Search2.displayName = "Search";
}
var search_default = Search2;

// packages/ant-design/components/transfer/list.tsx
var defaultRender2 = /* @__PURE__ */ __name(() => null, "defaultRender");
function isRenderResultPlainObject(result) {
  return !!(result && !React574.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
__name(isRenderResultPlainObject, "isRenderResultPlainObject");
function getEnabledItemKeys(items) {
  return items.filter((data) => !data.disabled).map((data) => data.key);
}
__name(getEnabledItemKeys, "getEnabledItemKeys");
var isValidIcon = /* @__PURE__ */ __name((icon) => icon !== void 0, "isValidIcon");
var TransferList = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    dataSource = [],
    titleText = "",
    checkedKeys,
    disabled,
    showSearch = false,
    style: style2,
    searchPlaceholder,
    notFoundContent,
    selectAll,
    deselectAll,
    selectCurrent,
    selectInvert,
    removeAll,
    removeCurrent,
    showSelectAll = true,
    showRemove,
    pagination,
    direction,
    itemsUnit,
    itemUnit,
    selectAllLabel,
    selectionsIcon,
    footer,
    renderList,
    onItemSelectAll,
    onItemRemove,
    handleFilter,
    handleClear,
    filterOption: filterOption2,
    render: render2 = defaultRender2
  } = props;
  const [filterValue, setFilterValue] = useState140("");
  const listBodyRef = useRef176({});
  const internalHandleFilter = /* @__PURE__ */ __name((e3) => {
    setFilterValue(e3.target.value);
    handleFilter(e3);
  }, "internalHandleFilter");
  const internalHandleClear = /* @__PURE__ */ __name(() => {
    setFilterValue("");
    handleClear();
  }, "internalHandleClear");
  const matchFilter = /* @__PURE__ */ __name((text, item) => {
    if (filterOption2) {
      return filterOption2(filterValue, item, direction);
    }
    return text.includes(filterValue);
  }, "matchFilter");
  const renderListBody = /* @__PURE__ */ __name((listProps) => {
    let bodyContent = renderList ? renderList({
      ...listProps,
      onItemSelect: (key, check) => listProps.onItemSelect(key, check)
    }) : null;
    const customize = !!bodyContent;
    if (!customize) {
      bodyContent = /* @__PURE__ */ React574.createElement(ListBody_default, { ref: listBodyRef, ...listProps });
    }
    return { customize, bodyContent };
  }, "renderListBody");
  const renderItem2 = /* @__PURE__ */ __name((item) => {
    const renderResult = render2(item);
    const isRenderResultPlain = isRenderResultPlainObject(renderResult);
    return {
      item,
      renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
      renderedText: isRenderResultPlain ? renderResult.value : renderResult
    };
  }, "renderItem");
  const notFoundContentEle = useMemo179(
    () => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent,
    [notFoundContent, direction]
  );
  const [filteredItems, filteredRenderItems] = useMemo179(() => {
    const filterItems = [];
    const filterRenderItems = [];
    dataSource.forEach((item) => {
      const renderedItem = renderItem2(item);
      if (filterValue && !matchFilter(renderedItem.renderedText, item)) {
        return;
      }
      filterItems.push(item);
      filterRenderItems.push(renderedItem);
    });
    return [filterItems, filterRenderItems];
  }, [dataSource, filterValue]);
  const checkStatus = useMemo179(() => {
    if (checkedKeys.length === 0) {
      return "none";
    }
    const checkedKeysMap = groupKeysMap(checkedKeys);
    if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) {
      return "all";
    }
    return "part";
  }, [checkedKeys, filteredItems]);
  const listBody = useMemo179(() => {
    const search = showSearch ? /* @__PURE__ */ React574.createElement("div", { className: `${prefixCls}-body-search-wrapper` }, /* @__PURE__ */ React574.createElement(
      search_default,
      {
        prefixCls: `${prefixCls}-search`,
        onChange: internalHandleFilter,
        handleClear: internalHandleClear,
        placeholder: searchPlaceholder,
        value: filterValue,
        disabled
      }
    )) : null;
    const { customize, bodyContent } = renderListBody({
      ...omit(props, OmitProps),
      filteredItems,
      filteredRenderItems,
      selectedKeys: checkedKeys
    });
    let bodyNode;
    if (customize) {
      bodyNode = /* @__PURE__ */ React574.createElement("div", { className: `${prefixCls}-body-customize-wrapper` }, bodyContent);
    } else {
      bodyNode = filteredItems.length ? bodyContent : /* @__PURE__ */ React574.createElement("div", { className: `${prefixCls}-body-not-found` }, notFoundContentEle);
    }
    return /* @__PURE__ */ React574.createElement(
      "div",
      {
        className: (0, import_classnames260.default)(
          showSearch ? `${prefixCls}-body ${prefixCls}-body-with-search` : `${prefixCls}-body`
        )
      },
      search,
      bodyNode
    );
  }, [
    showSearch,
    prefixCls,
    searchPlaceholder,
    filterValue,
    disabled,
    checkedKeys,
    filteredItems,
    filteredRenderItems,
    notFoundContentEle
  ]);
  const checkBox = /* @__PURE__ */ React574.createElement(
    checkbox_default,
    {
      disabled: dataSource.length === 0 || disabled,
      checked: checkStatus === "all",
      indeterminate: checkStatus === "part",
      className: `${prefixCls}-checkbox`,
      onChange: () => {
        onItemSelectAll?.(
          filteredItems.filter((item) => !item.disabled).map(({ key }) => key),
          checkStatus !== "all"
        );
      }
    }
  );
  const getSelectAllLabel = /* @__PURE__ */ __name((selectedCount, totalCount) => {
    if (selectAllLabel) {
      return typeof selectAllLabel === "function" ? selectAllLabel({ selectedCount, totalCount }) : selectAllLabel;
    }
    const unit3 = totalCount > 1 ? itemsUnit : itemUnit;
    return /* @__PURE__ */ React574.createElement(React574.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit3);
  }, "getSelectAllLabel");
  const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, { direction }));
  const listCls = (0, import_classnames260.default)(prefixCls, {
    [`${prefixCls}-with-pagination`]: !!pagination,
    [`${prefixCls}-with-footer`]: !!footerDom
  });
  const listFooter = footerDom ? /* @__PURE__ */ React574.createElement("div", { className: `${prefixCls}-footer` }, footerDom) : null;
  const checkAllCheckbox = !showRemove && !pagination && checkBox;
  let items;
  if (showRemove) {
    items = [
      /* Remove Current Page */
      pagination ? {
        key: "removeCurrent",
        label: removeCurrent,
        onClick() {
          const pageKeys = getEnabledItemKeys(
            (listBodyRef.current?.items || []).map((entity) => entity.item)
          );
          onItemRemove?.(pageKeys);
        }
      } : null,
      /* Remove All */
      {
        key: "removeAll",
        label: removeAll,
        onClick() {
          onItemRemove?.(getEnabledItemKeys(filteredItems));
        }
      }
    ].filter(Boolean);
  } else {
    items = [
      {
        key: "selectAll",
        label: checkStatus === "all" ? deselectAll : selectAll,
        onClick() {
          const keys2 = getEnabledItemKeys(filteredItems);
          onItemSelectAll?.(keys2, keys2.length !== checkedKeys.length);
        }
      },
      pagination ? {
        key: "selectCurrent",
        label: selectCurrent,
        onClick() {
          const pageItems = listBodyRef.current?.items || [];
          onItemSelectAll?.(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
        }
      } : null,
      {
        key: "selectInvert",
        label: selectInvert,
        onClick() {
          const availablePageItemKeys = getEnabledItemKeys(
            (listBodyRef.current?.items || []).map((entity) => entity.item)
          );
          const checkedKeySet = new Set(checkedKeys);
          const newCheckedKeysSet = new Set(checkedKeySet);
          availablePageItemKeys.forEach((key) => {
            if (checkedKeySet.has(key)) {
              newCheckedKeysSet.delete(key);
            } else {
              newCheckedKeysSet.add(key);
            }
          });
          onItemSelectAll?.(Array.from(newCheckedKeysSet), "replace");
        }
      }
    ];
  }
  const dropdown = /* @__PURE__ */ React574.createElement(dropdown_default3, { className: `${prefixCls}-header-dropdown`, menu: { items }, disabled }, isValidIcon(selectionsIcon) ? selectionsIcon : /* @__PURE__ */ React574.createElement(import_DownOutlined5.default, null));
  return /* @__PURE__ */ React574.createElement("div", { className: listCls, style: style2 }, /* @__PURE__ */ React574.createElement("div", { className: `${prefixCls}-header` }, showSelectAll ? /* @__PURE__ */ React574.createElement(React574.Fragment, null, checkAllCheckbox, dropdown) : null, /* @__PURE__ */ React574.createElement("span", { className: `${prefixCls}-header-selected` }, getSelectAllLabel(checkedKeys.length, filteredItems.length)), /* @__PURE__ */ React574.createElement("span", { className: `${prefixCls}-header-title` }, titleText)), listBody, listFooter);
}, "TransferList");
if (true) {
  TransferList.displayName = "TransferList";
}
var list_default2 = TransferList;

// packages/ant-design/components/transfer/operation.tsx
var import_LeftOutlined5 = __toESM(require_LeftOutlined3());
var import_RightOutlined7 = __toESM(require_RightOutlined3());
import * as React575 from "react";
var Operation = /* @__PURE__ */ __name((props) => {
  const {
    disabled,
    moveToLeft,
    moveToRight,
    leftArrowText = "",
    rightArrowText = "",
    leftActive,
    rightActive,
    className,
    style: style2,
    direction,
    oneWay
  } = props;
  return /* @__PURE__ */ React575.createElement("div", { className, style: style2 }, /* @__PURE__ */ React575.createElement(
    button_default2,
    {
      type: "primary",
      size: "small",
      disabled: disabled || !rightActive,
      onClick: moveToRight,
      icon: direction !== "rtl" ? /* @__PURE__ */ React575.createElement(import_RightOutlined7.default, null) : /* @__PURE__ */ React575.createElement(import_LeftOutlined5.default, null)
    },
    rightArrowText
  ), !oneWay && /* @__PURE__ */ React575.createElement(
    button_default2,
    {
      type: "primary",
      size: "small",
      disabled: disabled || !leftActive,
      onClick: moveToLeft,
      icon: direction !== "rtl" ? /* @__PURE__ */ React575.createElement(import_LeftOutlined5.default, null) : /* @__PURE__ */ React575.createElement(import_RightOutlined7.default, null)
    },
    leftArrowText
  ));
}, "Operation");
if (true) {
  Operation.displayName = "Operation";
}
var operation_default = Operation;

// packages/ant-design/components/transfer/style/index.ts
var genTransferCustomizeStyle = /* @__PURE__ */ __name((token2) => {
  const { antCls, componentCls, listHeight, controlHeightLG } = token2;
  const tableCls = `${antCls}-table`;
  const inputCls = `${antCls}-input`;
  return {
    [`${componentCls}-customize-list`]: {
      [`${componentCls}-list`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: listHeight
      },
      // =================== Hook Components ===================
      [`${tableCls}-wrapper`]: {
        [`${tableCls}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${tableCls}-selection-column`]: {
            width: controlHeightLG,
            minWidth: controlHeightLG
          }
        },
        [`${tableCls}-pagination${tableCls}-pagination`]: {
          margin: 0,
          padding: token2.paddingXS
        }
      },
      [`${inputCls}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
}, "genTransferCustomizeStyle");
var genTransferStatusColor = /* @__PURE__ */ __name((token2, color) => {
  const { componentCls, colorBorder } = token2;
  return {
    [`${componentCls}-list`]: {
      borderColor: color,
      "&-search:not([disabled])": {
        borderColor: colorBorder
      }
    }
  };
}, "genTransferStatusColor");
var genTransferStatusStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-status-error`]: {
      ...genTransferStatusColor(token2, token2.colorError)
    },
    [`${componentCls}-status-warning`]: {
      ...genTransferStatusColor(token2, token2.colorWarning)
    }
  };
}, "genTransferStatusStyle");
var genTransferListStyle = /* @__PURE__ */ __name((token2) => {
  const {
    componentCls,
    colorBorder,
    colorSplit,
    lineWidth,
    itemHeight,
    headerHeight,
    transferHeaderVerticalPadding,
    itemPaddingBlock,
    controlItemBgActive,
    colorTextDisabled,
    listHeight,
    listWidth,
    listWidthLG,
    fontSizeIcon,
    marginXS,
    paddingSM,
    lineType,
    antCls,
    iconCls,
    motionDurationSlow,
    controlItemBgHover,
    borderRadiusLG,
    colorBgContainer,
    colorText,
    controlItemBgActiveHover
  } = token2;
  return {
    display: "flex",
    flexDirection: "column",
    width: listWidth,
    height: listHeight,
    border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
    borderRadius: token2.borderRadiusLG,
    "&-with-pagination": {
      width: listWidthLG,
      height: "auto"
    },
    "&-search": {
      [`${iconCls}-search`]: {
        color: colorTextDisabled
      }
    },
    "&-header": {
      display: "flex",
      flex: "none",
      alignItems: "center",
      height: headerHeight,
      // border-top is on the transfer dom. We should minus 1px for this
      padding: `${unit(token2.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit(
        paddingSM
      )} ${unit(transferHeaderVerticalPadding)}`,
      color: colorText,
      background: colorBgContainer,
      borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      borderRadius: `${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0 0`,
      "> *:not(:last-child)": {
        marginInlineEnd: 4
        // This is magic and fixed number, DO NOT use token since it may change.
      },
      "> *": {
        flex: "none"
      },
      "&-title": {
        ...textEllipsis,
        flex: "auto",
        textAlign: "end"
      },
      "&-dropdown": {
        ...resetIcon(),
        fontSize: fontSizeIcon,
        transform: "translateY(10%)",
        cursor: "pointer",
        "&[disabled]": {
          cursor: "not-allowed"
        }
      }
    },
    "&-body": {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      fontSize: token2.fontSize,
      // https://blog.csdn.net/qq449245884/article/details/107373672/
      minHeight: 0,
      "&-search-wrapper": {
        position: "relative",
        flex: "none",
        padding: paddingSM
      }
    },
    "&-content": {
      flex: "auto",
      margin: 0,
      padding: 0,
      overflow: "auto",
      listStyle: "none",
      "&-item": {
        display: "flex",
        alignItems: "center",
        minHeight: itemHeight,
        padding: `${unit(itemPaddingBlock)} ${unit(paddingSM)}`,
        transition: `all ${motionDurationSlow}`,
        "> *:not(:last-child)": {
          marginInlineEnd: marginXS
        },
        "> *": {
          flex: "none"
        },
        "&-text": {
          ...textEllipsis,
          flex: "auto"
        },
        "&-remove": {
          position: "relative",
          color: colorBorder,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: token2.colorLinkHover
          },
          "&::after": {
            position: "absolute",
            inset: `-${unit(itemPaddingBlock)} -50%`,
            content: '""'
          }
        },
        [`&:not(${componentCls}-list-content-item-disabled)`]: {
          "&:hover": {
            backgroundColor: controlItemBgHover,
            cursor: "pointer"
          },
          [`&${componentCls}-list-content-item-checked:hover`]: {
            backgroundColor: controlItemBgActiveHover
          }
        },
        "&-checked": {
          backgroundColor: controlItemBgActive
        },
        "&-disabled": {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // Do not change hover style when `oneWay` mode
      [`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
        background: "transparent",
        cursor: "default"
      }
    },
    "&-pagination": {
      padding: token2.paddingXS,
      textAlign: "end",
      borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      [`${antCls}-pagination-options`]: {
        paddingInlineEnd: token2.paddingXS
      }
    },
    "&-body-not-found": {
      flex: "none",
      width: "100%",
      margin: "auto 0",
      color: colorTextDisabled,
      textAlign: "center"
    },
    "&-footer": {
      borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
    },
    // fix: https://github.com/ant-design/ant-design/issues/44489
    "&-checkbox": {
      lineHeight: 1
    }
  };
}, "genTransferListStyle");
var genTransferStyle = /* @__PURE__ */ __name((token2) => {
  const {
    antCls,
    iconCls,
    componentCls,
    marginXS,
    marginXXS,
    fontSizeIcon,
    colorBgContainerDisabled
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${componentCls}-disabled`]: {
        [`${componentCls}-list`]: {
          background: colorBgContainerDisabled
        }
      },
      [`${componentCls}-list`]: genTransferListStyle(token2),
      [`${componentCls}-operation`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${unit(marginXS)}`,
        verticalAlign: "middle",
        [`${antCls}-btn`]: {
          display: "block",
          "&:first-child": {
            marginBottom: marginXXS
          },
          [iconCls]: {
            fontSize: fontSizeIcon
          }
        }
      }
    }
  };
}, "genTransferStyle");
var genTransferRTLStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genTransferRTLStyle");
var prepareComponentToken55 = /* @__PURE__ */ __name((token2) => {
  const { fontSize, lineHeight, controlHeight, controlHeightLG, lineWidth } = token2;
  const fontHeight = Math.round(fontSize * lineHeight);
  return {
    listWidth: 180,
    listHeight: 200,
    listWidthLG: 250,
    headerHeight: controlHeightLG,
    itemHeight: controlHeight,
    itemPaddingBlock: (controlHeight - fontHeight) / 2,
    transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
  };
}, "prepareComponentToken");
var style_default61 = genStyleHooks(
  "Transfer",
  (token2) => {
    const transferToken = merge2(token2);
    return [
      genTransferStyle(transferToken),
      genTransferCustomizeStyle(transferToken),
      genTransferStatusStyle(transferToken),
      genTransferRTLStyle(transferToken)
    ];
  },
  prepareComponentToken55
);

// packages/ant-design/components/transfer/index.tsx
var Transfer = /* @__PURE__ */ __name((props) => {
  const {
    dataSource,
    targetKeys = [],
    selectedKeys,
    selectAllLabels = [],
    operations = [],
    style: style2 = {},
    listStyle = {},
    locale: locale6 = {},
    titles,
    disabled,
    showSearch = false,
    operationStyle,
    showSelectAll,
    oneWay,
    pagination,
    status: customStatus,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    selectionsIcon,
    filterOption: filterOption2,
    render: render2,
    footer,
    children,
    rowKey,
    onScroll,
    onChange,
    onSearch,
    onSelectChange
  } = props;
  const {
    getPrefixCls,
    renderEmpty,
    direction: dir,
    transfer
  } = useContext220(ConfigContext);
  const prefixCls = getPrefixCls("transfer", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default61(prefixCls);
  const [mergedDataSource, leftDataSource, rightDataSource] = useData_default(
    dataSource,
    rowKey,
    targetKeys
  );
  const [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Setters
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ] = useSelection2(leftDataSource, rightDataSource, selectedKeys);
  const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  if (true) {
    const warning5 = devUseWarning("Transfer");
    warning5(!pagination || !children, "usage", "`pagination` not support customize render list.");
  }
  const setStateKeys = useCallback49(
    (direction, keys2) => {
      if (direction === "left") {
        const nextKeys = typeof keys2 === "function" ? keys2(sourceSelectedKeys || []) : keys2;
        setSourceSelectedKeys(nextKeys);
      } else {
        const nextKeys = typeof keys2 === "function" ? keys2(targetSelectedKeys || []) : keys2;
        setTargetSelectedKeys(nextKeys);
      }
    },
    [sourceSelectedKeys, targetSelectedKeys]
  );
  const setPrevSelectedIndex = /* @__PURE__ */ __name((direction, value) => {
    const isLeftDirection = direction === "left";
    const updatePrevSelectedIndex = isLeftDirection ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex;
    updatePrevSelectedIndex(value);
  }, "setPrevSelectedIndex");
  const handleSelectChange = useCallback49(
    (direction, holder) => {
      if (direction === "left") {
        onSelectChange?.(holder, targetSelectedKeys);
      } else {
        onSelectChange?.(sourceSelectedKeys, holder);
      }
    },
    [sourceSelectedKeys, targetSelectedKeys]
  );
  const getTitles = /* @__PURE__ */ __name((transferLocale) => titles ?? transferLocale.titles ?? [], "getTitles");
  const handleLeftScroll = /* @__PURE__ */ __name((e3) => {
    onScroll?.("left", e3);
  }, "handleLeftScroll");
  const handleRightScroll = /* @__PURE__ */ __name((e3) => {
    onScroll?.("right", e3);
  }, "handleRightScroll");
  const moveTo = /* @__PURE__ */ __name((direction) => {
    const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
    const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
    const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
    const newMoveKeysMap = groupKeysMap(newMoveKeys);
    const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
    const oppositeDirection = direction === "right" ? "left" : "right";
    setStateKeys(oppositeDirection, []);
    handleSelectChange(oppositeDirection, []);
    onChange?.(newTargetKeys, direction, newMoveKeys);
  }, "moveTo");
  const moveToLeft = /* @__PURE__ */ __name(() => {
    moveTo("left");
    setPrevSelectedIndex("left", null);
  }, "moveToLeft");
  const moveToRight = /* @__PURE__ */ __name(() => {
    moveTo("right");
    setPrevSelectedIndex("right", null);
  }, "moveToRight");
  const onItemSelectAll = /* @__PURE__ */ __name((direction, keys2, checkAll) => {
    setStateKeys(direction, (prevKeys) => {
      let mergedCheckedKeys = [];
      if (checkAll === "replace") {
        mergedCheckedKeys = keys2;
      } else if (checkAll) {
        mergedCheckedKeys = Array.from(/* @__PURE__ */ new Set([...prevKeys, ...keys2]));
      } else {
        const selectedKeysMap = groupKeysMap(keys2);
        mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
      }
      handleSelectChange(direction, mergedCheckedKeys);
      return mergedCheckedKeys;
    });
    setPrevSelectedIndex(direction, null);
  }, "onItemSelectAll");
  const onLeftItemSelectAll = /* @__PURE__ */ __name((keys2, checkAll) => {
    onItemSelectAll("left", keys2, checkAll);
  }, "onLeftItemSelectAll");
  const onRightItemSelectAll = /* @__PURE__ */ __name((keys2, checkAll) => {
    onItemSelectAll("right", keys2, checkAll);
  }, "onRightItemSelectAll");
  const leftFilter = /* @__PURE__ */ __name((e3) => onSearch?.("left", e3.target.value), "leftFilter");
  const rightFilter = /* @__PURE__ */ __name((e3) => onSearch?.("right", e3.target.value), "rightFilter");
  const handleLeftClear = /* @__PURE__ */ __name(() => onSearch?.("left", ""), "handleLeftClear");
  const handleRightClear = /* @__PURE__ */ __name(() => onSearch?.("right", ""), "handleRightClear");
  const handleSingleSelect = /* @__PURE__ */ __name((direction, holder, selectedKey, checked, currentSelectedIndex) => {
    const isSelected = holder.has(selectedKey);
    if (isSelected) {
      holder.delete(selectedKey);
      setPrevSelectedIndex(direction, null);
    }
    if (checked) {
      holder.add(selectedKey);
      setPrevSelectedIndex(direction, currentSelectedIndex);
    }
  }, "handleSingleSelect");
  const handleMultipleSelect = /* @__PURE__ */ __name((direction, data, holder, currentSelectedIndex) => {
    const isLeftDirection = direction === "left";
    const multipleSelect = isLeftDirection ? leftMultipleSelect : rightMultipleSelect;
    multipleSelect(currentSelectedIndex, data, holder);
  }, "handleMultipleSelect");
  const onItemSelect = /* @__PURE__ */ __name((direction, selectedKey, checked, multiple) => {
    const isLeftDirection = direction === "left";
    const holder = [...isLeftDirection ? sourceSelectedKeys : targetSelectedKeys];
    const holderSet = new Set(holder);
    const data = [...isLeftDirection ? leftDataSource : rightDataSource].filter(
      (item) => !item.disabled
    );
    const currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
    if (multiple && holder.length > 0) {
      handleMultipleSelect(direction, data, holderSet, currentSelectedIndex);
    } else {
      handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
    }
    const holderArr = Array.from(holderSet);
    handleSelectChange(direction, holderArr);
    if (!props.selectedKeys) {
      setStateKeys(direction, holderArr);
    }
  }, "onItemSelect");
  const onLeftItemSelect = /* @__PURE__ */ __name((selectedKey, checked, e3) => {
    onItemSelect("left", selectedKey, checked, e3?.shiftKey);
  }, "onLeftItemSelect");
  const onRightItemSelect = /* @__PURE__ */ __name((selectedKey, checked, e3) => {
    onItemSelect("right", selectedKey, checked, e3?.shiftKey);
  }, "onRightItemSelect");
  const onRightItemRemove = /* @__PURE__ */ __name((keys2) => {
    setStateKeys("right", []);
    onChange?.(
      targetKeys.filter((key) => !keys2.includes(key)),
      "left",
      [...keys2]
    );
  }, "onRightItemRemove");
  const handleListStyle = /* @__PURE__ */ __name((direction) => {
    if (typeof listStyle === "function") {
      return listStyle({ direction });
    }
    return listStyle || {};
  }, "handleListStyle");
  const formItemContext = useContext220(FormItemInputContext);
  const { hasFeedback, status } = formItemContext;
  const getLocale = /* @__PURE__ */ __name((transferLocale) => ({
    ...transferLocale,
    notFoundContent: renderEmpty?.("Transfer") || /* @__PURE__ */ React576.createElement(defaultRenderEmpty_default, { componentName: "Transfer" }),
    ...locale6
  }), "getLocale");
  const mergedStatus = getMergedStatus(status, customStatus);
  const mergedPagination = !children && pagination;
  const leftActive = targetSelectedKeys.length > 0;
  const rightActive = sourceSelectedKeys.length > 0;
  const cls5 = (0, import_classnames261.default)(
    prefixCls,
    {
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-customize-list`]: !!children,
      [`${prefixCls}-rtl`]: dir === "rtl"
    },
    getStatusClassNames(prefixCls, mergedStatus, hasFeedback),
    transfer?.className,
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const [contextLocale] = useLocale_default("Transfer", en_US_default6.Transfer);
  const listLocale = getLocale(contextLocale);
  const [leftTitle, rightTitle] = getTitles(listLocale);
  const mergedSelectionsIcon = selectionsIcon ?? transfer?.selectionsIcon;
  return wrapCSSVar(
    /* @__PURE__ */ React576.createElement("div", { className: cls5, style: { ...transfer?.style, ...style2 } }, /* @__PURE__ */ React576.createElement(
      list_default2,
      {
        prefixCls: `${prefixCls}-list`,
        titleText: leftTitle,
        dataSource: leftDataSource,
        filterOption: filterOption2,
        style: handleListStyle("left"),
        checkedKeys: sourceSelectedKeys,
        handleFilter: leftFilter,
        handleClear: handleLeftClear,
        onItemSelect: onLeftItemSelect,
        onItemSelectAll: onLeftItemSelectAll,
        render: render2,
        showSearch,
        renderList: children,
        footer,
        onScroll: handleLeftScroll,
        disabled,
        direction: dir === "rtl" ? "right" : "left",
        showSelectAll,
        selectAllLabel: selectAllLabels[0],
        pagination: mergedPagination,
        selectionsIcon: mergedSelectionsIcon,
        ...listLocale
      }
    ), /* @__PURE__ */ React576.createElement(
      operation_default,
      {
        className: `${prefixCls}-operation`,
        rightActive,
        rightArrowText: operations[0],
        moveToRight,
        leftActive,
        leftArrowText: operations[1],
        moveToLeft,
        style: operationStyle,
        disabled,
        direction: dir,
        oneWay
      }
    ), /* @__PURE__ */ React576.createElement(
      list_default2,
      {
        prefixCls: `${prefixCls}-list`,
        titleText: rightTitle,
        dataSource: rightDataSource,
        filterOption: filterOption2,
        style: handleListStyle("right"),
        checkedKeys: targetSelectedKeys,
        handleFilter: rightFilter,
        handleClear: handleRightClear,
        onItemSelect: onRightItemSelect,
        onItemSelectAll: onRightItemSelectAll,
        onItemRemove: onRightItemRemove,
        render: render2,
        showSearch,
        renderList: children,
        footer,
        onScroll: handleRightScroll,
        disabled,
        direction: dir === "rtl" ? "left" : "right",
        showSelectAll,
        selectAllLabel: selectAllLabels[1],
        showRemove: oneWay,
        pagination: mergedPagination,
        selectionsIcon: mergedSelectionsIcon,
        ...listLocale
      }
    ))
  );
}, "Transfer");
if (true) {
  Transfer.displayName = "Transfer";
}
Transfer.List = list_default2;
Transfer.Search = search_default;
Transfer.Operation = operation_default;
var transfer_default = Transfer;

// packages/ant-design/components/tree-select/index.tsx
var import_classnames262 = __toESM(require_classnames());
import * as React588 from "react";

// packages/tree-select/src/TreeSelect.tsx
init_warning();
import * as React587 from "react";

// packages/tree-select/src/hooks/useCache.ts
import * as React577 from "react";
var useCache_default2 = /* @__PURE__ */ __name((values) => {
  const cacheRef = React577.useRef({
    valueLabels: /* @__PURE__ */ new Map()
  });
  return React577.useMemo(() => {
    const { valueLabels } = cacheRef.current;
    const valueLabelsCache = /* @__PURE__ */ new Map();
    const filledValues = values.map((item) => {
      const { value } = item;
      const mergedLabel = item.label ?? valueLabels.get(value);
      valueLabelsCache.set(value, mergedLabel);
      return {
        ...item,
        label: mergedLabel
      };
    });
    cacheRef.current.valueLabels = valueLabelsCache;
    return [filledValues];
  }, [values]);
}, "default");

// packages/tree-select/src/hooks/useCheckedKeys.ts
import * as React578 from "react";
var useCheckedKeys_default = /* @__PURE__ */ __name((rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities) => React578.useMemo(() => {
  let checkedKeys = rawLabeledValues.map(({ value }) => value);
  let halfCheckedKeys = rawHalfCheckedValues.map(({ value }) => value);
  const missingValues = checkedKeys.filter((key) => !keyEntities[key]);
  if (treeConduction) {
    ({ checkedKeys, halfCheckedKeys } = conductCheck(checkedKeys, true, keyEntities));
  }
  return [
    // Checked keys should fill with missing keys which should de-duplicated
    Array.from(/* @__PURE__ */ new Set([...missingValues, ...checkedKeys])),
    // Half checked keys
    halfCheckedKeys
  ];
}, [rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities]), "default");

// packages/tree-select/src/hooks/useDataEntities.ts
import * as React579 from "react";
init_warning();

// packages/tree-select/src/utils/valueUtil.ts
function toArray9(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
__name(toArray9, "toArray");
function fillFieldNames4(fieldNames) {
  const { label, value, children } = fieldNames || {};
  const mergedValue = value || "value";
  return {
    _title: label ? [label] : ["title", "label"],
    value: mergedValue,
    key: mergedValue,
    children: children || "children"
  };
}
__name(fillFieldNames4, "fillFieldNames");
function isCheckDisabled2(node2) {
  return !node2 || node2.disabled || node2.disableCheckbox || node2.checkable === false;
}
__name(isCheckDisabled2, "isCheckDisabled");
function getAllKeys(treeData, fieldNames) {
  const keys2 = [];
  function dig(list) {
    list.forEach((item) => {
      const children = item[fieldNames.children];
      if (children) {
        keys2.push(item[fieldNames.value]);
        dig(children);
      }
    });
  }
  __name(dig, "dig");
  dig(treeData);
  return keys2;
}
__name(getAllKeys, "getAllKeys");
function isNil(val) {
  return val === null || val === void 0;
}
__name(isNil, "isNil");

// packages/tree-select/src/hooks/useDataEntities.ts
var useDataEntities_default = /* @__PURE__ */ __name((treeData, fieldNames) => React579.useMemo(() => {
  const collection = convertDataToEntities(treeData, {
    fieldNames,
    initWrapper: (wrapper) => ({
      ...wrapper,
      valueEntities: /* @__PURE__ */ new Map()
    }),
    processEntity: (entity, wrapper) => {
      const val = entity.node[fieldNames.value];
      if (true) {
        const key = entity.node.key;
        warning_default(!isNil(val), "TreeNode `value` is invalidate: undefined");
        warning_default(!wrapper.valueEntities.has(val), `Same \`value\` exist in the tree: ${val}`);
        warning_default(
          !key || String(key) === String(val),
          `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${key}, value: ${val}.`
        );
      }
      wrapper.valueEntities.set(val, entity);
    }
  });
  return collection;
}, [treeData, fieldNames]), "default");

// packages/tree-select/src/hooks/useFilterTreeData.ts
import * as React581 from "react";

// packages/tree-select/src/utils/legacyUtil.tsx
import * as React580 from "react";
init_warning();

// packages/tree-select/src/TreeNode.tsx
var TreeNode = /* @__PURE__ */ __name(() => null, "TreeNode");
var TreeNode_default2 = TreeNode;

// packages/tree-select/src/utils/legacyUtil.tsx
function convertChildrenToData2(nodes) {
  return toArray(nodes).map((node2) => {
    if (!React580.isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      key,
      props: { children, value, ...restProps }
    } = node2;
    const data = {
      key,
      value,
      ...restProps
    };
    const childData = convertChildrenToData2(children);
    if (childData.length) {
      data.children = childData;
    }
    return data;
  }).filter((data) => data);
}
__name(convertChildrenToData2, "convertChildrenToData");
function fillLegacyProps(dataNode) {
  if (!dataNode) {
    return dataNode;
  }
  const cloneNode = { ...dataNode };
  if (!("props" in cloneNode)) {
    Object.defineProperty(cloneNode, "props", {
      get() {
        warning_default(
          false,
          "New `rc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access."
        );
        return cloneNode;
      }
    });
  }
  return cloneNode;
}
__name(fillLegacyProps, "fillLegacyProps");
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
  let triggerNode = null;
  let nodeList = null;
  function generateMap() {
    function dig(list, level = "0", parentIncluded = false) {
      return list.map((option, index3) => {
        const pos = `${level}-${index3}`;
        const value = option[fieldNames.value];
        const included = checkedValues.includes(value);
        const children = dig(option[fieldNames.children] || [], pos, included);
        const node2 = /* @__PURE__ */ React580.createElement(TreeNode_default2, { ...option }, children.map((child) => child.node));
        if (triggerValue === value) {
          triggerNode = node2;
        }
        if (included) {
          const checkedNode = {
            pos,
            node: node2,
            children
          };
          if (!parentIncluded) {
            nodeList.push(checkedNode);
          }
          return checkedNode;
        }
        return null;
      }).filter((node2) => node2);
    }
    __name(dig, "dig");
    if (!nodeList) {
      nodeList = [];
      dig(treeData);
      nodeList.sort(
        ({
          node: {
            props: { value: val1 }
          }
        }, {
          node: {
            props: { value: val2 }
          }
        }) => {
          const index1 = checkedValues.indexOf(val1);
          const index22 = checkedValues.indexOf(val2);
          return index1 - index22;
        }
      );
    }
  }
  __name(generateMap, "generateMap");
  Object.defineProperty(extra, "triggerNode", {
    get() {
      warning_default(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
      generateMap();
      return triggerNode;
    }
  });
  Object.defineProperty(extra, "allCheckedNodes", {
    get() {
      warning_default(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
      generateMap();
      if (showPosition) {
        return nodeList;
      }
      return nodeList.map(({ node: node2 }) => node2);
    }
  });
}
__name(fillAdditionalInfo, "fillAdditionalInfo");

// packages/tree-select/src/hooks/useFilterTreeData.ts
var useFilterTreeData_default = /* @__PURE__ */ __name((treeData, searchValue, {
  treeNodeFilterProp,
  filterTreeNode,
  fieldNames
}) => {
  const { children: fieldChildren } = fieldNames;
  return React581.useMemo(() => {
    if (!searchValue || filterTreeNode === false) {
      return treeData;
    }
    let filterOptionFunc;
    if (typeof filterTreeNode === "function") {
      filterOptionFunc = filterTreeNode;
    } else {
      const upperStr = searchValue.toUpperCase();
      filterOptionFunc = /* @__PURE__ */ __name((_, dataNode) => {
        const value = dataNode[treeNodeFilterProp];
        return String(value).toUpperCase().includes(upperStr);
      }, "filterOptionFunc");
    }
    function dig(list, keepAll = false) {
      return list.reduce((total, dataNode) => {
        const children = dataNode[fieldChildren];
        const match2 = keepAll || filterOptionFunc(searchValue, fillLegacyProps(dataNode));
        const childList = dig(children || [], match2);
        if (match2 || childList.length) {
          total.push({
            ...dataNode,
            isLeaf: void 0,
            [fieldChildren]: childList
          });
        }
        return total;
      }, []);
    }
    __name(dig, "dig");
    return dig(treeData);
  }, [treeData, searchValue, fieldChildren, treeNodeFilterProp, filterTreeNode]);
}, "default");

// packages/tree-select/src/hooks/useRefFunc.ts
import * as React582 from "react";
function useRefFunc2(callback) {
  const funcRef = React582.useRef();
  funcRef.current = callback;
  const cacheFn = React582.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}
__name(useRefFunc2, "useRefFunc");

// packages/tree-select/src/hooks/useTreeData.ts
import * as React583 from "react";
function parseSimpleTreeData(treeData, { id, pId, rootPId }) {
  const keyNodes = {};
  const rootNodeList = [];
  const nodeList = treeData.map((node2) => {
    const clone = { ...node2 };
    const key = clone[id];
    keyNodes[key] = clone;
    clone.key = clone.key || key;
    return clone;
  });
  nodeList.forEach((node2) => {
    const parentKey = node2[pId];
    const parent = keyNodes[parentKey];
    if (parent) {
      parent.children = parent.children || [];
      parent.children.push(node2);
    }
    if (parentKey === rootPId || !parent && rootPId === null) {
      rootNodeList.push(node2);
    }
  });
  return rootNodeList;
}
__name(parseSimpleTreeData, "parseSimpleTreeData");
function useTreeData(treeData, children, simpleMode) {
  return React583.useMemo(() => {
    if (treeData) {
      return simpleMode ? parseSimpleTreeData(treeData, {
        id: "id",
        pId: "pId",
        rootPId: null,
        ...simpleMode !== true ? simpleMode : {}
      }) : treeData;
    }
    return convertChildrenToData2(children);
  }, [children, simpleMode, treeData]);
}
__name(useTreeData, "useTreeData");

// packages/tree-select/src/LegacyContext.tsx
import * as React584 from "react";
var LegacySelectContext = React584.createContext(null);
var LegacyContext_default = LegacySelectContext;

// packages/tree-select/src/OptionList.tsx
import * as React586 from "react";

// packages/tree-select/src/TreeSelectContext.ts
import * as React585 from "react";
var TreeSelectContext = React585.createContext(null);
var TreeSelectContext_default = TreeSelectContext;

// packages/tree-select/src/OptionList.tsx
var HIDDEN_STYLE3 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var OptionList2 = /* @__PURE__ */ __name((_, ref) => {
  const { prefixCls, multiple, searchValue, toggleOpen, open: open3, notFoundContent } = useBaseProps();
  const {
    virtual,
    listHeight,
    listItemHeight,
    listItemScrollOffset,
    treeData,
    fieldNames,
    onSelect,
    dropdownMatchSelectWidth,
    treeExpandAction,
    treeTitleRender
  } = React586.useContext(TreeSelectContext_default);
  const {
    checkable,
    checkedKeys,
    halfCheckedKeys,
    treeExpandedKeys,
    treeDefaultExpandAll,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeLine,
    treeNodeFilterProp,
    loadData,
    treeLoadedKeys,
    treeMotion,
    onTreeLoad,
    keyEntities
  } = React586.useContext(LegacyContext_default);
  const treeRef = React586.useRef();
  const memoTreeData = useMemo(
    () => treeData,
    [open3, treeData],
    (prev2, next2) => next2[0] && prev2[1] !== next2[1]
  );
  const [activeKey, setActiveKey] = React586.useState(null);
  const activeEntity = keyEntities[activeKey];
  const mergedCheckedKeys = React586.useMemo(() => {
    if (!checkable) {
      return null;
    }
    return {
      checked: checkedKeys,
      halfChecked: halfCheckedKeys
    };
  }, [checkable, checkedKeys, halfCheckedKeys]);
  React586.useEffect(() => {
    if (open3 && !multiple && checkedKeys.length) {
      treeRef.current?.scrollTo({ key: checkedKeys[0] });
      setActiveKey(checkedKeys[0]);
    }
  }, [open3]);
  const lowerSearchValue = String(searchValue).toLowerCase();
  const filterTreeNode = /* @__PURE__ */ __name((treeNode) => {
    if (!lowerSearchValue) {
      return false;
    }
    return String(treeNode[treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue);
  }, "filterTreeNode");
  const [expandedKeys, setExpandedKeys] = React586.useState(treeDefaultExpandedKeys);
  const [searchExpandedKeys, setSearchExpandedKeys] = React586.useState(null);
  const mergedExpandedKeys = React586.useMemo(() => {
    if (treeExpandedKeys) {
      return [...treeExpandedKeys];
    }
    return searchValue ? searchExpandedKeys : expandedKeys;
  }, [expandedKeys, searchExpandedKeys, treeExpandedKeys, searchValue]);
  React586.useEffect(() => {
    if (searchValue) {
      setSearchExpandedKeys(getAllKeys(treeData, fieldNames));
    }
  }, [searchValue]);
  const onInternalExpand = /* @__PURE__ */ __name((keys2) => {
    setExpandedKeys(keys2);
    setSearchExpandedKeys(keys2);
    if (onTreeExpand) {
      onTreeExpand(keys2);
    }
  }, "onInternalExpand");
  const onListMouseDown = /* @__PURE__ */ __name((event) => {
    event.preventDefault();
  }, "onListMouseDown");
  const onInternalSelect = /* @__PURE__ */ __name((__, info) => {
    const { node: node2 } = info;
    if (checkable && isCheckDisabled2(node2)) {
      return;
    }
    onSelect(node2.key, {
      selected: !checkedKeys.includes(node2.key)
    });
    if (!multiple) {
      toggleOpen(false);
    }
  }, "onInternalSelect");
  React586.useImperativeHandle(ref, () => ({
    scrollTo: treeRef.current?.scrollTo,
    onKeyDown: (event) => {
      const { which } = event;
      switch (which) {
        case KeyCode_default.UP:
        case KeyCode_default.DOWN:
        case KeyCode_default.LEFT:
        case KeyCode_default.RIGHT:
          treeRef.current?.onKeyDown(event);
          break;
        case KeyCode_default.ENTER: {
          if (activeEntity) {
            const { selectable, value } = activeEntity?.node || {};
            if (selectable !== false) {
              onInternalSelect(null, {
                node: { key: activeKey },
                selected: !checkedKeys.includes(value)
              });
            }
          }
          break;
        }
        case KeyCode_default.ESC: {
          toggleOpen(false);
        }
      }
    },
    onKeyUp: () => {
    }
  }));
  if (memoTreeData.length === 0) {
    return /* @__PURE__ */ React586.createElement("div", { role: "listbox", className: `${prefixCls}-empty`, onMouseDown: onListMouseDown }, notFoundContent);
  }
  const treeProps = {
    fieldNames
  };
  if (treeLoadedKeys) {
    treeProps.loadedKeys = treeLoadedKeys;
  }
  if (mergedExpandedKeys) {
    treeProps.expandedKeys = mergedExpandedKeys;
  }
  return /* @__PURE__ */ React586.createElement("div", { onMouseDown: onListMouseDown }, activeEntity && open3 && /* @__PURE__ */ React586.createElement("span", { style: HIDDEN_STYLE3, "aria-live": "assertive" }, activeEntity.node.value), /* @__PURE__ */ React586.createElement(
    src_default28,
    {
      ref: treeRef,
      focusable: false,
      prefixCls: `${prefixCls}-tree`,
      treeData: memoTreeData,
      height: listHeight,
      itemHeight: listItemHeight,
      itemScrollOffset: listItemScrollOffset,
      virtual: virtual !== false && dropdownMatchSelectWidth !== false,
      multiple,
      icon: treeIcon,
      showIcon: showTreeIcon,
      switcherIcon,
      showLine: treeLine,
      loadData: searchValue ? null : loadData,
      motion: treeMotion,
      activeKey,
      checkable,
      checkStrictly: true,
      checkedKeys: mergedCheckedKeys,
      selectedKeys: !checkable ? checkedKeys : [],
      defaultExpandAll: treeDefaultExpandAll,
      titleRender: treeTitleRender,
      ...treeProps,
      onActiveChange: setActiveKey,
      onSelect: onInternalSelect,
      onCheck: onInternalSelect,
      onExpand: onInternalExpand,
      onLoad: onTreeLoad,
      filterTreeNode,
      expandAction: treeExpandAction
    }
  ));
}, "OptionList");
var RefOptionList3 = React586.forwardRef(OptionList2);
if (true) {
  RefOptionList3.displayName = "OptionList";
}
var OptionList_default3 = RefOptionList3;

// packages/tree-select/src/utils/strategyUtil.ts
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT3 = "SHOW_PARENT";
var SHOW_CHILD3 = "SHOW_CHILD";
function formatStrategyValues2(values, strategy, keyEntities, fieldNames) {
  const valueSet = new Set(values);
  if (strategy === SHOW_CHILD3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      if (entity && entity.children && entity.children.some(({ node: node2 }) => valueSet.has(node2[fieldNames.value])) && entity.children.every(
        ({ node: node2 }) => isCheckDisabled2(node2) || valueSet.has(node2[fieldNames.value])
      )) {
        return false;
      }
      return true;
    });
  }
  if (strategy === SHOW_PARENT3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      const parent = entity ? entity.parent : null;
      if (parent && !isCheckDisabled2(parent.node) && valueSet.has(parent.key)) {
        return false;
      }
      return true;
    });
  }
  return values;
}
__name(formatStrategyValues2, "formatStrategyValues");

// packages/tree-select/src/utils/warningPropsUtil.ts
init_warning();
function warningProps3(props) {
  const {
    searchPlaceholder,
    treeCheckStrictly,
    treeCheckable,
    labelInValue,
    value,
    multiple
  } = props;
  warning_default(!searchPlaceholder, "`searchPlaceholder` has been removed.");
  if (treeCheckStrictly && labelInValue === false) {
    warning_default(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
  }
  if (labelInValue || treeCheckStrictly) {
    warning_default(
      toArray9(value).every((val) => val && typeof val === "object" && "value" in val),
      "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead."
    );
  }
  if (treeCheckStrictly || multiple || treeCheckable) {
    warning_default(
      !value || Array.isArray(value),
      "`value` should be an array when `TreeSelect` is checkable or multiple."
    );
  } else {
    warning_default(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
  }
}
__name(warningProps3, "warningProps");
var warningPropsUtil_default3 = warningProps3;

// packages/tree-select/src/TreeSelect.tsx
function isRawValue2(value) {
  return !value || typeof value !== "object";
}
__name(isRawValue2, "isRawValue");
var TreeSelect = React587.forwardRef((props, ref) => {
  const {
    id,
    prefixCls = "rc-tree-select",
    // Value
    value,
    defaultValue,
    onChange,
    onSelect,
    onDeselect,
    // Search
    searchValue,
    inputValue,
    onSearch,
    autoClearSearchValue = true,
    filterTreeNode,
    treeNodeFilterProp = "value",
    // Selector
    showCheckedStrategy,
    treeNodeLabelProp,
    //  Mode
    multiple,
    treeCheckable,
    treeCheckStrictly,
    labelInValue,
    // FieldNames
    fieldNames,
    // Data
    treeDataSimpleMode,
    treeData,
    children,
    loadData,
    treeLoadedKeys,
    onTreeLoad,
    // Expanded
    treeDefaultExpandAll,
    treeExpandedKeys,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeExpandAction,
    // Options
    virtual,
    listHeight = 200,
    listItemHeight = 20,
    listItemScrollOffset = 0,
    onDropdownVisibleChange,
    dropdownMatchSelectWidth = true,
    // Tree
    treeLine,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeMotion,
    treeTitleRender,
    ...restProps
  } = props;
  const mergedId = useId3(id);
  const treeConduction = treeCheckable && !treeCheckStrictly;
  const mergedCheckable = treeCheckable || treeCheckStrictly;
  const mergedLabelInValue = treeCheckStrictly || labelInValue;
  const mergedMultiple = mergedCheckable || multiple;
  const [internalValue, setInternalValue] = useMergedState(defaultValue, { value });
  const mergedShowCheckedStrategy = React587.useMemo(() => {
    if (!treeCheckable) {
      return SHOW_ALL;
    }
    return showCheckedStrategy || SHOW_CHILD3;
  }, [showCheckedStrategy, treeCheckable]);
  if (true) {
    warningPropsUtil_default3(props);
  }
  const mergedFieldNames = React587.useMemo(
    () => fillFieldNames4(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedSearchValue, setSearchValue] = useMergedState("", {
    value: searchValue !== void 0 ? searchValue : inputValue,
    postState: (search) => search || ""
  });
  const onInternalSearch = /* @__PURE__ */ __name((searchText) => {
    setSearchValue(searchText);
    onSearch?.(searchText);
  }, "onInternalSearch");
  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);
  const { keyEntities, valueEntities } = useDataEntities_default(mergedTreeData, mergedFieldNames);
  const splitRawValues = React587.useCallback(
    (newRawValues) => {
      const missingRawValues = [];
      const existRawValues = [];
      newRawValues.forEach((val) => {
        if (valueEntities.has(val)) {
          existRawValues.push(val);
        } else {
          missingRawValues.push(val);
        }
      });
      return { missingRawValues, existRawValues };
    },
    [valueEntities]
  );
  const filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
    fieldNames: mergedFieldNames,
    treeNodeFilterProp,
    filterTreeNode
  });
  const getLabel = React587.useCallback(
    (item) => {
      if (item) {
        if (treeNodeLabelProp) {
          return item[treeNodeLabelProp];
        }
        const { _title: titleList } = mergedFieldNames;
        for (let i = 0; i < titleList.length; i += 1) {
          const title = item[titleList[i]];
          if (title !== void 0) {
            return title;
          }
        }
      }
    },
    [mergedFieldNames, treeNodeLabelProp]
  );
  const toLabeledValues = React587.useCallback((draftValues) => {
    const values = toArray9(draftValues);
    return values.map((val) => {
      if (isRawValue2(val)) {
        return { value: val };
      }
      return val;
    });
  }, []);
  const convert2LabelValues = React587.useCallback(
    (draftValues) => {
      const values = toLabeledValues(draftValues);
      return values.map((item) => {
        let { label: rawLabel } = item;
        const { value: rawValue, halfChecked: rawHalfChecked } = item;
        let rawDisabled;
        const entity = valueEntities.get(rawValue);
        if (entity) {
          rawLabel = rawLabel ?? getLabel(entity.node);
          rawDisabled = entity.node.disabled;
        } else if (rawLabel === void 0) {
          const labelInValueItem = toLabeledValues(internalValue).find(
            (labeledItem) => labeledItem.value === rawValue
          );
          rawLabel = labelInValueItem.label;
        }
        return {
          label: rawLabel,
          value: rawValue,
          halfChecked: rawHalfChecked,
          disabled: rawDisabled
        };
      });
    },
    [valueEntities, getLabel, toLabeledValues, internalValue]
  );
  const rawMixedLabeledValues = React587.useMemo(
    () => toLabeledValues(internalValue),
    [toLabeledValues, internalValue]
  );
  const [rawLabeledValues, rawHalfLabeledValues] = React587.useMemo(() => {
    const fullCheckValues = [];
    const halfCheckValues = [];
    rawMixedLabeledValues.forEach((item) => {
      if (item.halfChecked) {
        halfCheckValues.push(item);
      } else {
        fullCheckValues.push(item);
      }
    });
    return [fullCheckValues, halfCheckValues];
  }, [rawMixedLabeledValues]);
  const rawValues = React587.useMemo(
    () => rawLabeledValues.map((item) => item.value),
    [rawLabeledValues]
  );
  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys_default(
    rawLabeledValues,
    rawHalfLabeledValues,
    treeConduction,
    keyEntities
  );
  const displayValues = React587.useMemo(() => {
    const displayKeys = formatStrategyValues2(
      rawCheckedValues,
      mergedShowCheckedStrategy,
      keyEntities,
      mergedFieldNames
    );
    const values = displayKeys.map((key) => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key);
    const labeledValues = values.map((val) => {
      const targetItem = rawLabeledValues.find((item) => item.value === val);
      let label;
      if (labelInValue && targetItem.label !== void 0) {
        label = targetItem.label;
      } else if (!labelInValue && treeTitleRender) {
        label = treeTitleRender(targetItem);
      }
      return {
        value: val,
        label
      };
    });
    const rawDisplayValues = convert2LabelValues(labeledValues);
    const firstVal = rawDisplayValues[0];
    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {
      return [];
    }
    return rawDisplayValues.map((item) => ({
      ...item,
      label: item.label ?? item.value
    }));
  }, [
    mergedFieldNames,
    mergedMultiple,
    rawCheckedValues,
    rawLabeledValues,
    convert2LabelValues,
    mergedShowCheckedStrategy,
    keyEntities
  ]);
  const [cachedDisplayValues] = useCache_default2(displayValues);
  const triggerChange = useRefFunc2(
    (newRawValues, extra, source) => {
      const labeledValues = convert2LabelValues(newRawValues);
      setInternalValue(labeledValues);
      if (autoClearSearchValue) {
        setSearchValue("");
      }
      if (onChange) {
        let eventValues = newRawValues;
        if (treeConduction) {
          const formattedKeyList = formatStrategyValues2(
            newRawValues,
            mergedShowCheckedStrategy,
            keyEntities,
            mergedFieldNames
          );
          eventValues = formattedKeyList.map((key) => {
            const entity = valueEntities.get(key);
            return entity ? entity.node[mergedFieldNames.value] : key;
          });
        }
        const { triggerValue, selected } = extra || {
          triggerValue: void 0,
          selected: void 0
        };
        let returnRawValues = eventValues;
        if (treeCheckStrictly) {
          const halfValues = rawHalfLabeledValues.filter((item) => !eventValues.includes(item.value));
          returnRawValues = [...returnRawValues, ...halfValues];
        }
        const returnLabeledValues = convert2LabelValues(returnRawValues);
        const additionalInfo = {
          // [Legacy] Always return as array contains label & value
          preValue: rawLabeledValues,
          triggerValue
        };
        let showPosition = true;
        if (treeCheckStrictly || source === "selection" && !selected) {
          showPosition = false;
        }
        fillAdditionalInfo(
          additionalInfo,
          triggerValue,
          newRawValues,
          mergedTreeData,
          showPosition,
          mergedFieldNames
        );
        if (mergedCheckable) {
          additionalInfo.checked = selected;
        } else {
          additionalInfo.selected = selected;
        }
        const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map((item) => item.value);
        onChange(
          mergedMultiple ? returnValues : returnValues[0],
          mergedLabelInValue ? null : returnLabeledValues.map((item) => item.label),
          additionalInfo
        );
      }
    }
  );
  const onOptionSelect = React587.useCallback(
    (selectedKey, { selected, source }) => {
      const entity = keyEntities[selectedKey];
      const node2 = entity?.node;
      const selectedValue = node2?.[mergedFieldNames.value] ?? selectedKey;
      if (!mergedMultiple) {
        triggerChange([selectedValue], { selected: true, triggerValue: selectedValue }, "option");
      } else {
        let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter((v) => v !== selectedValue);
        if (treeConduction) {
          const { missingRawValues, existRawValues } = splitRawValues(newRawValues);
          const keyList = existRawValues.map((val) => valueEntities.get(val).key);
          let checkedKeys;
          if (selected) {
            ({ checkedKeys } = conductCheck(keyList, true, keyEntities));
          } else {
            ({ checkedKeys } = conductCheck(
              keyList,
              { checked: false, halfCheckedKeys: rawHalfCheckedValues },
              keyEntities
            ));
          }
          newRawValues = [
            ...missingRawValues,
            ...checkedKeys.map((key) => keyEntities[key].node[mergedFieldNames.value])
          ];
        }
        triggerChange(newRawValues, { selected, triggerValue: selectedValue }, source || "option");
      }
      if (selected || !mergedMultiple) {
        onSelect?.(selectedValue, fillLegacyProps(node2));
      } else {
        onDeselect?.(selectedValue, fillLegacyProps(node2));
      }
    },
    [
      splitRawValues,
      valueEntities,
      keyEntities,
      mergedFieldNames,
      mergedMultiple,
      rawValues,
      triggerChange,
      treeConduction,
      onSelect,
      onDeselect,
      rawCheckedValues,
      rawHalfCheckedValues
    ]
  );
  const onInternalDropdownVisibleChange = React587.useCallback(
    (open3) => {
      if (onDropdownVisibleChange) {
        const legacyParam = {};
        Object.defineProperty(legacyParam, "documentClickClose", {
          get() {
            warning_default(false, "Second param of `onDropdownVisibleChange` has been removed.");
            return false;
          }
        });
        onDropdownVisibleChange(open3, legacyParam);
      }
    },
    [onDropdownVisibleChange]
  );
  const onDisplayValuesChange = useRefFunc2(
    (newValues, info) => {
      const newRawValues = newValues.map((item) => item.value);
      if (info.type === "clear") {
        triggerChange(newRawValues, {}, "selection");
        return;
      }
      if (info.values.length) {
        onOptionSelect(info.values[0].value, { selected: false, source: "selection" });
      }
    }
  );
  const treeSelectContext = React587.useMemo(
    () => ({
      virtual,
      dropdownMatchSelectWidth,
      listHeight,
      listItemHeight,
      listItemScrollOffset,
      treeData: filteredTreeData,
      fieldNames: mergedFieldNames,
      onSelect: onOptionSelect,
      treeExpandAction,
      treeTitleRender
    }),
    [
      virtual,
      dropdownMatchSelectWidth,
      listHeight,
      listItemHeight,
      listItemScrollOffset,
      filteredTreeData,
      mergedFieldNames,
      onOptionSelect,
      treeExpandAction,
      treeTitleRender
    ]
  );
  const legacyContext = React587.useMemo(
    () => ({
      checkable: mergedCheckable,
      loadData,
      treeLoadedKeys,
      onTreeLoad,
      checkedKeys: rawCheckedValues,
      halfCheckedKeys: rawHalfCheckedValues,
      treeDefaultExpandAll,
      treeExpandedKeys,
      treeDefaultExpandedKeys,
      onTreeExpand,
      treeIcon,
      treeMotion,
      showTreeIcon,
      switcherIcon,
      treeLine,
      treeNodeFilterProp,
      keyEntities
    }),
    [
      mergedCheckable,
      loadData,
      treeLoadedKeys,
      onTreeLoad,
      rawCheckedValues,
      rawHalfCheckedValues,
      treeDefaultExpandAll,
      treeExpandedKeys,
      treeDefaultExpandedKeys,
      onTreeExpand,
      treeIcon,
      treeMotion,
      showTreeIcon,
      switcherIcon,
      treeLine,
      treeNodeFilterProp,
      keyEntities
    ]
  );
  return /* @__PURE__ */ React587.createElement(TreeSelectContext_default.Provider, { value: treeSelectContext }, /* @__PURE__ */ React587.createElement(LegacyContext_default.Provider, { value: legacyContext }, /* @__PURE__ */ React587.createElement(
    BaseSelect_default,
    {
      ref,
      ...restProps,
      id: mergedId,
      prefixCls,
      mode: mergedMultiple ? "multiple" : void 0,
      displayValues: cachedDisplayValues,
      onDisplayValuesChange,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      OptionList: OptionList_default3,
      emptyOptions: !mergedTreeData.length,
      onDropdownVisibleChange: onInternalDropdownVisibleChange,
      dropdownMatchSelectWidth
    }
  )));
});
if (true) {
  TreeSelect.displayName = "TreeSelect";
}
var GenericTreeSelect = TreeSelect;
GenericTreeSelect.TreeNode = TreeNode_default2;
GenericTreeSelect.SHOW_ALL = SHOW_ALL;
GenericTreeSelect.SHOW_PARENT = SHOW_PARENT3;
GenericTreeSelect.SHOW_CHILD = SHOW_CHILD3;
var TreeSelect_default = GenericTreeSelect;

// packages/tree-select/src/index.tsx
var src_default30 = TreeSelect_default;

// packages/ant-design/components/tree-select/style/index.ts
var genBaseStyle18 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, treePrefixCls, colorBgElevated } = token2;
  const treeCls = `.${treePrefixCls}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${componentCls}-dropdown`]: [
        {
          padding: `${unit(token2.paddingXS)} ${unit(token2.calc(token2.paddingXS).div(2).equal())}`
        },
        // ====================== Tree ======================
        genTreeStyle(
          treePrefixCls,
          merge2(token2, {
            colorBgContainer: colorBgElevated
          })
        ),
        {
          [treeCls]: {
            borderRadius: 0,
            [`${treeCls}-list-holder-inner`]: {
              alignItems: "stretch",
              [`${treeCls}-treenode`]: {
                [`${treeCls}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        getStyle2(`${treePrefixCls}-checkbox`, token2),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${treeCls}-switcher${treeCls}-switcher_close`]: {
              [`${treeCls}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
}, "genBaseStyle");
function useTreeSelectStyle(prefixCls, treePrefixCls, rootCls) {
  return genStyleHooks(
    "TreeSelect",
    (token2) => {
      const treeSelectToken = merge2(token2, { treePrefixCls });
      return [genBaseStyle18(treeSelectToken)];
    },
    initComponentToken2
  )(prefixCls, rootCls);
}
__name(useTreeSelectStyle, "useTreeSelectStyle");

// packages/ant-design/components/tree-select/index.tsx
var InternalTreeSelect = /* @__PURE__ */ __name(({
  prefixCls: customizePrefixCls,
  size: customizeSize,
  disabled: customDisabled,
  bordered = true,
  className,
  rootClassName,
  treeCheckable,
  multiple,
  listHeight = 256,
  listItemHeight = 26,
  placement,
  notFoundContent,
  switcherIcon,
  treeLine,
  getPopupContainer,
  popupClassName,
  dropdownClassName,
  treeIcon = false,
  transitionName,
  choiceTransitionName = "",
  status: customStatus,
  treeExpandAction,
  builtinPlacements,
  dropdownMatchSelectWidth,
  popupMatchSelectWidth,
  allowClear,
  variant: customVariant,
  dropdownStyle,
  tagRender,
  ...props
}, ref) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow
  } = React588.useContext(ConfigContext);
  if (true) {
    const warning5 = devUseWarning("TreeSelect");
    warning5(
      multiple !== false || !treeCheckable,
      "usage",
      "`multiple` will always be `true` when `treeCheckable` is true"
    );
    warning5.deprecated(!dropdownClassName, "dropdownClassName", "popupClassName");
    warning5.deprecated(
      dropdownMatchSelectWidth === void 0,
      "dropdownMatchSelectWidth",
      "popupMatchSelectWidth"
    );
    warning5(
      !("showArrow" in props),
      "deprecated",
      "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."
    );
    warning5.deprecated(!("bordered" in props), "bordered", "variant");
  }
  const rootPrefixCls = getPrefixCls();
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const treePrefixCls = getPrefixCls("select-tree", customizePrefixCls);
  const treeSelectPrefixCls = getPrefixCls("tree-select", customizePrefixCls);
  const { compactSize, compactItemClassnames } = useCompactItemContext(prefixCls, direction);
  const rootCls = useCSSVarCls_default(prefixCls);
  const treeSelectRootCls = useCSSVarCls_default(treeSelectPrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default12(prefixCls, rootCls);
  const [treeSelectWrapCSSVar] = useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls, treeSelectRootCls);
  const [variant, enableVariantCls] = useVariants_default(customVariant, bordered);
  const mergedDropdownClassName = (0, import_classnames262.default)(
    popupClassName || dropdownClassName,
    `${treeSelectPrefixCls}-dropdown`,
    {
      [`${treeSelectPrefixCls}-dropdown-rtl`]: direction === "rtl"
    },
    rootClassName,
    cssVarCls,
    rootCls,
    treeSelectRootCls,
    hashId
  );
  const isMultiple2 = !!(treeCheckable || multiple);
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React588.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const { suffixIcon, removeIcon, clearIcon } = useIcons({
    ...props,
    multiple: isMultiple2,
    showSuffixIcon,
    hasFeedback,
    feedbackIcon,
    prefixCls,
    componentName: "TreeSelect"
  });
  const mergedAllowClear = allowClear === true ? { clearIcon } : allowClear;
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else {
    mergedNotFound = renderEmpty?.("Select") || /* @__PURE__ */ React588.createElement(defaultRenderEmpty_default, { componentName: "Select" });
  }
  const selectProps = omit(props, [
    "suffixIcon",
    "removeIcon",
    "clearIcon",
    "itemIcon",
    "switcherIcon"
  ]);
  const memoizedPlacement = React588.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React588.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedClassName = (0, import_classnames262.default)(
    !customizePrefixCls && treeSelectPrefixCls,
    {
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    },
    getStatusClassNames(prefixCls, mergedStatus, hasFeedback),
    compactItemClassnames,
    className,
    rootClassName,
    cssVarCls,
    rootCls,
    treeSelectRootCls,
    hashId
  );
  const renderSwitcherIcon = /* @__PURE__ */ __name((nodeProps) => /* @__PURE__ */ React588.createElement(
    iconUtil_default,
    {
      prefixCls: treePrefixCls,
      switcherIcon,
      treeNodeProps: nodeProps,
      showLine: treeLine
    }
  ), "renderSwitcherIcon");
  const [zIndex] = useZIndex("SelectLike", dropdownStyle?.zIndex);
  const returnNode = /* @__PURE__ */ React588.createElement(
    src_default30,
    {
      virtual,
      disabled: mergedDisabled,
      ...selectProps,
      dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
      builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
      ref,
      prefixCls,
      className: mergedClassName,
      listHeight,
      listItemHeight,
      treeCheckable: treeCheckable ? /* @__PURE__ */ React588.createElement("span", { className: `${prefixCls}-tree-checkbox-inner` }) : treeCheckable,
      treeLine: !!treeLine,
      suffixIcon,
      multiple: isMultiple2,
      placement: memoizedPlacement,
      removeIcon,
      allowClear: mergedAllowClear,
      switcherIcon: renderSwitcherIcon,
      showTreeIcon: treeIcon,
      notFoundContent: mergedNotFound,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      treeMotion: null,
      dropdownClassName: mergedDropdownClassName,
      dropdownStyle: { ...dropdownStyle, zIndex },
      choiceTransitionName: getTransitionName2(rootPrefixCls, "", choiceTransitionName),
      transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
      treeExpandAction,
      tagRender: isMultiple2 ? tagRender : void 0
    }
  );
  return wrapCSSVar(treeSelectWrapCSSVar(returnNode));
}, "InternalTreeSelect");
var TreeSelectRef = React588.forwardRef(InternalTreeSelect);
var TreeSelect2 = TreeSelectRef;
var PurePanel18 = PurePanel_default3(TreeSelect2);
TreeSelect2.TreeNode = TreeNode_default2;
TreeSelect2.SHOW_ALL = SHOW_ALL;
TreeSelect2.SHOW_PARENT = SHOW_PARENT3;
TreeSelect2.SHOW_CHILD = SHOW_CHILD3;
TreeSelect2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel18;
if (true) {
  TreeSelect2.displayName = "TreeSelect";
}
var tree_select_default = TreeSelect2;

// packages/ant-design/components/typography/Link.tsx
import * as React598 from "react";

// packages/ant-design/components/typography/Base/index.tsx
var import_EditOutlined = __toESM(require_EditOutlined3());
var import_classnames266 = __toESM(require_classnames());
import * as React597 from "react";

// packages/ant-design/components/typography/Editable.tsx
var import_EnterOutlined = __toESM(require_EnterOutlined3());
var import_classnames263 = __toESM(require_classnames());
import * as React589 from "react";

// packages/ant-design/components/typography/style/mixins.ts
init_src();
var getTitleStyle = /* @__PURE__ */ __name((fontSize, lineHeight, color, token2) => {
  const { titleMarginBottom, fontWeightStrong } = token2;
  return {
    marginBottom: titleMarginBottom,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
}, "getTitleStyle");
var getTitleStyles = /* @__PURE__ */ __name((token2) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(
      token2[`fontSizeHeading${headingLevel}`],
      token2[`lineHeightHeading${headingLevel}`],
      token2.colorTextHeading,
      token2
    );
  });
  return styles;
}, "getTitleStyles");
var getLinkStyles = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    "a&, a": {
      ...operationUnit(token2),
      textDecoration: token2.linkDecoration,
      "&:active, &:hover": {
        textDecoration: token2.linkHoverDecoration
      },
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token2.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    }
  };
}, "getLinkStyles");
var getResetStyles = /* @__PURE__ */ __name((token2) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: token2.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), "getResetStyles");
var getEditableStyles = /* @__PURE__ */ __name((token2) => {
  const { componentCls, paddingSM } = token2;
  const inputShift = paddingSM;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: token2.calc(token2.paddingSM).mul(-1).equal(),
        marginTop: token2.calc(inputShift).mul(-1).equal(),
        marginBottom: `calc(1em - ${unit(inputShift)})`
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token2.calc(token2.marginXS).add(2).equal(),
        insetBlockEnd: token2.marginXS,
        color: token2.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: token2.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, "getEditableStyles");
var getCopyableStyles = /* @__PURE__ */ __name((token2) => ({
  [`${token2.componentCls}-copy-success`]: {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token2.colorSuccess
    }
  },
  [`${token2.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
}), "getCopyableStyles");
var getEllipsisStyles = /* @__PURE__ */ __name(() => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), "getEllipsisStyles");

// packages/ant-design/components/typography/style/index.ts
var genTypographyStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, titleMarginTop } = token2;
  return {
    [componentCls]: {
      color: token2.colorText,
      wordBreak: "break-word",
      lineHeight: token2.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token2.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token2.colorSuccess
      },
      [`&${componentCls}-warning`]: {
        color: token2.colorWarning
      },
      [`&${componentCls}-danger`]: {
        color: token2.colorError,
        "a&:active, a&:focus": {
          color: token2.colorErrorActive
        },
        "a&:hover": {
          color: token2.colorErrorHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      },
      ...getTitleStyles(token2),
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: titleMarginTop
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: titleMarginTop
        }
      },
      ...getResetStyles(token2),
      ...getLinkStyles(token2),
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: {
        ...operationUnit(token2),
        marginInlineStart: token2.marginXXS
      },
      ...getEditableStyles(token2),
      ...getCopyableStyles(token2),
      ...getEllipsisStyles(),
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, "genTypographyStyle");
var prepareComponentToken56 = /* @__PURE__ */ __name(() => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
}), "prepareComponentToken");
var style_default62 = genStyleHooks(
  "Typography",
  (token2) => [genTypographyStyle(token2)],
  prepareComponentToken56
);

// packages/ant-design/components/typography/Editable.tsx
var Editable = /* @__PURE__ */ __name((props) => {
  const {
    prefixCls,
    "aria-label": ariaLabel,
    className,
    style: style2,
    direction,
    maxLength,
    autoSize = true,
    value,
    onSave,
    onCancel,
    onEnd,
    component,
    enterIcon = /* @__PURE__ */ React589.createElement(import_EnterOutlined.default, null)
  } = props;
  const ref = React589.useRef(null);
  const inComposition = React589.useRef(false);
  const lastKeyCode = React589.useRef();
  const [current, setCurrent] = React589.useState(value);
  React589.useEffect(() => {
    setCurrent(value);
  }, [value]);
  React589.useEffect(() => {
    if (ref.current && ref.current.resizableTextArea) {
      const { textArea } = ref.current.resizableTextArea;
      textArea.focus();
      const { length: length2 } = textArea.value;
      textArea.setSelectionRange(length2, length2);
    }
  }, []);
  const onChange = /* @__PURE__ */ __name(({ target }) => {
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  }, "onChange");
  const onCompositionStart = /* @__PURE__ */ __name(() => {
    inComposition.current = true;
  }, "onCompositionStart");
  const onCompositionEnd = /* @__PURE__ */ __name(() => {
    inComposition.current = false;
  }, "onCompositionEnd");
  const onKeyDown2 = /* @__PURE__ */ __name(({ keyCode }) => {
    if (inComposition.current)
      return;
    lastKeyCode.current = keyCode;
  }, "onKeyDown");
  const confirmChange = /* @__PURE__ */ __name(() => {
    onSave(current.trim());
  }, "confirmChange");
  const onKeyUp = /* @__PURE__ */ __name(({
    keyCode,
    ctrlKey,
    altKey,
    metaKey,
    shiftKey
  }) => {
    if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
      if (keyCode === KeyCode_default.ENTER) {
        confirmChange();
        onEnd?.();
      } else if (keyCode === KeyCode_default.ESC) {
        onCancel();
      }
    }
  }, "onKeyUp");
  const onBlur = /* @__PURE__ */ __name(() => {
    confirmChange();
  }, "onBlur");
  const textClassName = component ? `${prefixCls}-${component}` : "";
  const [wrapCSSVar, hashId, cssVarCls] = style_default62(prefixCls);
  const textAreaClassName = (0, import_classnames263.default)(
    prefixCls,
    `${prefixCls}-edit-content`,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    textClassName,
    hashId,
    cssVarCls
  );
  return wrapCSSVar(
    /* @__PURE__ */ React589.createElement("div", { className: textAreaClassName, style: style2 }, /* @__PURE__ */ React589.createElement(
      TextArea_default2,
      {
        ref,
        maxLength,
        value: current,
        onChange,
        onKeyDown: onKeyDown2,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBlur,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize
      }
    ), enterIcon !== null ? cloneElement3(enterIcon, { className: `${prefixCls}-edit-content-confirm` }) : null)
  );
}, "Editable");
var Editable_default = Editable;

// packages/ant-design/components/typography/hooks/useCopyClick.ts
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
import * as React590 from "react";
var useCopyClick = /* @__PURE__ */ __name(({
  copyConfig,
  children
}) => {
  const [copied, setCopied] = React590.useState(false);
  const [copyLoading, setCopyLoading] = React590.useState(false);
  const copyIdRef = React590.useRef(null);
  const cleanCopyId = /* @__PURE__ */ __name(() => {
    if (copyIdRef.current) {
      clearTimeout(copyIdRef.current);
    }
  }, "cleanCopyId");
  const copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  React590.useEffect(() => cleanCopyId, []);
  const onClick = useEvent(async (e3) => {
    e3?.preventDefault();
    e3?.stopPropagation();
    setCopyLoading(true);
    try {
      const text = typeof copyConfig.text === "function" ? await copyConfig.text() : copyConfig.text;
      (0, import_copy_to_clipboard.default)(text || String(children) || "", copyOptions);
      setCopyLoading(false);
      setCopied(true);
      cleanCopyId();
      copyIdRef.current = setTimeout(() => {
        setCopied(false);
      }, 3e3);
      copyConfig.onCopy?.(e3);
    } catch (error) {
      setCopyLoading(false);
      throw error;
    }
  });
  return {
    copied,
    copyLoading,
    onClick
  };
}, "useCopyClick");
var useCopyClick_default = useCopyClick;

// packages/ant-design/components/typography/hooks/useMergedConfig.ts
import * as React591 from "react";
function useMergedConfig(propConfig, templateConfig) {
  return React591.useMemo(() => {
    const support = !!propConfig;
    return [
      support,
      {
        ...templateConfig,
        ...support && typeof propConfig === "object" ? propConfig : null
      }
    ];
  }, [propConfig]);
}
__name(useMergedConfig, "useMergedConfig");

// packages/ant-design/components/typography/hooks/useUpdatedEffect.ts
import * as React592 from "react";
var useUpdatedEffect = /* @__PURE__ */ __name((callback, conditions) => {
  const mountRef = React592.useRef(false);
  React592.useEffect(() => {
    if (mountRef.current) {
      callback();
    } else {
      mountRef.current = true;
    }
  }, conditions);
}, "useUpdatedEffect");
var useUpdatedEffect_default = useUpdatedEffect;

// packages/ant-design/components/typography/Typography.tsx
var import_classnames264 = __toESM(require_classnames());
import * as React593 from "react";
var Typography = React593.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    component: Component11 = "article",
    className,
    rootClassName,
    setContentRef,
    children,
    direction: typographyDirection,
    style: style2,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction: contextDirection,
    typography
  } = React593.useContext(ConfigContext);
  const direction = typographyDirection ?? contextDirection;
  let mergedRef = ref;
  if (setContentRef) {
    mergedRef = composeRef(ref, setContentRef);
  }
  if (true) {
    const warning5 = devUseWarning("Typography");
    warning5.deprecated(!setContentRef, "setContentRef", "ref");
  }
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default62(prefixCls);
  const componentClassName = (0, import_classnames264.default)(
    prefixCls,
    typography?.className,
    {
      [`${prefixCls}-rtl`]: direction === "rtl"
    },
    className,
    rootClassName,
    hashId,
    cssVarCls
  );
  const mergedStyle = { ...typography?.style, ...style2 };
  return wrapCSSVar(
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    /* @__PURE__ */ React593.createElement(Component11, { className: componentClassName, style: mergedStyle, ref: mergedRef, ...restProps }, children)
  );
});
if (true) {
  Typography.displayName = "Typography";
}
var Typography_default = Typography;

// packages/ant-design/components/typography/Base/CopyBtn.tsx
var import_CheckOutlined4 = __toESM(require_CheckOutlined3());
var import_CopyOutlined = __toESM(require_CopyOutlined3());
var import_LoadingOutlined9 = __toESM(require_LoadingOutlined3());
var import_classnames265 = __toESM(require_classnames());
import * as React594 from "react";

// packages/ant-design/components/typography/Base/util.ts
function toList(val) {
  if (val === false) {
    return [false, false];
  }
  return Array.isArray(val) ? val : [val];
}
__name(toList, "toList");
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === void 0) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
__name(getNode, "getNode");

// packages/ant-design/components/typography/Base/CopyBtn.tsx
function CopyBtn(props) {
  const { prefixCls, copied, locale: locale6 = {}, onCopy, iconOnly, tooltips, icon, loading } = props;
  const tooltipNodes = toList(tooltips);
  const iconNodes = toList(icon);
  const { copied: copiedText, copy: copyText } = locale6;
  const copyTitle = copied ? getNode(tooltipNodes[1], copiedText) : getNode(tooltipNodes[0], copyText);
  const systemStr = copied ? copiedText : copyText;
  const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
  return /* @__PURE__ */ React594.createElement(tooltip_default, { key: "copy", title: copyTitle }, /* @__PURE__ */ React594.createElement(
    transButton_default,
    {
      className: (0, import_classnames265.default)(`${prefixCls}-copy`, {
        [`${prefixCls}-copy-success`]: copied,
        [`${prefixCls}-copy-icon-only`]: iconOnly
      }),
      onClick: onCopy,
      "aria-label": ariaLabel
    },
    copied ? getNode(iconNodes[1], /* @__PURE__ */ React594.createElement(import_CheckOutlined4.default, null), true) : getNode(iconNodes[0], loading ? /* @__PURE__ */ React594.createElement(import_LoadingOutlined9.default, null) : /* @__PURE__ */ React594.createElement(import_CopyOutlined.default, null), true)
  ));
}
__name(CopyBtn, "CopyBtn");

// packages/ant-design/components/typography/Base/Ellipsis.tsx
import * as React595 from "react";
var MeasureText = React595.forwardRef(
  ({ style: style2, children }, ref) => {
    const spanRef = React595.useRef(null);
    React595.useImperativeHandle(ref, () => ({
      isExceed: () => {
        const span = spanRef.current;
        return span.scrollHeight > span.clientHeight;
      },
      getHeight: () => spanRef.current.clientHeight
    }));
    return /* @__PURE__ */ React595.createElement(
      "span",
      {
        "aria-hidden": true,
        ref: spanRef,
        style: {
          position: "fixed",
          display: "block",
          left: 0,
          top: 0,
          pointerEvents: "none",
          backgroundColor: "rgba(255, 0, 0, 0.65)",
          ...style2
        }
      },
      children
    );
  }
);
function cuttable(node2) {
  const type5 = typeof node2;
  return type5 === "string" || type5 === "number";
}
__name(cuttable, "cuttable");
function getNodesLen(nodeList) {
  let totalLen = 0;
  nodeList.forEach((node2) => {
    if (cuttable(node2)) {
      totalLen += String(node2).length;
    } else {
      totalLen += 1;
    }
  });
  return totalLen;
}
__name(getNodesLen, "getNodesLen");
function sliceNodes(nodeList, len) {
  let currLen = 0;
  const currentNodeList = [];
  for (let i = 0; i < nodeList.length; i += 1) {
    if (currLen === len) {
      return currentNodeList;
    }
    const node2 = nodeList[i];
    const canCut = cuttable(node2);
    const nodeLen = canCut ? String(node2).length : 1;
    const nextLen = currLen + nodeLen;
    if (nextLen > len) {
      const restLen = len - currLen;
      currentNodeList.push(String(node2).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node2);
    currLen = nextLen;
  }
  return nodeList;
}
__name(sliceNodes, "sliceNodes");
var STATUS_MEASURE_NONE = 0;
var STATUS_MEASURE_START = 1;
var STATUS_MEASURE_NEED_ELLIPSIS = 2;
var STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;
var lineClipStyle = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
  const { enableMeasure, width, text, children, rows, expanded, miscDeps, onEllipsis } = props;
  const nodeList = React595.useMemo(() => toArray(text), [text]);
  const nodeLen = React595.useMemo(() => getNodesLen(nodeList), [text]);
  const fullContent = React595.useMemo(() => children(nodeList, false), [text]);
  const [ellipsisCutIndex, setEllipsisCutIndex] = React595.useState(null);
  const cutMidRef = React595.useRef(null);
  const needEllipsisRef = React595.useRef(null);
  const descRowsEllipsisRef = React595.useRef(null);
  const symbolRowEllipsisRef = React595.useRef(null);
  const [canEllipsis, setCanEllipsis] = React595.useState(false);
  const [needEllipsis, setNeedEllipsis] = React595.useState(STATUS_MEASURE_NONE);
  const [ellipsisHeight, setEllipsisHeight] = React595.useState(0);
  useLayoutEffect_default(() => {
    if (enableMeasure && width && nodeLen) {
      setNeedEllipsis(STATUS_MEASURE_START);
    } else {
      setNeedEllipsis(STATUS_MEASURE_NONE);
    }
  }, [width, text, rows, enableMeasure, nodeList]);
  useLayoutEffect_default(() => {
    if (needEllipsis === STATUS_MEASURE_START) {
      const isOverflow = !!needEllipsisRef.current?.isExceed();
      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
      setCanEllipsis(isOverflow);
      const baseRowsEllipsisHeight = needEllipsisRef.current?.getHeight() || 0;
      const descRowsEllipsisHeight = rows === 1 ? 0 : descRowsEllipsisRef.current?.getHeight() || 0;
      const symbolRowEllipsisHeight = symbolRowEllipsisRef.current?.getHeight() || 0;
      const rowsWithEllipsisHeight = descRowsEllipsisHeight + symbolRowEllipsisHeight;
      const maxRowsHeight = Math.max(baseRowsEllipsisHeight, rowsWithEllipsisHeight);
      setEllipsisHeight(maxRowsHeight + 1);
      onEllipsis(isOverflow);
    }
  }, [needEllipsis]);
  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
  useLayoutEffect_default(() => {
    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
    if (minIndex !== maxIndex) {
      const midHeight = cutMidRef.current?.getHeight() || 0;
      const isOverflow = midHeight > ellipsisHeight;
      let targetMidIndex = cutMidIndex;
      if (maxIndex - minIndex === 1) {
        targetMidIndex = isOverflow ? minIndex : maxIndex;
      }
      if (isOverflow) {
        setEllipsisCutIndex([minIndex, targetMidIndex]);
      } else {
        setEllipsisCutIndex([targetMidIndex, maxIndex]);
      }
    }
  }, [ellipsisCutIndex, cutMidIndex]);
  const finalContent = React595.useMemo(() => {
    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
      const content = children(nodeList, false);
      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {
        return /* @__PURE__ */ React595.createElement(
          "span",
          {
            style: {
              ...lineClipStyle,
              WebkitLineClamp: rows
            }
          },
          content
        );
      }
      return content;
    }
    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList, ...miscDeps]);
  const measureStyle = {
    width,
    whiteSpace: "normal",
    margin: 0,
    padding: 0
  };
  return /* @__PURE__ */ React595.createElement(React595.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /* @__PURE__ */ React595.createElement(React595.Fragment, null, /* @__PURE__ */ React595.createElement(
    MeasureText,
    {
      style: {
        ...measureStyle,
        ...lineClipStyle,
        WebkitLineClamp: rows
      },
      ref: needEllipsisRef
    },
    fullContent
  ), /* @__PURE__ */ React595.createElement(
    MeasureText,
    {
      style: {
        ...measureStyle,
        ...lineClipStyle,
        WebkitLineClamp: rows - 1
      },
      ref: descRowsEllipsisRef
    },
    fullContent
  ), /* @__PURE__ */ React595.createElement(
    MeasureText,
    {
      style: {
        ...measureStyle,
        ...lineClipStyle,
        WebkitLineClamp: 1
      },
      ref: symbolRowEllipsisRef
    },
    children([], true)
  )), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /* @__PURE__ */ React595.createElement(
    MeasureText,
    {
      style: {
        ...measureStyle,
        top: 400
      },
      ref: cutMidRef
    },
    children(sliceNodes(nodeList, cutMidIndex), true)
  ));
}
__name(EllipsisMeasure, "EllipsisMeasure");

// packages/ant-design/components/typography/Base/EllipsisTooltip.tsx
import * as React596 from "react";
var EllipsisTooltip = /* @__PURE__ */ __name(({
  enableEllipsis,
  isEllipsis,
  children,
  tooltipProps
}) => {
  if (!tooltipProps?.title || !enableEllipsis) {
    return children;
  }
  return /* @__PURE__ */ React596.createElement(tooltip_default, { open: isEllipsis ? void 0 : false, ...tooltipProps }, children);
}, "EllipsisTooltip");
if (true) {
  EllipsisTooltip.displayName = "EllipsisTooltip";
}
var EllipsisTooltip_default = EllipsisTooltip;

// packages/ant-design/components/typography/Base/index.tsx
function wrapperDecorations({ mark, code, underline, delete: del, strong, keyboard, italic }, content) {
  let currentContent = content;
  function wrap(tag, needed) {
    if (!needed) {
      return;
    }
    currentContent = React597.createElement(tag, {}, currentContent);
  }
  __name(wrap, "wrap");
  wrap("strong", strong);
  wrap("u", underline);
  wrap("del", del);
  wrap("code", code);
  wrap("mark", mark);
  wrap("kbd", keyboard);
  wrap("i", italic);
  return currentContent;
}
__name(wrapperDecorations, "wrapperDecorations");
var ELLIPSIS_STR = "...";
var Base = React597.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    type: type5,
    disabled,
    children,
    ellipsis,
    editable,
    copyable,
    component,
    title,
    ...restProps
  } = props;
  const { getPrefixCls, direction } = React597.useContext(ConfigContext);
  const [textLocale] = useLocale_default("Text");
  const typographyRef = React597.useRef(null);
  const editIconRef = React597.useRef(null);
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const textProps = omit(restProps, [
    "mark",
    "code",
    "delete",
    "underline",
    "strong",
    "keyboard",
    "italic"
  ]);
  const [enableEdit, editConfig] = useMergedConfig(editable);
  const [editing, setEditing] = useMergedState(false, {
    value: editConfig.editing
  });
  const { triggerType = ["icon"] } = editConfig;
  const triggerEdit = /* @__PURE__ */ __name((edit) => {
    if (edit) {
      editConfig.onStart?.();
    }
    setEditing(edit);
  }, "triggerEdit");
  useUpdatedEffect_default(() => {
    if (!editing) {
      editIconRef.current?.focus();
    }
  }, [editing]);
  const onEditClick = /* @__PURE__ */ __name((e3) => {
    e3?.preventDefault();
    triggerEdit(true);
  }, "onEditClick");
  const onEditChange = /* @__PURE__ */ __name((value) => {
    editConfig.onChange?.(value);
    triggerEdit(false);
  }, "onEditChange");
  const onEditCancel = /* @__PURE__ */ __name(() => {
    editConfig.onCancel?.();
    triggerEdit(false);
  }, "onEditCancel");
  const [enableCopy, copyConfig] = useMergedConfig(copyable);
  const { copied, copyLoading, onClick: onCopyClick } = useCopyClick_default({ copyConfig, children });
  const [isLineClampSupport, setIsLineClampSupport] = React597.useState(false);
  const [isTextOverflowSupport, setIsTextOverflowSupport] = React597.useState(false);
  const [isJsEllipsis, setIsJsEllipsis] = React597.useState(false);
  const [isNativeEllipsis, setIsNativeEllipsis] = React597.useState(false);
  const [isNativeVisible, setIsNativeVisible] = React597.useState(true);
  const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
    expandable: false,
    symbol: (isExpanded) => isExpanded ? textLocale?.collapse : textLocale?.expand
  });
  const [expanded, setExpanded] = useMergedState(ellipsisConfig.defaultExpanded || false, {
    value: ellipsisConfig.expanded
  });
  const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
  const { rows = 1 } = ellipsisConfig;
  const needMeasureEllipsis = React597.useMemo(
    () => (
      // Disable ellipsis
      mergedEnableEllipsis && // Provide suffix
      (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
      ellipsisConfig.expandable || enableEdit || enableCopy)
    ),
    [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]
  );
  useLayoutEffect_default(() => {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
      setIsTextOverflowSupport(isStyleSupport("textOverflow"));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  const [cssEllipsis, setCssEllipsis] = React597.useState(mergedEnableEllipsis);
  const canUseCssEllipsis = React597.useMemo(() => {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  useLayoutEffect_default(() => {
    setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
  }, [canUseCssEllipsis, mergedEnableEllipsis]);
  const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  const onExpandClick = /* @__PURE__ */ __name((e3, info) => {
    setExpanded(info.expanded);
    ellipsisConfig.onExpand?.(e3, info);
  }, "onExpandClick");
  const [ellipsisWidth, setEllipsisWidth] = React597.useState(0);
  const onResize2 = /* @__PURE__ */ __name(({ offsetWidth }) => {
    setEllipsisWidth(offsetWidth);
  }, "onResize");
  const onJsEllipsis = /* @__PURE__ */ __name((jsEllipsis) => {
    setIsJsEllipsis(jsEllipsis);
    if (isJsEllipsis !== jsEllipsis) {
      ellipsisConfig.onEllipsis?.(jsEllipsis);
    }
  }, "onJsEllipsis");
  React597.useEffect(() => {
    const textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      const currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible, ellipsisWidth]);
  React597.useEffect(() => {
    const textEle = typographyRef.current;
    if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
      return;
    }
    const observer = new IntersectionObserver(() => {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    observer.observe(textEle);
    return () => {
      observer.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  let tooltipProps = {};
  if (ellipsisConfig.tooltip === true) {
    tooltipProps = { title: editConfig.text ?? children };
  } else if (React597.isValidElement(ellipsisConfig.tooltip)) {
    tooltipProps = { title: ellipsisConfig.tooltip };
  } else if (typeof ellipsisConfig.tooltip === "object") {
    tooltipProps = { title: editConfig.text ?? children, ...ellipsisConfig.tooltip };
  } else {
    tooltipProps = { title: ellipsisConfig.tooltip };
  }
  const topAriaLabel = React597.useMemo(() => {
    const isValid = /* @__PURE__ */ __name((val) => ["string", "number"].includes(typeof val), "isValid");
    if (!enableEllipsis || cssEllipsis) {
      return void 0;
    }
    if (isValid(editConfig.text)) {
      return editConfig.text;
    }
    if (isValid(children)) {
      return children;
    }
    if (isValid(title)) {
      return title;
    }
    if (isValid(tooltipProps.title)) {
      return tooltipProps.title;
    }
    return void 0;
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  if (editing) {
    return /* @__PURE__ */ React597.createElement(
      Editable_default,
      {
        value: editConfig.text ?? (typeof children === "string" ? children : ""),
        onSave: onEditChange,
        onCancel: onEditCancel,
        onEnd: editConfig.onEnd,
        prefixCls,
        className,
        style: style2,
        direction,
        component,
        maxLength: editConfig.maxLength,
        autoSize: editConfig.autoSize,
        enterIcon: editConfig.enterIcon
      }
    );
  }
  const renderExpand = /* @__PURE__ */ __name(() => {
    const { expandable, symbol } = ellipsisConfig;
    if (!expandable)
      return null;
    if (expanded && expandable !== "collapsible")
      return null;
    return /* @__PURE__ */ React597.createElement(
      "a",
      {
        key: "expand",
        className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
        onClick: (e3) => onExpandClick(e3, { expanded: !expanded }),
        "aria-label": expanded ? textLocale.collapse : textLocale?.expand
      },
      typeof symbol === "function" ? symbol(expanded) : symbol
    );
  }, "renderExpand");
  const renderEdit = /* @__PURE__ */ __name(() => {
    if (!enableEdit)
      return;
    const { icon, tooltip } = editConfig;
    const editTitle = toArray(tooltip)[0] || textLocale?.edit;
    const ariaLabel = typeof editTitle === "string" ? editTitle : "";
    return triggerType.includes("icon") ? /* @__PURE__ */ React597.createElement(tooltip_default, { key: "edit", title: tooltip === false ? "" : editTitle }, /* @__PURE__ */ React597.createElement(
      transButton_default,
      {
        ref: editIconRef,
        className: `${prefixCls}-edit`,
        onClick: onEditClick,
        "aria-label": ariaLabel
      },
      icon || /* @__PURE__ */ React597.createElement(import_EditOutlined.default, { role: "button" })
    )) : null;
  }, "renderEdit");
  const renderCopy = /* @__PURE__ */ __name(() => {
    if (!enableCopy) {
      return null;
    }
    return /* @__PURE__ */ React597.createElement(
      CopyBtn,
      {
        key: "copy",
        ...copyConfig,
        prefixCls,
        copied,
        locale: textLocale,
        onCopy: onCopyClick,
        loading: copyLoading,
        iconOnly: children === null || children === void 0
      }
    );
  }, "renderCopy");
  const renderOperations = /* @__PURE__ */ __name((canEllipsis) => [
    // (renderExpanded || ellipsisConfig.collapsible) && renderExpand(),
    canEllipsis && renderExpand(),
    renderEdit(),
    renderCopy()
  ], "renderOperations");
  const renderEllipsis = /* @__PURE__ */ __name((canEllipsis) => [
    canEllipsis && !expanded && /* @__PURE__ */ React597.createElement("span", { "aria-hidden": true, key: "ellipsis" }, ELLIPSIS_STR),
    ellipsisConfig.suffix,
    renderOperations(canEllipsis)
  ], "renderEllipsis");
  return /* @__PURE__ */ React597.createElement(src_default, { onResize: onResize2, disabled: !mergedEnableEllipsis }, (resizeRef) => /* @__PURE__ */ React597.createElement(
    EllipsisTooltip_default,
    {
      tooltipProps,
      enableEllipsis: mergedEnableEllipsis,
      isEllipsis: isMergedEllipsis
    },
    /* @__PURE__ */ React597.createElement(
      Typography_default,
      {
        className: (0, import_classnames266.default)(
          {
            [`${prefixCls}-${type5}`]: type5,
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-ellipsis`]: enableEllipsis,
            [`${prefixCls}-single-line`]: mergedEnableEllipsis && rows === 1 && !expanded,
            [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
            [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
          },
          className
        ),
        prefixCls: customizePrefixCls,
        style: {
          ...style2,
          WebkitLineClamp: cssLineClamp ? rows : void 0
        },
        component,
        ref: composeRef(resizeRef, typographyRef, ref),
        direction,
        onClick: triggerType.includes("text") ? onEditClick : void 0,
        "aria-label": topAriaLabel?.toString(),
        title,
        ...textProps
      },
      /* @__PURE__ */ React597.createElement(
        EllipsisMeasure,
        {
          enableMeasure: mergedEnableEllipsis && !cssEllipsis,
          text: children,
          rows,
          width: ellipsisWidth,
          onEllipsis: onJsEllipsis,
          expanded,
          miscDeps: [copied, expanded, copyLoading, enableEdit, enableCopy]
        },
        (node2, canEllipsis) => {
          let renderNode = node2;
          if (node2.length && canEllipsis && !expanded && topAriaLabel) {
            renderNode = /* @__PURE__ */ React597.createElement("span", { key: "show-content", "aria-hidden": true }, renderNode);
          }
          const wrappedContext = wrapperDecorations(
            props,
            /* @__PURE__ */ React597.createElement(React597.Fragment, null, renderNode, renderEllipsis(canEllipsis))
          );
          return wrappedContext;
        }
      )
    )
  ));
});
var Base_default = Base;

// packages/ant-design/components/typography/Link.tsx
var Link = React598.forwardRef(({ ellipsis, rel, ...restProps }, ref) => {
  if (true) {
    const warning5 = devUseWarning("Typography.Link");
    warning5(typeof ellipsis !== "object", "usage", "`ellipsis` only supports boolean value.");
  }
  const mergedProps = {
    ...restProps,
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  };
  delete mergedProps.navigate;
  return /* @__PURE__ */ React598.createElement(Base_default, { ...mergedProps, ref, ellipsis: !!ellipsis, component: "a" });
});
var Link_default = Link;

// packages/ant-design/components/typography/Paragraph.tsx
import * as React599 from "react";
var Paragraph2 = React599.forwardRef((props, ref) => /* @__PURE__ */ React599.createElement(Base_default, { ref, ...props, component: "div" }));
var Paragraph_default2 = Paragraph2;

// packages/ant-design/components/typography/Text.tsx
import * as React600 from "react";
var Text = /* @__PURE__ */ __name(({ ellipsis, ...restProps }, ref) => {
  const mergedEllipsis = React600.useMemo(() => {
    if (ellipsis && typeof ellipsis === "object") {
      return omit(ellipsis, ["expandable", "rows"]);
    }
    return ellipsis;
  }, [ellipsis]);
  if (true) {
    const warning5 = devUseWarning("Typography.Text");
    warning5(
      typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis),
      "usage",
      "`ellipsis` do not support `expandable` or `rows` props."
    );
  }
  return /* @__PURE__ */ React600.createElement(Base_default, { ref, ...restProps, ellipsis: mergedEllipsis, component: "span" });
}, "Text");
var Text_default = React600.forwardRef(Text);

// packages/ant-design/components/typography/Title.tsx
import * as React601 from "react";
var TITLE_ELE_LIST = [1, 2, 3, 4, 5];
var Title2 = React601.forwardRef((props, ref) => {
  const { level = 1, ...restProps } = props;
  let component;
  if (true) {
    const warning5 = devUseWarning("Typography.Title");
    warning5(
      TITLE_ELE_LIST.includes(level),
      "usage",
      "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version."
    );
  }
  if (TITLE_ELE_LIST.includes(level)) {
    component = `h${level}`;
  } else {
    component = "h1";
  }
  return /* @__PURE__ */ React601.createElement(Base_default, { ref, ...restProps, component });
});
var Title_default2 = Title2;

// packages/ant-design/components/typography/index.ts
var Typography2 = Typography_default;
Typography2.Text = Text_default;
Typography2.Link = Link_default;
Typography2.Title = Title_default2;
Typography2.Paragraph = Paragraph_default2;
var typography_default = Typography2;

// packages/ant-design/components/upload/Dragger.tsx
import * as React607 from "react";

// packages/ant-design/components/upload/Upload.tsx
var import_classnames270 = __toESM(require_classnames());
import * as React606 from "react";
import { flushSync as flushSync4 } from "react-dom";

// packages/upload/src/Upload.tsx
import React603, { Component as Component10 } from "react";

// packages/upload/src/AjaxUploader.tsx
var import_classnames267 = __toESM(require_classnames());
import React602, { Component as Component9 } from "react";

// packages/upload/src/attr-accept.ts
init_warning();
var attr_accept_default = /* @__PURE__ */ __name((file, acceptedFiles) => {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name || "";
    const mimeType = file.type || "";
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type5) => {
      const validType = type5.trim();
      if (/^\*(\/\*)?$/.test(type5)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        const lowerFileName = fileName.toLowerCase();
        const lowerType = validType.toLowerCase();
        let affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some((affix) => lowerFileName.endsWith(affix));
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        warning_default(false, `Upload takes an invalidate 'accept' type '${validType}'.Skip for check.`);
        return true;
      }
      return false;
    });
  }
  return true;
}, "default");

// packages/upload/src/request.ts
function getError(option, xhr) {
  const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
__name(getError, "getError");
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e3) {
    return text;
  }
}
__name(getBody, "getBody");
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = /* @__PURE__ */ __name(function progress(e3) {
      if (e3.total > 0) {
        e3.percent = e3.loaded / e3.total * 100;
      }
      option.onProgress(e3);
    }, "progress");
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach((key) => {
      const value = option.data[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key}[]`, item);
        });
        return;
      }
      formData.append(key, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = /* @__PURE__ */ __name(function error(e3) {
    option.onError(e3);
  }, "error");
  xhr.onload = /* @__PURE__ */ __name(function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  }, "onload");
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h) => {
    if (headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}
__name(upload, "upload");

// packages/upload/src/traverseFileTree.ts
function loopFiles(item, callback) {
  const dirReader = item.createReader();
  let fileList = [];
  function sequence() {
    dirReader.readEntries((entries) => {
      const entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList);
      const isFinished = !entryList.length;
      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }
  __name(sequence, "sequence");
  sequence();
}
__name(loopFiles, "loopFiles");
var traverseFileTree = /* @__PURE__ */ __name((files, callback, isAccepted) => {
  const _traverseFileTree = /* @__PURE__ */ __name((item, path2) => {
    if (!item) {
      return;
    }
    item.path = path2 || "";
    if (item.isFile) {
      item.file((file) => {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, (entries) => {
        entries.forEach((entryItem) => {
          _traverseFileTree(entryItem, `${path2}${item.name}/`);
        });
      });
    }
  }, "_traverseFileTree");
  files.forEach((file) => {
    _traverseFileTree(file.webkitGetAsEntry());
  });
}, "traverseFileTree");
var traverseFileTree_default = traverseFileTree;

// packages/upload/src/uid.ts
var now = +/* @__PURE__ */ new Date();
var index2 = 0;
function uid2() {
  return `rc-upload-${now}-${++index2}`;
}
__name(uid2, "uid");

// packages/upload/src/AjaxUploader.tsx
var AjaxUploader = class extends Component9 {
  static {
    __name(this, "AjaxUploader");
  }
  state = { uid: uid2() };
  reqs = {};
  fileInput;
  _isMounted;
  onChange = (e3) => {
    const { accept, directory } = this.props;
    const { files } = e3.target;
    const acceptedFiles = [...files].filter(
      (file) => !directory || attr_accept_default(file, accept)
    );
    this.uploadFiles(acceptedFiles);
    this.reset();
  };
  onClick = (event) => {
    const el = this.fileInput;
    if (!el) {
      return;
    }
    const target = event.target;
    const { onClick } = this.props;
    if (target && target.tagName === "BUTTON") {
      const parent = el.parentNode;
      parent.focus();
      target.blur();
    }
    el.click();
    if (onClick) {
      onClick(event);
    }
  };
  onKeyDown = (e3) => {
    if (e3.key === "Enter") {
      this.onClick(e3);
    }
  };
  onFileDrop = (e3) => {
    const { multiple } = this.props;
    e3.preventDefault();
    if (e3.type === "dragover") {
      return;
    }
    if (this.props.directory) {
      traverseFileTree_default(
        Array.prototype.slice.call(e3.dataTransfer.items),
        this.uploadFiles,
        (_file) => attr_accept_default(_file, this.props.accept)
      );
    } else {
      let files = [...e3.dataTransfer.files].filter(
        (file) => attr_accept_default(file, this.props.accept)
      );
      if (multiple === false) {
        files = files.slice(0, 1);
      }
      this.uploadFiles(files);
    }
  };
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
    this.abort();
  }
  uploadFiles = (files) => {
    const originFiles = [...files];
    const postFiles = originFiles.map((file) => {
      file.uid = uid2();
      return this.processFile(file, originFiles);
    });
    Promise.all(postFiles).then((fileList) => {
      const { onBatchStart } = this.props;
      onBatchStart?.(fileList.map(({ origin, parsedFile }) => ({ file: origin, parsedFile })));
      fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
        this.post(file);
      });
    });
  };
  /**
   * Process file before upload. When all the file is ready, we start upload.
   */
  processFile = async (file, fileList) => {
    const { beforeUpload } = this.props;
    let transformedFile = file;
    if (beforeUpload) {
      try {
        transformedFile = await beforeUpload(file, fileList);
      } catch (e3) {
        transformedFile = false;
      }
      if (transformedFile === false) {
        return {
          origin: file,
          parsedFile: null,
          action: null,
          data: null
        };
      }
    }
    const { action } = this.props;
    let mergedAction;
    if (typeof action === "function") {
      mergedAction = await action(file);
    } else {
      mergedAction = action;
    }
    const { data } = this.props;
    let mergedData;
    if (typeof data === "function") {
      mergedData = await data(file);
    } else {
      mergedData = data;
    }
    const parsedData = (
      // string type is from legacy `transformFile`.
      // Not sure if this will work since no related test case works with it
      (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file
    );
    let parsedFile;
    if (parsedData instanceof File) {
      parsedFile = parsedData;
    } else {
      parsedFile = new File([parsedData], file.name, { type: file.type });
    }
    const mergedParsedFile = parsedFile;
    mergedParsedFile.uid = file.uid;
    return {
      origin: file,
      data: mergedData,
      parsedFile: mergedParsedFile,
      action: mergedAction
    };
  };
  post({ data, origin, action, parsedFile }) {
    if (!this._isMounted) {
      return;
    }
    const { onStart, customRequest, name, headers, withCredentials, method: method4 } = this.props;
    const { uid: uid3 } = origin;
    const request = customRequest || upload;
    const requestOption = {
      action,
      filename: name,
      data,
      file: parsedFile,
      headers,
      withCredentials,
      method: method4 || "post",
      onProgress: (e3) => {
        const { onProgress } = this.props;
        onProgress?.(e3, parsedFile);
      },
      onSuccess: (ret, xhr) => {
        const { onSuccess } = this.props;
        onSuccess?.(ret, parsedFile, xhr);
        delete this.reqs[uid3];
      },
      onError: (err, ret) => {
        const { onError } = this.props;
        onError?.(err, ret, parsedFile);
        delete this.reqs[uid3];
      }
    };
    onStart(origin);
    this.reqs[uid3] = request(requestOption);
  }
  reset() {
    this.setState({
      uid: uid2()
    });
  }
  abort(file) {
    const { reqs } = this;
    if (file) {
      const uid3 = file.uid ? file.uid : file;
      if (reqs[uid3] && reqs[uid3].abort) {
        reqs[uid3].abort();
      }
      delete reqs[uid3];
    } else {
      Object.keys(reqs).forEach((uid3) => {
        if (reqs[uid3] && reqs[uid3].abort) {
          reqs[uid3].abort();
        }
        delete reqs[uid3];
      });
    }
  }
  saveFileInput = (node2) => {
    this.fileInput = node2;
  };
  render() {
    const {
      component: Tag2,
      prefixCls,
      className,
      classNames: classNames253 = {},
      disabled,
      id,
      style: style2,
      styles = {},
      multiple,
      accept,
      capture,
      children,
      directory,
      openFileDialogOnClick,
      onMouseEnter,
      onMouseLeave,
      hasControlInside,
      ...otherProps
    } = this.props;
    const cls5 = (0, import_classnames267.default)({
      [prefixCls]: true,
      [`${prefixCls}-disabled`]: disabled,
      [className]: className
    });
    const dirProps = directory ? { directory: "directory", webkitdirectory: "webkitdirectory" } : {};
    const events = disabled ? {} : {
      onClick: openFileDialogOnClick ? this.onClick : () => {
      },
      onKeyDown: openFileDialogOnClick ? this.onKeyDown : () => {
      },
      onMouseEnter,
      onMouseLeave,
      onDrop: this.onFileDrop,
      onDragOver: this.onFileDrop,
      tabIndex: hasControlInside ? void 0 : "0"
    };
    return /* @__PURE__ */ React602.createElement(Tag2, { ...events, className: cls5, role: hasControlInside ? void 0 : "button", style: style2 }, /* @__PURE__ */ React602.createElement(
      "input",
      {
        ...pickAttrs(otherProps, { aria: true, data: true }),
        id,
        disabled,
        type: "file",
        ref: this.saveFileInput,
        onClick: (e3) => e3.stopPropagation(),
        key: this.state.uid,
        style: { display: "none", ...styles.input },
        className: classNames253.input,
        accept,
        ...dirProps,
        multiple,
        onChange: this.onChange,
        ...capture != null ? { capture } : {}
      }
    ), children);
  }
};
var AjaxUploader_default = AjaxUploader;

// packages/upload/src/Upload.tsx
function empty() {
}
__name(empty, "empty");
var Upload = class extends Component10 {
  static {
    __name(this, "Upload");
  }
  static defaultProps = {
    component: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true,
    hasControlInside: false
  };
  uploader;
  abort(file) {
    this.uploader.abort(file);
  }
  saveUploader = (node2) => {
    this.uploader = node2;
  };
  render() {
    return /* @__PURE__ */ React603.createElement(AjaxUploader_default, { ...this.props, ref: this.saveUploader });
  }
};
var Upload_default = Upload;

// packages/upload/src/index.ts
var src_default31 = Upload_default;

// packages/ant-design/components/upload/style/dragger.ts
var genDraggerStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token2.colorFillAlter,
        border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [componentCls]: {
          padding: token2.padding
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none",
          borderRadius: token2.borderRadiusLG,
          "&:focus-visible": {
            outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`
          }
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
          borderColor: token2.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token2.margin,
          [iconCls]: {
            color: token2.colorPrimary,
            fontSize: token2.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${unit(token2.marginXXS)}`,
          color: token2.colorTextHeading,
          fontSize: token2.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token2.colorTextDescription,
          fontSize: token2.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token2.colorTextDisabled
          }
        }
      }
    }
  };
}, "genDraggerStyle");
var dragger_default = genDraggerStyle;

// packages/ant-design/components/upload/style/list.ts
var genListStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, antCls, iconCls, fontSize, lineHeight, calc } = token2;
  const itemCls = `${componentCls}-list-item`;
  const actionsCls = `${itemCls}-actions`;
  const actionCls = `${itemCls}-action`;
  const listItemHeightSM = token2.fontHeightSM;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: {
        ...clearFix(),
        lineHeight: token2.lineHeight,
        [itemCls]: {
          position: "relative",
          height: calc(token2.lineHeight).mul(fontSize).equal(),
          marginTop: token2.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token2.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: token2.controlItemBgHover
          },
          [`${itemCls}-name`]: {
            ...textEllipsis,
            padding: `0 ${unit(token2.paddingXS)}`,
            lineHeight,
            flex: "auto",
            transition: `all ${token2.motionDurationSlow}`
          },
          [actionsCls]: {
            whiteSpace: "nowrap",
            [actionCls]: {
              opacity: 0
            },
            [iconCls]: {
              color: token2.actionsColor,
              transition: `all ${token2.motionDurationSlow}`
            },
            [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            },
            [`${actionCls}${antCls}-btn`]: {
              height: listItemHeightSM,
              border: 0,
              lineHeight: 1
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token2.colorTextDescription,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: token2.calc(token2.uploadProgressOffset).mul(-1).equal(),
            width: "100%",
            paddingInlineStart: calc(fontSize).add(token2.paddingXS).equal(),
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1
        },
        [`${itemCls}-error`]: {
          color: token2.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token2.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token2.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      }
    }
  };
}, "genListStyle");
var list_default3 = genListStyle;

// packages/ant-design/components/upload/style/motion.ts
var genMotionStyle3 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", {
    from: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  });
  const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", {
    to: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  });
  const inlineCls = `${componentCls}-animate-inline`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseInOutCirc,
          animationFillMode: "forwards"
        },
        [`${inlineCls}-appear, ${inlineCls}-enter`]: {
          animationName: uploadAnimateInlineIn
        },
        [`${inlineCls}-leave`]: {
          animationName: uploadAnimateInlineOut
        }
      }
    },
    {
      [`${componentCls}-wrapper`]: initFadeMotion(token2)
    },
    uploadAnimateInlineIn,
    uploadAnimateInlineOut
  ];
}, "genMotionStyle");
var motion_default4 = genMotionStyle3;

// packages/ant-design/components/upload/style/picture.ts
init_src();
var genPictureStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls, uploadThumbnailSize, uploadProgressOffset, calc } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 增加优先级
      [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
        [itemCls]: {
          position: "relative",
          height: calc(uploadThumbnailSize).add(calc(token2.lineWidth).mul(2)).add(calc(token2.paddingXS).mul(2)).equal(),
          padding: token2.paddingXS,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: {
            ...textEllipsis,
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: unit(calc(uploadThumbnailSize).add(token2.paddingSM).equal()),
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token2.fontSizeHeading2,
              color: token2.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          },
          [`${itemCls}-progress`]: {
            bottom: uploadProgressOffset,
            width: `calc(100% - ${unit(calc(token2.paddingSM).mul(2).equal())})`,
            marginTop: 0,
            paddingInlineStart: calc(uploadThumbnailSize).add(token2.paddingXS).equal()
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token2.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='${blue[0]}']`]: {
              fill: token2.colorErrorBg
            },
            [`svg path[fill='${blue.primary}']`]: {
              fill: token2.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      },
      [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
        [`&, &::before, ${itemCls}-thumbnail`]: {
          borderRadius: "50%"
        }
      }
    }
  };
}, "genPictureStyle");
var genPictureCardStyle = /* @__PURE__ */ __name((token2) => {
  const { componentCls, iconCls, fontSizeLG, colorTextLightSolid, calc } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  const uploadPictureCardSize = token2.uploadPicCardSize;
  return {
    [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: {
      ...clearFix(),
      display: "block",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token2.colorFillAlter,
        border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token2.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
        display: "flex",
        flexWrap: "wrap",
        "@supports not (gap: 1px)": {
          "& > *": {
            marginBlockEnd: token2.marginXS,
            marginInlineEnd: token2.marginXS
          }
        },
        "@supports (gap: 1px)": {
          gap: token2.marginXS
        },
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        "&::before": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
            height: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
            backgroundColor: token2.colorBgMask,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          [`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${unit(token2.marginXXS)}`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            color: colorTextLightSolid,
            "&:hover": {
              color: colorTextLightSolid
            },
            svg: {
              verticalAlign: "baseline"
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token2.margin,
          display: "block",
          width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token2.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token2.marginXL,
          width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
          paddingInlineStart: 0
        }
      }
    },
    [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
      [`${componentCls}${componentCls}-select`]: {
        borderRadius: "50%"
      }
    }
  };
}, "genPictureCardStyle");

// packages/ant-design/components/upload/style/rtl.ts
var genRtlStyle3 = /* @__PURE__ */ __name((token2) => {
  const { componentCls } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, "genRtlStyle");
var rtl_default4 = genRtlStyle3;

// packages/ant-design/components/upload/style/index.ts
var genBaseStyle19 = /* @__PURE__ */ __name((token2) => {
  const { componentCls, colorTextDisabled } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token2),
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  };
}, "genBaseStyle");
var prepareComponentToken57 = /* @__PURE__ */ __name((token2) => ({
  actionsColor: token2.colorTextDescription
}), "prepareComponentToken");
var style_default63 = genStyleHooks(
  "Upload",
  (token2) => {
    const { fontSizeHeading3, fontHeight, lineWidth, controlHeightLG, calc } = token2;
    const uploadToken = merge2(token2, {
      uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
      uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
      uploadPicCardSize: calc(controlHeightLG).mul(2.55).equal()
    });
    return [
      genBaseStyle19(uploadToken),
      dragger_default(uploadToken),
      genPictureStyle(uploadToken),
      genPictureCardStyle(uploadToken),
      list_default3(uploadToken),
      motion_default4(uploadToken),
      rtl_default4(uploadToken),
      collapse_default(uploadToken)
    ];
  },
  prepareComponentToken57
);

// packages/ant-design/components/upload/UploadList/index.tsx
var import_FileTwoTone = __toESM(require_FileTwoTone3());
var import_LoadingOutlined10 = __toESM(require_LoadingOutlined3());
var import_PaperClipOutlined = __toESM(require_PaperClipOutlined3());
var import_PictureTwoTone = __toESM(require_PictureTwoTone3());
var import_classnames269 = __toESM(require_classnames());
import * as React605 from "react";

// packages/ant-design/components/upload/utils.ts
function file2Obj(file) {
  return {
    ...file,
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  };
}
__name(file2Obj, "file2Obj");
function updateFileList(file, fileList) {
  const nextFileList = [...fileList];
  const fileIndex = nextFileList.findIndex(({ uid: uid3 }) => uid3 === file.uid);
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
__name(updateFileList, "updateFileList");
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
__name(getFileItem, "getFileItem");
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
__name(removeFileItem, "removeFileItem");
var extname = /* @__PURE__ */ __name((url2 = "") => {
  const temp = url2.split("/");
  const filename = temp[temp.length - 1];
  const filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
}, "extname");
var isImageFileType = /* @__PURE__ */ __name((type5) => type5.indexOf("image/") === 0, "isImageFileType");
var isImageUrl = /* @__PURE__ */ __name((file) => {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  const url2 = file.thumbUrl || file.url || "";
  const extension = extname(url2);
  if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url2)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
}, "isImageUrl");
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
      const { width, height } = img;
      let drawWidth = MEASURE_SIZE;
      let drawHeight = MEASURE_SIZE;
      let offsetX = 0;
      let offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      window.URL.revokeObjectURL(img.src);
      resolve(dataURL);
    };
    img.crossOrigin = "anonymous";
    if (file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result && typeof reader.result === "string") {
          img.src = reader.result;
        }
      };
      reader.readAsDataURL(file);
    } else if (file.type.startsWith("image/gif")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result) {
          resolve(reader.result);
        }
      };
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}
__name(previewImage, "previewImage");

// packages/ant-design/components/upload/UploadList/ListItem.tsx
var import_DeleteOutlined2 = __toESM(require_DeleteOutlined3());
var import_DownloadOutlined = __toESM(require_DownloadOutlined3());
var import_EyeOutlined3 = __toESM(require_EyeOutlined3());
var import_classnames268 = __toESM(require_classnames());
import * as React604 from "react";
var ListItem2 = React604.forwardRef(
  ({
    prefixCls,
    className,
    style: style2,
    locale: locale6,
    listType,
    file,
    items,
    progress: progressProps,
    iconRender,
    actionIconRender,
    itemRender,
    isImgUrl,
    showPreviewIcon,
    showRemoveIcon,
    showDownloadIcon,
    previewIcon: customPreviewIcon,
    removeIcon: customRemoveIcon,
    downloadIcon: customDownloadIcon,
    onPreview,
    onDownload,
    onClose
  }, ref) => {
    const { status } = file;
    const [mergedStatus, setMergedStatus] = React604.useState(status);
    React604.useEffect(() => {
      if (status !== "removed") {
        setMergedStatus(status);
      }
    }, [status]);
    const [showProgress, setShowProgress] = React604.useState(false);
    React604.useEffect(() => {
      const timer = setTimeout(() => {
        setShowProgress(true);
      }, 300);
      return () => {
        clearTimeout(timer);
      };
    }, []);
    const iconNode = iconRender(file);
    let icon = /* @__PURE__ */ React604.createElement("div", { className: `${prefixCls}-icon` }, iconNode);
    if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
      if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
        const uploadingClassName = (0, import_classnames268.default)(`${prefixCls}-list-item-thumbnail`, {
          [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
        });
        icon = /* @__PURE__ */ React604.createElement("div", { className: uploadingClassName }, iconNode);
      } else {
        const thumbnail = isImgUrl?.(file) ? /* @__PURE__ */ React604.createElement(
          "img",
          {
            src: file.thumbUrl || file.url,
            alt: file.name,
            className: `${prefixCls}-list-item-image`,
            crossOrigin: file.crossOrigin
          }
        ) : iconNode;
        const aClassName = (0, import_classnames268.default)(`${prefixCls}-list-item-thumbnail`, {
          [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
        });
        icon = /* @__PURE__ */ React604.createElement(
          "a",
          {
            className: aClassName,
            onClick: (e3) => onPreview(file, e3),
            href: file.url || file.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          },
          thumbnail
        );
      }
    }
    const listItemClassName = (0, import_classnames268.default)(
      `${prefixCls}-list-item`,
      `${prefixCls}-list-item-${mergedStatus}`
    );
    const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
    const removeIcon = showRemoveIcon ? actionIconRender(
      (typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ React604.createElement(import_DeleteOutlined2.default, null),
      () => onClose(file),
      prefixCls,
      locale6.removeFile,
      // acceptUploadDisabled is true, only remove icon will follow Upload disabled prop
      // https://github.com/ant-design/ant-design/issues/46171
      true
    ) : null;
    const downloadIcon = showDownloadIcon && mergedStatus === "done" ? actionIconRender(
      (typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ React604.createElement(import_DownloadOutlined.default, null),
      () => onDownload(file),
      prefixCls,
      locale6.downloadFile
    ) : null;
    const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ React604.createElement(
      "span",
      {
        key: "download-delete",
        className: (0, import_classnames268.default)(`${prefixCls}-list-item-actions`, {
          picture: listType === "picture"
        })
      },
      downloadIcon,
      removeIcon
    );
    const listItemNameClass = (0, import_classnames268.default)(`${prefixCls}-list-item-name`);
    const fileName = file.url ? [
      /* @__PURE__ */ React604.createElement(
        "a",
        {
          key: "view",
          target: "_blank",
          rel: "noopener noreferrer",
          className: listItemNameClass,
          title: file.name,
          ...linkProps,
          href: file.url,
          onClick: (e3) => onPreview(file, e3)
        },
        file.name
      ),
      downloadOrDelete
    ] : [
      /* @__PURE__ */ React604.createElement(
        "span",
        {
          key: "view",
          className: listItemNameClass,
          onClick: (e3) => onPreview(file, e3),
          title: file.name
        },
        file.name
      ),
      downloadOrDelete
    ];
    const previewIcon = showPreviewIcon && (file.url || file.thumbUrl) ? /* @__PURE__ */ React604.createElement(
      "a",
      {
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        onClick: (e3) => onPreview(file, e3),
        title: locale6.previewFile
      },
      typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ React604.createElement(import_EyeOutlined3.default, null)
    ) : null;
    const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ React604.createElement("span", { className: `${prefixCls}-list-item-actions` }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
    const { getPrefixCls } = React604.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const dom = /* @__PURE__ */ React604.createElement("div", { className: listItemClassName }, icon, fileName, pictureCardActions, showProgress && /* @__PURE__ */ React604.createElement(
      src_default2,
      {
        motionName: `${rootPrefixCls}-fade`,
        visible: mergedStatus === "uploading",
        motionDeadline: 2e3
      },
      ({ className: motionClassName }) => {
        const loadingProgress = "percent" in file ? /* @__PURE__ */ React604.createElement(
          progress_default2,
          {
            ...progressProps,
            type: "line",
            percent: file.percent,
            "aria-label": file["aria-label"],
            "aria-labelledby": file["aria-labelledby"]
          }
        ) : null;
        return /* @__PURE__ */ React604.createElement("div", { className: (0, import_classnames268.default)(`${prefixCls}-list-item-progress`, motionClassName) }, loadingProgress);
      }
    ));
    const message2 = file.response && typeof file.response === "string" ? file.response : file.error?.statusText || file.error?.message || locale6.uploadError;
    const item = mergedStatus === "error" ? /* @__PURE__ */ React604.createElement(tooltip_default, { title: message2, getPopupContainer: (node2) => node2.parentNode }, dom) : dom;
    return /* @__PURE__ */ React604.createElement(
      "div",
      {
        className: (0, import_classnames268.default)(`${prefixCls}-list-item-container`, className),
        style: style2,
        ref
      },
      itemRender ? itemRender(item, file, items, {
        download: onDownload.bind(null, file),
        preview: onPreview.bind(null, file),
        remove: onClose.bind(null, file)
      }) : item
    );
  }
);
var ListItem_default2 = ListItem2;

// packages/ant-design/components/upload/UploadList/index.tsx
var InternalUploadList = /* @__PURE__ */ __name((props, ref) => {
  const {
    listType = "text",
    previewFile = previewImage,
    onPreview,
    onDownload,
    onRemove,
    locale: locale6,
    iconRender,
    isImageUrl: isImgUrl = isImageUrl,
    prefixCls: customizePrefixCls,
    items = [],
    showPreviewIcon = true,
    showRemoveIcon = true,
    showDownloadIcon = false,
    removeIcon,
    previewIcon,
    downloadIcon,
    progress = { size: [-1, 2], showInfo: false },
    appendAction,
    appendActionVisible = true,
    itemRender,
    disabled
  } = props;
  const forceUpdate = useForceUpdate();
  const [motionAppear, setMotionAppear] = React605.useState(false);
  React605.useEffect(() => {
    if (listType !== "picture" && listType !== "picture-card" && listType !== "picture-circle") {
      return;
    }
    (items || []).forEach((file) => {
      if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj) || file.thumbUrl !== void 0) {
        return;
      }
      if (previewFile) {
        previewFile(file.originFileObj).then((previewDataUrl) => {
          file.thumbUrl = previewDataUrl || "";
          forceUpdate();
        });
      }
    });
  }, [listType, items, previewFile]);
  React605.useEffect(() => {
    setMotionAppear(true);
  }, []);
  const onInternalPreview = /* @__PURE__ */ __name((file, e3) => {
    if (!onPreview) {
      return;
    }
    e3?.preventDefault();
    return onPreview(file);
  }, "onInternalPreview");
  const onInternalDownload = /* @__PURE__ */ __name((file) => {
    if (typeof onDownload === "function") {
      onDownload(file);
    } else if (file.url) {
      window.open(file.url);
    }
  }, "onInternalDownload");
  const onInternalClose = /* @__PURE__ */ __name((file) => {
    onRemove?.(file);
  }, "onInternalClose");
  const internalIconRender = /* @__PURE__ */ __name((file) => {
    if (iconRender) {
      return iconRender(file, listType);
    }
    const isLoading = file.status === "uploading";
    const fileIcon = isImgUrl && isImgUrl(file) ? /* @__PURE__ */ React605.createElement(import_PictureTwoTone.default, null) : /* @__PURE__ */ React605.createElement(import_FileTwoTone.default, null);
    let icon = isLoading ? /* @__PURE__ */ React605.createElement(import_LoadingOutlined10.default, null) : /* @__PURE__ */ React605.createElement(import_PaperClipOutlined.default, null);
    if (listType === "picture") {
      icon = isLoading ? /* @__PURE__ */ React605.createElement(import_LoadingOutlined10.default, null) : fileIcon;
    } else if (listType === "picture-card" || listType === "picture-circle") {
      icon = isLoading ? locale6.uploading : fileIcon;
    }
    return icon;
  }, "internalIconRender");
  const actionIconRender = /* @__PURE__ */ __name((customIcon, callback, prefixCls2, title, acceptUploadDisabled) => {
    const btnProps = {
      type: "text",
      size: "small",
      title,
      onClick: (e3) => {
        callback();
        if (React605.isValidElement(customIcon)) {
          customIcon.props.onClick?.(e3);
        }
      },
      className: `${prefixCls2}-list-item-action`
    };
    if (acceptUploadDisabled) {
      btnProps.disabled = disabled;
    }
    if (React605.isValidElement(customIcon)) {
      const btnIcon = cloneElement3(customIcon, {
        ...customIcon.props,
        onClick: () => {
        }
      });
      return /* @__PURE__ */ React605.createElement(button_default2, { ...btnProps, icon: btnIcon });
    }
    return /* @__PURE__ */ React605.createElement(button_default2, { ...btnProps }, /* @__PURE__ */ React605.createElement("span", null, customIcon));
  }, "actionIconRender");
  React605.useImperativeHandle(ref, () => ({
    handlePreview: onInternalPreview,
    handleDownload: onInternalDownload
  }));
  const { getPrefixCls } = React605.useContext(ConfigContext);
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const listClassNames = (0, import_classnames269.default)(`${prefixCls}-list`, `${prefixCls}-list-${listType}`);
  const motionKeyList = [...items.map((file) => ({ key: file.uid, file }))];
  const animationDirection = listType === "picture-card" || listType === "picture-circle" ? "animate-inline" : "animate";
  let motionConfig = {
    motionDeadline: 2e3,
    motionName: `${prefixCls}-${animationDirection}`,
    keys: motionKeyList,
    motionAppear
  };
  const listItemMotion = React605.useMemo(() => {
    const motion2 = {
      ...motion_default(rootPrefixCls)
    };
    delete motion2.onAppearEnd;
    delete motion2.onEnterEnd;
    delete motion2.onLeaveEnd;
    return motion2;
  }, [rootPrefixCls]);
  if (listType !== "picture-card" && listType !== "picture-circle") {
    motionConfig = {
      ...listItemMotion,
      ...motionConfig
    };
  }
  return /* @__PURE__ */ React605.createElement("div", { className: listClassNames }, /* @__PURE__ */ React605.createElement(CSSMotionList_default, { ...motionConfig, component: false }, ({ key, file, className: motionClassName, style: motionStyle }) => /* @__PURE__ */ React605.createElement(
    ListItem_default2,
    {
      key,
      locale: locale6,
      prefixCls,
      className: motionClassName,
      style: motionStyle,
      file,
      items,
      progress,
      listType,
      isImgUrl,
      showPreviewIcon,
      showRemoveIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      iconRender: internalIconRender,
      actionIconRender,
      itemRender,
      onPreview: onInternalPreview,
      onDownload: onInternalDownload,
      onClose: onInternalClose
    }
  )), appendAction && /* @__PURE__ */ React605.createElement(src_default2, { ...motionConfig, visible: appendActionVisible, forceRender: true }, ({ className: motionClassName, style: motionStyle }) => cloneElement3(appendAction, (oriProps) => ({
    className: (0, import_classnames269.default)(oriProps.className, motionClassName),
    style: {
      ...motionStyle,
      // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
      pointerEvents: motionClassName ? "none" : void 0,
      ...oriProps.style
    }
  }))));
}, "InternalUploadList");
var UploadList = React605.forwardRef(InternalUploadList);
if (true) {
  UploadList.displayName = "UploadList";
}
var UploadList_default = UploadList;

// packages/ant-design/components/upload/Upload.tsx
var LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var InternalUpload = /* @__PURE__ */ __name((props, ref) => {
  const {
    fileList,
    defaultFileList,
    onRemove,
    showUploadList = true,
    listType = "text",
    onPreview,
    onDownload,
    onChange,
    onDrop,
    previewFile,
    disabled: customDisabled,
    locale: propLocale,
    iconRender,
    isImageUrl: isImageUrl2,
    progress,
    prefixCls: customizePrefixCls,
    className,
    type: type5 = "select",
    children,
    style: style2,
    itemRender,
    maxCount,
    data = {},
    multiple = false,
    hasControlInside = true,
    action = "",
    accept = "",
    supportServerRender = true,
    rootClassName
  } = props;
  const disabled = React606.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
    value: fileList,
    postState: (list) => list ?? []
  });
  const [dragState, setDragState] = React606.useState("drop");
  const upload2 = React606.useRef(null);
  if (true) {
    const warning5 = devUseWarning("Upload");
    warning5(
      "fileList" in props || !("value" in props),
      "usage",
      "`value` is not a valid prop, do you mean `fileList`?"
    );
    warning5.deprecated(!("transformFile" in props), "transformFile", "beforeUpload");
  }
  React606.useMemo(() => {
    const timestamp = Date.now();
    (fileList || []).forEach((file, index3) => {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = `__AUTO__${timestamp}_${index3}__`;
      }
    });
  }, [fileList]);
  const onInternalChange = /* @__PURE__ */ __name((file, changedFileList, event) => {
    let cloneList = [...changedFileList];
    let exceedMaxCount = false;
    if (maxCount === 1) {
      cloneList = cloneList.slice(-1);
    } else if (maxCount) {
      exceedMaxCount = cloneList.length > maxCount;
      cloneList = cloneList.slice(0, maxCount);
    }
    flushSync4(() => {
      setMergedFileList(cloneList);
    });
    const changeInfo = {
      file,
      fileList: cloneList
    };
    if (event) {
      changeInfo.event = event;
    }
    if (!exceedMaxCount || file.status === "removed" || // We should ignore event if current file is exceed `maxCount`
    cloneList.some((f) => f.uid === file.uid)) {
      flushSync4(() => {
        onChange?.(changeInfo);
      });
    }
  }, "onInternalChange");
  const mergedBeforeUpload = /* @__PURE__ */ __name(async (file, fileListArgs) => {
    const { beforeUpload, transformFile } = props;
    let parsedFile = file;
    if (beforeUpload) {
      const result = await beforeUpload(file, fileListArgs);
      if (result === false) {
        return false;
      }
      delete file[LIST_IGNORE];
      if (result === LIST_IGNORE) {
        Object.defineProperty(file, LIST_IGNORE, {
          value: true,
          configurable: true
        });
        return false;
      }
      if (typeof result === "object" && result) {
        parsedFile = result;
      }
    }
    if (transformFile) {
      parsedFile = await transformFile(parsedFile);
    }
    return parsedFile;
  }, "mergedBeforeUpload");
  const onBatchStart = /* @__PURE__ */ __name((batchFileInfoList) => {
    const filteredFileInfoList = batchFileInfoList.filter(
      (info) => !info.file[LIST_IGNORE]
    );
    if (!filteredFileInfoList.length) {
      return;
    }
    const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
    let newFileList = [...mergedFileList];
    objectFileList.forEach((fileObj) => {
      newFileList = updateFileList(fileObj, newFileList);
    });
    objectFileList.forEach((fileObj, index3) => {
      let triggerFileObj = fileObj;
      if (!filteredFileInfoList[index3].parsedFile) {
        const { originFileObj } = fileObj;
        let clone;
        try {
          clone = new File([originFileObj], originFileObj.name, {
            type: originFileObj.type
          });
        } catch (e3) {
          clone = new Blob([originFileObj], {
            type: originFileObj.type
          });
          clone.name = originFileObj.name;
          clone.lastModifiedDate = /* @__PURE__ */ new Date();
          clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
        }
        clone.uid = fileObj.uid;
        triggerFileObj = clone;
      } else {
        fileObj.status = "uploading";
      }
      onInternalChange(triggerFileObj, newFileList);
    });
  }, "onBatchStart");
  const onSuccess = /* @__PURE__ */ __name((response, file, xhr) => {
    try {
      if (typeof response === "string") {
        response = JSON.parse(response);
      }
    } catch (e3) {
    }
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "done";
    targetItem.percent = 100;
    targetItem.response = response;
    targetItem.xhr = xhr;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  }, "onSuccess");
  const onProgress = /* @__PURE__ */ __name((e3, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "uploading";
    targetItem.percent = e3.percent;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList, e3);
  }, "onProgress");
  const onError = /* @__PURE__ */ __name((error, response, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.error = error;
    targetItem.response = response;
    targetItem.status = "error";
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  }, "onError");
  const handleRemove = /* @__PURE__ */ __name((file) => {
    let currentFile;
    Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
      if (ret === false) {
        return;
      }
      const removedFileList = removeFileItem(file, mergedFileList);
      if (removedFileList) {
        currentFile = { ...file, status: "removed" };
        mergedFileList?.forEach((item) => {
          const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
          if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
            item.status = "removed";
          }
        });
        upload2.current?.abort(currentFile);
        onInternalChange(currentFile, removedFileList);
      }
    });
  }, "handleRemove");
  const onFileDrop = /* @__PURE__ */ __name((e3) => {
    setDragState(e3.type);
    if (e3.type === "drop") {
      onDrop?.(e3);
    }
  }, "onFileDrop");
  React606.useImperativeHandle(ref, () => ({
    onBatchStart,
    onSuccess,
    onProgress,
    onError,
    fileList: mergedFileList,
    upload: upload2.current
  }));
  const { getPrefixCls, direction, upload: ctxUpload } = React606.useContext(ConfigContext);
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const rcUploadProps = {
    onBatchStart,
    onError,
    onProgress,
    onSuccess,
    ...props,
    data,
    multiple,
    action,
    accept,
    supportServerRender,
    prefixCls,
    disabled: mergedDisabled,
    beforeUpload: mergedBeforeUpload,
    onChange: void 0,
    hasControlInside
  };
  delete rcUploadProps.className;
  delete rcUploadProps.style;
  if (!children || mergedDisabled) {
    delete rcUploadProps.id;
  }
  const wrapperCls = `${prefixCls}-wrapper`;
  const [wrapCSSVar, hashId, cssVarCls] = style_default63(prefixCls, wrapperCls);
  const [contextLocale] = useLocale_default("Upload", en_US_default6.Upload);
  const {
    showRemoveIcon,
    showPreviewIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon
  } = typeof showUploadList === "boolean" ? {} : showUploadList;
  const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : !!showRemoveIcon;
  const renderUploadList = /* @__PURE__ */ __name((button, buttonVisible) => {
    if (!showUploadList) {
      return button;
    }
    return /* @__PURE__ */ React606.createElement(
      UploadList_default,
      {
        prefixCls,
        listType,
        items: mergedFileList,
        previewFile,
        onPreview,
        onDownload,
        onRemove: handleRemove,
        showRemoveIcon: realShowRemoveIcon,
        showPreviewIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon,
        iconRender,
        locale: { ...contextLocale, ...propLocale },
        isImageUrl: isImageUrl2,
        progress,
        appendAction: button,
        appendActionVisible: buttonVisible,
        itemRender,
        disabled: mergedDisabled
      }
    );
  }, "renderUploadList");
  const mergedCls = (0, import_classnames270.default)(
    wrapperCls,
    className,
    rootClassName,
    hashId,
    cssVarCls,
    ctxUpload?.className,
    {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
      [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
    }
  );
  const mergedStyle = { ...ctxUpload?.style, ...style2 };
  if (type5 === "drag") {
    const dragCls = (0, import_classnames270.default)(hashId, prefixCls, `${prefixCls}-drag`, {
      [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
      [`${prefixCls}-drag-hover`]: dragState === "dragover",
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    return wrapCSSVar(
      /* @__PURE__ */ React606.createElement("span", { className: mergedCls }, /* @__PURE__ */ React606.createElement(
        "div",
        {
          className: dragCls,
          style: mergedStyle,
          onDrop: onFileDrop,
          onDragOver: onFileDrop,
          onDragLeave: onFileDrop
        },
        /* @__PURE__ */ React606.createElement(src_default31, { ...rcUploadProps, ref: upload2, className: `${prefixCls}-btn` }, /* @__PURE__ */ React606.createElement("div", { className: `${prefixCls}-drag-container` }, children))
      ), renderUploadList())
    );
  }
  const uploadButtonCls = (0, import_classnames270.default)(prefixCls, `${prefixCls}-select`, {
    [`${prefixCls}-disabled`]: mergedDisabled
  });
  const uploadButton = /* @__PURE__ */ React606.createElement("div", { className: uploadButtonCls, style: children ? void 0 : { display: "none" } }, /* @__PURE__ */ React606.createElement(src_default31, { ...rcUploadProps, ref: upload2 }));
  if (listType === "picture-card" || listType === "picture-circle") {
    return wrapCSSVar(
      /* @__PURE__ */ React606.createElement("span", { className: mergedCls }, renderUploadList(uploadButton, !!children))
    );
  }
  return wrapCSSVar(
    /* @__PURE__ */ React606.createElement("span", { className: mergedCls }, uploadButton, renderUploadList())
  );
}, "InternalUpload");
var Upload2 = React606.forwardRef(InternalUpload);
if (true) {
  Upload2.displayName = "Upload";
}
var Upload_default2 = Upload2;

// packages/ant-design/components/upload/Dragger.tsx
var Dragger = React607.forwardRef(
  ({ style: style2, height, hasControlInside = false, ...restProps }, ref) => /* @__PURE__ */ React607.createElement(
    Upload_default2,
    {
      ref,
      hasControlInside,
      ...restProps,
      type: "drag",
      style: { ...style2, height }
    }
  )
);
if (true) {
  Dragger.displayName = "Dragger";
}
var Dragger_default = Dragger;

// packages/ant-design/components/upload/index.ts
var Upload3 = Upload_default2;
Upload3.Dragger = Dragger_default;
Upload3.LIST_IGNORE = LIST_IGNORE;
var upload_default = Upload3;

// packages/ant-design/components/watermark/index.tsx
import React613, { useEffect as useEffect144 } from "react";

// packages/mutate-observer/src/MutateObserver.tsx
import React610 from "react";

// packages/mutate-observer/src/wrapper.ts
import React608 from "react";
var DomWrapper3 = class extends React608.Component {
  static {
    __name(this, "DomWrapper");
  }
  render() {
    return this.props.children;
  }
};

// packages/mutate-observer/src/useMutateObserver.tsx
init_canUseDom();
import * as React609 from "react";
var defaultOptions = {
  subtree: true,
  childList: true,
  attributeFilter: ["style", "class"]
};
function useMutateObserver(nodeOrList, callback, options = defaultOptions) {
  React609.useEffect(() => {
    if (!canUseDom() || !nodeOrList) {
      return;
    }
    let instance;
    const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
    if ("MutationObserver" in window) {
      instance = new MutationObserver(callback);
      nodeList.forEach((element) => {
        instance.observe(element, options);
      });
    }
    return () => {
      instance?.takeRecords();
      instance?.disconnect();
    };
  }, [options, nodeOrList]);
}
__name(useMutateObserver, "useMutateObserver");

// packages/ant-design/components/watermark/index.tsx
var import_classnames271 = __toESM(require_classnames());

// packages/ant-design/components/watermark/useClips.ts
var FontGap = 3;
function prepareCanvas(width, height, ratio = 1) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const realWidth = width * ratio;
  const realHeight = height * ratio;
  canvas.setAttribute("width", `${realWidth}px`);
  canvas.setAttribute("height", `${realHeight}px`);
  ctx.save();
  return [ctx, canvas, realWidth, realHeight];
}
__name(prepareCanvas, "prepareCanvas");
function useClips() {
  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {
    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
    if (content instanceof HTMLImageElement) {
      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
    } else {
      const { color, fontSize, fontStyle, fontWeight, fontFamily, textAlign } = font;
      const mergedFontSize = Number(fontSize) * ratio;
      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
      ctx.fillStyle = color;
      ctx.textAlign = textAlign;
      ctx.textBaseline = "top";
      const contents = Array.isArray(content) ? content : [content];
      contents?.forEach((item, index3) => {
        ctx.fillText(item ?? "", contentWidth / 2, index3 * (mergedFontSize + FontGap * ratio));
      });
    }
    const angle = Math.PI / 180 * Number(rotate);
    const maxSize = Math.max(width, height);
    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
    rCtx.translate(realMaxSize / 2, realMaxSize / 2);
    rCtx.rotate(angle);
    if (contentWidth > 0 && contentHeight > 0) {
      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
    }
    function getRotatePos(x, y) {
      const targetX = x * Math.cos(angle) - y * Math.sin(angle);
      const targetY = x * Math.sin(angle) + y * Math.cos(angle);
      return [targetX, targetY];
    }
    __name(getRotatePos, "getRotatePos");
    let left = 0;
    let right = 0;
    let top = 0;
    let bottom = 0;
    const halfWidth = contentWidth / 2;
    const halfHeight = contentHeight / 2;
    const points = [
      [0 - halfWidth, 0 - halfHeight],
      [0 + halfWidth, 0 - halfHeight],
      [0 + halfWidth, 0 + halfHeight],
      [0 - halfWidth, 0 + halfHeight]
    ];
    points.forEach(([x, y]) => {
      const [targetX, targetY] = getRotatePos(x, y);
      left = Math.min(left, targetX);
      right = Math.max(right, targetX);
      top = Math.min(top, targetY);
      bottom = Math.max(bottom, targetY);
    });
    const cutLeft = left + realMaxSize / 2;
    const cutTop = top + realMaxSize / 2;
    const cutWidth = right - left;
    const cutHeight = bottom - top;
    const realGapX = gapX * ratio;
    const realGapY = gapY * ratio;
    const filledWidth = (cutWidth + realGapX) * 2;
    const filledHeight = cutHeight + realGapY;
    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
    function drawImg(targetX = 0, targetY = 0) {
      fCtx.drawImage(
        rCanvas,
        cutLeft,
        cutTop,
        cutWidth,
        cutHeight,
        targetX,
        targetY,
        cutWidth,
        cutHeight
      );
    }
    __name(drawImg, "drawImg");
    drawImg();
    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
  }
  __name(getClips, "getClips");
  return getClips;
}
__name(useClips, "useClips");

// packages/ant-design/components/watermark/useRafDebounce.ts
import React611 from "react";
function useRafDebounce(callback) {
  const executeRef = React611.useRef(false);
  const rafRef = React611.useRef();
  const wrapperCallback = useEvent(callback);
  return () => {
    if (executeRef.current) {
      return;
    }
    executeRef.current = true;
    wrapperCallback();
    rafRef.current = raf_default(() => {
      executeRef.current = false;
    });
  };
}
__name(useRafDebounce, "useRafDebounce");

// packages/ant-design/components/watermark/useWatermark.ts
import * as React612 from "react";

// packages/ant-design/components/watermark/utils.ts
function toLowercaseSeparator(key) {
  return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
__name(toLowercaseSeparator, "toLowercaseSeparator");
function getStyleStr(style2) {
  return Object.keys(style2).map((key) => `${toLowercaseSeparator(key)}: ${style2[key]};`).join(" ");
}
__name(getStyleStr, "getStyleStr");
function getPixelRatio() {
  return window.devicePixelRatio || 1;
}
__name(getPixelRatio, "getPixelRatio");
var reRendering = /* @__PURE__ */ __name((mutation, isWatermarkEle) => {
  let flag = false;
  if (mutation.removedNodes.length) {
    flag = Array.from(mutation.removedNodes).some((node2) => isWatermarkEle(node2));
  }
  if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) {
    flag = true;
  }
  return flag;
}, "reRendering");

// packages/ant-design/components/watermark/useWatermark.ts
var emphasizedStyle = {
  visibility: "visible !important"
};
function useWatermark(markStyle) {
  const [watermarkMap] = React612.useState(() => /* @__PURE__ */ new Map());
  const appendWatermark = /* @__PURE__ */ __name((base64Url, markWidth, container) => {
    if (container) {
      if (!watermarkMap.get(container)) {
        const newWatermarkEle = document.createElement("div");
        watermarkMap.set(container, newWatermarkEle);
      }
      const watermarkEle = watermarkMap.get(container);
      watermarkEle.setAttribute(
        "style",
        getStyleStr({
          ...markStyle,
          backgroundImage: `url('${base64Url}')`,
          backgroundSize: `${Math.floor(markWidth)}px`,
          ...emphasizedStyle
        })
      );
      watermarkEle.removeAttribute("class");
      if (watermarkEle.parentElement !== container) {
        container.append(watermarkEle);
      }
    }
    return watermarkMap.get(container);
  }, "appendWatermark");
  const removeWatermark = /* @__PURE__ */ __name((container) => {
    const watermarkEle = watermarkMap.get(container);
    if (watermarkEle && container) {
      container.removeChild(watermarkEle);
    }
    watermarkMap.delete(container);
  }, "removeWatermark");
  const isWatermarkEle = /* @__PURE__ */ __name((ele) => Array.from(watermarkMap.values()).includes(ele), "isWatermarkEle");
  return [appendWatermark, removeWatermark, isWatermarkEle];
}
__name(useWatermark, "useWatermark");

// packages/ant-design/components/watermark/index.tsx
function getSizeDiff(prev2, next2) {
  return prev2.size === next2.size ? prev2 : next2;
}
__name(getSizeDiff, "getSizeDiff");
var DEFAULT_GAP_X = 100;
var DEFAULT_GAP_Y = 100;
var Watermark = /* @__PURE__ */ __name((props) => {
  const {
    /**
     * The antd content layer zIndex is basically below 10
     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335
     */
    zIndex = 9,
    rotate = -22,
    width,
    height,
    image,
    content,
    font = {},
    style: style2,
    className,
    rootClassName,
    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],
    offset: offset3,
    children,
    inherit = true
  } = props;
  const [, token2] = useToken();
  const {
    color = token2.colorFill,
    fontSize = token2.fontSizeLG,
    fontWeight = "normal",
    fontStyle = "normal",
    fontFamily = "sans-serif",
    textAlign = "center"
  } = font;
  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
  const gapXCenter = gapX / 2;
  const gapYCenter = gapY / 2;
  const offsetLeft = offset3?.[0] ?? gapXCenter;
  const offsetTop = offset3?.[1] ?? gapYCenter;
  const markStyle = React613.useMemo(() => {
    const mergedStyle = {
      zIndex,
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      backgroundRepeat: "repeat"
    };
    let positionLeft = offsetLeft - gapXCenter;
    let positionTop = offsetTop - gapYCenter;
    if (positionLeft > 0) {
      mergedStyle.left = `${positionLeft}px`;
      mergedStyle.width = `calc(100% - ${positionLeft}px)`;
      positionLeft = 0;
    }
    if (positionTop > 0) {
      mergedStyle.top = `${positionTop}px`;
      mergedStyle.height = `calc(100% - ${positionTop}px)`;
      positionTop = 0;
    }
    mergedStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
    return mergedStyle;
  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);
  const [container, setContainer] = React613.useState();
  const [subElements, setSubElements] = React613.useState(/* @__PURE__ */ new Set());
  const targetElements = React613.useMemo(() => {
    const list = container ? [container] : [];
    return [...list, ...Array.from(subElements)];
  }, [container, subElements]);
  const getMarkSize = /* @__PURE__ */ __name((ctx) => {
    let defaultWidth = 120;
    let defaultHeight = 64;
    if (!image && ctx.measureText) {
      ctx.font = `${Number(fontSize)}px ${fontFamily}`;
      const contents = Array.isArray(content) ? content : [content];
      const sizes2 = contents.map((item) => {
        const metrics = ctx.measureText(item);
        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
      });
      defaultWidth = Math.ceil(Math.max(...sizes2.map((size) => size[0])));
      defaultHeight = Math.ceil(Math.max(...sizes2.map((size) => size[1]))) * contents.length + (contents.length - 1) * FontGap;
    }
    return [width ?? defaultWidth, height ?? defaultHeight];
  }, "getMarkSize");
  const getClips = useClips();
  const [watermarkInfo, setWatermarkInfo] = React613.useState(
    null
  );
  const renderWatermark = /* @__PURE__ */ __name(() => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const ratio = getPixelRatio();
      const [markWidth, markHeight] = getMarkSize(ctx);
      const drawCanvas = /* @__PURE__ */ __name((drawContent) => {
        const [nextClips, clipWidth] = getClips(
          drawContent || "",
          rotate,
          ratio,
          markWidth,
          markHeight,
          {
            color,
            fontSize,
            fontStyle,
            fontWeight,
            fontFamily,
            textAlign
          },
          gapX,
          gapY
        );
        setWatermarkInfo([nextClips, clipWidth]);
      }, "drawCanvas");
      if (image) {
        const img = new Image();
        img.onload = () => {
          drawCanvas(img);
        };
        img.onerror = () => {
          drawCanvas(content);
        };
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.src = image;
      } else {
        drawCanvas(content);
      }
    }
  }, "renderWatermark");
  const syncWatermark = useRafDebounce(renderWatermark);
  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);
  useEffect144(() => {
    if (watermarkInfo) {
      targetElements.forEach((holder) => {
        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
      });
    }
  }, [watermarkInfo, targetElements]);
  const onMutate = /* @__PURE__ */ __name((mutations) => {
    mutations.forEach((mutation) => {
      if (reRendering(mutation, isWatermarkEle)) {
        syncWatermark();
      }
    });
  }, "onMutate");
  useMutateObserver(targetElements, onMutate);
  useEffect144(syncWatermark, [
    rotate,
    zIndex,
    width,
    height,
    image,
    content,
    color,
    fontSize,
    fontWeight,
    fontStyle,
    fontFamily,
    textAlign,
    gapX,
    gapY,
    offsetLeft,
    offsetTop
  ]);
  const watermarkContext = React613.useMemo(
    () => ({
      add: (ele) => {
        setSubElements((prev2) => {
          const clone = new Set(prev2);
          clone.add(ele);
          return getSizeDiff(prev2, clone);
        });
      },
      remove: (ele) => {
        removeWatermark(ele);
        setSubElements((prev2) => {
          const clone = new Set(prev2);
          clone.delete(ele);
          return getSizeDiff(prev2, clone);
        });
      }
    }),
    []
  );
  const childNode = inherit ? /* @__PURE__ */ React613.createElement(context_default3.Provider, { value: watermarkContext }, children) : children;
  return /* @__PURE__ */ React613.createElement(
    "div",
    {
      ref: setContainer,
      className: (0, import_classnames271.default)(className, rootClassName),
      style: { position: "relative", ...style2 }
    },
    childNode
  );
}, "Watermark");
if (true) {
  Watermark.displayName = "Watermark";
}
var watermark_default = Watermark;
export {
  affix_default as Affix,
  alert_default as Alert,
  anchor_default as Anchor,
  app_default as App,
  auto_complete_default as AutoComplete,
  avatar_default2 as Avatar,
  back_top_default as BackTop,
  badge_default as Badge,
  breadcrumb_default as Breadcrumb,
  button_default2 as Button,
  calendar_default as Calendar,
  card_default as Card,
  carousel_default as Carousel,
  cascader_default as Cascader,
  checkbox_default as Checkbox,
  col_default2 as Col,
  collapse_default2 as Collapse,
  color_picker_default as ColorPicker,
  config_provider_default as ConfigProvider,
  date_picker_default as DatePicker,
  descriptions_default as Descriptions,
  divider_default as Divider,
  drawer_default as Drawer,
  dropdown_default3 as Dropdown,
  empty_default2 as Empty,
  flex_default as Flex,
  float_button_default as FloatButton,
  form_default as Form,
  grid_default as Grid,
  image_default as Image,
  input_default as Input,
  input_number_default as InputNumber,
  layout_default2 as Layout,
  list_default as List,
  mentions_default as Mentions,
  menu_default2 as Menu,
  modal_default as Modal,
  pagination_default as Pagination,
  popconfirm_default as Popconfirm,
  popover_default as Popover,
  progress_default2 as Progress,
  qr_code_default as QRCode,
  radio_default2 as Radio,
  rate_default as Rate,
  result_default as Result,
  row_default2 as Row,
  segmented_default as Segmented,
  select_default as Select,
  skeleton_default as Skeleton,
  slider_default as Slider,
  space_default as Space,
  spin_default as Spin,
  statistic_default2 as Statistic,
  steps_default as Steps,
  switch_default as Switch,
  table_default as Table,
  tabs_default as Tabs,
  tag_default as Tag,
  time_picker_default as TimePicker,
  timeline_default as Timeline,
  tooltip_default as Tooltip,
  tour_default as Tour,
  transfer_default as Transfer,
  tree_default as Tree,
  tree_select_default as TreeSelect,
  typography_default as Typography,
  upload_default as Upload,
  watermark_default as Watermark,
  message_default as message,
  notification_default as notification,
  theme_default2 as theme,
  version_default as version
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

qrcode.react/lib/esm/index.js:
  (**
   * @license QR Code generator library (TypeScript)
   * Copyright (c) Project Nayuki.
   * SPDX-License-Identifier: MIT
   *)
  (**
   * @license qrcode.react
   * Copyright (c) Paul O'Shannessy
   * SPDX-License-Identifier: ISC
   *)
*/
//# sourceMappingURL=index.js.map
