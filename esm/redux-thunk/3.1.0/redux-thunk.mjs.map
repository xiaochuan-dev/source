{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { Action, AnyAction } from 'redux'\n\nimport type { ThunkMiddleware } from './types'\n\nexport type {\n  ThunkAction,\n  ThunkDispatch,\n  ThunkActionDispatch,\n  ThunkMiddleware\n} from './types'\n\n/** A function that accepts a potential \"extra argument\" value to be injected later,\n * and returns an instance of the thunk middleware that uses that value\n */\nfunction createThunkMiddleware<\n  State = any,\n  BasicAction extends Action = AnyAction,\n  ExtraThunkArg = undefined\n>(extraArgument?: ExtraThunkArg) {\n  // Standard Redux middleware definition pattern:\n  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n  const middleware: ThunkMiddleware<State, BasicAction, ExtraThunkArg> =\n    ({ dispatch, getState }) =>\n    next =>\n    action => {\n      // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n      // If this \"action\" is really a function, call it and return the result.\n      if (typeof action === 'function') {\n        // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n        return action(dispatch, getState, extraArgument)\n      }\n\n      // Otherwise, pass the action down the middleware chain as usual\n      return next(action)\n    }\n  return middleware\n}\n\nexport const thunk = createThunkMiddleware()\n\n// Export the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\nexport const withExtraArgument = createThunkMiddleware\n"],"mappings":";AAcA,SAAS,sBAIP,eAA+B;AAG/B,QAAM,aACJ,CAAC,EAAE,UAAU,SAAS,MACtB,UACA,YAAU;AAGR,QAAI,OAAO,WAAW,YAAY;AAEhC,aAAO,OAAO,UAAU,UAAU,aAAa;AAAA,IACjD;AAGA,WAAO,KAAK,MAAM;AAAA,EACpB;AACF,SAAO;AACT;AAEO,IAAM,QAAQ,sBAAsB;AAIpC,IAAM,oBAAoB;","names":[]}