{
  "version": 3,
  "sources": ["../src/scope.ts", "../src/attributor/attributor.ts", "../src/error.ts", "../src/registry.ts", "../src/attributor/class.ts", "../src/attributor/style.ts", "../src/attributor/store.ts", "../src/blot/abstract/shadow.ts", "../src/blot/abstract/leaf.ts", "../src/collection/linked-list.ts", "../src/blot/abstract/parent.ts", "../src/blot/inline.ts", "../src/blot/block.ts", "../src/blot/abstract/container.ts", "../src/blot/embed.ts", "../src/blot/scroll.ts", "../src/blot/text.ts"],
  "sourcesContent": ["enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n", "import Scope from '../scope.js';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    public readonly attrName: string,\n    public readonly keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): any {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n", "export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n", "import Attributor from './attributor/attributor.js';\nimport {\n  type Blot,\n  type BlotConstructor,\n  type Root,\n} from './blot/abstract/blot.js';\nimport ParchmentError from './error.js';\nimport Scope from './scope.js';\n\nexport type RegistryDefinition = Attributor | BlotConstructor;\n\nexport interface RegistryInterface {\n  create(scroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(query: string | Node | Scope, scope: Scope): RegistryDefinition | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node?: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: RegistryDefinition } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error Fix me later\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    if (\n      'scope' in match &&\n      scope & Scope.LEVEL & match.scope &&\n      scope & Scope.TYPE & match.scope\n    ) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: RegistryDefinition[]): RegistryDefinition[] {\n    return definitions.map((definition) => {\n      const isBlot = 'blotName' in definition;\n      const isAttr = 'attrName' in definition;\n      if (!isBlot && !isAttr) {\n        throw new ParchmentError('Invalid definition');\n      } else if (isBlot && definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n      }\n      const key = isBlot\n        ? definition.blotName\n        : isAttr\n          ? definition.attrName\n          : (undefined as never); // already handled by above checks\n      this.types[key] = definition;\n\n      if (isAttr) {\n        if (typeof definition.keyName === 'string') {\n          this.attributes[definition.keyName] = definition;\n        }\n      } else if (isBlot) {\n        if (definition.className) {\n          this.classes[definition.className] = definition;\n        }\n        if (definition.tagName) {\n          if (Array.isArray(definition.tagName)) {\n            definition.tagName = definition.tagName.map((tagName: string) => {\n              return tagName.toUpperCase();\n            });\n          } else {\n            definition.tagName = definition.tagName.toUpperCase();\n          }\n          const tagNames = Array.isArray(definition.tagName)\n            ? definition.tagName\n            : [definition.tagName];\n          tagNames.forEach((tag: string) => {\n            if (this.tags[tag] == null || definition.className == null) {\n              this.tags[tag] = definition;\n            }\n          });\n        }\n      }\n      return definition;\n    });\n  }\n}\n", "import Attributor from './attributor.js';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n", "import Attributor from './attributor.js';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    // @ts-expect-error Fix me later\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n", "import type { Formattable } from '../blot/abstract/blot.js';\nimport Registry from '../registry.js';\nimport Scope from '../scope.js';\nimport Attributor from './attributor.js';\nimport ClassAttributor from './class.js';\nimport StyleAttributor from './style.js';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n", "import ParchmentError from '../../error.js';\nimport Registry from '../../registry.js';\nimport Scope from '../../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './blot.js';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string | string[];\n\n  public static create(rawValue?: unknown): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node: HTMLElement;\n    let value: string | number | undefined;\n    if (Array.isArray(this.tagName)) {\n      if (typeof rawValue === 'string') {\n        value = rawValue.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      } else if (typeof rawValue === 'number') {\n        value = rawValue;\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (value && this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error Fix me later\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(\n    public scroll: Root,\n    public domNode: Node,\n  ) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context?: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n", "import Scope from '../../scope.js';\nimport type { Leaf } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n", "import type LinkedNode from './linked-node.js';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n", "import LinkedList from '../../collection/linked-list.js';\nimport ParchmentError from '../../error.js';\nimport Scope from '../../scope.js';\nimport type { Blot, BlotConstructor, Parent, Root } from './blot.js';\nimport ShadowBlot from './shadow.js';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (e) {\n    const blot = scroll.create(Scope.INLINE);\n    Array.from(node.childNodes).forEach((child: Node) => {\n      blot.domNode.appendChild(child);\n    });\n    if (node.parentNode) {\n      node.parentNode.replaceChild(blot.domNode, node);\n    }\n    blot.attach();\n    return blot;\n  }\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  /**\n   * Whitelist array of Blots that can be direct children.\n   */\n  public static allowedChildren?: BlotConstructor[];\n\n  /**\n   * Default child blot to be inserted if this blot becomes empty.\n   */\n  public static defaultChild?: BlotConstructor;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index: number,\n  ): [T | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index?: number,\n    length?: number,\n  ): T[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index?: number,\n    length?: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot | null): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context?: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode && node !== this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n", "import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\n\n// Shallow object comparison\nfunction isEqual(\n  obj1: Record<string, unknown>,\n  obj2: Record<string, unknown>,\n): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName: string | string[] = 'SPAN';\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n", "import Attributor from '../attributor/attributor.js';\nimport AttributorStore from '../attributor/store.js';\nimport Scope from '../scope.js';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Root,\n} from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\nimport ParentBlot from './abstract/parent.js';\nimport InlineBlot from './inline.js';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[] = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n", "import Scope from '../../scope.js';\nimport BlockBlot from '../block.js';\nimport ParentBlot from './parent.js';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[];\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n", "import type { Formattable, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n", "import Registry, { type RegistryDefinition } from '../registry.js';\nimport Scope from '../scope.js';\nimport type { Blot, BlotConstructor, Root } from './abstract/blot.js';\nimport ContainerBlot from './abstract/container.js';\nimport ParentBlot from './abstract/parent.js';\nimport BlockBlot from './block.js';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public observer: MutationObserver;\n\n  constructor(\n    public registry: Registry,\n    node: HTMLDivElement,\n  ) {\n    // @ts-expect-error scroll is the root with no parent\n    super(null, node);\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: RegistryDefinition[]) {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context?: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n", "import Scope from '../scope.js';\nimport type { Blot, Leaf, Root } from './abstract/blot.js';\nimport LeafBlot from './abstract/leaf.js';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static readonly blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],
  "mappings": "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",
  "names": ["Scope", "match", "match", "match"]
}
